import {
  r as ee,
  G as ja,
  h as hn,
  _ as Ut,
  N as Va,
  C as Ha,
  O as lr,
  P as gs,
  e as Kt,
  g as Wa,
  u as Ya,
  v as za,
  f as sr,
  i as ys,
  m as qa,
  n as Xa,
  Q as Qa,
  p as Za,
  l as Ja,
  S as eo,
  z as to,
  U as ro,
  V as Lr,
  A as no,
  J as io,
  W as so,
  d as xt,
  X as ao,
  j as Ae,
  I as oo,
  Y as zt,
  Z as lo
} from './index-7ec5c925.js'
import { P as uo, C as wt, T as co } from './index-75272ee3.js'
import { P as fo } from './index-be5ad900.js'
import './PlusOutlined-b08ffc51.js'
var ho = {
  icon: {
    tag: 'svg',
    attrs: { viewBox: '64 64 896 896', focusable: 'false' },
    children: [
      {
        tag: 'path',
        attrs: {
          d: 'M705.6 124.9a8 8 0 00-11.6 7.2v64.2c0 5.5 2.9 10.6 7.5 13.6a352.2 352.2 0 0162.2 49.8c32.7 32.8 58.4 70.9 76.3 113.3a355 355 0 0127.9 138.7c0 48.1-9.4 94.8-27.9 138.7a355.92 355.92 0 01-76.3 113.3 353.06 353.06 0 01-113.2 76.4c-43.8 18.6-90.5 28-138.5 28s-94.7-9.4-138.5-28a353.06 353.06 0 01-113.2-76.4A355.92 355.92 0 01184 650.4a355 355 0 01-27.9-138.7c0-48.1 9.4-94.8 27.9-138.7 17.9-42.4 43.6-80.5 76.3-113.3 19-19 39.8-35.6 62.2-49.8 4.7-2.9 7.5-8.1 7.5-13.6V132c0-6-6.3-9.8-11.6-7.2C178.5 195.2 82 339.3 80 506.3 77.2 745.1 272.5 943.5 511.2 944c239 .5 432.8-193.3 432.8-432.4 0-169.2-97-315.7-238.4-386.7zM480 560h64c4.4 0 8-3.6 8-8V88c0-4.4-3.6-8-8-8h-64c-4.4 0-8 3.6-8 8v464c0 4.4 3.6 8 8 8z'
        }
      }
    ]
  },
  name: 'poweroff',
  theme: 'outlined'
}
const po = ho
var mo = function (e, t) {
  return ee.createElement(ja, hn({}, e, { ref: t, icon: po }))
}
const go = ee.forwardRef(mo)
var zn = function (e) {
    return e
      ? {
          left: e.offsetLeft,
          right: e.parentElement.clientWidth - e.clientWidth - e.offsetLeft,
          width: e.clientWidth
        }
      : null
  },
  St = function (e) {
    return e !== void 0 ? ''.concat(e, 'px') : void 0
  }
function yo(s) {
  var e = s.prefixCls,
    t = s.containerRef,
    r = s.value,
    n = s.getValueIndex,
    i = s.motionName,
    a = s.onMotionStart,
    o = s.onMotionEnd,
    l = s.direction,
    u = ee.useRef(null),
    c = ee.useState(r),
    f = Ut(c, 2),
    d = f[0],
    m = f[1],
    p = function (P) {
      var D,
        C = n(P),
        N =
          (D = t.current) === null || D === void 0
            ? void 0
            : D.querySelectorAll('.'.concat(e, '-item'))[C]
      return (N == null ? void 0 : N.offsetParent) && N
    },
    v = ee.useState(null),
    E = Ut(v, 2),
    x = E[0],
    T = E[1],
    b = ee.useState(null),
    R = Ut(b, 2),
    g = R[0],
    A = R[1]
  Va(
    function () {
      if (d !== r) {
        var I = p(d),
          P = p(r),
          D = zn(I),
          C = zn(P)
        m(r), T(D), A(C), I && P ? a() : o()
      }
    },
    [r]
  )
  var S = ee.useMemo(
      function () {
        return St(l === 'rtl' ? -(x == null ? void 0 : x.right) : x == null ? void 0 : x.left)
      },
      [l, x]
    ),
    h = ee.useMemo(
      function () {
        return St(l === 'rtl' ? -(g == null ? void 0 : g.right) : g == null ? void 0 : g.left)
      },
      [l, g]
    ),
    _ = function () {
      return { transform: 'translateX(var(--thumb-start-left))', width: 'var(--thumb-start-width)' }
    },
    y = function () {
      return {
        transform: 'translateX(var(--thumb-active-left))',
        width: 'var(--thumb-active-width)'
      }
    },
    L = function () {
      T(null), A(null), o()
    }
  return !x || !g
    ? null
    : ee.createElement(
        Ha,
        {
          visible: !0,
          motionName: i,
          motionAppear: !0,
          onAppearStart: _,
          onAppearActive: y,
          onAppearEnd: L
        },
        function (I, P) {
          var D = I.className,
            C = I.style,
            N = lr(
              lr({}, C),
              {},
              {
                '--thumb-start-left': S,
                '--thumb-start-width': St(x == null ? void 0 : x.width),
                '--thumb-active-left': h,
                '--thumb-active-width': St(g == null ? void 0 : g.width)
              }
            ),
            M = { ref: gs(u, P), style: N, className: Kt(''.concat(e, '-thumb'), D) }
          return ee.createElement('div', M)
        }
      )
}
var vo = [
  'prefixCls',
  'direction',
  'options',
  'disabled',
  'defaultValue',
  'value',
  'onChange',
  'className',
  'motionName'
]
function _o(s) {
  if (typeof s.title < 'u') return s.title
  if (ys(s.label) !== 'object') {
    var e
    return (e = s.label) === null || e === void 0 ? void 0 : e.toString()
  }
}
function Eo(s) {
  return s.map(function (e) {
    if (ys(e) === 'object' && e !== null) {
      var t = _o(e)
      return lr(lr({}, e), {}, { title: t })
    }
    return {
      label: e == null ? void 0 : e.toString(),
      title: e == null ? void 0 : e.toString(),
      value: e
    }
  })
}
var xo = function (e) {
    var t = e.prefixCls,
      r = e.className,
      n = e.disabled,
      i = e.checked,
      a = e.label,
      o = e.title,
      l = e.value,
      u = e.onChange,
      c = function (d) {
        n || u(d, l)
      }
    return ee.createElement(
      'label',
      { className: Kt(r, sr({}, ''.concat(t, '-item-disabled'), n)) },
      ee.createElement('input', {
        className: ''.concat(t, '-item-input'),
        type: 'radio',
        disabled: n,
        checked: i,
        onChange: c
      }),
      ee.createElement('div', { className: ''.concat(t, '-item-label'), title: o }, a)
    )
  },
  In = ee.forwardRef(function (s, e) {
    var t,
      r,
      n = s.prefixCls,
      i = n === void 0 ? 'rc-segmented' : n,
      a = s.direction,
      o = s.options,
      l = s.disabled,
      u = s.defaultValue,
      c = s.value,
      f = s.onChange,
      d = s.className,
      m = d === void 0 ? '' : d,
      p = s.motionName,
      v = p === void 0 ? 'thumb-motion' : p,
      E = Wa(s, vo),
      x = ee.useRef(null),
      T = ee.useMemo(
        function () {
          return gs(x, e)
        },
        [x, e]
      ),
      b = ee.useMemo(
        function () {
          return Eo(o)
        },
        [o]
      ),
      R = Ya((t = b[0]) === null || t === void 0 ? void 0 : t.value, { value: c, defaultValue: u }),
      g = Ut(R, 2),
      A = g[0],
      S = g[1],
      h = ee.useState(!1),
      _ = Ut(h, 2),
      y = _[0],
      L = _[1],
      I = function (C, N) {
        l || (S(N), f == null || f(N))
      },
      P = za(E, ['children'])
    return ee.createElement(
      'div',
      hn({}, P, {
        className: Kt(
          i,
          ((r = {}),
          sr(r, ''.concat(i, '-rtl'), a === 'rtl'),
          sr(r, ''.concat(i, '-disabled'), l),
          r),
          m
        ),
        ref: T
      }),
      ee.createElement(
        'div',
        { className: ''.concat(i, '-group') },
        ee.createElement(yo, {
          prefixCls: i,
          value: A,
          containerRef: x,
          motionName: ''.concat(i, '-').concat(v),
          direction: a,
          getValueIndex: function (C) {
            return b.findIndex(function (N) {
              return N.value === C
            })
          },
          onMotionStart: function () {
            L(!0)
          },
          onMotionEnd: function () {
            L(!1)
          }
        }),
        b.map(function (D) {
          return ee.createElement(
            xo,
            hn(
              {
                key: D.value,
                prefixCls: i,
                className: Kt(
                  D.className,
                  ''.concat(i, '-item'),
                  sr({}, ''.concat(i, '-item-selected'), D.value === A && !y)
                ),
                checked: D.value === A,
                onChange: I
              },
              D,
              { disabled: !!l || !!D.disabled }
            )
          )
        })
      )
    )
  })
In.displayName = 'Segmented'
In.defaultProps = { options: [] }
function qn(s, e) {
  return { [`${s}, ${s}:hover, ${s}:focus`]: { color: e.colorTextDisabled, cursor: 'not-allowed' } }
}
function Xn(s) {
  return { backgroundColor: s.bgColorSelected, boxShadow: s.boxShadowTertiary }
}
const So = Object.assign({ overflow: 'hidden' }, Qa),
  To = (s) => {
    const { componentCls: e } = s
    return {
      [e]: Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(Object.assign({}, Za(s)), {
              display: 'inline-block',
              padding: s.segmentedContainerPadding,
              color: s.labelColor,
              backgroundColor: s.bgColor,
              borderRadius: s.borderRadius,
              transition: `all ${s.motionDurationMid} ${s.motionEaseInOut}`,
              [`${e}-group`]: {
                position: 'relative',
                display: 'flex',
                alignItems: 'stretch',
                justifyItems: 'flex-start',
                width: '100%'
              },
              [`&${e}-rtl`]: { direction: 'rtl' },
              [`&${e}-block`]: { display: 'flex' },
              [`&${e}-block ${e}-item`]: { flex: 1, minWidth: 0 },
              [`${e}-item`]: {
                position: 'relative',
                textAlign: 'center',
                cursor: 'pointer',
                transition: `color ${s.motionDurationMid} ${s.motionEaseInOut}`,
                borderRadius: s.borderRadiusSM,
                '&-selected': Object.assign(Object.assign({}, Xn(s)), { color: s.labelColorHover }),
                '&::after': {
                  content: '""',
                  position: 'absolute',
                  width: '100%',
                  height: '100%',
                  top: 0,
                  insetInlineStart: 0,
                  borderRadius: 'inherit',
                  transition: `background-color ${s.motionDurationMid}`,
                  pointerEvents: 'none'
                },
                [`&:hover:not(${e}-item-selected):not(${e}-item-disabled)`]: {
                  color: s.labelColorHover,
                  '&::after': { backgroundColor: s.bgColorHover }
                },
                '&-label': Object.assign(
                  {
                    minHeight: s.controlHeight - s.segmentedContainerPadding * 2,
                    lineHeight: `${s.controlHeight - s.segmentedContainerPadding * 2}px`,
                    padding: `0 ${s.segmentedPaddingHorizontal}px`
                  },
                  So
                ),
                '&-icon + *': { marginInlineStart: s.marginSM / 2 },
                '&-input': {
                  position: 'absolute',
                  insetBlockStart: 0,
                  insetInlineStart: 0,
                  width: 0,
                  height: 0,
                  opacity: 0,
                  pointerEvents: 'none'
                }
              },
              [`${e}-thumb`]: Object.assign(Object.assign({}, Xn(s)), {
                position: 'absolute',
                insetBlockStart: 0,
                insetInlineStart: 0,
                width: 0,
                height: '100%',
                padding: `${s.paddingXXS}px 0`,
                borderRadius: s.borderRadiusSM,
                [`& ~ ${e}-item:not(${e}-item-selected):not(${e}-item-disabled)::after`]: {
                  backgroundColor: 'transparent'
                }
              }),
              [`&${e}-lg`]: {
                borderRadius: s.borderRadiusLG,
                [`${e}-item-label`]: {
                  minHeight: s.controlHeightLG - s.segmentedContainerPadding * 2,
                  lineHeight: `${s.controlHeightLG - s.segmentedContainerPadding * 2}px`,
                  padding: `0 ${s.segmentedPaddingHorizontal}px`,
                  fontSize: s.fontSizeLG
                },
                [`${e}-item, ${e}-thumb`]: { borderRadius: s.borderRadius }
              },
              [`&${e}-sm`]: {
                borderRadius: s.borderRadiusSM,
                [`${e}-item-label`]: {
                  minHeight: s.controlHeightSM - s.segmentedContainerPadding * 2,
                  lineHeight: `${s.controlHeightSM - s.segmentedContainerPadding * 2}px`,
                  padding: `0 ${s.segmentedPaddingHorizontalSM}px`
                },
                [`${e}-item, ${e}-thumb`]: { borderRadius: s.borderRadiusXS }
              }
            }),
            qn(`&-disabled ${e}-item`, s)
          ),
          qn(`${e}-item-disabled`, s)
        ),
        {
          [`${e}-thumb-motion-appear-active`]: {
            transition: `transform ${s.motionDurationSlow} ${s.motionEaseInOut}, width ${s.motionDurationSlow} ${s.motionEaseInOut}`,
            willChange: 'transform, width'
          }
        }
      )
    }
  },
  bo = qa('Segmented', (s) => {
    const {
        lineWidthBold: e,
        lineWidth: t,
        colorTextLabel: r,
        colorText: n,
        colorFillSecondary: i,
        colorBgLayout: a,
        colorBgElevated: o
      } = s,
      l = Xa(s, {
        segmentedPaddingHorizontal: s.controlPaddingHorizontal - t,
        segmentedPaddingHorizontalSM: s.controlPaddingHorizontalSM - t,
        segmentedContainerPadding: e,
        labelColor: r,
        labelColorHover: n,
        bgColor: a,
        bgColorHover: i,
        bgColorSelected: o
      })
    return [To(l)]
  })
var Qn =
  (globalThis && globalThis.__rest) ||
  function (s, e) {
    var t = {}
    for (var r in s) Object.prototype.hasOwnProperty.call(s, r) && e.indexOf(r) < 0 && (t[r] = s[r])
    if (s != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var n = 0, r = Object.getOwnPropertySymbols(s); n < r.length; n++)
        e.indexOf(r[n]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(s, r[n]) &&
          (t[r[n]] = s[r[n]])
    return t
  }
function Lo(s) {
  return typeof s == 'object' && !!(s != null && s.icon)
}
const Ao = ee.forwardRef((s, e) => {
    const {
        prefixCls: t,
        className: r,
        rootClassName: n,
        block: i,
        options: a = [],
        size: o = 'middle'
      } = s,
      l = Qn(s, ['prefixCls', 'className', 'rootClassName', 'block', 'options', 'size']),
      { getPrefixCls: u, direction: c } = ee.useContext(Ja),
      f = u('segmented', t),
      [d, m] = bo(f),
      p = ee.useContext(eo),
      v = o || p,
      E = ee.useMemo(
        () =>
          a.map((x) => {
            if (Lo(x)) {
              const { icon: T, label: b } = x,
                R = Qn(x, ['icon', 'label'])
              return Object.assign(Object.assign({}, R), {
                label: ee.createElement(
                  ee.Fragment,
                  null,
                  ee.createElement('span', { className: `${f}-item-icon` }, T),
                  b && ee.createElement('span', null, b)
                )
              })
            }
            return x
          }),
        [a, f]
      )
    return d(
      ee.createElement(
        In,
        Object.assign({}, l, {
          className: Kt(
            r,
            n,
            { [`${f}-block`]: i, [`${f}-sm`]: v === 'small', [`${f}-lg`]: v === 'large' },
            m
          ),
          options: E,
          ref: e,
          prefixCls: f,
          direction: c
        })
      )
    )
  }),
  Ro = Ao
var vs = {},
  _s = {},
  me = {},
  Io = function (e, t, r) {
    var n = document.head || document.getElementsByTagName('head')[0],
      i = document.createElement('script')
    typeof t == 'function' && ((r = t), (t = {})),
      (t = t || {}),
      (r = r || function () {}),
      (i.type = t.type || 'text/javascript'),
      (i.charset = t.charset || 'utf8'),
      (i.async = 'async' in t ? !!t.async : !0),
      (i.src = e),
      t.attrs && Po(i, t.attrs),
      t.text && (i.text = '' + t.text)
    var a = 'onload' in i ? Zn : Do
    a(i, r), i.onload || Zn(i, r), n.appendChild(i)
  }
function Po(s, e) {
  for (var t in e) s.setAttribute(t, e[t])
}
function Zn(s, e) {
  ;(s.onload = function () {
    ;(this.onerror = this.onload = null), e(null, s)
  }),
    (s.onerror = function () {
      ;(this.onerror = this.onload = null), e(new Error('Failed to load ' + this.src), s)
    })
}
function Do(s, e) {
  s.onreadystatechange = function () {
    ;(this.readyState != 'complete' && this.readyState != 'loaded') ||
      ((this.onreadystatechange = null), e(null, s))
  }
}
var Oo = function (e) {
  return wo(e) && !Co(e)
}
function wo(s) {
  return !!s && typeof s == 'object'
}
function Co(s) {
  var e = Object.prototype.toString.call(s)
  return e === '[object RegExp]' || e === '[object Date]' || Fo(s)
}
var ko = typeof Symbol == 'function' && Symbol.for,
  Mo = ko ? Symbol.for('react.element') : 60103
function Fo(s) {
  return s.$$typeof === Mo
}
function No(s) {
  return Array.isArray(s) ? [] : {}
}
function jt(s, e) {
  return e.clone !== !1 && e.isMergeableObject(s) ? Ot(No(s), s, e) : s
}
function Uo(s, e, t) {
  return s.concat(e).map(function (r) {
    return jt(r, t)
  })
}
function Bo(s, e) {
  if (!e.customMerge) return Ot
  var t = e.customMerge(s)
  return typeof t == 'function' ? t : Ot
}
function Go(s) {
  return Object.getOwnPropertySymbols
    ? Object.getOwnPropertySymbols(s).filter(function (e) {
        return Object.propertyIsEnumerable.call(s, e)
      })
    : []
}
function Jn(s) {
  return Object.keys(s).concat(Go(s))
}
function Es(s, e) {
  try {
    return e in s
  } catch {
    return !1
  }
}
function $o(s, e) {
  return Es(s, e) && !(Object.hasOwnProperty.call(s, e) && Object.propertyIsEnumerable.call(s, e))
}
function Ko(s, e, t) {
  var r = {}
  return (
    t.isMergeableObject(s) &&
      Jn(s).forEach(function (n) {
        r[n] = jt(s[n], t)
      }),
    Jn(e).forEach(function (n) {
      $o(s, n) ||
        (Es(s, n) && t.isMergeableObject(e[n])
          ? (r[n] = Bo(n, t)(s[n], e[n], t))
          : (r[n] = jt(e[n], t)))
    }),
    r
  )
}
function Ot(s, e, t) {
  ;(t = t || {}),
    (t.arrayMerge = t.arrayMerge || Uo),
    (t.isMergeableObject = t.isMergeableObject || Oo),
    (t.cloneUnlessOtherwiseSpecified = jt)
  var r = Array.isArray(e),
    n = Array.isArray(s),
    i = r === n
  return i ? (r ? t.arrayMerge(s, e, t) : Ko(s, e, t)) : jt(e, t)
}
Ot.all = function (e, t) {
  if (!Array.isArray(e)) throw new Error('first argument should be an array')
  return e.reduce(function (r, n) {
    return Ot(r, n, t)
  }, {})
}
var jo = Ot,
  xs = jo
Object.defineProperty(me, '__esModule', { value: !0 })
me.parseStartTime = tl
me.parseEndTime = rl
me.randomString = nl
me.queryString = il
me.getSDK = sl
me.getConfig = al
me.omit = ol
me.callPlayer = ll
me.isMediaStream = ul
me.isBlobUrl = cl
me.supportsWebKitPresentationMode = fl
var Vo = Ss(Io),
  Ho = Ss(xs)
function Ss(s) {
  return s && s.__esModule ? s : { default: s }
}
function Wo(s, e) {
  return Xo(s) || qo(s, e) || zo(s, e) || Yo()
}
function Yo() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function zo(s, e) {
  if (s) {
    if (typeof s == 'string') return ei(s, e)
    var t = Object.prototype.toString.call(s).slice(8, -1)
    if ((t === 'Object' && s.constructor && (t = s.constructor.name), t === 'Map' || t === 'Set'))
      return Array.from(s)
    if (t === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return ei(s, e)
  }
}
function ei(s, e) {
  ;(e == null || e > s.length) && (e = s.length)
  for (var t = 0, r = new Array(e); t < e; t++) r[t] = s[t]
  return r
}
function qo(s, e) {
  if (!(typeof Symbol > 'u' || !(Symbol.iterator in Object(s)))) {
    var t = [],
      r = !0,
      n = !1,
      i = void 0
    try {
      for (
        var a = s[Symbol.iterator](), o;
        !(r = (o = a.next()).done) && (t.push(o.value), !(e && t.length === e));
        r = !0
      );
    } catch (l) {
      ;(n = !0), (i = l)
    } finally {
      try {
        !r && a.return != null && a.return()
      } finally {
        if (n) throw i
      }
    }
    return t
  }
}
function Xo(s) {
  if (Array.isArray(s)) return s
}
var Qo = /[?&#](?:start|t)=([0-9hms]+)/,
  Zo = /[?&#]end=([0-9hms]+)/,
  pn = /(\d+)(h|m|s)/g,
  Jo = /^\d+$/
function Ts(s, e) {
  if (!(s instanceof Array)) {
    var t = s.match(e)
    if (t) {
      var r = t[1]
      if (r.match(pn)) return el(r)
      if (Jo.test(r)) return parseInt(r)
    }
  }
}
function el(s) {
  for (var e = 0, t = pn.exec(s); t !== null; ) {
    var r = t,
      n = Wo(r, 3),
      i = n[1],
      a = n[2]
    a === 'h' && (e += parseInt(i, 10) * 60 * 60),
      a === 'm' && (e += parseInt(i, 10) * 60),
      a === 's' && (e += parseInt(i, 10)),
      (t = pn.exec(s))
  }
  return e
}
function tl(s) {
  return Ts(s, Qo)
}
function rl(s) {
  return Ts(s, Zo)
}
function nl() {
  return Math.random().toString(36).substr(2, 5)
}
function il(s) {
  return Object.keys(s)
    .map(function (e) {
      return ''.concat(e, '=').concat(s[e])
    })
    .join('&')
}
function Ar(s) {
  return window[s]
    ? window[s]
    : window.exports && window.exports[s]
    ? window.exports[s]
    : window.module && window.module.exports && window.module.exports[s]
    ? window.module.exports[s]
    : null
}
var Tt = {}
function sl(s, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
    r =
      arguments.length > 3 && arguments[3] !== void 0
        ? arguments[3]
        : function () {
            return !0
          },
    n = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Vo.default,
    i = Ar(e)
  return i && r(i)
    ? Promise.resolve(i)
    : new Promise(function (a, o) {
        if (Tt[s]) {
          Tt[s].push({ resolve: a, reject: o })
          return
        }
        Tt[s] = [{ resolve: a, reject: o }]
        var l = function (f) {
          Tt[s].forEach(function (d) {
            return d.resolve(f)
          })
        }
        if (t) {
          var u = window[t]
          window[t] = function () {
            u && u(), l(Ar(e))
          }
        }
        n(s, function (c) {
          c
            ? (Tt[s].forEach(function (f) {
                return f.reject(c)
              }),
              (Tt[s] = null))
            : t || l(Ar(e))
        })
      })
}
function al(s, e) {
  return (0, Ho.default)(e.config, s.config)
}
function ol(s) {
  for (var e, t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n]
  for (
    var i = (e = []).concat.apply(e, r), a = {}, o = Object.keys(s), l = 0, u = o;
    l < u.length;
    l++
  ) {
    var c = u[l]
    i.indexOf(c) === -1 && (a[c] = s[c])
  }
  return a
}
function ll(s) {
  var e
  if (!this.player || !this.player[s]) {
    var t = 'ReactPlayer: '
      .concat(this.constructor.displayName, ' player could not call %c')
      .concat(s, '%c – ')
    return (
      this.player
        ? this.player[s] || (t += 'The method was not available')
        : (t += 'The player was not available'),
      console.warn(t, 'font-weight: bold', ''),
      null
    )
  }
  for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
    n[i - 1] = arguments[i]
  return (e = this.player)[s].apply(e, n)
}
function ul(s) {
  return typeof window < 'u' && typeof window.MediaStream < 'u' && s instanceof window.MediaStream
}
function cl(s) {
  return /^blob:/.test(s)
}
function fl() {
  var s =
      arguments.length > 0 && arguments[0] !== void 0
        ? arguments[0]
        : document.createElement('video'),
    e = /iPhone|iPod/.test(navigator.userAgent) === !1
  return s.webkitSupportsPresentationMode && typeof s.webkitSetPresentationMode == 'function' && e
}
var re = {}
Object.defineProperty(re, '__esModule', { value: !0 })
re.canPlay =
  re.FLV_EXTENSIONS =
  re.DASH_EXTENSIONS =
  re.HLS_EXTENSIONS =
  re.VIDEO_EXTENSIONS =
  re.AUDIO_EXTENSIONS =
  re.MATCH_URL_KALTURA =
  re.MATCH_URL_VIDYARD =
  re.MATCH_URL_MIXCLOUD =
  re.MATCH_URL_DAILYMOTION =
  re.MATCH_URL_TWITCH_CHANNEL =
  re.MATCH_URL_TWITCH_VIDEO =
  re.MATCH_URL_WISTIA =
  re.MATCH_URL_STREAMABLE =
  re.MATCH_URL_FACEBOOK_WATCH =
  re.MATCH_URL_FACEBOOK =
  re.MATCH_URL_VIMEO =
  re.MATCH_URL_SOUNDCLOUD =
  re.MATCH_URL_YOUTUBE =
    void 0
var ti = me
function dl(s, e) {
  var t
  if (typeof Symbol > 'u' || s[Symbol.iterator] == null) {
    if (Array.isArray(s) || (t = hl(s)) || (e && s && typeof s.length == 'number')) {
      t && (s = t)
      var r = 0,
        n = function () {}
      return {
        s: n,
        n: function () {
          return r >= s.length ? { done: !0 } : { done: !1, value: s[r++] }
        },
        e: function (u) {
          throw u
        },
        f: n
      }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  }
  var i = !0,
    a = !1,
    o
  return {
    s: function () {
      t = s[Symbol.iterator]()
    },
    n: function () {
      var u = t.next()
      return (i = u.done), u
    },
    e: function (u) {
      ;(a = !0), (o = u)
    },
    f: function () {
      try {
        !i && t.return != null && t.return()
      } finally {
        if (a) throw o
      }
    }
  }
}
function hl(s, e) {
  if (s) {
    if (typeof s == 'string') return ri(s, e)
    var t = Object.prototype.toString.call(s).slice(8, -1)
    if ((t === 'Object' && s.constructor && (t = s.constructor.name), t === 'Map' || t === 'Set'))
      return Array.from(s)
    if (t === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return ri(s, e)
  }
}
function ri(s, e) {
  ;(e == null || e > s.length) && (e = s.length)
  for (var t = 0, r = new Array(e); t < e; t++) r[t] = s[t]
  return r
}
var mn =
  /(?:youtu\.be\/|youtube(?:-nocookie|education)?\.com\/(?:embed\/|v\/|watch\/|watch\?v=|watch\?.+&v=|shorts\/|live\/))((\w|-){11})|youtube\.com\/playlist\?list=|youtube\.com\/user\//
re.MATCH_URL_YOUTUBE = mn
var bs = /(?:soundcloud\.com|snd\.sc)\/[^.]+$/
re.MATCH_URL_SOUNDCLOUD = bs
var Ls = /vimeo\.com\/(?!progressive_redirect).+/
re.MATCH_URL_VIMEO = Ls
var As = /^https?:\/\/(www\.)?facebook\.com.*\/(video(s)?|watch|story)(\.php?|\/).+$/
re.MATCH_URL_FACEBOOK = As
var Rs = /^https?:\/\/fb\.watch\/.+$/
re.MATCH_URL_FACEBOOK_WATCH = Rs
var Is = /streamable\.com\/([a-z0-9]+)$/
re.MATCH_URL_STREAMABLE = Is
var Ps = /(?:wistia\.(?:com|net)|wi\.st)\/(?:medias|embed)\/(?:iframe\/)?([^?]+)/
re.MATCH_URL_WISTIA = Ps
var Ds = /(?:www\.|go\.)?twitch\.tv\/videos\/(\d+)($|\?)/
re.MATCH_URL_TWITCH_VIDEO = Ds
var Os = /(?:www\.|go\.)?twitch\.tv\/([a-zA-Z0-9_]+)($|\?)/
re.MATCH_URL_TWITCH_CHANNEL = Os
var ws =
  /^(?:(?:https?):)?(?:\/\/)?(?:www\.)?(?:(?:dailymotion\.com(?:\/embed)?\/video)|dai\.ly)\/([a-zA-Z0-9]+)(?:_[\w_-]+)?(?:[\w.#_-]+)?/
re.MATCH_URL_DAILYMOTION = ws
var Cs = /mixcloud\.com\/([^/]+\/[^/]+)/
re.MATCH_URL_MIXCLOUD = Cs
var ks = /vidyard.com\/(?:watch\/)?([a-zA-Z0-9-_]+)/
re.MATCH_URL_VIDYARD = ks
var Ms =
  /^https?:\/\/[a-zA-Z]+\.kaltura.(com|org)\/p\/([0-9]+)\/sp\/([0-9]+)00\/embedIframeJs\/uiconf_id\/([0-9]+)\/partner_id\/([0-9]+)(.*)entry_id.([a-zA-Z0-9-_].*)$/
re.MATCH_URL_KALTURA = Ms
var Pn = /\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i
re.AUDIO_EXTENSIONS = Pn
var Dn = /\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\d+]+)?($|\?)/i
re.VIDEO_EXTENSIONS = Dn
var On = /\.(m3u8)($|\?)/i
re.HLS_EXTENSIONS = On
var Fs = /\.(mpd)($|\?)/i
re.DASH_EXTENSIONS = Fs
var Ns = /\.(flv)($|\?)/i
re.FLV_EXTENSIONS = Ns
var pl = function s(e) {
    if (e instanceof Array) {
      var t = dl(e),
        r
      try {
        for (t.s(); !(r = t.n()).done; ) {
          var n = r.value
          if ((typeof n == 'string' && s(n)) || s(n.src)) return !0
        }
      } catch (i) {
        t.e(i)
      } finally {
        t.f()
      }
      return !1
    }
    return (0, ti.isMediaStream)(e) || (0, ti.isBlobUrl)(e)
      ? !0
      : Pn.test(e) || Dn.test(e) || On.test(e) || Fs.test(e) || Ns.test(e)
  },
  ml = {
    youtube: function (e) {
      return e instanceof Array
        ? e.every(function (t) {
            return mn.test(t)
          })
        : mn.test(e)
    },
    soundcloud: function (e) {
      return bs.test(e) && !Pn.test(e)
    },
    vimeo: function (e) {
      return Ls.test(e) && !Dn.test(e) && !On.test(e)
    },
    facebook: function (e) {
      return As.test(e) || Rs.test(e)
    },
    streamable: function (e) {
      return Is.test(e)
    },
    wistia: function (e) {
      return Ps.test(e)
    },
    twitch: function (e) {
      return Ds.test(e) || Os.test(e)
    },
    dailymotion: function (e) {
      return ws.test(e)
    },
    mixcloud: function (e) {
      return Cs.test(e)
    },
    vidyard: function (e) {
      return ks.test(e)
    },
    kaltura: function (e) {
      return Ms.test(e)
    },
    file: pl
  }
re.canPlay = ml
var Rr = {},
  ni
function gl() {
  return (
    ni ||
      ((ni = 1),
      (function (s) {
        function e(w) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (F) {
                  return typeof F
                })
              : (e = function (F) {
                  return F &&
                    typeof Symbol == 'function' &&
                    F.constructor === Symbol &&
                    F !== Symbol.prototype
                    ? 'symbol'
                    : typeof F
                }),
            e(w)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = a(ee),
          r = me,
          n = re
        function i() {
          if (typeof WeakMap != 'function') return null
          var w = new WeakMap()
          return (
            (i = function () {
              return w
            }),
            w
          )
        }
        function a(w) {
          if (w && w.__esModule) return w
          if (w === null || (e(w) !== 'object' && typeof w != 'function')) return { default: w }
          var U = i()
          if (U && U.has(w)) return U.get(w)
          var F = {},
            k = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var B in w)
            if (Object.prototype.hasOwnProperty.call(w, B)) {
              var V = k ? Object.getOwnPropertyDescriptor(w, B) : null
              V && (V.get || V.set) ? Object.defineProperty(F, B, V) : (F[B] = w[B])
            }
          return (F.default = w), U && U.set(w, F), F
        }
        function o(w, U) {
          var F = Object.keys(w)
          if (Object.getOwnPropertySymbols) {
            var k = Object.getOwnPropertySymbols(w)
            U &&
              (k = k.filter(function (B) {
                return Object.getOwnPropertyDescriptor(w, B).enumerable
              })),
              F.push.apply(F, k)
          }
          return F
        }
        function l(w) {
          for (var U = 1; U < arguments.length; U++) {
            var F = arguments[U] != null ? arguments[U] : {}
            U % 2
              ? o(Object(F), !0).forEach(function (k) {
                  _(w, k, F[k])
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(F))
              : o(Object(F)).forEach(function (k) {
                  Object.defineProperty(w, k, Object.getOwnPropertyDescriptor(F, k))
                })
          }
          return w
        }
        function u(w, U) {
          return p(w) || m(w, U) || f(w, U) || c()
        }
        function c() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }
        function f(w, U) {
          if (w) {
            if (typeof w == 'string') return d(w, U)
            var F = Object.prototype.toString.call(w).slice(8, -1)
            if (
              (F === 'Object' && w.constructor && (F = w.constructor.name),
              F === 'Map' || F === 'Set')
            )
              return Array.from(w)
            if (F === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(F))
              return d(w, U)
          }
        }
        function d(w, U) {
          ;(U == null || U > w.length) && (U = w.length)
          for (var F = 0, k = new Array(U); F < U; F++) k[F] = w[F]
          return k
        }
        function m(w, U) {
          if (!(typeof Symbol > 'u' || !(Symbol.iterator in Object(w)))) {
            var F = [],
              k = !0,
              B = !1,
              V = void 0
            try {
              for (
                var H = w[Symbol.iterator](), q;
                !(k = (q = H.next()).done) && (F.push(q.value), !(U && F.length === U));
                k = !0
              );
            } catch (X) {
              ;(B = !0), (V = X)
            } finally {
              try {
                !k && H.return != null && H.return()
              } finally {
                if (B) throw V
              }
            }
            return F
          }
        }
        function p(w) {
          if (Array.isArray(w)) return w
        }
        function v(w, U) {
          if (!(w instanceof U)) throw new TypeError('Cannot call a class as a function')
        }
        function E(w, U) {
          for (var F = 0; F < U.length; F++) {
            var k = U[F]
            ;(k.enumerable = k.enumerable || !1),
              (k.configurable = !0),
              'value' in k && (k.writable = !0),
              Object.defineProperty(w, k.key, k)
          }
        }
        function x(w, U, F) {
          return U && E(w.prototype, U), F && E(w, F), w
        }
        function T(w, U) {
          if (typeof U != 'function' && U !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(w.prototype = Object.create(U && U.prototype, {
            constructor: { value: w, writable: !0, configurable: !0 }
          })),
            U && b(w, U)
        }
        function b(w, U) {
          return (
            (b =
              Object.setPrototypeOf ||
              function (k, B) {
                return (k.__proto__ = B), k
              }),
            b(w, U)
          )
        }
        function R(w) {
          var U = S()
          return function () {
            var k = h(w),
              B
            if (U) {
              var V = h(this).constructor
              B = Reflect.construct(k, arguments, V)
            } else B = k.apply(this, arguments)
            return g(this, B)
          }
        }
        function g(w, U) {
          return U && (e(U) === 'object' || typeof U == 'function') ? U : A(w)
        }
        function A(w) {
          if (w === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return w
        }
        function S() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function h(w) {
          return (
            (h = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (F) {
                  return F.__proto__ || Object.getPrototypeOf(F)
                }),
            h(w)
          )
        }
        function _(w, U, F) {
          return (
            U in w
              ? Object.defineProperty(w, U, {
                  value: F,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (w[U] = F),
            w
          )
        }
        var y = 'https://www.youtube.com/iframe_api',
          L = 'YT',
          I = 'onYouTubeIframeAPIReady',
          P = /[?&](?:list|channel)=([a-zA-Z0-9_-]+)/,
          D = /user\/([a-zA-Z0-9_-]+)\/?/,
          C = /youtube-nocookie\.com/,
          N = 'https://www.youtube-nocookie.com',
          M = (function (w) {
            T(F, w)
            var U = R(F)
            function F() {
              var k
              v(this, F)
              for (var B = arguments.length, V = new Array(B), H = 0; H < B; H++)
                V[H] = arguments[H]
              return (
                (k = U.call.apply(U, [this].concat(V))),
                _(A(k), 'callPlayer', r.callPlayer),
                _(A(k), 'parsePlaylist', function (q) {
                  if (q instanceof Array)
                    return { listType: 'playlist', playlist: q.map(k.getID).join(',') }
                  if (P.test(q)) {
                    var X = q.match(P),
                      Q = u(X, 2),
                      ae = Q[1]
                    return { listType: 'playlist', list: ae.replace(/^UC/, 'UU') }
                  }
                  if (D.test(q)) {
                    var ue = q.match(D),
                      he = u(ue, 2),
                      _e = he[1]
                    return { listType: 'user_uploads', list: _e }
                  }
                  return {}
                }),
                _(A(k), 'onStateChange', function (q) {
                  var X = q.data,
                    Q = k.props,
                    ae = Q.onPlay,
                    ue = Q.onPause,
                    he = Q.onBuffer,
                    _e = Q.onBufferEnd,
                    de = Q.onEnded,
                    te = Q.onReady,
                    be = Q.loop,
                    De = Q.config,
                    Ue = De.playerVars,
                    ke = De.onUnstarted,
                    xe = window[L].PlayerState,
                    at = xe.UNSTARTED,
                    ot = xe.PLAYING,
                    He = xe.PAUSED,
                    Be = xe.BUFFERING,
                    ft = xe.ENDED,
                    _t = xe.CUED
                  if (
                    (X === at && ke(),
                    X === ot && (ae(), _e()),
                    X === He && ue(),
                    X === Be && he(),
                    X === ft)
                  ) {
                    var Sr = !!k.callPlayer('getPlaylist')
                    be && !Sr && (Ue.start ? k.seekTo(Ue.start) : k.play()), de()
                  }
                  X === _t && te()
                }),
                _(A(k), 'mute', function () {
                  k.callPlayer('mute')
                }),
                _(A(k), 'unmute', function () {
                  k.callPlayer('unMute')
                }),
                _(A(k), 'ref', function (q) {
                  k.container = q
                }),
                k
              )
            }
            return (
              x(F, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    this.props.onMount && this.props.onMount(this)
                  }
                },
                {
                  key: 'getID',
                  value: function (B) {
                    return !B || B instanceof Array || P.test(B)
                      ? null
                      : B.match(n.MATCH_URL_YOUTUBE)[1]
                  }
                },
                {
                  key: 'load',
                  value: function (B, V) {
                    var H = this,
                      q = this.props,
                      X = q.playing,
                      Q = q.muted,
                      ae = q.playsinline,
                      ue = q.controls,
                      he = q.loop,
                      _e = q.config,
                      de = q.onError,
                      te = _e.playerVars,
                      be = _e.embedOptions,
                      De = this.getID(B)
                    if (V) {
                      if (P.test(B) || D.test(B) || B instanceof Array) {
                        this.player.loadPlaylist(this.parsePlaylist(B))
                        return
                      }
                      this.player.cueVideoById({
                        videoId: De,
                        startSeconds: (0, r.parseStartTime)(B) || te.start,
                        endSeconds: (0, r.parseEndTime)(B) || te.end
                      })
                      return
                    }
                    ;(0, r.getSDK)(y, L, I, function (Ue) {
                      return Ue.loaded
                    }).then(function (Ue) {
                      H.container &&
                        (H.player = new Ue.Player(
                          H.container,
                          l(
                            {
                              width: '100%',
                              height: '100%',
                              videoId: De,
                              playerVars: l(
                                l(
                                  {
                                    autoplay: X ? 1 : 0,
                                    mute: Q ? 1 : 0,
                                    controls: ue ? 1 : 0,
                                    start: (0, r.parseStartTime)(B),
                                    end: (0, r.parseEndTime)(B),
                                    origin: window.location.origin,
                                    playsinline: ae ? 1 : 0
                                  },
                                  H.parsePlaylist(B)
                                ),
                                te
                              ),
                              events: {
                                onReady: function () {
                                  he && H.player.setLoop(!0), H.props.onReady()
                                },
                                onPlaybackRateChange: function (xe) {
                                  return H.props.onPlaybackRateChange(xe.data)
                                },
                                onPlaybackQualityChange: function (xe) {
                                  return H.props.onPlaybackQualityChange(xe)
                                },
                                onStateChange: H.onStateChange,
                                onError: function (xe) {
                                  return de(xe.data)
                                }
                              },
                              host: C.test(B) ? N : void 0
                            },
                            be
                          )
                        ))
                    }, de),
                      be.events &&
                        console.warn(
                          'Using `embedOptions.events` will likely break things. Use ReactPlayer’s callback props instead, eg onReady, onPlay, onPause'
                        )
                  }
                },
                {
                  key: 'play',
                  value: function () {
                    this.callPlayer('playVideo')
                  }
                },
                {
                  key: 'pause',
                  value: function () {
                    this.callPlayer('pauseVideo')
                  }
                },
                {
                  key: 'stop',
                  value: function () {
                    document.body.contains(this.callPlayer('getIframe')) &&
                      this.callPlayer('stopVideo')
                  }
                },
                {
                  key: 'seekTo',
                  value: function (B) {
                    var V = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
                    this.callPlayer('seekTo', B), !V && !this.props.playing && this.pause()
                  }
                },
                {
                  key: 'setVolume',
                  value: function (B) {
                    this.callPlayer('setVolume', B * 100)
                  }
                },
                {
                  key: 'setPlaybackRate',
                  value: function (B) {
                    this.callPlayer('setPlaybackRate', B)
                  }
                },
                {
                  key: 'setLoop',
                  value: function (B) {
                    this.callPlayer('setLoop', B)
                  }
                },
                {
                  key: 'getDuration',
                  value: function () {
                    return this.callPlayer('getDuration')
                  }
                },
                {
                  key: 'getCurrentTime',
                  value: function () {
                    return this.callPlayer('getCurrentTime')
                  }
                },
                {
                  key: 'getSecondsLoaded',
                  value: function () {
                    return this.callPlayer('getVideoLoadedFraction') * this.getDuration()
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var B = this.props.display,
                      V = { width: '100%', height: '100%', display: B }
                    return t.default.createElement(
                      'div',
                      { style: V },
                      t.default.createElement('div', { ref: this.ref })
                    )
                  }
                }
              ]),
              F
            )
          })(t.Component)
        ;(s.default = M), _(M, 'displayName', 'YouTube'), _(M, 'canPlay', n.canPlay.youtube)
      })(Rr)),
    Rr
  )
}
var Ir = {},
  ii
function yl() {
  return (
    ii ||
      ((ii = 1),
      (function (s) {
        function e(S) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (_) {
                  return typeof _
                })
              : (e = function (_) {
                  return _ &&
                    typeof Symbol == 'function' &&
                    _.constructor === Symbol &&
                    _ !== Symbol.prototype
                    ? 'symbol'
                    : typeof _
                }),
            e(S)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = a(ee),
          r = me,
          n = re
        function i() {
          if (typeof WeakMap != 'function') return null
          var S = new WeakMap()
          return (
            (i = function () {
              return S
            }),
            S
          )
        }
        function a(S) {
          if (S && S.__esModule) return S
          if (S === null || (e(S) !== 'object' && typeof S != 'function')) return { default: S }
          var h = i()
          if (h && h.has(S)) return h.get(S)
          var _ = {},
            y = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var L in S)
            if (Object.prototype.hasOwnProperty.call(S, L)) {
              var I = y ? Object.getOwnPropertyDescriptor(S, L) : null
              I && (I.get || I.set) ? Object.defineProperty(_, L, I) : (_[L] = S[L])
            }
          return (_.default = S), h && h.set(S, _), _
        }
        function o(S, h) {
          var _ = Object.keys(S)
          if (Object.getOwnPropertySymbols) {
            var y = Object.getOwnPropertySymbols(S)
            h &&
              (y = y.filter(function (L) {
                return Object.getOwnPropertyDescriptor(S, L).enumerable
              })),
              _.push.apply(_, y)
          }
          return _
        }
        function l(S) {
          for (var h = 1; h < arguments.length; h++) {
            var _ = arguments[h] != null ? arguments[h] : {}
            h % 2
              ? o(Object(_), !0).forEach(function (y) {
                  b(S, y, _[y])
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(S, Object.getOwnPropertyDescriptors(_))
              : o(Object(_)).forEach(function (y) {
                  Object.defineProperty(S, y, Object.getOwnPropertyDescriptor(_, y))
                })
          }
          return S
        }
        function u(S, h) {
          if (!(S instanceof h)) throw new TypeError('Cannot call a class as a function')
        }
        function c(S, h) {
          for (var _ = 0; _ < h.length; _++) {
            var y = h[_]
            ;(y.enumerable = y.enumerable || !1),
              (y.configurable = !0),
              'value' in y && (y.writable = !0),
              Object.defineProperty(S, y.key, y)
          }
        }
        function f(S, h, _) {
          return h && c(S.prototype, h), _ && c(S, _), S
        }
        function d(S, h) {
          if (typeof h != 'function' && h !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(S.prototype = Object.create(h && h.prototype, {
            constructor: { value: S, writable: !0, configurable: !0 }
          })),
            h && m(S, h)
        }
        function m(S, h) {
          return (
            (m =
              Object.setPrototypeOf ||
              function (y, L) {
                return (y.__proto__ = L), y
              }),
            m(S, h)
          )
        }
        function p(S) {
          var h = x()
          return function () {
            var y = T(S),
              L
            if (h) {
              var I = T(this).constructor
              L = Reflect.construct(y, arguments, I)
            } else L = y.apply(this, arguments)
            return v(this, L)
          }
        }
        function v(S, h) {
          return h && (e(h) === 'object' || typeof h == 'function') ? h : E(S)
        }
        function E(S) {
          if (S === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return S
        }
        function x() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function T(S) {
          return (
            (T = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (_) {
                  return _.__proto__ || Object.getPrototypeOf(_)
                }),
            T(S)
          )
        }
        function b(S, h, _) {
          return (
            h in S
              ? Object.defineProperty(S, h, {
                  value: _,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (S[h] = _),
            S
          )
        }
        var R = 'https://w.soundcloud.com/player/api.js',
          g = 'SC',
          A = (function (S) {
            d(_, S)
            var h = p(_)
            function _() {
              var y
              u(this, _)
              for (var L = arguments.length, I = new Array(L), P = 0; P < L; P++)
                I[P] = arguments[P]
              return (
                (y = h.call.apply(h, [this].concat(I))),
                b(E(y), 'callPlayer', r.callPlayer),
                b(E(y), 'duration', null),
                b(E(y), 'currentTime', null),
                b(E(y), 'fractionLoaded', null),
                b(E(y), 'mute', function () {
                  y.setVolume(0)
                }),
                b(E(y), 'unmute', function () {
                  y.props.volume !== null && y.setVolume(y.props.volume)
                }),
                b(E(y), 'ref', function (D) {
                  y.iframe = D
                }),
                y
              )
            }
            return (
              f(_, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    this.props.onMount && this.props.onMount(this)
                  }
                },
                {
                  key: 'load',
                  value: function (L, I) {
                    var P = this
                    ;(0, r.getSDK)(R, g).then(function (D) {
                      if (P.iframe) {
                        var C = D.Widget.Events,
                          N = C.PLAY,
                          M = C.PLAY_PROGRESS,
                          w = C.PAUSE,
                          U = C.FINISH,
                          F = C.ERROR
                        I ||
                          ((P.player = D.Widget(P.iframe)),
                          P.player.bind(N, P.props.onPlay),
                          P.player.bind(w, function () {
                            var k = P.duration - P.currentTime
                            k < 0.05 || P.props.onPause()
                          }),
                          P.player.bind(M, function (k) {
                            ;(P.currentTime = k.currentPosition / 1e3),
                              (P.fractionLoaded = k.loadedProgress)
                          }),
                          P.player.bind(U, function () {
                            return P.props.onEnded()
                          }),
                          P.player.bind(F, function (k) {
                            return P.props.onError(k)
                          })),
                          P.player.load(
                            L,
                            l(
                              l({}, P.props.config.options),
                              {},
                              {
                                callback: function () {
                                  P.player.getDuration(function (B) {
                                    ;(P.duration = B / 1e3), P.props.onReady()
                                  })
                                }
                              }
                            )
                          )
                      }
                    })
                  }
                },
                {
                  key: 'play',
                  value: function () {
                    this.callPlayer('play')
                  }
                },
                {
                  key: 'pause',
                  value: function () {
                    this.callPlayer('pause')
                  }
                },
                { key: 'stop', value: function () {} },
                {
                  key: 'seekTo',
                  value: function (L) {
                    var I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
                    this.callPlayer('seekTo', L * 1e3), I || this.pause()
                  }
                },
                {
                  key: 'setVolume',
                  value: function (L) {
                    this.callPlayer('setVolume', L * 100)
                  }
                },
                {
                  key: 'getDuration',
                  value: function () {
                    return this.duration
                  }
                },
                {
                  key: 'getCurrentTime',
                  value: function () {
                    return this.currentTime
                  }
                },
                {
                  key: 'getSecondsLoaded',
                  value: function () {
                    return this.fractionLoaded * this.duration
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var L = this.props.display,
                      I = { width: '100%', height: '100%', display: L }
                    return t.default.createElement('iframe', {
                      ref: this.ref,
                      src: 'https://w.soundcloud.com/player/?url='.concat(
                        encodeURIComponent(this.props.url)
                      ),
                      style: I,
                      frameBorder: 0,
                      allow: 'autoplay'
                    })
                  }
                }
              ]),
              _
            )
          })(t.Component)
        ;(s.default = A),
          b(A, 'displayName', 'SoundCloud'),
          b(A, 'canPlay', n.canPlay.soundcloud),
          b(A, 'loopOnEnded', !0)
      })(Ir)),
    Ir
  )
}
var Pr = {},
  si
function vl() {
  return (
    si ||
      ((si = 1),
      (function (s) {
        function e(h) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (y) {
                  return typeof y
                })
              : (e = function (y) {
                  return y &&
                    typeof Symbol == 'function' &&
                    y.constructor === Symbol &&
                    y !== Symbol.prototype
                    ? 'symbol'
                    : typeof y
                }),
            e(h)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = a(ee),
          r = me,
          n = re
        function i() {
          if (typeof WeakMap != 'function') return null
          var h = new WeakMap()
          return (
            (i = function () {
              return h
            }),
            h
          )
        }
        function a(h) {
          if (h && h.__esModule) return h
          if (h === null || (e(h) !== 'object' && typeof h != 'function')) return { default: h }
          var _ = i()
          if (_ && _.has(h)) return _.get(h)
          var y = {},
            L = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var I in h)
            if (Object.prototype.hasOwnProperty.call(h, I)) {
              var P = L ? Object.getOwnPropertyDescriptor(h, I) : null
              P && (P.get || P.set) ? Object.defineProperty(y, I, P) : (y[I] = h[I])
            }
          return (y.default = h), _ && _.set(h, y), y
        }
        function o(h, _) {
          var y = Object.keys(h)
          if (Object.getOwnPropertySymbols) {
            var L = Object.getOwnPropertySymbols(h)
            _ &&
              (L = L.filter(function (I) {
                return Object.getOwnPropertyDescriptor(h, I).enumerable
              })),
              y.push.apply(y, L)
          }
          return y
        }
        function l(h) {
          for (var _ = 1; _ < arguments.length; _++) {
            var y = arguments[_] != null ? arguments[_] : {}
            _ % 2
              ? o(Object(y), !0).forEach(function (L) {
                  b(h, L, y[L])
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(h, Object.getOwnPropertyDescriptors(y))
              : o(Object(y)).forEach(function (L) {
                  Object.defineProperty(h, L, Object.getOwnPropertyDescriptor(y, L))
                })
          }
          return h
        }
        function u(h, _) {
          if (!(h instanceof _)) throw new TypeError('Cannot call a class as a function')
        }
        function c(h, _) {
          for (var y = 0; y < _.length; y++) {
            var L = _[y]
            ;(L.enumerable = L.enumerable || !1),
              (L.configurable = !0),
              'value' in L && (L.writable = !0),
              Object.defineProperty(h, L.key, L)
          }
        }
        function f(h, _, y) {
          return _ && c(h.prototype, _), y && c(h, y), h
        }
        function d(h, _) {
          if (typeof _ != 'function' && _ !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(h.prototype = Object.create(_ && _.prototype, {
            constructor: { value: h, writable: !0, configurable: !0 }
          })),
            _ && m(h, _)
        }
        function m(h, _) {
          return (
            (m =
              Object.setPrototypeOf ||
              function (L, I) {
                return (L.__proto__ = I), L
              }),
            m(h, _)
          )
        }
        function p(h) {
          var _ = x()
          return function () {
            var L = T(h),
              I
            if (_) {
              var P = T(this).constructor
              I = Reflect.construct(L, arguments, P)
            } else I = L.apply(this, arguments)
            return v(this, I)
          }
        }
        function v(h, _) {
          return _ && (e(_) === 'object' || typeof _ == 'function') ? _ : E(h)
        }
        function E(h) {
          if (h === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return h
        }
        function x() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function T(h) {
          return (
            (T = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (y) {
                  return y.__proto__ || Object.getPrototypeOf(y)
                }),
            T(h)
          )
        }
        function b(h, _, y) {
          return (
            _ in h
              ? Object.defineProperty(h, _, {
                  value: y,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (h[_] = y),
            h
          )
        }
        var R = 'https://player.vimeo.com/api/player.js',
          g = 'Vimeo',
          A = function (_) {
            return _.replace('/manage/videos', '')
          },
          S = (function (h) {
            d(y, h)
            var _ = p(y)
            function y() {
              var L
              u(this, y)
              for (var I = arguments.length, P = new Array(I), D = 0; D < I; D++)
                P[D] = arguments[D]
              return (
                (L = _.call.apply(_, [this].concat(P))),
                b(E(L), 'callPlayer', r.callPlayer),
                b(E(L), 'duration', null),
                b(E(L), 'currentTime', null),
                b(E(L), 'secondsLoaded', null),
                b(E(L), 'mute', function () {
                  L.setMuted(!0)
                }),
                b(E(L), 'unmute', function () {
                  L.setMuted(!1)
                }),
                b(E(L), 'ref', function (C) {
                  L.container = C
                }),
                L
              )
            }
            return (
              f(y, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    this.props.onMount && this.props.onMount(this)
                  }
                },
                {
                  key: 'load',
                  value: function (I) {
                    var P = this
                    ;(this.duration = null),
                      (0, r.getSDK)(R, g).then(function (D) {
                        if (P.container) {
                          var C = P.props.config,
                            N = C.playerOptions,
                            M = C.title
                          ;(P.player = new D.Player(
                            P.container,
                            l(
                              {
                                url: A(I),
                                autoplay: P.props.playing,
                                muted: P.props.muted,
                                loop: P.props.loop,
                                playsinline: P.props.playsinline,
                                controls: P.props.controls
                              },
                              N
                            )
                          )),
                            P.player
                              .ready()
                              .then(function () {
                                var w = P.container.querySelector('iframe')
                                ;(w.style.width = '100%'),
                                  (w.style.height = '100%'),
                                  M && (w.title = M)
                              })
                              .catch(P.props.onError),
                            P.player.on('loaded', function () {
                              P.props.onReady(), P.refreshDuration()
                            }),
                            P.player.on('play', function () {
                              P.props.onPlay(), P.refreshDuration()
                            }),
                            P.player.on('pause', P.props.onPause),
                            P.player.on('seeked', function (w) {
                              return P.props.onSeek(w.seconds)
                            }),
                            P.player.on('ended', P.props.onEnded),
                            P.player.on('error', P.props.onError),
                            P.player.on('timeupdate', function (w) {
                              var U = w.seconds
                              P.currentTime = U
                            }),
                            P.player.on('progress', function (w) {
                              var U = w.seconds
                              P.secondsLoaded = U
                            }),
                            P.player.on('bufferstart', P.props.onBuffer),
                            P.player.on('bufferend', P.props.onBufferEnd),
                            P.player.on('playbackratechange', function (w) {
                              return P.props.onPlaybackRateChange(w.playbackRate)
                            })
                        }
                      }, this.props.onError)
                  }
                },
                {
                  key: 'refreshDuration',
                  value: function () {
                    var I = this
                    this.player.getDuration().then(function (P) {
                      I.duration = P
                    })
                  }
                },
                {
                  key: 'play',
                  value: function () {
                    var I = this.callPlayer('play')
                    I && I.catch(this.props.onError)
                  }
                },
                {
                  key: 'pause',
                  value: function () {
                    this.callPlayer('pause')
                  }
                },
                {
                  key: 'stop',
                  value: function () {
                    this.callPlayer('unload')
                  }
                },
                {
                  key: 'seekTo',
                  value: function (I) {
                    var P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
                    this.callPlayer('setCurrentTime', I), P || this.pause()
                  }
                },
                {
                  key: 'setVolume',
                  value: function (I) {
                    this.callPlayer('setVolume', I)
                  }
                },
                {
                  key: 'setMuted',
                  value: function (I) {
                    this.callPlayer('setMuted', I)
                  }
                },
                {
                  key: 'setLoop',
                  value: function (I) {
                    this.callPlayer('setLoop', I)
                  }
                },
                {
                  key: 'setPlaybackRate',
                  value: function (I) {
                    this.callPlayer('setPlaybackRate', I)
                  }
                },
                {
                  key: 'getDuration',
                  value: function () {
                    return this.duration
                  }
                },
                {
                  key: 'getCurrentTime',
                  value: function () {
                    return this.currentTime
                  }
                },
                {
                  key: 'getSecondsLoaded',
                  value: function () {
                    return this.secondsLoaded
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var I = this.props.display,
                      P = { width: '100%', height: '100%', overflow: 'hidden', display: I }
                    return t.default.createElement('div', {
                      key: this.props.url,
                      ref: this.ref,
                      style: P
                    })
                  }
                }
              ]),
              y
            )
          })(t.Component)
        ;(s.default = S),
          b(S, 'displayName', 'Vimeo'),
          b(S, 'canPlay', n.canPlay.vimeo),
          b(S, 'forceLoad', !0)
      })(Pr)),
    Pr
  )
}
var Dr = {},
  ai
function _l() {
  return (
    ai ||
      ((ai = 1),
      (function (s) {
        function e(h) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (y) {
                  return typeof y
                })
              : (e = function (y) {
                  return y &&
                    typeof Symbol == 'function' &&
                    y.constructor === Symbol &&
                    y !== Symbol.prototype
                    ? 'symbol'
                    : typeof y
                }),
            e(h)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = a(ee),
          r = me,
          n = re
        function i() {
          if (typeof WeakMap != 'function') return null
          var h = new WeakMap()
          return (
            (i = function () {
              return h
            }),
            h
          )
        }
        function a(h) {
          if (h && h.__esModule) return h
          if (h === null || (e(h) !== 'object' && typeof h != 'function')) return { default: h }
          var _ = i()
          if (_ && _.has(h)) return _.get(h)
          var y = {},
            L = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var I in h)
            if (Object.prototype.hasOwnProperty.call(h, I)) {
              var P = L ? Object.getOwnPropertyDescriptor(h, I) : null
              P && (P.get || P.set) ? Object.defineProperty(y, I, P) : (y[I] = h[I])
            }
          return (y.default = h), _ && _.set(h, y), y
        }
        function o() {
          return (
            (o =
              Object.assign ||
              function (h) {
                for (var _ = 1; _ < arguments.length; _++) {
                  var y = arguments[_]
                  for (var L in y) Object.prototype.hasOwnProperty.call(y, L) && (h[L] = y[L])
                }
                return h
              }),
            o.apply(this, arguments)
          )
        }
        function l(h, _) {
          if (!(h instanceof _)) throw new TypeError('Cannot call a class as a function')
        }
        function u(h, _) {
          for (var y = 0; y < _.length; y++) {
            var L = _[y]
            ;(L.enumerable = L.enumerable || !1),
              (L.configurable = !0),
              'value' in L && (L.writable = !0),
              Object.defineProperty(h, L.key, L)
          }
        }
        function c(h, _, y) {
          return _ && u(h.prototype, _), y && u(h, y), h
        }
        function f(h, _) {
          if (typeof _ != 'function' && _ !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(h.prototype = Object.create(_ && _.prototype, {
            constructor: { value: h, writable: !0, configurable: !0 }
          })),
            _ && d(h, _)
        }
        function d(h, _) {
          return (
            (d =
              Object.setPrototypeOf ||
              function (L, I) {
                return (L.__proto__ = I), L
              }),
            d(h, _)
          )
        }
        function m(h) {
          var _ = E()
          return function () {
            var L = x(h),
              I
            if (_) {
              var P = x(this).constructor
              I = Reflect.construct(L, arguments, P)
            } else I = L.apply(this, arguments)
            return p(this, I)
          }
        }
        function p(h, _) {
          return _ && (e(_) === 'object' || typeof _ == 'function') ? _ : v(h)
        }
        function v(h) {
          if (h === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return h
        }
        function E() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function x(h) {
          return (
            (x = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (y) {
                  return y.__proto__ || Object.getPrototypeOf(y)
                }),
            x(h)
          )
        }
        function T(h, _, y) {
          return (
            _ in h
              ? Object.defineProperty(h, _, {
                  value: y,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (h[_] = y),
            h
          )
        }
        var b = 'https://connect.facebook.net/en_US/sdk.js',
          R = 'FB',
          g = 'fbAsyncInit',
          A = 'facebook-player-',
          S = (function (h) {
            f(y, h)
            var _ = m(y)
            function y() {
              var L
              l(this, y)
              for (var I = arguments.length, P = new Array(I), D = 0; D < I; D++)
                P[D] = arguments[D]
              return (
                (L = _.call.apply(_, [this].concat(P))),
                T(v(L), 'callPlayer', r.callPlayer),
                T(
                  v(L),
                  'playerID',
                  L.props.config.playerId || ''.concat(A).concat((0, r.randomString)())
                ),
                T(v(L), 'mute', function () {
                  L.callPlayer('mute')
                }),
                T(v(L), 'unmute', function () {
                  L.callPlayer('unmute')
                }),
                L
              )
            }
            return (
              c(y, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    this.props.onMount && this.props.onMount(this)
                  }
                },
                {
                  key: 'load',
                  value: function (I, P) {
                    var D = this
                    if (P) {
                      ;(0, r.getSDK)(b, R, g).then(function (C) {
                        return C.XFBML.parse()
                      })
                      return
                    }
                    ;(0, r.getSDK)(b, R, g).then(function (C) {
                      C.init({
                        appId: D.props.config.appId,
                        xfbml: !0,
                        version: D.props.config.version
                      }),
                        C.Event.subscribe('xfbml.render', function (N) {
                          D.props.onLoaded()
                        }),
                        C.Event.subscribe('xfbml.ready', function (N) {
                          N.type === 'video' &&
                            N.id === D.playerID &&
                            ((D.player = N.instance),
                            D.player.subscribe('startedPlaying', D.props.onPlay),
                            D.player.subscribe('paused', D.props.onPause),
                            D.player.subscribe('finishedPlaying', D.props.onEnded),
                            D.player.subscribe('startedBuffering', D.props.onBuffer),
                            D.player.subscribe('finishedBuffering', D.props.onBufferEnd),
                            D.player.subscribe('error', D.props.onError),
                            D.props.muted ? D.callPlayer('mute') : D.callPlayer('unmute'),
                            D.props.onReady(),
                            (document
                              .getElementById(D.playerID)
                              .querySelector('iframe').style.visibility = 'visible'))
                        })
                    })
                  }
                },
                {
                  key: 'play',
                  value: function () {
                    this.callPlayer('play')
                  }
                },
                {
                  key: 'pause',
                  value: function () {
                    this.callPlayer('pause')
                  }
                },
                { key: 'stop', value: function () {} },
                {
                  key: 'seekTo',
                  value: function (I) {
                    var P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
                    this.callPlayer('seek', I), P || this.pause()
                  }
                },
                {
                  key: 'setVolume',
                  value: function (I) {
                    this.callPlayer('setVolume', I)
                  }
                },
                {
                  key: 'getDuration',
                  value: function () {
                    return this.callPlayer('getDuration')
                  }
                },
                {
                  key: 'getCurrentTime',
                  value: function () {
                    return this.callPlayer('getCurrentPosition')
                  }
                },
                {
                  key: 'getSecondsLoaded',
                  value: function () {
                    return null
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var I = this.props.config.attributes,
                      P = { width: '100%', height: '100%' }
                    return t.default.createElement(
                      'div',
                      o(
                        {
                          style: P,
                          id: this.playerID,
                          className: 'fb-video',
                          'data-href': this.props.url,
                          'data-autoplay': this.props.playing ? 'true' : 'false',
                          'data-allowfullscreen': 'true',
                          'data-controls': this.props.controls ? 'true' : 'false'
                        },
                        I
                      )
                    )
                  }
                }
              ]),
              y
            )
          })(t.Component)
        ;(s.default = S),
          T(S, 'displayName', 'Facebook'),
          T(S, 'canPlay', n.canPlay.facebook),
          T(S, 'loopOnEnded', !0)
      })(Dr)),
    Dr
  )
}
var Or = {},
  oi
function El() {
  return (
    oi ||
      ((oi = 1),
      (function (s) {
        function e(g) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (S) {
                  return typeof S
                })
              : (e = function (S) {
                  return S &&
                    typeof Symbol == 'function' &&
                    S.constructor === Symbol &&
                    S !== Symbol.prototype
                    ? 'symbol'
                    : typeof S
                }),
            e(g)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = a(ee),
          r = me,
          n = re
        function i() {
          if (typeof WeakMap != 'function') return null
          var g = new WeakMap()
          return (
            (i = function () {
              return g
            }),
            g
          )
        }
        function a(g) {
          if (g && g.__esModule) return g
          if (g === null || (e(g) !== 'object' && typeof g != 'function')) return { default: g }
          var A = i()
          if (A && A.has(g)) return A.get(g)
          var S = {},
            h = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var _ in g)
            if (Object.prototype.hasOwnProperty.call(g, _)) {
              var y = h ? Object.getOwnPropertyDescriptor(g, _) : null
              y && (y.get || y.set) ? Object.defineProperty(S, _, y) : (S[_] = g[_])
            }
          return (S.default = g), A && A.set(g, S), S
        }
        function o(g, A) {
          if (!(g instanceof A)) throw new TypeError('Cannot call a class as a function')
        }
        function l(g, A) {
          for (var S = 0; S < A.length; S++) {
            var h = A[S]
            ;(h.enumerable = h.enumerable || !1),
              (h.configurable = !0),
              'value' in h && (h.writable = !0),
              Object.defineProperty(g, h.key, h)
          }
        }
        function u(g, A, S) {
          return A && l(g.prototype, A), S && l(g, S), g
        }
        function c(g, A) {
          if (typeof A != 'function' && A !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(g.prototype = Object.create(A && A.prototype, {
            constructor: { value: g, writable: !0, configurable: !0 }
          })),
            A && f(g, A)
        }
        function f(g, A) {
          return (
            (f =
              Object.setPrototypeOf ||
              function (h, _) {
                return (h.__proto__ = _), h
              }),
            f(g, A)
          )
        }
        function d(g) {
          var A = v()
          return function () {
            var h = E(g),
              _
            if (A) {
              var y = E(this).constructor
              _ = Reflect.construct(h, arguments, y)
            } else _ = h.apply(this, arguments)
            return m(this, _)
          }
        }
        function m(g, A) {
          return A && (e(A) === 'object' || typeof A == 'function') ? A : p(g)
        }
        function p(g) {
          if (g === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return g
        }
        function v() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function E(g) {
          return (
            (E = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (S) {
                  return S.__proto__ || Object.getPrototypeOf(S)
                }),
            E(g)
          )
        }
        function x(g, A, S) {
          return (
            A in g
              ? Object.defineProperty(g, A, {
                  value: S,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (g[A] = S),
            g
          )
        }
        var T = 'https://cdn.embed.ly/player-0.1.0.min.js',
          b = 'playerjs',
          R = (function (g) {
            c(S, g)
            var A = d(S)
            function S() {
              var h
              o(this, S)
              for (var _ = arguments.length, y = new Array(_), L = 0; L < _; L++)
                y[L] = arguments[L]
              return (
                (h = A.call.apply(A, [this].concat(y))),
                x(p(h), 'callPlayer', r.callPlayer),
                x(p(h), 'duration', null),
                x(p(h), 'currentTime', null),
                x(p(h), 'secondsLoaded', null),
                x(p(h), 'mute', function () {
                  h.callPlayer('mute')
                }),
                x(p(h), 'unmute', function () {
                  h.callPlayer('unmute')
                }),
                x(p(h), 'ref', function (I) {
                  h.iframe = I
                }),
                h
              )
            }
            return (
              u(S, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    this.props.onMount && this.props.onMount(this)
                  }
                },
                {
                  key: 'load',
                  value: function (_) {
                    var y = this
                    ;(0, r.getSDK)(T, b).then(function (L) {
                      y.iframe &&
                        ((y.player = new L.Player(y.iframe)),
                        y.player.setLoop(y.props.loop),
                        y.player.on('ready', y.props.onReady),
                        y.player.on('play', y.props.onPlay),
                        y.player.on('pause', y.props.onPause),
                        y.player.on('seeked', y.props.onSeek),
                        y.player.on('ended', y.props.onEnded),
                        y.player.on('error', y.props.onError),
                        y.player.on('timeupdate', function (I) {
                          var P = I.duration,
                            D = I.seconds
                          ;(y.duration = P), (y.currentTime = D)
                        }),
                        y.player.on('buffered', function (I) {
                          var P = I.percent
                          y.duration && (y.secondsLoaded = y.duration * P)
                        }),
                        y.props.muted && y.player.mute())
                    }, this.props.onError)
                  }
                },
                {
                  key: 'play',
                  value: function () {
                    this.callPlayer('play')
                  }
                },
                {
                  key: 'pause',
                  value: function () {
                    this.callPlayer('pause')
                  }
                },
                { key: 'stop', value: function () {} },
                {
                  key: 'seekTo',
                  value: function (_) {
                    var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
                    this.callPlayer('setCurrentTime', _), y || this.pause()
                  }
                },
                {
                  key: 'setVolume',
                  value: function (_) {
                    this.callPlayer('setVolume', _ * 100)
                  }
                },
                {
                  key: 'setLoop',
                  value: function (_) {
                    this.callPlayer('setLoop', _)
                  }
                },
                {
                  key: 'getDuration',
                  value: function () {
                    return this.duration
                  }
                },
                {
                  key: 'getCurrentTime',
                  value: function () {
                    return this.currentTime
                  }
                },
                {
                  key: 'getSecondsLoaded',
                  value: function () {
                    return this.secondsLoaded
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var _ = this.props.url.match(n.MATCH_URL_STREAMABLE)[1],
                      y = { width: '100%', height: '100%' }
                    return t.default.createElement('iframe', {
                      ref: this.ref,
                      src: 'https://streamable.com/o/'.concat(_),
                      frameBorder: '0',
                      scrolling: 'no',
                      style: y,
                      allow: 'encrypted-media; autoplay; fullscreen;'
                    })
                  }
                }
              ]),
              S
            )
          })(t.Component)
        ;(s.default = R), x(R, 'displayName', 'Streamable'), x(R, 'canPlay', n.canPlay.streamable)
      })(Or)),
    Or
  )
}
var wr = {},
  li
function xl() {
  return (
    li ||
      ((li = 1),
      (function (s) {
        function e(h) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (y) {
                  return typeof y
                })
              : (e = function (y) {
                  return y &&
                    typeof Symbol == 'function' &&
                    y.constructor === Symbol &&
                    y !== Symbol.prototype
                    ? 'symbol'
                    : typeof y
                }),
            e(h)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = a(ee),
          r = me,
          n = re
        function i() {
          if (typeof WeakMap != 'function') return null
          var h = new WeakMap()
          return (
            (i = function () {
              return h
            }),
            h
          )
        }
        function a(h) {
          if (h && h.__esModule) return h
          if (h === null || (e(h) !== 'object' && typeof h != 'function')) return { default: h }
          var _ = i()
          if (_ && _.has(h)) return _.get(h)
          var y = {},
            L = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var I in h)
            if (Object.prototype.hasOwnProperty.call(h, I)) {
              var P = L ? Object.getOwnPropertyDescriptor(h, I) : null
              P && (P.get || P.set) ? Object.defineProperty(y, I, P) : (y[I] = h[I])
            }
          return (y.default = h), _ && _.set(h, y), y
        }
        function o(h, _) {
          var y = Object.keys(h)
          if (Object.getOwnPropertySymbols) {
            var L = Object.getOwnPropertySymbols(h)
            _ &&
              (L = L.filter(function (I) {
                return Object.getOwnPropertyDescriptor(h, I).enumerable
              })),
              y.push.apply(y, L)
          }
          return y
        }
        function l(h) {
          for (var _ = 1; _ < arguments.length; _++) {
            var y = arguments[_] != null ? arguments[_] : {}
            _ % 2
              ? o(Object(y), !0).forEach(function (L) {
                  b(h, L, y[L])
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(h, Object.getOwnPropertyDescriptors(y))
              : o(Object(y)).forEach(function (L) {
                  Object.defineProperty(h, L, Object.getOwnPropertyDescriptor(y, L))
                })
          }
          return h
        }
        function u(h, _) {
          if (!(h instanceof _)) throw new TypeError('Cannot call a class as a function')
        }
        function c(h, _) {
          for (var y = 0; y < _.length; y++) {
            var L = _[y]
            ;(L.enumerable = L.enumerable || !1),
              (L.configurable = !0),
              'value' in L && (L.writable = !0),
              Object.defineProperty(h, L.key, L)
          }
        }
        function f(h, _, y) {
          return _ && c(h.prototype, _), y && c(h, y), h
        }
        function d(h, _) {
          if (typeof _ != 'function' && _ !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(h.prototype = Object.create(_ && _.prototype, {
            constructor: { value: h, writable: !0, configurable: !0 }
          })),
            _ && m(h, _)
        }
        function m(h, _) {
          return (
            (m =
              Object.setPrototypeOf ||
              function (L, I) {
                return (L.__proto__ = I), L
              }),
            m(h, _)
          )
        }
        function p(h) {
          var _ = x()
          return function () {
            var L = T(h),
              I
            if (_) {
              var P = T(this).constructor
              I = Reflect.construct(L, arguments, P)
            } else I = L.apply(this, arguments)
            return v(this, I)
          }
        }
        function v(h, _) {
          return _ && (e(_) === 'object' || typeof _ == 'function') ? _ : E(h)
        }
        function E(h) {
          if (h === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return h
        }
        function x() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function T(h) {
          return (
            (T = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (y) {
                  return y.__proto__ || Object.getPrototypeOf(y)
                }),
            T(h)
          )
        }
        function b(h, _, y) {
          return (
            _ in h
              ? Object.defineProperty(h, _, {
                  value: y,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (h[_] = y),
            h
          )
        }
        var R = 'https://fast.wistia.com/assets/external/E-v1.js',
          g = 'Wistia',
          A = 'wistia-player-',
          S = (function (h) {
            d(y, h)
            var _ = p(y)
            function y() {
              var L
              u(this, y)
              for (var I = arguments.length, P = new Array(I), D = 0; D < I; D++)
                P[D] = arguments[D]
              return (
                (L = _.call.apply(_, [this].concat(P))),
                b(E(L), 'callPlayer', r.callPlayer),
                b(
                  E(L),
                  'playerID',
                  L.props.config.playerId || ''.concat(A).concat((0, r.randomString)())
                ),
                b(E(L), 'onPlay', function () {
                  var C
                  return (C = L.props).onPlay.apply(C, arguments)
                }),
                b(E(L), 'onPause', function () {
                  var C
                  return (C = L.props).onPause.apply(C, arguments)
                }),
                b(E(L), 'onSeek', function () {
                  var C
                  return (C = L.props).onSeek.apply(C, arguments)
                }),
                b(E(L), 'onEnded', function () {
                  var C
                  return (C = L.props).onEnded.apply(C, arguments)
                }),
                b(E(L), 'onPlaybackRateChange', function () {
                  var C
                  return (C = L.props).onPlaybackRateChange.apply(C, arguments)
                }),
                b(E(L), 'mute', function () {
                  L.callPlayer('mute')
                }),
                b(E(L), 'unmute', function () {
                  L.callPlayer('unmute')
                }),
                L
              )
            }
            return (
              f(y, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    this.props.onMount && this.props.onMount(this)
                  }
                },
                {
                  key: 'load',
                  value: function (I) {
                    var P = this,
                      D = this.props,
                      C = D.playing,
                      N = D.muted,
                      M = D.controls,
                      w = D.onReady,
                      U = D.config,
                      F = D.onError
                    ;(0, r.getSDK)(R, g).then(function (k) {
                      U.customControls &&
                        U.customControls.forEach(function (B) {
                          return k.defineControl(B)
                        }),
                        (window._wq = window._wq || []),
                        window._wq.push({
                          id: P.playerID,
                          options: l(
                            {
                              autoPlay: C,
                              silentAutoPlay: 'allow',
                              muted: N,
                              controlsVisibleOnLoad: M,
                              fullscreenButton: M,
                              playbar: M,
                              playbackRateControl: M,
                              qualityControl: M,
                              volumeControl: M,
                              settingsControl: M,
                              smallPlayButton: M
                            },
                            U.options
                          ),
                          onReady: function (V) {
                            ;(P.player = V),
                              P.unbind(),
                              P.player.bind('play', P.onPlay),
                              P.player.bind('pause', P.onPause),
                              P.player.bind('seek', P.onSeek),
                              P.player.bind('end', P.onEnded),
                              P.player.bind('playbackratechange', P.onPlaybackRateChange),
                              w()
                          }
                        })
                    }, F)
                  }
                },
                {
                  key: 'unbind',
                  value: function () {
                    this.player.unbind('play', this.onPlay),
                      this.player.unbind('pause', this.onPause),
                      this.player.unbind('seek', this.onSeek),
                      this.player.unbind('end', this.onEnded),
                      this.player.unbind('playbackratechange', this.onPlaybackRateChange)
                  }
                },
                {
                  key: 'play',
                  value: function () {
                    this.callPlayer('play')
                  }
                },
                {
                  key: 'pause',
                  value: function () {
                    this.callPlayer('pause')
                  }
                },
                {
                  key: 'stop',
                  value: function () {
                    this.unbind(), this.callPlayer('remove')
                  }
                },
                {
                  key: 'seekTo',
                  value: function (I) {
                    var P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
                    this.callPlayer('time', I), P || this.pause()
                  }
                },
                {
                  key: 'setVolume',
                  value: function (I) {
                    this.callPlayer('volume', I)
                  }
                },
                {
                  key: 'setPlaybackRate',
                  value: function (I) {
                    this.callPlayer('playbackRate', I)
                  }
                },
                {
                  key: 'getDuration',
                  value: function () {
                    return this.callPlayer('duration')
                  }
                },
                {
                  key: 'getCurrentTime',
                  value: function () {
                    return this.callPlayer('time')
                  }
                },
                {
                  key: 'getSecondsLoaded',
                  value: function () {
                    return null
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var I = this.props.url,
                      P = I && I.match(n.MATCH_URL_WISTIA)[1],
                      D = 'wistia_embed wistia_async_'.concat(P),
                      C = { width: '100%', height: '100%' }
                    return t.default.createElement('div', {
                      id: this.playerID,
                      key: P,
                      className: D,
                      style: C
                    })
                  }
                }
              ]),
              y
            )
          })(t.Component)
        ;(s.default = S),
          b(S, 'displayName', 'Wistia'),
          b(S, 'canPlay', n.canPlay.wistia),
          b(S, 'loopOnEnded', !0)
      })(wr)),
    wr
  )
}
var Cr = {},
  ui
function Sl() {
  return (
    ui ||
      ((ui = 1),
      (function (s) {
        function e(h) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (y) {
                  return typeof y
                })
              : (e = function (y) {
                  return y &&
                    typeof Symbol == 'function' &&
                    y.constructor === Symbol &&
                    y !== Symbol.prototype
                    ? 'symbol'
                    : typeof y
                }),
            e(h)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = a(ee),
          r = me,
          n = re
        function i() {
          if (typeof WeakMap != 'function') return null
          var h = new WeakMap()
          return (
            (i = function () {
              return h
            }),
            h
          )
        }
        function a(h) {
          if (h && h.__esModule) return h
          if (h === null || (e(h) !== 'object' && typeof h != 'function')) return { default: h }
          var _ = i()
          if (_ && _.has(h)) return _.get(h)
          var y = {},
            L = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var I in h)
            if (Object.prototype.hasOwnProperty.call(h, I)) {
              var P = L ? Object.getOwnPropertyDescriptor(h, I) : null
              P && (P.get || P.set) ? Object.defineProperty(y, I, P) : (y[I] = h[I])
            }
          return (y.default = h), _ && _.set(h, y), y
        }
        function o(h, _) {
          var y = Object.keys(h)
          if (Object.getOwnPropertySymbols) {
            var L = Object.getOwnPropertySymbols(h)
            _ &&
              (L = L.filter(function (I) {
                return Object.getOwnPropertyDescriptor(h, I).enumerable
              })),
              y.push.apply(y, L)
          }
          return y
        }
        function l(h) {
          for (var _ = 1; _ < arguments.length; _++) {
            var y = arguments[_] != null ? arguments[_] : {}
            _ % 2
              ? o(Object(y), !0).forEach(function (L) {
                  b(h, L, y[L])
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(h, Object.getOwnPropertyDescriptors(y))
              : o(Object(y)).forEach(function (L) {
                  Object.defineProperty(h, L, Object.getOwnPropertyDescriptor(y, L))
                })
          }
          return h
        }
        function u(h, _) {
          if (!(h instanceof _)) throw new TypeError('Cannot call a class as a function')
        }
        function c(h, _) {
          for (var y = 0; y < _.length; y++) {
            var L = _[y]
            ;(L.enumerable = L.enumerable || !1),
              (L.configurable = !0),
              'value' in L && (L.writable = !0),
              Object.defineProperty(h, L.key, L)
          }
        }
        function f(h, _, y) {
          return _ && c(h.prototype, _), y && c(h, y), h
        }
        function d(h, _) {
          if (typeof _ != 'function' && _ !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(h.prototype = Object.create(_ && _.prototype, {
            constructor: { value: h, writable: !0, configurable: !0 }
          })),
            _ && m(h, _)
        }
        function m(h, _) {
          return (
            (m =
              Object.setPrototypeOf ||
              function (L, I) {
                return (L.__proto__ = I), L
              }),
            m(h, _)
          )
        }
        function p(h) {
          var _ = x()
          return function () {
            var L = T(h),
              I
            if (_) {
              var P = T(this).constructor
              I = Reflect.construct(L, arguments, P)
            } else I = L.apply(this, arguments)
            return v(this, I)
          }
        }
        function v(h, _) {
          return _ && (e(_) === 'object' || typeof _ == 'function') ? _ : E(h)
        }
        function E(h) {
          if (h === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return h
        }
        function x() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function T(h) {
          return (
            (T = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (y) {
                  return y.__proto__ || Object.getPrototypeOf(y)
                }),
            T(h)
          )
        }
        function b(h, _, y) {
          return (
            _ in h
              ? Object.defineProperty(h, _, {
                  value: y,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (h[_] = y),
            h
          )
        }
        var R = 'https://player.twitch.tv/js/embed/v1.js',
          g = 'Twitch',
          A = 'twitch-player-',
          S = (function (h) {
            d(y, h)
            var _ = p(y)
            function y() {
              var L
              u(this, y)
              for (var I = arguments.length, P = new Array(I), D = 0; D < I; D++)
                P[D] = arguments[D]
              return (
                (L = _.call.apply(_, [this].concat(P))),
                b(E(L), 'callPlayer', r.callPlayer),
                b(
                  E(L),
                  'playerID',
                  L.props.config.playerId || ''.concat(A).concat((0, r.randomString)())
                ),
                b(E(L), 'mute', function () {
                  L.callPlayer('setMuted', !0)
                }),
                b(E(L), 'unmute', function () {
                  L.callPlayer('setMuted', !1)
                }),
                L
              )
            }
            return (
              f(y, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    this.props.onMount && this.props.onMount(this)
                  }
                },
                {
                  key: 'load',
                  value: function (I, P) {
                    var D = this,
                      C = this.props,
                      N = C.playsinline,
                      M = C.onError,
                      w = C.config,
                      U = C.controls,
                      F = n.MATCH_URL_TWITCH_CHANNEL.test(I),
                      k = F
                        ? I.match(n.MATCH_URL_TWITCH_CHANNEL)[1]
                        : I.match(n.MATCH_URL_TWITCH_VIDEO)[1]
                    if (P) {
                      F ? this.player.setChannel(k) : this.player.setVideo('v' + k)
                      return
                    }
                    ;(0, r.getSDK)(R, g).then(function (B) {
                      D.player = new B.Player(
                        D.playerID,
                        l(
                          {
                            video: F ? '' : k,
                            channel: F ? k : '',
                            height: '100%',
                            width: '100%',
                            playsinline: N,
                            autoplay: D.props.playing,
                            muted: D.props.muted,
                            controls: F ? !0 : U,
                            time: (0, r.parseStartTime)(I)
                          },
                          w.options
                        )
                      )
                      var V = B.Player,
                        H = V.READY,
                        q = V.PLAYING,
                        X = V.PAUSE,
                        Q = V.ENDED,
                        ae = V.ONLINE,
                        ue = V.OFFLINE,
                        he = V.SEEK
                      D.player.addEventListener(H, D.props.onReady),
                        D.player.addEventListener(q, D.props.onPlay),
                        D.player.addEventListener(X, D.props.onPause),
                        D.player.addEventListener(Q, D.props.onEnded),
                        D.player.addEventListener(he, D.props.onSeek),
                        D.player.addEventListener(ae, D.props.onLoaded),
                        D.player.addEventListener(ue, D.props.onLoaded)
                    }, M)
                  }
                },
                {
                  key: 'play',
                  value: function () {
                    this.callPlayer('play')
                  }
                },
                {
                  key: 'pause',
                  value: function () {
                    this.callPlayer('pause')
                  }
                },
                {
                  key: 'stop',
                  value: function () {
                    this.callPlayer('pause')
                  }
                },
                {
                  key: 'seekTo',
                  value: function (I) {
                    var P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
                    this.callPlayer('seek', I), P || this.pause()
                  }
                },
                {
                  key: 'setVolume',
                  value: function (I) {
                    this.callPlayer('setVolume', I)
                  }
                },
                {
                  key: 'getDuration',
                  value: function () {
                    return this.callPlayer('getDuration')
                  }
                },
                {
                  key: 'getCurrentTime',
                  value: function () {
                    return this.callPlayer('getCurrentTime')
                  }
                },
                {
                  key: 'getSecondsLoaded',
                  value: function () {
                    return null
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var I = { width: '100%', height: '100%' }
                    return t.default.createElement('div', { style: I, id: this.playerID })
                  }
                }
              ]),
              y
            )
          })(t.Component)
        ;(s.default = S),
          b(S, 'displayName', 'Twitch'),
          b(S, 'canPlay', n.canPlay.twitch),
          b(S, 'loopOnEnded', !0)
      })(Cr)),
    Cr
  )
}
var kr = {},
  ci
function Tl() {
  return (
    ci ||
      ((ci = 1),
      (function (s) {
        function e(D) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (N) {
                  return typeof N
                })
              : (e = function (N) {
                  return N &&
                    typeof Symbol == 'function' &&
                    N.constructor === Symbol &&
                    N !== Symbol.prototype
                    ? 'symbol'
                    : typeof N
                }),
            e(D)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = a(ee),
          r = me,
          n = re
        function i() {
          if (typeof WeakMap != 'function') return null
          var D = new WeakMap()
          return (
            (i = function () {
              return D
            }),
            D
          )
        }
        function a(D) {
          if (D && D.__esModule) return D
          if (D === null || (e(D) !== 'object' && typeof D != 'function')) return { default: D }
          var C = i()
          if (C && C.has(D)) return C.get(D)
          var N = {},
            M = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var w in D)
            if (Object.prototype.hasOwnProperty.call(D, w)) {
              var U = M ? Object.getOwnPropertyDescriptor(D, w) : null
              U && (U.get || U.set) ? Object.defineProperty(N, w, U) : (N[w] = D[w])
            }
          return (N.default = D), C && C.set(D, N), N
        }
        function o(D, C) {
          var N = Object.keys(D)
          if (Object.getOwnPropertySymbols) {
            var M = Object.getOwnPropertySymbols(D)
            C &&
              (M = M.filter(function (w) {
                return Object.getOwnPropertyDescriptor(D, w).enumerable
              })),
              N.push.apply(N, M)
          }
          return N
        }
        function l(D) {
          for (var C = 1; C < arguments.length; C++) {
            var N = arguments[C] != null ? arguments[C] : {}
            C % 2
              ? o(Object(N), !0).forEach(function (M) {
                  _(D, M, N[M])
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(D, Object.getOwnPropertyDescriptors(N))
              : o(Object(N)).forEach(function (M) {
                  Object.defineProperty(D, M, Object.getOwnPropertyDescriptor(N, M))
                })
          }
          return D
        }
        function u(D, C) {
          return p(D) || m(D, C) || f(D, C) || c()
        }
        function c() {
          throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }
        function f(D, C) {
          if (D) {
            if (typeof D == 'string') return d(D, C)
            var N = Object.prototype.toString.call(D).slice(8, -1)
            if (
              (N === 'Object' && D.constructor && (N = D.constructor.name),
              N === 'Map' || N === 'Set')
            )
              return Array.from(D)
            if (N === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(N))
              return d(D, C)
          }
        }
        function d(D, C) {
          ;(C == null || C > D.length) && (C = D.length)
          for (var N = 0, M = new Array(C); N < C; N++) M[N] = D[N]
          return M
        }
        function m(D, C) {
          if (!(typeof Symbol > 'u' || !(Symbol.iterator in Object(D)))) {
            var N = [],
              M = !0,
              w = !1,
              U = void 0
            try {
              for (
                var F = D[Symbol.iterator](), k;
                !(M = (k = F.next()).done) && (N.push(k.value), !(C && N.length === C));
                M = !0
              );
            } catch (B) {
              ;(w = !0), (U = B)
            } finally {
              try {
                !M && F.return != null && F.return()
              } finally {
                if (w) throw U
              }
            }
            return N
          }
        }
        function p(D) {
          if (Array.isArray(D)) return D
        }
        function v(D, C) {
          if (!(D instanceof C)) throw new TypeError('Cannot call a class as a function')
        }
        function E(D, C) {
          for (var N = 0; N < C.length; N++) {
            var M = C[N]
            ;(M.enumerable = M.enumerable || !1),
              (M.configurable = !0),
              'value' in M && (M.writable = !0),
              Object.defineProperty(D, M.key, M)
          }
        }
        function x(D, C, N) {
          return C && E(D.prototype, C), N && E(D, N), D
        }
        function T(D, C) {
          if (typeof C != 'function' && C !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(D.prototype = Object.create(C && C.prototype, {
            constructor: { value: D, writable: !0, configurable: !0 }
          })),
            C && b(D, C)
        }
        function b(D, C) {
          return (
            (b =
              Object.setPrototypeOf ||
              function (M, w) {
                return (M.__proto__ = w), M
              }),
            b(D, C)
          )
        }
        function R(D) {
          var C = S()
          return function () {
            var M = h(D),
              w
            if (C) {
              var U = h(this).constructor
              w = Reflect.construct(M, arguments, U)
            } else w = M.apply(this, arguments)
            return g(this, w)
          }
        }
        function g(D, C) {
          return C && (e(C) === 'object' || typeof C == 'function') ? C : A(D)
        }
        function A(D) {
          if (D === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return D
        }
        function S() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function h(D) {
          return (
            (h = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (N) {
                  return N.__proto__ || Object.getPrototypeOf(N)
                }),
            h(D)
          )
        }
        function _(D, C, N) {
          return (
            C in D
              ? Object.defineProperty(D, C, {
                  value: N,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (D[C] = N),
            D
          )
        }
        var y = 'https://api.dmcdn.net/all.js',
          L = 'DM',
          I = 'dmAsyncInit',
          P = (function (D) {
            T(N, D)
            var C = R(N)
            function N() {
              var M
              v(this, N)
              for (var w = arguments.length, U = new Array(w), F = 0; F < w; F++)
                U[F] = arguments[F]
              return (
                (M = C.call.apply(C, [this].concat(U))),
                _(A(M), 'callPlayer', r.callPlayer),
                _(A(M), 'onDurationChange', function () {
                  var k = M.getDuration()
                  M.props.onDuration(k)
                }),
                _(A(M), 'mute', function () {
                  M.callPlayer('setMuted', !0)
                }),
                _(A(M), 'unmute', function () {
                  M.callPlayer('setMuted', !1)
                }),
                _(A(M), 'ref', function (k) {
                  M.container = k
                }),
                M
              )
            }
            return (
              x(N, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    this.props.onMount && this.props.onMount(this)
                  }
                },
                {
                  key: 'load',
                  value: function (w) {
                    var U = this,
                      F = this.props,
                      k = F.controls,
                      B = F.config,
                      V = F.onError,
                      H = F.playing,
                      q = w.match(n.MATCH_URL_DAILYMOTION),
                      X = u(q, 2),
                      Q = X[1]
                    if (this.player) {
                      this.player.load(Q, { start: (0, r.parseStartTime)(w), autoplay: H })
                      return
                    }
                    ;(0, r.getSDK)(y, L, I, function (ae) {
                      return ae.player
                    }).then(function (ae) {
                      if (U.container) {
                        var ue = ae.player
                        U.player = new ue(U.container, {
                          width: '100%',
                          height: '100%',
                          video: Q,
                          params: l(
                            {
                              controls: k,
                              autoplay: U.props.playing,
                              mute: U.props.muted,
                              start: (0, r.parseStartTime)(w),
                              origin: window.location.origin
                            },
                            B.params
                          ),
                          events: {
                            apiready: U.props.onReady,
                            seeked: function () {
                              return U.props.onSeek(U.player.currentTime)
                            },
                            video_end: U.props.onEnded,
                            durationchange: U.onDurationChange,
                            pause: U.props.onPause,
                            playing: U.props.onPlay,
                            waiting: U.props.onBuffer,
                            error: function (_e) {
                              return V(_e)
                            }
                          }
                        })
                      }
                    }, V)
                  }
                },
                {
                  key: 'play',
                  value: function () {
                    this.callPlayer('play')
                  }
                },
                {
                  key: 'pause',
                  value: function () {
                    this.callPlayer('pause')
                  }
                },
                { key: 'stop', value: function () {} },
                {
                  key: 'seekTo',
                  value: function (w) {
                    var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
                    this.callPlayer('seek', w), U || this.pause()
                  }
                },
                {
                  key: 'setVolume',
                  value: function (w) {
                    this.callPlayer('setVolume', w)
                  }
                },
                {
                  key: 'getDuration',
                  value: function () {
                    return this.player.duration || null
                  }
                },
                {
                  key: 'getCurrentTime',
                  value: function () {
                    return this.player.currentTime
                  }
                },
                {
                  key: 'getSecondsLoaded',
                  value: function () {
                    return this.player.bufferedTime
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var w = this.props.display,
                      U = { width: '100%', height: '100%', display: w }
                    return t.default.createElement(
                      'div',
                      { style: U },
                      t.default.createElement('div', { ref: this.ref })
                    )
                  }
                }
              ]),
              N
            )
          })(t.Component)
        ;(s.default = P),
          _(P, 'displayName', 'DailyMotion'),
          _(P, 'canPlay', n.canPlay.dailymotion),
          _(P, 'loopOnEnded', !0)
      })(kr)),
    kr
  )
}
var Mr = {},
  fi
function bl() {
  return (
    fi ||
      ((fi = 1),
      (function (s) {
        function e(S) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (_) {
                  return typeof _
                })
              : (e = function (_) {
                  return _ &&
                    typeof Symbol == 'function' &&
                    _.constructor === Symbol &&
                    _ !== Symbol.prototype
                    ? 'symbol'
                    : typeof _
                }),
            e(S)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = a(ee),
          r = me,
          n = re
        function i() {
          if (typeof WeakMap != 'function') return null
          var S = new WeakMap()
          return (
            (i = function () {
              return S
            }),
            S
          )
        }
        function a(S) {
          if (S && S.__esModule) return S
          if (S === null || (e(S) !== 'object' && typeof S != 'function')) return { default: S }
          var h = i()
          if (h && h.has(S)) return h.get(S)
          var _ = {},
            y = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var L in S)
            if (Object.prototype.hasOwnProperty.call(S, L)) {
              var I = y ? Object.getOwnPropertyDescriptor(S, L) : null
              I && (I.get || I.set) ? Object.defineProperty(_, L, I) : (_[L] = S[L])
            }
          return (_.default = S), h && h.set(S, _), _
        }
        function o(S, h) {
          var _ = Object.keys(S)
          if (Object.getOwnPropertySymbols) {
            var y = Object.getOwnPropertySymbols(S)
            h &&
              (y = y.filter(function (L) {
                return Object.getOwnPropertyDescriptor(S, L).enumerable
              })),
              _.push.apply(_, y)
          }
          return _
        }
        function l(S) {
          for (var h = 1; h < arguments.length; h++) {
            var _ = arguments[h] != null ? arguments[h] : {}
            h % 2
              ? o(Object(_), !0).forEach(function (y) {
                  b(S, y, _[y])
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(S, Object.getOwnPropertyDescriptors(_))
              : o(Object(_)).forEach(function (y) {
                  Object.defineProperty(S, y, Object.getOwnPropertyDescriptor(_, y))
                })
          }
          return S
        }
        function u(S, h) {
          if (!(S instanceof h)) throw new TypeError('Cannot call a class as a function')
        }
        function c(S, h) {
          for (var _ = 0; _ < h.length; _++) {
            var y = h[_]
            ;(y.enumerable = y.enumerable || !1),
              (y.configurable = !0),
              'value' in y && (y.writable = !0),
              Object.defineProperty(S, y.key, y)
          }
        }
        function f(S, h, _) {
          return h && c(S.prototype, h), _ && c(S, _), S
        }
        function d(S, h) {
          if (typeof h != 'function' && h !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(S.prototype = Object.create(h && h.prototype, {
            constructor: { value: S, writable: !0, configurable: !0 }
          })),
            h && m(S, h)
        }
        function m(S, h) {
          return (
            (m =
              Object.setPrototypeOf ||
              function (y, L) {
                return (y.__proto__ = L), y
              }),
            m(S, h)
          )
        }
        function p(S) {
          var h = x()
          return function () {
            var y = T(S),
              L
            if (h) {
              var I = T(this).constructor
              L = Reflect.construct(y, arguments, I)
            } else L = y.apply(this, arguments)
            return v(this, L)
          }
        }
        function v(S, h) {
          return h && (e(h) === 'object' || typeof h == 'function') ? h : E(S)
        }
        function E(S) {
          if (S === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return S
        }
        function x() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function T(S) {
          return (
            (T = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (_) {
                  return _.__proto__ || Object.getPrototypeOf(_)
                }),
            T(S)
          )
        }
        function b(S, h, _) {
          return (
            h in S
              ? Object.defineProperty(S, h, {
                  value: _,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (S[h] = _),
            S
          )
        }
        var R = 'https://widget.mixcloud.com/media/js/widgetApi.js',
          g = 'Mixcloud',
          A = (function (S) {
            d(_, S)
            var h = p(_)
            function _() {
              var y
              u(this, _)
              for (var L = arguments.length, I = new Array(L), P = 0; P < L; P++)
                I[P] = arguments[P]
              return (
                (y = h.call.apply(h, [this].concat(I))),
                b(E(y), 'callPlayer', r.callPlayer),
                b(E(y), 'duration', null),
                b(E(y), 'currentTime', null),
                b(E(y), 'secondsLoaded', null),
                b(E(y), 'mute', function () {}),
                b(E(y), 'unmute', function () {}),
                b(E(y), 'ref', function (D) {
                  y.iframe = D
                }),
                y
              )
            }
            return (
              f(_, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    this.props.onMount && this.props.onMount(this)
                  }
                },
                {
                  key: 'load',
                  value: function (L) {
                    var I = this
                    ;(0, r.getSDK)(R, g).then(function (P) {
                      ;(I.player = P.PlayerWidget(I.iframe)),
                        I.player.ready.then(function () {
                          I.player.events.play.on(I.props.onPlay),
                            I.player.events.pause.on(I.props.onPause),
                            I.player.events.ended.on(I.props.onEnded),
                            I.player.events.error.on(I.props.error),
                            I.player.events.progress.on(function (D, C) {
                              ;(I.currentTime = D), (I.duration = C)
                            }),
                            I.props.onReady()
                        })
                    }, this.props.onError)
                  }
                },
                {
                  key: 'play',
                  value: function () {
                    this.callPlayer('play')
                  }
                },
                {
                  key: 'pause',
                  value: function () {
                    this.callPlayer('pause')
                  }
                },
                { key: 'stop', value: function () {} },
                {
                  key: 'seekTo',
                  value: function (L) {
                    var I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
                    this.callPlayer('seek', L), I || this.pause()
                  }
                },
                { key: 'setVolume', value: function (L) {} },
                {
                  key: 'getDuration',
                  value: function () {
                    return this.duration
                  }
                },
                {
                  key: 'getCurrentTime',
                  value: function () {
                    return this.currentTime
                  }
                },
                {
                  key: 'getSecondsLoaded',
                  value: function () {
                    return null
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var L = this.props,
                      I = L.url,
                      P = L.config,
                      D = I.match(n.MATCH_URL_MIXCLOUD)[1],
                      C = { width: '100%', height: '100%' },
                      N = (0, r.queryString)(l(l({}, P.options), {}, { feed: '/'.concat(D, '/') }))
                    return t.default.createElement('iframe', {
                      key: D,
                      ref: this.ref,
                      style: C,
                      src: 'https://www.mixcloud.com/widget/iframe/?'.concat(N),
                      frameBorder: '0',
                      allow: 'autoplay'
                    })
                  }
                }
              ]),
              _
            )
          })(t.Component)
        ;(s.default = A),
          b(A, 'displayName', 'Mixcloud'),
          b(A, 'canPlay', n.canPlay.mixcloud),
          b(A, 'loopOnEnded', !0)
      })(Mr)),
    Mr
  )
}
var Fr = {},
  di
function Ll() {
  return (
    di ||
      ((di = 1),
      (function (s) {
        function e(h) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (y) {
                  return typeof y
                })
              : (e = function (y) {
                  return y &&
                    typeof Symbol == 'function' &&
                    y.constructor === Symbol &&
                    y !== Symbol.prototype
                    ? 'symbol'
                    : typeof y
                }),
            e(h)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = a(ee),
          r = me,
          n = re
        function i() {
          if (typeof WeakMap != 'function') return null
          var h = new WeakMap()
          return (
            (i = function () {
              return h
            }),
            h
          )
        }
        function a(h) {
          if (h && h.__esModule) return h
          if (h === null || (e(h) !== 'object' && typeof h != 'function')) return { default: h }
          var _ = i()
          if (_ && _.has(h)) return _.get(h)
          var y = {},
            L = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var I in h)
            if (Object.prototype.hasOwnProperty.call(h, I)) {
              var P = L ? Object.getOwnPropertyDescriptor(h, I) : null
              P && (P.get || P.set) ? Object.defineProperty(y, I, P) : (y[I] = h[I])
            }
          return (y.default = h), _ && _.set(h, y), y
        }
        function o(h, _) {
          var y = Object.keys(h)
          if (Object.getOwnPropertySymbols) {
            var L = Object.getOwnPropertySymbols(h)
            _ &&
              (L = L.filter(function (I) {
                return Object.getOwnPropertyDescriptor(h, I).enumerable
              })),
              y.push.apply(y, L)
          }
          return y
        }
        function l(h) {
          for (var _ = 1; _ < arguments.length; _++) {
            var y = arguments[_] != null ? arguments[_] : {}
            _ % 2
              ? o(Object(y), !0).forEach(function (L) {
                  b(h, L, y[L])
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(h, Object.getOwnPropertyDescriptors(y))
              : o(Object(y)).forEach(function (L) {
                  Object.defineProperty(h, L, Object.getOwnPropertyDescriptor(y, L))
                })
          }
          return h
        }
        function u(h, _) {
          if (!(h instanceof _)) throw new TypeError('Cannot call a class as a function')
        }
        function c(h, _) {
          for (var y = 0; y < _.length; y++) {
            var L = _[y]
            ;(L.enumerable = L.enumerable || !1),
              (L.configurable = !0),
              'value' in L && (L.writable = !0),
              Object.defineProperty(h, L.key, L)
          }
        }
        function f(h, _, y) {
          return _ && c(h.prototype, _), y && c(h, y), h
        }
        function d(h, _) {
          if (typeof _ != 'function' && _ !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(h.prototype = Object.create(_ && _.prototype, {
            constructor: { value: h, writable: !0, configurable: !0 }
          })),
            _ && m(h, _)
        }
        function m(h, _) {
          return (
            (m =
              Object.setPrototypeOf ||
              function (L, I) {
                return (L.__proto__ = I), L
              }),
            m(h, _)
          )
        }
        function p(h) {
          var _ = x()
          return function () {
            var L = T(h),
              I
            if (_) {
              var P = T(this).constructor
              I = Reflect.construct(L, arguments, P)
            } else I = L.apply(this, arguments)
            return v(this, I)
          }
        }
        function v(h, _) {
          return _ && (e(_) === 'object' || typeof _ == 'function') ? _ : E(h)
        }
        function E(h) {
          if (h === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return h
        }
        function x() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function T(h) {
          return (
            (T = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (y) {
                  return y.__proto__ || Object.getPrototypeOf(y)
                }),
            T(h)
          )
        }
        function b(h, _, y) {
          return (
            _ in h
              ? Object.defineProperty(h, _, {
                  value: y,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (h[_] = y),
            h
          )
        }
        var R = 'https://play.vidyard.com/embed/v4.js',
          g = 'VidyardV4',
          A = 'onVidyardAPI',
          S = (function (h) {
            d(y, h)
            var _ = p(y)
            function y() {
              var L
              u(this, y)
              for (var I = arguments.length, P = new Array(I), D = 0; D < I; D++)
                P[D] = arguments[D]
              return (
                (L = _.call.apply(_, [this].concat(P))),
                b(E(L), 'callPlayer', r.callPlayer),
                b(E(L), 'mute', function () {
                  L.setVolume(0)
                }),
                b(E(L), 'unmute', function () {
                  L.props.volume !== null && L.setVolume(L.props.volume)
                }),
                b(E(L), 'ref', function (C) {
                  L.container = C
                }),
                L
              )
            }
            return (
              f(y, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    this.props.onMount && this.props.onMount(this)
                  }
                },
                {
                  key: 'load',
                  value: function (I) {
                    var P = this,
                      D = this.props,
                      C = D.playing,
                      N = D.config,
                      M = D.onError,
                      w = D.onDuration,
                      U = I && I.match(n.MATCH_URL_VIDYARD)[1]
                    this.player && this.stop(),
                      (0, r.getSDK)(R, g, A).then(function (F) {
                        P.container &&
                          (F.api.addReadyListener(function (k, B) {
                            P.player ||
                              ((P.player = B),
                              P.player.on('ready', P.props.onReady),
                              P.player.on('play', P.props.onPlay),
                              P.player.on('pause', P.props.onPause),
                              P.player.on('seek', P.props.onSeek),
                              P.player.on('playerComplete', P.props.onEnded))
                          }, U),
                          F.api.renderPlayer(
                            l({ uuid: U, container: P.container, autoplay: C ? 1 : 0 }, N.options)
                          ),
                          F.api.getPlayerMetadata(U).then(function (k) {
                            ;(P.duration = k.length_in_seconds), w(k.length_in_seconds)
                          }))
                      }, M)
                  }
                },
                {
                  key: 'play',
                  value: function () {
                    this.callPlayer('play')
                  }
                },
                {
                  key: 'pause',
                  value: function () {
                    this.callPlayer('pause')
                  }
                },
                {
                  key: 'stop',
                  value: function () {
                    window.VidyardV4.api.destroyPlayer(this.player)
                  }
                },
                {
                  key: 'seekTo',
                  value: function (I) {
                    var P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
                    this.callPlayer('seek', I), P || this.pause()
                  }
                },
                {
                  key: 'setVolume',
                  value: function (I) {
                    this.callPlayer('setVolume', I)
                  }
                },
                {
                  key: 'setPlaybackRate',
                  value: function (I) {
                    this.callPlayer('setPlaybackSpeed', I)
                  }
                },
                {
                  key: 'getDuration',
                  value: function () {
                    return this.duration
                  }
                },
                {
                  key: 'getCurrentTime',
                  value: function () {
                    return this.callPlayer('currentTime')
                  }
                },
                {
                  key: 'getSecondsLoaded',
                  value: function () {
                    return null
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var I = this.props.display,
                      P = { width: '100%', height: '100%', display: I }
                    return t.default.createElement(
                      'div',
                      { style: P },
                      t.default.createElement('div', { ref: this.ref })
                    )
                  }
                }
              ]),
              y
            )
          })(t.Component)
        ;(s.default = S), b(S, 'displayName', 'Vidyard'), b(S, 'canPlay', n.canPlay.vidyard)
      })(Fr)),
    Fr
  )
}
var Nr = {},
  hi
function Al() {
  return (
    hi ||
      ((hi = 1),
      (function (s) {
        function e(g) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (S) {
                  return typeof S
                })
              : (e = function (S) {
                  return S &&
                    typeof Symbol == 'function' &&
                    S.constructor === Symbol &&
                    S !== Symbol.prototype
                    ? 'symbol'
                    : typeof S
                }),
            e(g)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = a(ee),
          r = me,
          n = re
        function i() {
          if (typeof WeakMap != 'function') return null
          var g = new WeakMap()
          return (
            (i = function () {
              return g
            }),
            g
          )
        }
        function a(g) {
          if (g && g.__esModule) return g
          if (g === null || (e(g) !== 'object' && typeof g != 'function')) return { default: g }
          var A = i()
          if (A && A.has(g)) return A.get(g)
          var S = {},
            h = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var _ in g)
            if (Object.prototype.hasOwnProperty.call(g, _)) {
              var y = h ? Object.getOwnPropertyDescriptor(g, _) : null
              y && (y.get || y.set) ? Object.defineProperty(S, _, y) : (S[_] = g[_])
            }
          return (S.default = g), A && A.set(g, S), S
        }
        function o(g, A) {
          if (!(g instanceof A)) throw new TypeError('Cannot call a class as a function')
        }
        function l(g, A) {
          for (var S = 0; S < A.length; S++) {
            var h = A[S]
            ;(h.enumerable = h.enumerable || !1),
              (h.configurable = !0),
              'value' in h && (h.writable = !0),
              Object.defineProperty(g, h.key, h)
          }
        }
        function u(g, A, S) {
          return A && l(g.prototype, A), S && l(g, S), g
        }
        function c(g, A) {
          if (typeof A != 'function' && A !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(g.prototype = Object.create(A && A.prototype, {
            constructor: { value: g, writable: !0, configurable: !0 }
          })),
            A && f(g, A)
        }
        function f(g, A) {
          return (
            (f =
              Object.setPrototypeOf ||
              function (h, _) {
                return (h.__proto__ = _), h
              }),
            f(g, A)
          )
        }
        function d(g) {
          var A = v()
          return function () {
            var h = E(g),
              _
            if (A) {
              var y = E(this).constructor
              _ = Reflect.construct(h, arguments, y)
            } else _ = h.apply(this, arguments)
            return m(this, _)
          }
        }
        function m(g, A) {
          return A && (e(A) === 'object' || typeof A == 'function') ? A : p(g)
        }
        function p(g) {
          if (g === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return g
        }
        function v() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function E(g) {
          return (
            (E = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (S) {
                  return S.__proto__ || Object.getPrototypeOf(S)
                }),
            E(g)
          )
        }
        function x(g, A, S) {
          return (
            A in g
              ? Object.defineProperty(g, A, {
                  value: S,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (g[A] = S),
            g
          )
        }
        var T = 'https://cdn.embed.ly/player-0.1.0.min.js',
          b = 'playerjs',
          R = (function (g) {
            c(S, g)
            var A = d(S)
            function S() {
              var h
              o(this, S)
              for (var _ = arguments.length, y = new Array(_), L = 0; L < _; L++)
                y[L] = arguments[L]
              return (
                (h = A.call.apply(A, [this].concat(y))),
                x(p(h), 'callPlayer', r.callPlayer),
                x(p(h), 'duration', null),
                x(p(h), 'currentTime', null),
                x(p(h), 'secondsLoaded', null),
                x(p(h), 'mute', function () {
                  h.callPlayer('mute')
                }),
                x(p(h), 'unmute', function () {
                  h.callPlayer('unmute')
                }),
                x(p(h), 'ref', function (I) {
                  h.iframe = I
                }),
                h
              )
            }
            return (
              u(S, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    this.props.onMount && this.props.onMount(this)
                  }
                },
                {
                  key: 'load',
                  value: function (_) {
                    var y = this
                    ;(0, r.getSDK)(T, b).then(function (L) {
                      y.iframe &&
                        ((y.player = new L.Player(y.iframe)),
                        y.player.on('ready', function () {
                          setTimeout(function () {
                            ;(y.player.isReady = !0),
                              y.player.setLoop(y.props.loop),
                              y.props.muted && y.player.mute(),
                              y.addListeners(y.player, y.props),
                              y.props.onReady()
                          }, 500)
                        }))
                    }, this.props.onError)
                  }
                },
                {
                  key: 'addListeners',
                  value: function (_, y) {
                    var L = this
                    _.on('play', y.onPlay),
                      _.on('pause', y.onPause),
                      _.on('ended', y.onEnded),
                      _.on('error', y.onError),
                      _.on('timeupdate', function (I) {
                        var P = I.duration,
                          D = I.seconds
                        ;(L.duration = P), (L.currentTime = D)
                      })
                  }
                },
                {
                  key: 'play',
                  value: function () {
                    this.callPlayer('play')
                  }
                },
                {
                  key: 'pause',
                  value: function () {
                    this.callPlayer('pause')
                  }
                },
                { key: 'stop', value: function () {} },
                {
                  key: 'seekTo',
                  value: function (_) {
                    var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
                    this.callPlayer('setCurrentTime', _), y || this.pause()
                  }
                },
                {
                  key: 'setVolume',
                  value: function (_) {
                    this.callPlayer('setVolume', _)
                  }
                },
                {
                  key: 'setLoop',
                  value: function (_) {
                    this.callPlayer('setLoop', _)
                  }
                },
                {
                  key: 'getDuration',
                  value: function () {
                    return this.duration
                  }
                },
                {
                  key: 'getCurrentTime',
                  value: function () {
                    return this.currentTime
                  }
                },
                {
                  key: 'getSecondsLoaded',
                  value: function () {
                    return this.secondsLoaded
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var _ = { width: '100%', height: '100%' }
                    return t.default.createElement('iframe', {
                      ref: this.ref,
                      src: this.props.url,
                      frameBorder: '0',
                      scrolling: 'no',
                      style: _,
                      allow: 'encrypted-media; autoplay; fullscreen;',
                      referrerPolicy: 'no-referrer-when-downgrade'
                    })
                  }
                }
              ]),
              S
            )
          })(t.Component)
        ;(s.default = R), x(R, 'displayName', 'Kaltura'), x(R, 'canPlay', n.canPlay.kaltura)
      })(Nr)),
    Nr
  )
}
var Ur = {},
  pi
function Rl() {
  return (
    pi ||
      ((pi = 1),
      (function (s) {
        function e(M) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (U) {
                  return typeof U
                })
              : (e = function (U) {
                  return U &&
                    typeof Symbol == 'function' &&
                    U.constructor === Symbol &&
                    U !== Symbol.prototype
                    ? 'symbol'
                    : typeof U
                }),
            e(M)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = a(ee),
          r = me,
          n = re
        function i() {
          if (typeof WeakMap != 'function') return null
          var M = new WeakMap()
          return (
            (i = function () {
              return M
            }),
            M
          )
        }
        function a(M) {
          if (M && M.__esModule) return M
          if (M === null || (e(M) !== 'object' && typeof M != 'function')) return { default: M }
          var w = i()
          if (w && w.has(M)) return w.get(M)
          var U = {},
            F = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var k in M)
            if (Object.prototype.hasOwnProperty.call(M, k)) {
              var B = F ? Object.getOwnPropertyDescriptor(M, k) : null
              B && (B.get || B.set) ? Object.defineProperty(U, k, B) : (U[k] = M[k])
            }
          return (U.default = M), w && w.set(M, U), U
        }
        function o() {
          return (
            (o =
              Object.assign ||
              function (M) {
                for (var w = 1; w < arguments.length; w++) {
                  var U = arguments[w]
                  for (var F in U) Object.prototype.hasOwnProperty.call(U, F) && (M[F] = U[F])
                }
                return M
              }),
            o.apply(this, arguments)
          )
        }
        function l(M, w) {
          if (!(M instanceof w)) throw new TypeError('Cannot call a class as a function')
        }
        function u(M, w) {
          for (var U = 0; U < w.length; U++) {
            var F = w[U]
            ;(F.enumerable = F.enumerable || !1),
              (F.configurable = !0),
              'value' in F && (F.writable = !0),
              Object.defineProperty(M, F.key, F)
          }
        }
        function c(M, w, U) {
          return w && u(M.prototype, w), U && u(M, U), M
        }
        function f(M, w) {
          if (typeof w != 'function' && w !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(M.prototype = Object.create(w && w.prototype, {
            constructor: { value: M, writable: !0, configurable: !0 }
          })),
            w && d(M, w)
        }
        function d(M, w) {
          return (
            (d =
              Object.setPrototypeOf ||
              function (F, k) {
                return (F.__proto__ = k), F
              }),
            d(M, w)
          )
        }
        function m(M) {
          var w = E()
          return function () {
            var F = x(M),
              k
            if (w) {
              var B = x(this).constructor
              k = Reflect.construct(F, arguments, B)
            } else k = F.apply(this, arguments)
            return p(this, k)
          }
        }
        function p(M, w) {
          return w && (e(w) === 'object' || typeof w == 'function') ? w : v(M)
        }
        function v(M) {
          if (M === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return M
        }
        function E() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function x(M) {
          return (
            (x = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (U) {
                  return U.__proto__ || Object.getPrototypeOf(U)
                }),
            x(M)
          )
        }
        function T(M, w, U) {
          return (
            w in M
              ? Object.defineProperty(M, w, {
                  value: U,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (M[w] = U),
            M
          )
        }
        var b = typeof navigator < 'u',
          R = b && navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1,
          g = b && (/iPad|iPhone|iPod/.test(navigator.userAgent) || R) && !window.MSStream,
          A = b && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) && !window.MSStream,
          S = 'https://cdn.jsdelivr.net/npm/hls.js@VERSION/dist/hls.min.js',
          h = 'Hls',
          _ = 'https://cdnjs.cloudflare.com/ajax/libs/dashjs/VERSION/dash.all.min.js',
          y = 'dashjs',
          L = 'https://cdn.jsdelivr.net/npm/flv.js@VERSION/dist/flv.min.js',
          I = 'flvjs',
          P = /www\.dropbox\.com\/.+/,
          D = /https:\/\/watch\.cloudflarestream\.com\/([a-z0-9]+)/,
          C = 'https://videodelivery.net/{id}/manifest/video.m3u8',
          N = (function (M) {
            f(U, M)
            var w = m(U)
            function U() {
              var F
              l(this, U)
              for (var k = arguments.length, B = new Array(k), V = 0; V < k; V++)
                B[V] = arguments[V]
              return (
                (F = w.call.apply(w, [this].concat(B))),
                T(v(F), 'onReady', function () {
                  var H
                  return (H = F.props).onReady.apply(H, arguments)
                }),
                T(v(F), 'onPlay', function () {
                  var H
                  return (H = F.props).onPlay.apply(H, arguments)
                }),
                T(v(F), 'onBuffer', function () {
                  var H
                  return (H = F.props).onBuffer.apply(H, arguments)
                }),
                T(v(F), 'onBufferEnd', function () {
                  var H
                  return (H = F.props).onBufferEnd.apply(H, arguments)
                }),
                T(v(F), 'onPause', function () {
                  var H
                  return (H = F.props).onPause.apply(H, arguments)
                }),
                T(v(F), 'onEnded', function () {
                  var H
                  return (H = F.props).onEnded.apply(H, arguments)
                }),
                T(v(F), 'onError', function () {
                  var H
                  return (H = F.props).onError.apply(H, arguments)
                }),
                T(v(F), 'onPlayBackRateChange', function (H) {
                  return F.props.onPlaybackRateChange(H.target.playbackRate)
                }),
                T(v(F), 'onEnablePIP', function () {
                  var H
                  return (H = F.props).onEnablePIP.apply(H, arguments)
                }),
                T(v(F), 'onDisablePIP', function (H) {
                  var q = F.props,
                    X = q.onDisablePIP,
                    Q = q.playing
                  X(H), Q && F.play()
                }),
                T(v(F), 'onPresentationModeChange', function (H) {
                  if (F.player && (0, r.supportsWebKitPresentationMode)(F.player)) {
                    var q = F.player.webkitPresentationMode
                    q === 'picture-in-picture'
                      ? F.onEnablePIP(H)
                      : q === 'inline' && F.onDisablePIP(H)
                  }
                }),
                T(v(F), 'onSeek', function (H) {
                  F.props.onSeek(H.target.currentTime)
                }),
                T(v(F), 'mute', function () {
                  F.player.muted = !0
                }),
                T(v(F), 'unmute', function () {
                  F.player.muted = !1
                }),
                T(v(F), 'renderSourceElement', function (H, q) {
                  return typeof H == 'string'
                    ? t.default.createElement('source', { key: q, src: H })
                    : t.default.createElement('source', o({ key: q }, H))
                }),
                T(v(F), 'renderTrack', function (H, q) {
                  return t.default.createElement('track', o({ key: q }, H))
                }),
                T(v(F), 'ref', function (H) {
                  F.player && (F.prevPlayer = F.player), (F.player = H)
                }),
                F
              )
            }
            return (
              c(U, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    this.props.onMount && this.props.onMount(this), this.addListeners(this.player)
                    var k = this.getSource(this.props.url)
                    k && (this.player.src = k),
                      (g || this.props.config.forceDisableHls) && this.player.load()
                  }
                },
                {
                  key: 'componentDidUpdate',
                  value: function (k) {
                    this.shouldUseAudio(this.props) !== this.shouldUseAudio(k) &&
                      (this.removeListeners(this.prevPlayer, k.url),
                      this.addListeners(this.player)),
                      this.props.url !== k.url &&
                        !(0, r.isMediaStream)(this.props.url) &&
                        !(this.props.url instanceof Array) &&
                        (this.player.srcObject = null)
                  }
                },
                {
                  key: 'componentWillUnmount',
                  value: function () {
                    this.player.removeAttribute('src'),
                      this.removeListeners(this.player),
                      this.hls && this.hls.destroy()
                  }
                },
                {
                  key: 'addListeners',
                  value: function (k) {
                    var B = this.props,
                      V = B.url,
                      H = B.playsinline
                    k.addEventListener('play', this.onPlay),
                      k.addEventListener('waiting', this.onBuffer),
                      k.addEventListener('playing', this.onBufferEnd),
                      k.addEventListener('pause', this.onPause),
                      k.addEventListener('seeked', this.onSeek),
                      k.addEventListener('ended', this.onEnded),
                      k.addEventListener('error', this.onError),
                      k.addEventListener('ratechange', this.onPlayBackRateChange),
                      k.addEventListener('enterpictureinpicture', this.onEnablePIP),
                      k.addEventListener('leavepictureinpicture', this.onDisablePIP),
                      k.addEventListener(
                        'webkitpresentationmodechanged',
                        this.onPresentationModeChange
                      ),
                      this.shouldUseHLS(V) || k.addEventListener('canplay', this.onReady),
                      H &&
                        (k.setAttribute('playsinline', ''),
                        k.setAttribute('webkit-playsinline', ''),
                        k.setAttribute('x5-playsinline', ''))
                  }
                },
                {
                  key: 'removeListeners',
                  value: function (k, B) {
                    k.removeEventListener('canplay', this.onReady),
                      k.removeEventListener('play', this.onPlay),
                      k.removeEventListener('waiting', this.onBuffer),
                      k.removeEventListener('playing', this.onBufferEnd),
                      k.removeEventListener('pause', this.onPause),
                      k.removeEventListener('seeked', this.onSeek),
                      k.removeEventListener('ended', this.onEnded),
                      k.removeEventListener('error', this.onError),
                      k.removeEventListener('ratechange', this.onPlayBackRateChange),
                      k.removeEventListener('enterpictureinpicture', this.onEnablePIP),
                      k.removeEventListener('leavepictureinpicture', this.onDisablePIP),
                      k.removeEventListener(
                        'webkitpresentationmodechanged',
                        this.onPresentationModeChange
                      ),
                      this.shouldUseHLS(B) || k.removeEventListener('canplay', this.onReady)
                  }
                },
                {
                  key: 'shouldUseAudio',
                  value: function (k) {
                    return k.config.forceVideo || k.config.attributes.poster
                      ? !1
                      : n.AUDIO_EXTENSIONS.test(k.url) || k.config.forceAudio
                  }
                },
                {
                  key: 'shouldUseHLS',
                  value: function (k) {
                    return (A && this.props.config.forceSafariHLS) || this.props.config.forceHLS
                      ? !0
                      : g || this.props.config.forceDisableHls
                      ? !1
                      : n.HLS_EXTENSIONS.test(k) || D.test(k)
                  }
                },
                {
                  key: 'shouldUseDASH',
                  value: function (k) {
                    return n.DASH_EXTENSIONS.test(k) || this.props.config.forceDASH
                  }
                },
                {
                  key: 'shouldUseFLV',
                  value: function (k) {
                    return n.FLV_EXTENSIONS.test(k) || this.props.config.forceFLV
                  }
                },
                {
                  key: 'load',
                  value: function (k) {
                    var B = this,
                      V = this.props.config,
                      H = V.hlsVersion,
                      q = V.hlsOptions,
                      X = V.dashVersion,
                      Q = V.flvVersion
                    if (
                      (this.hls && this.hls.destroy(),
                      this.dash && this.dash.reset(),
                      this.shouldUseHLS(k) &&
                        (0, r.getSDK)(S.replace('VERSION', H), h).then(function (ae) {
                          if (
                            ((B.hls = new ae(q)),
                            B.hls.on(ae.Events.MANIFEST_PARSED, function () {
                              B.props.onReady()
                            }),
                            B.hls.on(ae.Events.ERROR, function (he, _e) {
                              B.props.onError(he, _e, B.hls, ae)
                            }),
                            D.test(k))
                          ) {
                            var ue = k.match(D)[1]
                            B.hls.loadSource(C.replace('{id}', ue))
                          } else B.hls.loadSource(k)
                          B.hls.attachMedia(B.player), B.props.onLoaded()
                        }),
                      this.shouldUseDASH(k) &&
                        (0, r.getSDK)(_.replace('VERSION', X), y).then(function (ae) {
                          ;(B.dash = ae.MediaPlayer().create()),
                            B.dash.initialize(B.player, k, B.props.playing),
                            B.dash.on('error', B.props.onError),
                            parseInt(X) < 3
                              ? B.dash.getDebug().setLogToBrowserConsole(!1)
                              : B.dash.updateSettings({
                                  debug: { logLevel: ae.Debug.LOG_LEVEL_NONE }
                                }),
                            B.props.onLoaded()
                        }),
                      this.shouldUseFLV(k) &&
                        (0, r.getSDK)(L.replace('VERSION', Q), I).then(function (ae) {
                          ;(B.flv = ae.createPlayer({ type: 'flv', url: k })),
                            B.flv.attachMediaElement(B.player),
                            B.flv.on(ae.Events.ERROR, function (ue, he) {
                              B.props.onError(ue, he, B.flv, ae)
                            }),
                            B.flv.load(),
                            B.props.onLoaded()
                        }),
                      k instanceof Array)
                    )
                      this.player.load()
                    else if ((0, r.isMediaStream)(k))
                      try {
                        this.player.srcObject = k
                      } catch {
                        this.player.src = window.URL.createObjectURL(k)
                      }
                  }
                },
                {
                  key: 'play',
                  value: function () {
                    var k = this.player.play()
                    k && k.catch(this.props.onError)
                  }
                },
                {
                  key: 'pause',
                  value: function () {
                    this.player.pause()
                  }
                },
                {
                  key: 'stop',
                  value: function () {
                    this.player.removeAttribute('src'), this.dash && this.dash.reset()
                  }
                },
                {
                  key: 'seekTo',
                  value: function (k) {
                    var B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
                    ;(this.player.currentTime = k), B || this.pause()
                  }
                },
                {
                  key: 'setVolume',
                  value: function (k) {
                    this.player.volume = k
                  }
                },
                {
                  key: 'enablePIP',
                  value: function () {
                    this.player.requestPictureInPicture &&
                    document.pictureInPictureElement !== this.player
                      ? this.player.requestPictureInPicture()
                      : (0, r.supportsWebKitPresentationMode)(this.player) &&
                        this.player.webkitPresentationMode !== 'picture-in-picture' &&
                        this.player.webkitSetPresentationMode('picture-in-picture')
                  }
                },
                {
                  key: 'disablePIP',
                  value: function () {
                    document.exitPictureInPicture &&
                    document.pictureInPictureElement === this.player
                      ? document.exitPictureInPicture()
                      : (0, r.supportsWebKitPresentationMode)(this.player) &&
                        this.player.webkitPresentationMode !== 'inline' &&
                        this.player.webkitSetPresentationMode('inline')
                  }
                },
                {
                  key: 'setPlaybackRate',
                  value: function (k) {
                    try {
                      this.player.playbackRate = k
                    } catch (B) {
                      this.props.onError(B)
                    }
                  }
                },
                {
                  key: 'getDuration',
                  value: function () {
                    if (!this.player) return null
                    var k = this.player,
                      B = k.duration,
                      V = k.seekable
                    return B === 1 / 0 && V.length > 0 ? V.end(V.length - 1) : B
                  }
                },
                {
                  key: 'getCurrentTime',
                  value: function () {
                    return this.player ? this.player.currentTime : null
                  }
                },
                {
                  key: 'getSecondsLoaded',
                  value: function () {
                    if (!this.player) return null
                    var k = this.player.buffered
                    if (k.length === 0) return 0
                    var B = k.end(k.length - 1),
                      V = this.getDuration()
                    return B > V ? V : B
                  }
                },
                {
                  key: 'getSource',
                  value: function (k) {
                    var B = this.shouldUseHLS(k),
                      V = this.shouldUseDASH(k),
                      H = this.shouldUseFLV(k)
                    if (!(k instanceof Array || (0, r.isMediaStream)(k) || B || V || H))
                      return P.test(k)
                        ? k.replace('www.dropbox.com', 'dl.dropboxusercontent.com')
                        : k
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var k = this.props,
                      B = k.url,
                      V = k.playing,
                      H = k.loop,
                      q = k.controls,
                      X = k.muted,
                      Q = k.config,
                      ae = k.width,
                      ue = k.height,
                      he = this.shouldUseAudio(this.props),
                      _e = he ? 'audio' : 'video',
                      de = {
                        width: ae === 'auto' ? ae : '100%',
                        height: ue === 'auto' ? ue : '100%'
                      }
                    return t.default.createElement(
                      _e,
                      o(
                        {
                          ref: this.ref,
                          src: this.getSource(B),
                          style: de,
                          preload: 'auto',
                          autoPlay: V || void 0,
                          controls: q,
                          muted: X,
                          loop: H
                        },
                        Q.attributes
                      ),
                      B instanceof Array && B.map(this.renderSourceElement),
                      Q.tracks.map(this.renderTrack)
                    )
                  }
                }
              ]),
              U
            )
          })(t.Component)
        ;(s.default = N), T(N, 'displayName', 'FilePlayer'), T(N, 'canPlay', n.canPlay.file)
      })(Ur)),
    Ur
  )
}
;(function (s) {
  Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
  var e = ee,
    t = me,
    r = re
  function n(l) {
    '@babel/helpers - typeof'
    return (
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? (n = function (c) {
            return typeof c
          })
        : (n = function (c) {
            return c &&
              typeof Symbol == 'function' &&
              c.constructor === Symbol &&
              c !== Symbol.prototype
              ? 'symbol'
              : typeof c
          }),
      n(l)
    )
  }
  function i() {
    if (typeof WeakMap != 'function') return null
    var l = new WeakMap()
    return (
      (i = function () {
        return l
      }),
      l
    )
  }
  function a(l) {
    if (l && l.__esModule) return l
    if (l === null || (n(l) !== 'object' && typeof l != 'function')) return { default: l }
    var u = i()
    if (u && u.has(l)) return u.get(l)
    var c = {},
      f = Object.defineProperty && Object.getOwnPropertyDescriptor
    for (var d in l)
      if (Object.prototype.hasOwnProperty.call(l, d)) {
        var m = f ? Object.getOwnPropertyDescriptor(l, d) : null
        m && (m.get || m.set) ? Object.defineProperty(c, d, m) : (c[d] = l[d])
      }
    return (c.default = l), u && u.set(l, c), c
  }
  var o = [
    {
      key: 'youtube',
      name: 'YouTube',
      canPlay: r.canPlay.youtube,
      lazyPlayer: (0, e.lazy)(function () {
        return Promise.resolve().then(function () {
          return a(gl())
        })
      })
    },
    {
      key: 'soundcloud',
      name: 'SoundCloud',
      canPlay: r.canPlay.soundcloud,
      lazyPlayer: (0, e.lazy)(function () {
        return Promise.resolve().then(function () {
          return a(yl())
        })
      })
    },
    {
      key: 'vimeo',
      name: 'Vimeo',
      canPlay: r.canPlay.vimeo,
      lazyPlayer: (0, e.lazy)(function () {
        return Promise.resolve().then(function () {
          return a(vl())
        })
      })
    },
    {
      key: 'facebook',
      name: 'Facebook',
      canPlay: r.canPlay.facebook,
      lazyPlayer: (0, e.lazy)(function () {
        return Promise.resolve().then(function () {
          return a(_l())
        })
      })
    },
    {
      key: 'streamable',
      name: 'Streamable',
      canPlay: r.canPlay.streamable,
      lazyPlayer: (0, e.lazy)(function () {
        return Promise.resolve().then(function () {
          return a(El())
        })
      })
    },
    {
      key: 'wistia',
      name: 'Wistia',
      canPlay: r.canPlay.wistia,
      lazyPlayer: (0, e.lazy)(function () {
        return Promise.resolve().then(function () {
          return a(xl())
        })
      })
    },
    {
      key: 'twitch',
      name: 'Twitch',
      canPlay: r.canPlay.twitch,
      lazyPlayer: (0, e.lazy)(function () {
        return Promise.resolve().then(function () {
          return a(Sl())
        })
      })
    },
    {
      key: 'dailymotion',
      name: 'DailyMotion',
      canPlay: r.canPlay.dailymotion,
      lazyPlayer: (0, e.lazy)(function () {
        return Promise.resolve().then(function () {
          return a(Tl())
        })
      })
    },
    {
      key: 'mixcloud',
      name: 'Mixcloud',
      canPlay: r.canPlay.mixcloud,
      lazyPlayer: (0, e.lazy)(function () {
        return Promise.resolve().then(function () {
          return a(bl())
        })
      })
    },
    {
      key: 'vidyard',
      name: 'Vidyard',
      canPlay: r.canPlay.vidyard,
      lazyPlayer: (0, e.lazy)(function () {
        return Promise.resolve().then(function () {
          return a(Ll())
        })
      })
    },
    {
      key: 'kaltura',
      name: 'Kaltura',
      canPlay: r.canPlay.kaltura,
      lazyPlayer: (0, e.lazy)(function () {
        return Promise.resolve().then(function () {
          return a(Al())
        })
      })
    },
    {
      key: 'file',
      name: 'FilePlayer',
      canPlay: r.canPlay.file,
      canEnablePIP: function (u) {
        return (
          r.canPlay.file(u) &&
          (document.pictureInPictureEnabled || (0, t.supportsWebKitPresentationMode)()) &&
          !r.AUDIO_EXTENSIONS.test(u)
        )
      },
      lazyPlayer: (0, e.lazy)(function () {
        return Promise.resolve().then(function () {
          return a(Rl())
        })
      })
    }
  ]
  s.default = o
})(_s)
var yr = {},
  mi =
    Number.isNaN ||
    function (e) {
      return typeof e == 'number' && e !== e
    }
function Il(s, e) {
  return !!(s === e || (mi(s) && mi(e)))
}
function Pl(s, e) {
  if (s.length !== e.length) return !1
  for (var t = 0; t < s.length; t++) if (!Il(s[t], e[t])) return !1
  return !0
}
function Dl(s, e) {
  e === void 0 && (e = Pl)
  var t,
    r = [],
    n,
    i = !1
  function a() {
    for (var o = [], l = 0; l < arguments.length; l++) o[l] = arguments[l]
    return (
      (i && t === this && e(o, r)) || ((n = s.apply(this, o)), (i = !0), (t = this), (r = o)), n
    )
  }
  return a
}
const Ol = Object.freeze(
    Object.defineProperty({ __proto__: null, default: Dl }, Symbol.toStringTag, { value: 'Module' })
  ),
  wl = to(Ol)
var Cl = typeof Element < 'u',
  kl = typeof Map == 'function',
  Ml = typeof Set == 'function',
  Fl = typeof ArrayBuffer == 'function' && !!ArrayBuffer.isView
function ar(s, e) {
  if (s === e) return !0
  if (s && e && typeof s == 'object' && typeof e == 'object') {
    if (s.constructor !== e.constructor) return !1
    var t, r, n
    if (Array.isArray(s)) {
      if (((t = s.length), t != e.length)) return !1
      for (r = t; r-- !== 0; ) if (!ar(s[r], e[r])) return !1
      return !0
    }
    var i
    if (kl && s instanceof Map && e instanceof Map) {
      if (s.size !== e.size) return !1
      for (i = s.entries(); !(r = i.next()).done; ) if (!e.has(r.value[0])) return !1
      for (i = s.entries(); !(r = i.next()).done; )
        if (!ar(r.value[1], e.get(r.value[0]))) return !1
      return !0
    }
    if (Ml && s instanceof Set && e instanceof Set) {
      if (s.size !== e.size) return !1
      for (i = s.entries(); !(r = i.next()).done; ) if (!e.has(r.value[0])) return !1
      return !0
    }
    if (Fl && ArrayBuffer.isView(s) && ArrayBuffer.isView(e)) {
      if (((t = s.length), t != e.length)) return !1
      for (r = t; r-- !== 0; ) if (s[r] !== e[r]) return !1
      return !0
    }
    if (s.constructor === RegExp) return s.source === e.source && s.flags === e.flags
    if (
      s.valueOf !== Object.prototype.valueOf &&
      typeof s.valueOf == 'function' &&
      typeof e.valueOf == 'function'
    )
      return s.valueOf() === e.valueOf()
    if (
      s.toString !== Object.prototype.toString &&
      typeof s.toString == 'function' &&
      typeof e.toString == 'function'
    )
      return s.toString() === e.toString()
    if (((n = Object.keys(s)), (t = n.length), t !== Object.keys(e).length)) return !1
    for (r = t; r-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(e, n[r])) return !1
    if (Cl && s instanceof Element) return !1
    for (r = t; r-- !== 0; )
      if (
        !((n[r] === '_owner' || n[r] === '__v' || n[r] === '__o') && s.$$typeof) &&
        !ar(s[n[r]], e[n[r]])
      )
        return !1
    return !0
  }
  return s !== s && e !== e
}
var Us = function (e, t) {
    try {
      return ar(e, t)
    } catch (r) {
      if ((r.message || '').match(/stack|recursion/i))
        return console.warn('react-fast-compare cannot handle circular refs'), !1
      throw r
    }
  },
  yt = {}
Object.defineProperty(yt, '__esModule', { value: !0 })
yt.defaultProps = yt.propTypes = void 0
var st = Nl(ro)
function Nl(s) {
  return s && s.__esModule ? s : { default: s }
}
var Me = st.default.string,
  Fe = st.default.bool,
  bt = st.default.number,
  Br = st.default.array,
  Ct = st.default.oneOfType,
  We = st.default.shape,
  Ne = st.default.object,
  Se = st.default.func,
  gi = st.default.node,
  Ul = {
    url: Ct([Me, Br, Ne]),
    playing: Fe,
    loop: Fe,
    controls: Fe,
    volume: bt,
    muted: Fe,
    playbackRate: bt,
    width: Ct([Me, bt]),
    height: Ct([Me, bt]),
    style: Ne,
    progressInterval: bt,
    playsinline: Fe,
    pip: Fe,
    stopOnUnmount: Fe,
    light: Ct([Fe, Me, Ne]),
    playIcon: gi,
    previewTabIndex: bt,
    fallback: gi,
    oEmbedUrl: Me,
    wrapper: Ct([Me, Se, We({ render: Se.isRequired })]),
    config: We({
      soundcloud: We({ options: Ne }),
      youtube: We({ playerVars: Ne, embedOptions: Ne, onUnstarted: Se }),
      facebook: We({ appId: Me, version: Me, playerId: Me, attributes: Ne }),
      dailymotion: We({ params: Ne }),
      vimeo: We({ playerOptions: Ne, title: Me }),
      file: We({
        attributes: Ne,
        tracks: Br,
        forceVideo: Fe,
        forceAudio: Fe,
        forceHLS: Fe,
        forceSafariHLS: Fe,
        forceDisableHls: Fe,
        forceDASH: Fe,
        forceFLV: Fe,
        hlsOptions: Ne,
        hlsVersion: Me,
        dashVersion: Me,
        flvVersion: Me
      }),
      wistia: We({ options: Ne, playerId: Me, customControls: Br }),
      mixcloud: We({ options: Ne }),
      twitch: We({ options: Ne, playerId: Me }),
      vidyard: We({ options: Ne })
    }),
    onReady: Se,
    onStart: Se,
    onPlay: Se,
    onPause: Se,
    onBuffer: Se,
    onBufferEnd: Se,
    onEnded: Se,
    onError: Se,
    onDuration: Se,
    onSeek: Se,
    onPlaybackRateChange: Se,
    onPlaybackQualityChange: Se,
    onProgress: Se,
    onClickPreview: Se,
    onEnablePIP: Se,
    onDisablePIP: Se
  }
yt.propTypes = Ul
var Ie = function () {},
  Bl = {
    playing: !1,
    loop: !1,
    controls: !1,
    volume: null,
    muted: !1,
    playbackRate: 1,
    width: '640px',
    height: '360px',
    style: {},
    progressInterval: 1e3,
    playsinline: !1,
    pip: !1,
    stopOnUnmount: !0,
    light: !1,
    fallback: null,
    wrapper: 'div',
    previewTabIndex: 0,
    oEmbedUrl: 'https://noembed.com/embed?url={url}',
    config: {
      soundcloud: {
        options: {
          visual: !0,
          buying: !1,
          liking: !1,
          download: !1,
          sharing: !1,
          show_comments: !1,
          show_playcount: !1
        }
      },
      youtube: {
        playerVars: { playsinline: 1, showinfo: 0, rel: 0, iv_load_policy: 3, modestbranding: 1 },
        embedOptions: {},
        onUnstarted: Ie
      },
      facebook: { appId: '1309697205772819', version: 'v3.3', playerId: null, attributes: {} },
      dailymotion: { params: { api: 1, 'endscreen-enable': !1 } },
      vimeo: { playerOptions: { autopause: !1, byline: !1, portrait: !1, title: !1 }, title: null },
      file: {
        attributes: {},
        tracks: [],
        forceVideo: !1,
        forceAudio: !1,
        forceHLS: !1,
        forceDASH: !1,
        forceFLV: !1,
        hlsOptions: {},
        hlsVersion: '1.1.4',
        dashVersion: '3.1.3',
        flvVersion: '1.5.0',
        forceDisableHls: !1
      },
      wistia: { options: {}, playerId: null, customControls: null },
      mixcloud: { options: { hide_cover: 1 } },
      twitch: { options: {}, playerId: null },
      vidyard: { options: {} }
    },
    onReady: Ie,
    onStart: Ie,
    onPlay: Ie,
    onPause: Ie,
    onBuffer: Ie,
    onBufferEnd: Ie,
    onEnded: Ie,
    onError: Ie,
    onDuration: Ie,
    onSeek: Ie,
    onPlaybackRateChange: Ie,
    onPlaybackQualityChange: Ie,
    onProgress: Ie,
    onClickPreview: Ie,
    onEnablePIP: Ie,
    onDisablePIP: Ie
  }
yt.defaultProps = Bl
var Bs = {}
;(function (s) {
  function e(S) {
    '@babel/helpers - typeof'
    return (
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? (e = function (_) {
            return typeof _
          })
        : (e = function (_) {
            return _ &&
              typeof Symbol == 'function' &&
              _.constructor === Symbol &&
              _ !== Symbol.prototype
              ? 'symbol'
              : typeof _
          }),
      e(S)
    )
  }
  Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
  var t = l(ee),
    r = a(Us),
    n = yt,
    i = me
  function a(S) {
    return S && S.__esModule ? S : { default: S }
  }
  function o() {
    if (typeof WeakMap != 'function') return null
    var S = new WeakMap()
    return (
      (o = function () {
        return S
      }),
      S
    )
  }
  function l(S) {
    if (S && S.__esModule) return S
    if (S === null || (e(S) !== 'object' && typeof S != 'function')) return { default: S }
    var h = o()
    if (h && h.has(S)) return h.get(S)
    var _ = {},
      y = Object.defineProperty && Object.getOwnPropertyDescriptor
    for (var L in S)
      if (Object.prototype.hasOwnProperty.call(S, L)) {
        var I = y ? Object.getOwnPropertyDescriptor(S, L) : null
        I && (I.get || I.set) ? Object.defineProperty(_, L, I) : (_[L] = S[L])
      }
    return (_.default = S), h && h.set(S, _), _
  }
  function u() {
    return (
      (u =
        Object.assign ||
        function (S) {
          for (var h = 1; h < arguments.length; h++) {
            var _ = arguments[h]
            for (var y in _) Object.prototype.hasOwnProperty.call(_, y) && (S[y] = _[y])
          }
          return S
        }),
      u.apply(this, arguments)
    )
  }
  function c(S, h) {
    if (!(S instanceof h)) throw new TypeError('Cannot call a class as a function')
  }
  function f(S, h) {
    for (var _ = 0; _ < h.length; _++) {
      var y = h[_]
      ;(y.enumerable = y.enumerable || !1),
        (y.configurable = !0),
        'value' in y && (y.writable = !0),
        Object.defineProperty(S, y.key, y)
    }
  }
  function d(S, h, _) {
    return h && f(S.prototype, h), _ && f(S, _), S
  }
  function m(S, h) {
    if (typeof h != 'function' && h !== null)
      throw new TypeError('Super expression must either be null or a function')
    ;(S.prototype = Object.create(h && h.prototype, {
      constructor: { value: S, writable: !0, configurable: !0 }
    })),
      h && p(S, h)
  }
  function p(S, h) {
    return (
      (p =
        Object.setPrototypeOf ||
        function (y, L) {
          return (y.__proto__ = L), y
        }),
      p(S, h)
    )
  }
  function v(S) {
    var h = T()
    return function () {
      var y = b(S),
        L
      if (h) {
        var I = b(this).constructor
        L = Reflect.construct(y, arguments, I)
      } else L = y.apply(this, arguments)
      return E(this, L)
    }
  }
  function E(S, h) {
    return h && (e(h) === 'object' || typeof h == 'function') ? h : x(S)
  }
  function x(S) {
    if (S === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
    return S
  }
  function T() {
    if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
    if (typeof Proxy == 'function') return !0
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
    } catch {
      return !1
    }
  }
  function b(S) {
    return (
      (b = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (_) {
            return _.__proto__ || Object.getPrototypeOf(_)
          }),
      b(S)
    )
  }
  function R(S, h, _) {
    return (
      h in S
        ? Object.defineProperty(S, h, { value: _, enumerable: !0, configurable: !0, writable: !0 })
        : (S[h] = _),
      S
    )
  }
  var g = 5e3,
    A = (function (S) {
      m(_, S)
      var h = v(_)
      function _() {
        var y
        c(this, _)
        for (var L = arguments.length, I = new Array(L), P = 0; P < L; P++) I[P] = arguments[P]
        return (
          (y = h.call.apply(h, [this].concat(I))),
          R(x(y), 'mounted', !1),
          R(x(y), 'isReady', !1),
          R(x(y), 'isPlaying', !1),
          R(x(y), 'isLoading', !0),
          R(x(y), 'loadOnReady', null),
          R(x(y), 'startOnPlay', !0),
          R(x(y), 'seekOnPlay', null),
          R(x(y), 'onDurationCalled', !1),
          R(x(y), 'handlePlayerMount', function (D) {
            if (y.player) {
              y.progress()
              return
            }
            ;(y.player = D), y.player.load(y.props.url), y.progress()
          }),
          R(x(y), 'getInternalPlayer', function (D) {
            return y.player ? y.player[D] : null
          }),
          R(x(y), 'progress', function () {
            if (y.props.url && y.player && y.isReady) {
              var D = y.getCurrentTime() || 0,
                C = y.getSecondsLoaded(),
                N = y.getDuration()
              if (N) {
                var M = { playedSeconds: D, played: D / N }
                C !== null && ((M.loadedSeconds = C), (M.loaded = C / N)),
                  (M.playedSeconds !== y.prevPlayed || M.loadedSeconds !== y.prevLoaded) &&
                    y.props.onProgress(M),
                  (y.prevPlayed = M.playedSeconds),
                  (y.prevLoaded = M.loadedSeconds)
              }
            }
            y.progressTimeout = setTimeout(
              y.progress,
              y.props.progressFrequency || y.props.progressInterval
            )
          }),
          R(x(y), 'handleReady', function () {
            if (y.mounted) {
              ;(y.isReady = !0), (y.isLoading = !1)
              var D = y.props,
                C = D.onReady,
                N = D.playing,
                M = D.volume,
                w = D.muted
              C(),
                !w && M !== null && y.player.setVolume(M),
                y.loadOnReady
                  ? (y.player.load(y.loadOnReady, !0), (y.loadOnReady = null))
                  : N && y.player.play(),
                y.handleDurationCheck()
            }
          }),
          R(x(y), 'handlePlay', function () {
            ;(y.isPlaying = !0), (y.isLoading = !1)
            var D = y.props,
              C = D.onStart,
              N = D.onPlay,
              M = D.playbackRate
            y.startOnPlay &&
              (y.player.setPlaybackRate && M !== 1 && y.player.setPlaybackRate(M),
              C(),
              (y.startOnPlay = !1)),
              N(),
              y.seekOnPlay && (y.seekTo(y.seekOnPlay), (y.seekOnPlay = null)),
              y.handleDurationCheck()
          }),
          R(x(y), 'handlePause', function (D) {
            ;(y.isPlaying = !1), y.isLoading || y.props.onPause(D)
          }),
          R(x(y), 'handleEnded', function () {
            var D = y.props,
              C = D.activePlayer,
              N = D.loop,
              M = D.onEnded
            C.loopOnEnded && N && y.seekTo(0), N || ((y.isPlaying = !1), M())
          }),
          R(x(y), 'handleError', function () {
            var D
            ;(y.isLoading = !1), (D = y.props).onError.apply(D, arguments)
          }),
          R(x(y), 'handleDurationCheck', function () {
            clearTimeout(y.durationCheckTimeout)
            var D = y.getDuration()
            D
              ? y.onDurationCalled || (y.props.onDuration(D), (y.onDurationCalled = !0))
              : (y.durationCheckTimeout = setTimeout(y.handleDurationCheck, 100))
          }),
          R(x(y), 'handleLoaded', function () {
            y.isLoading = !1
          }),
          y
        )
      }
      return (
        d(_, [
          {
            key: 'componentDidMount',
            value: function () {
              this.mounted = !0
            }
          },
          {
            key: 'componentWillUnmount',
            value: function () {
              clearTimeout(this.progressTimeout),
                clearTimeout(this.durationCheckTimeout),
                this.isReady &&
                  this.props.stopOnUnmount &&
                  (this.player.stop(), this.player.disablePIP && this.player.disablePIP()),
                (this.mounted = !1)
            }
          },
          {
            key: 'componentDidUpdate',
            value: function (L) {
              var I = this
              if (this.player) {
                var P = this.props,
                  D = P.url,
                  C = P.playing,
                  N = P.volume,
                  M = P.muted,
                  w = P.playbackRate,
                  U = P.pip,
                  F = P.loop,
                  k = P.activePlayer,
                  B = P.disableDeferredLoading
                if (!(0, r.default)(L.url, D)) {
                  if (this.isLoading && !k.forceLoad && !B && !(0, i.isMediaStream)(D)) {
                    console.warn(
                      'ReactPlayer: the attempt to load '.concat(
                        D,
                        ' is being deferred until the player has loaded'
                      )
                    ),
                      (this.loadOnReady = D)
                    return
                  }
                  ;(this.isLoading = !0),
                    (this.startOnPlay = !0),
                    (this.onDurationCalled = !1),
                    this.player.load(D, this.isReady)
                }
                !L.playing && C && !this.isPlaying && this.player.play(),
                  L.playing && !C && this.isPlaying && this.player.pause(),
                  !L.pip && U && this.player.enablePIP && this.player.enablePIP(),
                  L.pip && !U && this.player.disablePIP && this.player.disablePIP(),
                  L.volume !== N && N !== null && this.player.setVolume(N),
                  L.muted !== M &&
                    (M
                      ? this.player.mute()
                      : (this.player.unmute(),
                        N !== null &&
                          setTimeout(function () {
                            return I.player.setVolume(N)
                          }))),
                  L.playbackRate !== w &&
                    this.player.setPlaybackRate &&
                    this.player.setPlaybackRate(w),
                  L.loop !== F && this.player.setLoop && this.player.setLoop(F)
              }
            }
          },
          {
            key: 'getDuration',
            value: function () {
              return this.isReady ? this.player.getDuration() : null
            }
          },
          {
            key: 'getCurrentTime',
            value: function () {
              return this.isReady ? this.player.getCurrentTime() : null
            }
          },
          {
            key: 'getSecondsLoaded',
            value: function () {
              return this.isReady ? this.player.getSecondsLoaded() : null
            }
          },
          {
            key: 'seekTo',
            value: function (L, I, P) {
              var D = this
              if (!this.isReady) {
                L !== 0 &&
                  ((this.seekOnPlay = L),
                  setTimeout(function () {
                    D.seekOnPlay = null
                  }, g))
                return
              }
              var C = I ? I === 'fraction' : L > 0 && L < 1
              if (C) {
                var N = this.player.getDuration()
                if (!N) {
                  console.warn(
                    'ReactPlayer: could not seek using fraction – duration not yet available'
                  )
                  return
                }
                this.player.seekTo(N * L, P)
                return
              }
              this.player.seekTo(L, P)
            }
          },
          {
            key: 'render',
            value: function () {
              var L = this.props.activePlayer
              return L
                ? t.default.createElement(
                    L,
                    u({}, this.props, {
                      onMount: this.handlePlayerMount,
                      onReady: this.handleReady,
                      onPlay: this.handlePlay,
                      onPause: this.handlePause,
                      onEnded: this.handleEnded,
                      onLoaded: this.handleLoaded,
                      onError: this.handleError
                    })
                  )
                : null
            }
          }
        ]),
        _
      )
    })(t.Component)
  ;(s.default = A),
    R(A, 'displayName', 'Player'),
    R(A, 'propTypes', n.propTypes),
    R(A, 'defaultProps', n.defaultProps)
})(Bs)
var Gr = {},
  yi
function Gl() {
  return (
    yi ||
      ((yi = 1),
      (function (s) {
        function e(g) {
          '@babel/helpers - typeof'
          return (
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? (e = function (S) {
                  return typeof S
                })
              : (e = function (S) {
                  return S &&
                    typeof Symbol == 'function' &&
                    S.constructor === Symbol &&
                    S !== Symbol.prototype
                    ? 'symbol'
                    : typeof S
                }),
            e(g)
          )
        }
        Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
        var t = n(ee)
        function r() {
          if (typeof WeakMap != 'function') return null
          var g = new WeakMap()
          return (
            (r = function () {
              return g
            }),
            g
          )
        }
        function n(g) {
          if (g && g.__esModule) return g
          if (g === null || (e(g) !== 'object' && typeof g != 'function')) return { default: g }
          var A = r()
          if (A && A.has(g)) return A.get(g)
          var S = {},
            h = Object.defineProperty && Object.getOwnPropertyDescriptor
          for (var _ in g)
            if (Object.prototype.hasOwnProperty.call(g, _)) {
              var y = h ? Object.getOwnPropertyDescriptor(g, _) : null
              y && (y.get || y.set) ? Object.defineProperty(S, _, y) : (S[_] = g[_])
            }
          return (S.default = g), A && A.set(g, S), S
        }
        function i(g, A) {
          var S = Object.keys(g)
          if (Object.getOwnPropertySymbols) {
            var h = Object.getOwnPropertySymbols(g)
            A &&
              (h = h.filter(function (_) {
                return Object.getOwnPropertyDescriptor(g, _).enumerable
              })),
              S.push.apply(S, h)
          }
          return S
        }
        function a(g) {
          for (var A = 1; A < arguments.length; A++) {
            var S = arguments[A] != null ? arguments[A] : {}
            A % 2
              ? i(Object(S), !0).forEach(function (h) {
                  x(g, h, S[h])
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(g, Object.getOwnPropertyDescriptors(S))
              : i(Object(S)).forEach(function (h) {
                  Object.defineProperty(g, h, Object.getOwnPropertyDescriptor(S, h))
                })
          }
          return g
        }
        function o(g, A) {
          if (!(g instanceof A)) throw new TypeError('Cannot call a class as a function')
        }
        function l(g, A) {
          for (var S = 0; S < A.length; S++) {
            var h = A[S]
            ;(h.enumerable = h.enumerable || !1),
              (h.configurable = !0),
              'value' in h && (h.writable = !0),
              Object.defineProperty(g, h.key, h)
          }
        }
        function u(g, A, S) {
          return A && l(g.prototype, A), S && l(g, S), g
        }
        function c(g, A) {
          if (typeof A != 'function' && A !== null)
            throw new TypeError('Super expression must either be null or a function')
          ;(g.prototype = Object.create(A && A.prototype, {
            constructor: { value: g, writable: !0, configurable: !0 }
          })),
            A && f(g, A)
        }
        function f(g, A) {
          return (
            (f =
              Object.setPrototypeOf ||
              function (h, _) {
                return (h.__proto__ = _), h
              }),
            f(g, A)
          )
        }
        function d(g) {
          var A = v()
          return function () {
            var h = E(g),
              _
            if (A) {
              var y = E(this).constructor
              _ = Reflect.construct(h, arguments, y)
            } else _ = h.apply(this, arguments)
            return m(this, _)
          }
        }
        function m(g, A) {
          return A && (e(A) === 'object' || typeof A == 'function') ? A : p(g)
        }
        function p(g) {
          if (g === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
          return g
        }
        function v() {
          if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
          if (typeof Proxy == 'function') return !0
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
          } catch {
            return !1
          }
        }
        function E(g) {
          return (
            (E = Object.setPrototypeOf
              ? Object.getPrototypeOf
              : function (S) {
                  return S.__proto__ || Object.getPrototypeOf(S)
                }),
            E(g)
          )
        }
        function x(g, A, S) {
          return (
            A in g
              ? Object.defineProperty(g, A, {
                  value: S,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
                })
              : (g[A] = S),
            g
          )
        }
        var T = '64px',
          b = {},
          R = (function (g) {
            c(S, g)
            var A = d(S)
            function S() {
              var h
              o(this, S)
              for (var _ = arguments.length, y = new Array(_), L = 0; L < _; L++)
                y[L] = arguments[L]
              return (
                (h = A.call.apply(A, [this].concat(y))),
                x(p(h), 'mounted', !1),
                x(p(h), 'state', { image: null }),
                x(p(h), 'handleKeyPress', function (I) {
                  ;(I.key === 'Enter' || I.key === ' ') && h.props.onClick()
                }),
                h
              )
            }
            return (
              u(S, [
                {
                  key: 'componentDidMount',
                  value: function () {
                    ;(this.mounted = !0), this.fetchImage(this.props)
                  }
                },
                {
                  key: 'componentDidUpdate',
                  value: function (_) {
                    var y = this.props,
                      L = y.url,
                      I = y.light
                    ;(_.url !== L || _.light !== I) && this.fetchImage(this.props)
                  }
                },
                {
                  key: 'componentWillUnmount',
                  value: function () {
                    this.mounted = !1
                  }
                },
                {
                  key: 'fetchImage',
                  value: function (_) {
                    var y = this,
                      L = _.url,
                      I = _.light,
                      P = _.oEmbedUrl
                    if (!t.default.isValidElement(I)) {
                      if (typeof I == 'string') {
                        this.setState({ image: I })
                        return
                      }
                      if (b[L]) {
                        this.setState({ image: b[L] })
                        return
                      }
                      return (
                        this.setState({ image: null }),
                        window
                          .fetch(P.replace('{url}', L))
                          .then(function (D) {
                            return D.json()
                          })
                          .then(function (D) {
                            if (D.thumbnail_url && y.mounted) {
                              var C = D.thumbnail_url
                                .replace('height=100', 'height=480')
                                .replace('-d_295x166', '-d_640')
                              y.setState({ image: C }), (b[L] = C)
                            }
                          })
                      )
                    }
                  }
                },
                {
                  key: 'render',
                  value: function () {
                    var _ = this.props,
                      y = _.light,
                      L = _.onClick,
                      I = _.playIcon,
                      P = _.previewTabIndex,
                      D = this.state.image,
                      C = t.default.isValidElement(y),
                      N = { display: 'flex', alignItems: 'center', justifyContent: 'center' },
                      M = {
                        preview: a(
                          {
                            width: '100%',
                            height: '100%',
                            backgroundImage: D && !C ? 'url('.concat(D, ')') : void 0,
                            backgroundSize: 'cover',
                            backgroundPosition: 'center',
                            cursor: 'pointer'
                          },
                          N
                        ),
                        shadow: a(
                          {
                            background: 'radial-gradient(rgb(0, 0, 0, 0.3), rgba(0, 0, 0, 0) 60%)',
                            borderRadius: T,
                            width: T,
                            height: T,
                            position: C ? 'absolute' : void 0
                          },
                          N
                        ),
                        playIcon: {
                          borderStyle: 'solid',
                          borderWidth: '16px 0 16px 26px',
                          borderColor: 'transparent transparent transparent white',
                          marginLeft: '7px'
                        }
                      },
                      w = t.default.createElement(
                        'div',
                        { style: M.shadow, className: 'react-player__shadow' },
                        t.default.createElement('div', {
                          style: M.playIcon,
                          className: 'react-player__play-icon'
                        })
                      )
                    return t.default.createElement(
                      'div',
                      {
                        style: M.preview,
                        className: 'react-player__preview',
                        onClick: L,
                        tabIndex: P,
                        onKeyPress: this.handleKeyPress
                      },
                      C ? y : null,
                      I || w
                    )
                  }
                }
              ]),
              S
            )
          })(t.Component)
        s.default = R
      })(Gr)),
    Gr
  )
}
Object.defineProperty(yr, '__esModule', { value: !0 })
yr.createReactPlayer = void 0
var pt = $s(ee),
  $l = vr(xs),
  $r = vr(wl),
  vi = vr(Us),
  Nt = yt,
  Kl = me,
  jl = vr(Bs)
function vr(s) {
  return s && s.__esModule ? s : { default: s }
}
function Bt(s) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (Bt = function (t) {
          return typeof t
        })
      : (Bt = function (t) {
          return t &&
            typeof Symbol == 'function' &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? 'symbol'
            : typeof t
        }),
    Bt(s)
  )
}
function _i(s, e) {
  var t = Object.keys(s)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(s)
    e &&
      (r = r.filter(function (n) {
        return Object.getOwnPropertyDescriptor(s, n).enumerable
      })),
      t.push.apply(t, r)
  }
  return t
}
function Ei(s) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? _i(Object(t), !0).forEach(function (r) {
          Ee(s, r, t[r])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(t))
      : _i(Object(t)).forEach(function (r) {
          Object.defineProperty(s, r, Object.getOwnPropertyDescriptor(t, r))
        })
  }
  return s
}
function ur() {
  return (
    (ur =
      Object.assign ||
      function (s) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e]
          for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (s[r] = t[r])
        }
        return s
      }),
    ur.apply(this, arguments)
  )
}
function Kr(s) {
  return Yl(s) || Wl(s) || Hl(s) || Vl()
}
function Vl() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function Hl(s, e) {
  if (s) {
    if (typeof s == 'string') return gn(s, e)
    var t = Object.prototype.toString.call(s).slice(8, -1)
    if ((t === 'Object' && s.constructor && (t = s.constructor.name), t === 'Map' || t === 'Set'))
      return Array.from(s)
    if (t === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return gn(s, e)
  }
}
function Wl(s) {
  if (typeof Symbol < 'u' && Symbol.iterator in Object(s)) return Array.from(s)
}
function Yl(s) {
  if (Array.isArray(s)) return gn(s)
}
function gn(s, e) {
  ;(e == null || e > s.length) && (e = s.length)
  for (var t = 0, r = new Array(e); t < e; t++) r[t] = s[t]
  return r
}
function zl(s, e) {
  if (!(s instanceof e)) throw new TypeError('Cannot call a class as a function')
}
function xi(s, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(s, r.key, r)
  }
}
function ql(s, e, t) {
  return e && xi(s.prototype, e), t && xi(s, t), s
}
function Xl(s, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(s.prototype = Object.create(e && e.prototype, {
    constructor: { value: s, writable: !0, configurable: !0 }
  })),
    e && yn(s, e)
}
function yn(s, e) {
  return (
    (yn =
      Object.setPrototypeOf ||
      function (r, n) {
        return (r.__proto__ = n), r
      }),
    yn(s, e)
  )
}
function Ql(s) {
  var e = Jl()
  return function () {
    var r = cr(s),
      n
    if (e) {
      var i = cr(this).constructor
      n = Reflect.construct(r, arguments, i)
    } else n = r.apply(this, arguments)
    return Zl(this, n)
  }
}
function Zl(s, e) {
  return e && (Bt(e) === 'object' || typeof e == 'function') ? e : we(s)
}
function we(s) {
  if (s === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
  return s
}
function Jl() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham) return !1
  if (typeof Proxy == 'function') return !0
  try {
    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
  } catch {
    return !1
  }
}
function cr(s) {
  return (
    (cr = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    cr(s)
  )
}
function Ee(s, e, t) {
  return (
    e in s
      ? Object.defineProperty(s, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (s[e] = t),
    s
  )
}
function Gs() {
  if (typeof WeakMap != 'function') return null
  var s = new WeakMap()
  return (
    (Gs = function () {
      return s
    }),
    s
  )
}
function $s(s) {
  if (s && s.__esModule) return s
  if (s === null || (Bt(s) !== 'object' && typeof s != 'function')) return { default: s }
  var e = Gs()
  if (e && e.has(s)) return e.get(s)
  var t = {},
    r = Object.defineProperty && Object.getOwnPropertyDescriptor
  for (var n in s)
    if (Object.prototype.hasOwnProperty.call(s, n)) {
      var i = r ? Object.getOwnPropertyDescriptor(s, n) : null
      i && (i.get || i.set) ? Object.defineProperty(t, n, i) : (t[n] = s[n])
    }
  return (t.default = s), e && e.set(s, t), t
}
var eu = (0, pt.lazy)(function () {
    return Promise.resolve().then(function () {
      return $s(Gl())
    })
  }),
  tu = typeof window < 'u' && window.document,
  ru = typeof Lr < 'u' && Lr.window && Lr.window.document,
  nu = Object.keys(Nt.propTypes),
  iu =
    tu || ru
      ? pt.Suspense
      : function () {
          return null
        },
  kt = [],
  su = function (e, t) {
    var r, n
    return (
      (n = r =
        (function (i) {
          Xl(o, i)
          var a = Ql(o)
          function o() {
            var l
            zl(this, o)
            for (var u = arguments.length, c = new Array(u), f = 0; f < u; f++) c[f] = arguments[f]
            return (
              (l = a.call.apply(a, [this].concat(c))),
              Ee(we(l), 'state', { showPreview: !!l.props.light }),
              Ee(we(l), 'references', {
                wrapper: function (m) {
                  l.wrapper = m
                },
                player: function (m) {
                  l.player = m
                }
              }),
              Ee(we(l), 'handleClickPreview', function (d) {
                l.setState({ showPreview: !1 }), l.props.onClickPreview(d)
              }),
              Ee(we(l), 'showPreview', function () {
                l.setState({ showPreview: !0 })
              }),
              Ee(we(l), 'getDuration', function () {
                return l.player ? l.player.getDuration() : null
              }),
              Ee(we(l), 'getCurrentTime', function () {
                return l.player ? l.player.getCurrentTime() : null
              }),
              Ee(we(l), 'getSecondsLoaded', function () {
                return l.player ? l.player.getSecondsLoaded() : null
              }),
              Ee(we(l), 'getInternalPlayer', function () {
                var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'player'
                return l.player ? l.player.getInternalPlayer(d) : null
              }),
              Ee(we(l), 'seekTo', function (d, m, p) {
                if (!l.player) return null
                l.player.seekTo(d, m, p)
              }),
              Ee(we(l), 'handleReady', function () {
                l.props.onReady(we(l))
              }),
              Ee(
                we(l),
                'getActivePlayer',
                (0, $r.default)(function (d) {
                  for (var m = 0, p = [].concat(kt, Kr(e)); m < p.length; m++) {
                    var v = p[m]
                    if (v.canPlay(d)) return v
                  }
                  return t || null
                })
              ),
              Ee(
                we(l),
                'getConfig',
                (0, $r.default)(function (d, m) {
                  var p = l.props.config
                  return $l.default.all([
                    Nt.defaultProps.config,
                    Nt.defaultProps.config[m] || {},
                    p,
                    p[m] || {}
                  ])
                })
              ),
              Ee(
                we(l),
                'getAttributes',
                (0, $r.default)(function (d) {
                  return (0, Kl.omit)(l.props, nu)
                })
              ),
              Ee(we(l), 'renderActivePlayer', function (d) {
                if (!d) return null
                var m = l.getActivePlayer(d)
                if (!m) return null
                var p = l.getConfig(d, m.key)
                return pt.default.createElement(
                  jl.default,
                  ur({}, l.props, {
                    key: m.key,
                    ref: l.references.player,
                    config: p,
                    activePlayer: m.lazyPlayer || m,
                    onReady: l.handleReady
                  })
                )
              }),
              l
            )
          }
          return (
            ql(o, [
              {
                key: 'shouldComponentUpdate',
                value: function (u, c) {
                  return !(0, vi.default)(this.props, u) || !(0, vi.default)(this.state, c)
                }
              },
              {
                key: 'componentDidUpdate',
                value: function (u) {
                  var c = this.props.light
                  !u.light && c && this.setState({ showPreview: !0 }),
                    u.light && !c && this.setState({ showPreview: !1 })
                }
              },
              {
                key: 'renderPreview',
                value: function (u) {
                  if (!u) return null
                  var c = this.props,
                    f = c.light,
                    d = c.playIcon,
                    m = c.previewTabIndex,
                    p = c.oEmbedUrl
                  return pt.default.createElement(eu, {
                    url: u,
                    light: f,
                    playIcon: d,
                    previewTabIndex: m,
                    oEmbedUrl: p,
                    onClick: this.handleClickPreview
                  })
                }
              },
              {
                key: 'render',
                value: function () {
                  var u = this.props,
                    c = u.url,
                    f = u.style,
                    d = u.width,
                    m = u.height,
                    p = u.fallback,
                    v = u.wrapper,
                    E = this.state.showPreview,
                    x = this.getAttributes(c),
                    T = typeof v == 'string' ? this.references.wrapper : void 0
                  return pt.default.createElement(
                    v,
                    ur({ ref: T, style: Ei(Ei({}, f), {}, { width: d, height: m }) }, x),
                    pt.default.createElement(
                      iu,
                      { fallback: p },
                      E ? this.renderPreview(c) : this.renderActivePlayer(c)
                    )
                  )
                }
              }
            ]),
            o
          )
        })(pt.Component)),
      Ee(r, 'displayName', 'ReactPlayer'),
      Ee(r, 'propTypes', Nt.propTypes),
      Ee(r, 'defaultProps', Nt.defaultProps),
      Ee(r, 'addCustomPlayer', function (i) {
        kt.push(i)
      }),
      Ee(r, 'removeCustomPlayers', function () {
        kt.length = 0
      }),
      Ee(r, 'canPlay', function (i) {
        for (var a = 0, o = [].concat(kt, Kr(e)); a < o.length; a++) {
          var l = o[a]
          if (l.canPlay(i)) return !0
        }
        return !1
      }),
      Ee(r, 'canEnablePIP', function (i) {
        for (var a = 0, o = [].concat(kt, Kr(e)); a < o.length; a++) {
          var l = o[a]
          if (l.canEnablePIP && l.canEnablePIP(i)) return !0
        }
        return !1
      }),
      n
    )
  }
yr.createReactPlayer = su
;(function (s) {
  Object.defineProperty(s, '__esModule', { value: !0 }), (s.default = void 0)
  var e = r(_s),
    t = yr
  function r(a) {
    return a && a.__esModule ? a : { default: a }
  }
  var n = e.default[e.default.length - 1],
    i = (0, t.createReactPlayer)(e.default, n)
  s.default = i
})(vs)
const au = no(vs)
var ou = { exports: {} }
;(function (s, e) {
  ;(function (r, n) {
    s.exports = n()
  })(self, function () {
    return (function () {
      var t = {
          './node_modules/es6-promise/dist/es6-promise.js': function (a, o, l) {
            /*!
             * @overview es6-promise - a tiny implementation of Promises/A+.
             * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
             * @license   Licensed under MIT license
             *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
             * @version   v4.2.8+1e68dce6
             */ ;(function (u, c) {
              a.exports = c()
            })(this, function () {
              function u(j) {
                var Y = typeof j
                return j !== null && (Y === 'object' || Y === 'function')
              }
              function c(j) {
                return typeof j == 'function'
              }
              var f = void 0
              Array.isArray
                ? (f = Array.isArray)
                : (f = function (j) {
                    return Object.prototype.toString.call(j) === '[object Array]'
                  })
              var d = f,
                m = 0,
                p = void 0,
                v = void 0,
                E = function (Y, z) {
                  ;(P[m] = Y), (P[m + 1] = z), (m += 2), m === 2 && (v ? v(D) : N())
                }
              function x(j) {
                v = j
              }
              function T(j) {
                E = j
              }
              var b = typeof window < 'u' ? window : void 0,
                R = b || {},
                g = R.MutationObserver || R.WebKitMutationObserver,
                A =
                  typeof self > 'u' &&
                  typeof process < 'u' &&
                  {}.toString.call(process) === '[object process]',
                S =
                  typeof Uint8ClampedArray < 'u' &&
                  typeof importScripts < 'u' &&
                  typeof MessageChannel < 'u'
              function h() {
                return function () {
                  return process.nextTick(D)
                }
              }
              function _() {
                return typeof p < 'u'
                  ? function () {
                      p(D)
                    }
                  : I()
              }
              function y() {
                var j = 0,
                  Y = new g(D),
                  z = document.createTextNode('')
                return (
                  Y.observe(z, { characterData: !0 }),
                  function () {
                    z.data = j = ++j % 2
                  }
                )
              }
              function L() {
                var j = new MessageChannel()
                return (
                  (j.port1.onmessage = D),
                  function () {
                    return j.port2.postMessage(0)
                  }
                )
              }
              function I() {
                var j = setTimeout
                return function () {
                  return j(D, 1)
                }
              }
              var P = new Array(1e3)
              function D() {
                for (var j = 0; j < m; j += 2) {
                  var Y = P[j],
                    z = P[j + 1]
                  Y(z), (P[j] = void 0), (P[j + 1] = void 0)
                }
                m = 0
              }
              function C() {
                try {
                  var j = Function('return this')().require('vertx')
                  return (p = j.runOnLoop || j.runOnContext), _()
                } catch {
                  return I()
                }
              }
              var N = void 0
              A ? (N = h()) : g ? (N = y()) : S ? (N = L()) : b === void 0 ? (N = C()) : (N = I())
              function M(j, Y) {
                var z = this,
                  Z = new this.constructor(F)
                Z[U] === void 0 && ot(Z)
                var oe = z._state
                if (oe) {
                  var le = arguments[oe - 1]
                  E(function () {
                    return Ue(oe, Z, le, z._result)
                  })
                } else be(z, Z, j, Y)
                return Z
              }
              function w(j) {
                var Y = this
                if (j && typeof j == 'object' && j.constructor === Y) return j
                var z = new Y(F)
                return he(z, j), z
              }
              var U = Math.random().toString(36).substring(2)
              function F() {}
              var k = void 0,
                B = 1,
                V = 2
              function H() {
                return new TypeError('You cannot resolve a promise with itself')
              }
              function q() {
                return new TypeError('A promises callback cannot return that same promise.')
              }
              function X(j, Y, z, Z) {
                try {
                  j.call(Y, z, Z)
                } catch (oe) {
                  return oe
                }
              }
              function Q(j, Y, z) {
                E(function (Z) {
                  var oe = !1,
                    le = X(
                      z,
                      Y,
                      function (Le) {
                        oe || ((oe = !0), Y !== Le ? he(Z, Le) : de(Z, Le))
                      },
                      function (Le) {
                        oe || ((oe = !0), te(Z, Le))
                      },
                      'Settle: ' + (Z._label || ' unknown promise')
                    )
                  !oe && le && ((oe = !0), te(Z, le))
                }, j)
              }
              function ae(j, Y) {
                Y._state === B
                  ? de(j, Y._result)
                  : Y._state === V
                  ? te(j, Y._result)
                  : be(
                      Y,
                      void 0,
                      function (z) {
                        return he(j, z)
                      },
                      function (z) {
                        return te(j, z)
                      }
                    )
              }
              function ue(j, Y, z) {
                Y.constructor === j.constructor && z === M && Y.constructor.resolve === w
                  ? ae(j, Y)
                  : z === void 0
                  ? de(j, Y)
                  : c(z)
                  ? Q(j, Y, z)
                  : de(j, Y)
              }
              function he(j, Y) {
                if (j === Y) te(j, H())
                else if (u(Y)) {
                  var z = void 0
                  try {
                    z = Y.then
                  } catch (Z) {
                    te(j, Z)
                    return
                  }
                  ue(j, Y, z)
                } else de(j, Y)
              }
              function _e(j) {
                j._onerror && j._onerror(j._result), De(j)
              }
              function de(j, Y) {
                j._state === k &&
                  ((j._result = Y), (j._state = B), j._subscribers.length !== 0 && E(De, j))
              }
              function te(j, Y) {
                j._state === k && ((j._state = V), (j._result = Y), E(_e, j))
              }
              function be(j, Y, z, Z) {
                var oe = j._subscribers,
                  le = oe.length
                ;(j._onerror = null),
                  (oe[le] = Y),
                  (oe[le + B] = z),
                  (oe[le + V] = Z),
                  le === 0 && j._state && E(De, j)
              }
              function De(j) {
                var Y = j._subscribers,
                  z = j._state
                if (Y.length !== 0) {
                  for (var Z = void 0, oe = void 0, le = j._result, Le = 0; Le < Y.length; Le += 3)
                    (Z = Y[Le]), (oe = Y[Le + z]), Z ? Ue(z, Z, oe, le) : oe(le)
                  j._subscribers.length = 0
                }
              }
              function Ue(j, Y, z, Z) {
                var oe = c(z),
                  le = void 0,
                  Le = void 0,
                  Et = !0
                if (oe) {
                  try {
                    le = z(Z)
                  } catch (Yt) {
                    ;(Et = !1), (Le = Yt)
                  }
                  if (Y === le) {
                    te(Y, q())
                    return
                  }
                } else le = Z
                Y._state !== k ||
                  (oe && Et
                    ? he(Y, le)
                    : Et === !1
                    ? te(Y, Le)
                    : j === B
                    ? de(Y, le)
                    : j === V && te(Y, le))
              }
              function ke(j, Y) {
                try {
                  Y(
                    function (Z) {
                      he(j, Z)
                    },
                    function (Z) {
                      te(j, Z)
                    }
                  )
                } catch (z) {
                  te(j, z)
                }
              }
              var xe = 0
              function at() {
                return xe++
              }
              function ot(j) {
                ;(j[U] = xe++), (j._state = void 0), (j._result = void 0), (j._subscribers = [])
              }
              function He() {
                return new Error('Array Methods must be provided an Array')
              }
              var Be = (function () {
                function j(Y, z) {
                  ;(this._instanceConstructor = Y),
                    (this.promise = new Y(F)),
                    this.promise[U] || ot(this.promise),
                    d(z)
                      ? ((this.length = z.length),
                        (this._remaining = z.length),
                        (this._result = new Array(this.length)),
                        this.length === 0
                          ? de(this.promise, this._result)
                          : ((this.length = this.length || 0),
                            this._enumerate(z),
                            this._remaining === 0 && de(this.promise, this._result)))
                      : te(this.promise, He())
                }
                return (
                  (j.prototype._enumerate = function (z) {
                    for (var Z = 0; this._state === k && Z < z.length; Z++) this._eachEntry(z[Z], Z)
                  }),
                  (j.prototype._eachEntry = function (z, Z) {
                    var oe = this._instanceConstructor,
                      le = oe.resolve
                    if (le === w) {
                      var Le = void 0,
                        Et = void 0,
                        Yt = !1
                      try {
                        Le = z.then
                      } catch (br) {
                        ;(Yt = !0), (Et = br)
                      }
                      if (Le === M && z._state !== k) this._settledAt(z._state, Z, z._result)
                      else if (typeof Le != 'function') this._remaining--, (this._result[Z] = z)
                      else if (oe === Ge) {
                        var Tr = new oe(F)
                        Yt ? te(Tr, Et) : ue(Tr, z, Le), this._willSettleAt(Tr, Z)
                      } else
                        this._willSettleAt(
                          new oe(function (br) {
                            return br(z)
                          }),
                          Z
                        )
                    } else this._willSettleAt(le(z), Z)
                  }),
                  (j.prototype._settledAt = function (z, Z, oe) {
                    var le = this.promise
                    le._state === k &&
                      (this._remaining--, z === V ? te(le, oe) : (this._result[Z] = oe)),
                      this._remaining === 0 && de(le, this._result)
                  }),
                  (j.prototype._willSettleAt = function (z, Z) {
                    var oe = this
                    be(
                      z,
                      void 0,
                      function (le) {
                        return oe._settledAt(B, Z, le)
                      },
                      function (le) {
                        return oe._settledAt(V, Z, le)
                      }
                    )
                  }),
                  j
                )
              })()
              function ft(j) {
                return new Be(this, j).promise
              }
              function _t(j) {
                var Y = this
                return d(j)
                  ? new Y(function (z, Z) {
                      for (var oe = j.length, le = 0; le < oe; le++) Y.resolve(j[le]).then(z, Z)
                    })
                  : new Y(function (z, Z) {
                      return Z(new TypeError('You must pass an array to race.'))
                    })
              }
              function Sr(j) {
                var Y = this,
                  z = new Y(F)
                return te(z, j), z
              }
              function Ga() {
                throw new TypeError(
                  'You must pass a resolver function as the first argument to the promise constructor'
                )
              }
              function $a() {
                throw new TypeError(
                  "Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."
                )
              }
              var Ge = (function () {
                function j(Y) {
                  ;(this[U] = at()),
                    (this._result = this._state = void 0),
                    (this._subscribers = []),
                    F !== Y &&
                      (typeof Y != 'function' && Ga(), this instanceof j ? ke(this, Y) : $a())
                }
                return (
                  (j.prototype.catch = function (z) {
                    return this.then(null, z)
                  }),
                  (j.prototype.finally = function (z) {
                    var Z = this,
                      oe = Z.constructor
                    return c(z)
                      ? Z.then(
                          function (le) {
                            return oe.resolve(z()).then(function () {
                              return le
                            })
                          },
                          function (le) {
                            return oe.resolve(z()).then(function () {
                              throw le
                            })
                          }
                        )
                      : Z.then(z, z)
                  }),
                  j
                )
              })()
              ;(Ge.prototype.then = M),
                (Ge.all = ft),
                (Ge.race = _t),
                (Ge.resolve = w),
                (Ge.reject = Sr),
                (Ge._setScheduler = x),
                (Ge._setAsap = T),
                (Ge._asap = E)
              function Ka() {
                var j = void 0
                if (typeof l.g < 'u') j = l.g
                else if (typeof self < 'u') j = self
                else
                  try {
                    j = Function('return this')()
                  } catch {
                    throw new Error(
                      'polyfill failed because global object is unavailable in this environment'
                    )
                  }
                var Y = j.Promise
                if (Y) {
                  var z = null
                  try {
                    z = Object.prototype.toString.call(Y.resolve())
                  } catch {}
                  if (z === '[object Promise]' && !Y.cast) return
                }
                j.Promise = Ge
              }
              return (Ge.polyfill = Ka), (Ge.Promise = Ge), Ge
            })
          },
          './node_modules/events/events.js': function (a) {
            var o = typeof Reflect == 'object' ? Reflect : null,
              l =
                o && typeof o.apply == 'function'
                  ? o.apply
                  : function (I, P, D) {
                      return Function.prototype.apply.call(I, P, D)
                    },
              u
            o && typeof o.ownKeys == 'function'
              ? (u = o.ownKeys)
              : Object.getOwnPropertySymbols
              ? (u = function (I) {
                  return Object.getOwnPropertyNames(I).concat(Object.getOwnPropertySymbols(I))
                })
              : (u = function (I) {
                  return Object.getOwnPropertyNames(I)
                })
            function c(L) {
              console && console.warn && console.warn(L)
            }
            var f =
              Number.isNaN ||
              function (I) {
                return I !== I
              }
            function d() {
              d.init.call(this)
            }
            ;(a.exports = d),
              (a.exports.once = h),
              (d.EventEmitter = d),
              (d.prototype._events = void 0),
              (d.prototype._eventsCount = 0),
              (d.prototype._maxListeners = void 0)
            var m = 10
            function p(L) {
              if (typeof L != 'function')
                throw new TypeError(
                  'The "listener" argument must be of type Function. Received type ' + typeof L
                )
            }
            Object.defineProperty(d, 'defaultMaxListeners', {
              enumerable: !0,
              get: function () {
                return m
              },
              set: function (L) {
                if (typeof L != 'number' || L < 0 || f(L))
                  throw new RangeError(
                    'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                      L +
                      '.'
                  )
                m = L
              }
            }),
              (d.init = function () {
                ;(this._events === void 0 ||
                  this._events === Object.getPrototypeOf(this)._events) &&
                  ((this._events = Object.create(null)), (this._eventsCount = 0)),
                  (this._maxListeners = this._maxListeners || void 0)
              }),
              (d.prototype.setMaxListeners = function (I) {
                if (typeof I != 'number' || I < 0 || f(I))
                  throw new RangeError(
                    'The value of "n" is out of range. It must be a non-negative number. Received ' +
                      I +
                      '.'
                  )
                return (this._maxListeners = I), this
              })
            function v(L) {
              return L._maxListeners === void 0 ? d.defaultMaxListeners : L._maxListeners
            }
            ;(d.prototype.getMaxListeners = function () {
              return v(this)
            }),
              (d.prototype.emit = function (I) {
                for (var P = [], D = 1; D < arguments.length; D++) P.push(arguments[D])
                var C = I === 'error',
                  N = this._events
                if (N !== void 0) C = C && N.error === void 0
                else if (!C) return !1
                if (C) {
                  var M
                  if ((P.length > 0 && (M = P[0]), M instanceof Error)) throw M
                  var w = new Error('Unhandled error.' + (M ? ' (' + M.message + ')' : ''))
                  throw ((w.context = M), w)
                }
                var U = N[I]
                if (U === void 0) return !1
                if (typeof U == 'function') l(U, this, P)
                else for (var F = U.length, k = g(U, F), D = 0; D < F; ++D) l(k[D], this, P)
                return !0
              })
            function E(L, I, P, D) {
              var C, N, M
              if (
                (p(P),
                (N = L._events),
                N === void 0
                  ? ((N = L._events = Object.create(null)), (L._eventsCount = 0))
                  : (N.newListener !== void 0 &&
                      (L.emit('newListener', I, P.listener ? P.listener : P), (N = L._events)),
                    (M = N[I])),
                M === void 0)
              )
                (M = N[I] = P), ++L._eventsCount
              else if (
                (typeof M == 'function'
                  ? (M = N[I] = D ? [P, M] : [M, P])
                  : D
                  ? M.unshift(P)
                  : M.push(P),
                (C = v(L)),
                C > 0 && M.length > C && !M.warned)
              ) {
                M.warned = !0
                var w = new Error(
                  'Possible EventEmitter memory leak detected. ' +
                    M.length +
                    ' ' +
                    String(I) +
                    ' listeners added. Use emitter.setMaxListeners() to increase limit'
                )
                ;(w.name = 'MaxListenersExceededWarning'),
                  (w.emitter = L),
                  (w.type = I),
                  (w.count = M.length),
                  c(w)
              }
              return L
            }
            ;(d.prototype.addListener = function (I, P) {
              return E(this, I, P, !1)
            }),
              (d.prototype.on = d.prototype.addListener),
              (d.prototype.prependListener = function (I, P) {
                return E(this, I, P, !0)
              })
            function x() {
              if (!this.fired)
                return (
                  this.target.removeListener(this.type, this.wrapFn),
                  (this.fired = !0),
                  arguments.length === 0
                    ? this.listener.call(this.target)
                    : this.listener.apply(this.target, arguments)
                )
            }
            function T(L, I, P) {
              var D = { fired: !1, wrapFn: void 0, target: L, type: I, listener: P },
                C = x.bind(D)
              return (C.listener = P), (D.wrapFn = C), C
            }
            ;(d.prototype.once = function (I, P) {
              return p(P), this.on(I, T(this, I, P)), this
            }),
              (d.prototype.prependOnceListener = function (I, P) {
                return p(P), this.prependListener(I, T(this, I, P)), this
              }),
              (d.prototype.removeListener = function (I, P) {
                var D, C, N, M, w
                if ((p(P), (C = this._events), C === void 0)) return this
                if (((D = C[I]), D === void 0)) return this
                if (D === P || D.listener === P)
                  --this._eventsCount === 0
                    ? (this._events = Object.create(null))
                    : (delete C[I],
                      C.removeListener && this.emit('removeListener', I, D.listener || P))
                else if (typeof D != 'function') {
                  for (N = -1, M = D.length - 1; M >= 0; M--)
                    if (D[M] === P || D[M].listener === P) {
                      ;(w = D[M].listener), (N = M)
                      break
                    }
                  if (N < 0) return this
                  N === 0 ? D.shift() : A(D, N),
                    D.length === 1 && (C[I] = D[0]),
                    C.removeListener !== void 0 && this.emit('removeListener', I, w || P)
                }
                return this
              }),
              (d.prototype.off = d.prototype.removeListener),
              (d.prototype.removeAllListeners = function (I) {
                var P, D, C
                if (((D = this._events), D === void 0)) return this
                if (D.removeListener === void 0)
                  return (
                    arguments.length === 0
                      ? ((this._events = Object.create(null)), (this._eventsCount = 0))
                      : D[I] !== void 0 &&
                        (--this._eventsCount === 0
                          ? (this._events = Object.create(null))
                          : delete D[I]),
                    this
                  )
                if (arguments.length === 0) {
                  var N = Object.keys(D),
                    M
                  for (C = 0; C < N.length; ++C)
                    (M = N[C]), M !== 'removeListener' && this.removeAllListeners(M)
                  return (
                    this.removeAllListeners('removeListener'),
                    (this._events = Object.create(null)),
                    (this._eventsCount = 0),
                    this
                  )
                }
                if (((P = D[I]), typeof P == 'function')) this.removeListener(I, P)
                else if (P !== void 0)
                  for (C = P.length - 1; C >= 0; C--) this.removeListener(I, P[C])
                return this
              })
            function b(L, I, P) {
              var D = L._events
              if (D === void 0) return []
              var C = D[I]
              return C === void 0
                ? []
                : typeof C == 'function'
                ? P
                  ? [C.listener || C]
                  : [C]
                : P
                ? S(C)
                : g(C, C.length)
            }
            ;(d.prototype.listeners = function (I) {
              return b(this, I, !0)
            }),
              (d.prototype.rawListeners = function (I) {
                return b(this, I, !1)
              }),
              (d.listenerCount = function (L, I) {
                return typeof L.listenerCount == 'function' ? L.listenerCount(I) : R.call(L, I)
              }),
              (d.prototype.listenerCount = R)
            function R(L) {
              var I = this._events
              if (I !== void 0) {
                var P = I[L]
                if (typeof P == 'function') return 1
                if (P !== void 0) return P.length
              }
              return 0
            }
            d.prototype.eventNames = function () {
              return this._eventsCount > 0 ? u(this._events) : []
            }
            function g(L, I) {
              for (var P = new Array(I), D = 0; D < I; ++D) P[D] = L[D]
              return P
            }
            function A(L, I) {
              for (; I + 1 < L.length; I++) L[I] = L[I + 1]
              L.pop()
            }
            function S(L) {
              for (var I = new Array(L.length), P = 0; P < I.length; ++P)
                I[P] = L[P].listener || L[P]
              return I
            }
            function h(L, I) {
              return new Promise(function (P, D) {
                function C(M) {
                  L.removeListener(I, N), D(M)
                }
                function N() {
                  typeof L.removeListener == 'function' && L.removeListener('error', C),
                    P([].slice.call(arguments))
                }
                y(L, I, N, { once: !0 }), I !== 'error' && _(L, C, { once: !0 })
              })
            }
            function _(L, I, P) {
              typeof L.on == 'function' && y(L, 'error', I, P)
            }
            function y(L, I, P, D) {
              if (typeof L.on == 'function') D.once ? L.once(I, P) : L.on(I, P)
              else if (typeof L.addEventListener == 'function')
                L.addEventListener(I, function C(N) {
                  D.once && L.removeEventListener(I, C), P(N)
                })
              else
                throw new TypeError(
                  'The "emitter" argument must be of type EventEmitter. Received type ' + typeof L
                )
            }
          },
          './node_modules/webworkify-webpack/index.js': function (a, o, l) {
            function u(x) {
              var T = {}
              function b(g) {
                if (T[g]) return T[g].exports
                var A = (T[g] = { i: g, l: !1, exports: {} })
                return x[g].call(A.exports, A, A.exports, b), (A.l = !0), A.exports
              }
              ;(b.m = x),
                (b.c = T),
                (b.i = function (g) {
                  return g
                }),
                (b.d = function (g, A, S) {
                  b.o(g, A) ||
                    Object.defineProperty(g, A, { configurable: !1, enumerable: !0, get: S })
                }),
                (b.r = function (g) {
                  Object.defineProperty(g, '__esModule', { value: !0 })
                }),
                (b.n = function (g) {
                  var A =
                    g && g.__esModule
                      ? function () {
                          return g.default
                        }
                      : function () {
                          return g
                        }
                  return b.d(A, 'a', A), A
                }),
                (b.o = function (g, A) {
                  return Object.prototype.hasOwnProperty.call(g, A)
                }),
                (b.p = '/'),
                (b.oe = function (g) {
                  throw (console.error(g), g)
                })
              var R = b((b.s = ENTRY_MODULE))
              return R.default || R
            }
            var c = '[\\.|\\-|\\+|\\w|/|@]+',
              f = '\\(\\s*(/\\*.*?\\*/)?\\s*.*?(' + c + ').*?\\)'
            function d(x) {
              return (x + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
            }
            function m(x) {
              return !isNaN(1 * x)
            }
            function p(x, T, b) {
              var R = {}
              R[b] = []
              var g = T.toString(),
                A = g.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/)
              if (!A) return R
              for (
                var S = A[1], h = new RegExp('(\\\\n|\\W)' + d(S) + f, 'g'), _;
                (_ = h.exec(g));

              )
                _[3] !== 'dll-reference' && R[b].push(_[3])
              for (
                h = new RegExp('\\(' + d(S) + '\\("(dll-reference\\s(' + c + '))"\\)\\)' + f, 'g');
                (_ = h.exec(g));

              )
                x[_[2]] || (R[b].push(_[1]), (x[_[2]] = l(_[1]).m)),
                  (R[_[2]] = R[_[2]] || []),
                  R[_[2]].push(_[4])
              for (var y = Object.keys(R), L = 0; L < y.length; L++)
                for (var I = 0; I < R[y[L]].length; I++)
                  m(R[y[L]][I]) && (R[y[L]][I] = 1 * R[y[L]][I])
              return R
            }
            function v(x) {
              var T = Object.keys(x)
              return T.reduce(function (b, R) {
                return b || x[R].length > 0
              }, !1)
            }
            function E(x, T) {
              for (var b = { main: [T] }, R = { main: [] }, g = { main: {} }; v(b); )
                for (var A = Object.keys(b), S = 0; S < A.length; S++) {
                  var h = A[S],
                    _ = b[h],
                    y = _.pop()
                  if (((g[h] = g[h] || {}), !(g[h][y] || !x[h][y]))) {
                    ;(g[h][y] = !0), (R[h] = R[h] || []), R[h].push(y)
                    for (var L = p(x, x[h][y], h), I = Object.keys(L), P = 0; P < I.length; P++)
                      (b[I[P]] = b[I[P]] || []), (b[I[P]] = b[I[P]].concat(L[I[P]]))
                  }
                }
              return R
            }
            a.exports = function (x, T) {
              T = T || {}
              var b = { main: l.m },
                R = T.all ? { main: Object.keys(b.main) } : E(b, x),
                g = ''
              Object.keys(R)
                .filter(function (y) {
                  return y !== 'main'
                })
                .forEach(function (y) {
                  for (var L = 0; R[y][L]; ) L++
                  R[y].push(L),
                    (b[y][L] =
                      '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'),
                    (g =
                      g +
                      'var ' +
                      y +
                      ' = (' +
                      u.toString().replace('ENTRY_MODULE', JSON.stringify(L)) +
                      ')({' +
                      R[y]
                        .map(function (I) {
                          return '' + JSON.stringify(I) + ': ' + b[y][I].toString()
                        })
                        .join(',') +
                      `});
`)
                }),
                (g =
                  g +
                  'new ((' +
                  u.toString().replace('ENTRY_MODULE', JSON.stringify(x)) +
                  ')({' +
                  R.main
                    .map(function (y) {
                      return '' + JSON.stringify(y) + ': ' + b.main[y].toString()
                    })
                    .join(',') +
                  '}))(self);')
              var A = new window.Blob([g], { type: 'text/javascript' })
              if (T.bare) return A
              var S = window.URL || window.webkitURL || window.mozURL || window.msURL,
                h = S.createObjectURL(A),
                _ = new window.Worker(h)
              return (_.objectURL = h), _
            }
          },
          './src/config.js': function (a, o, l) {
            l.r(o),
              l.d(o, {
                defaultConfig: function () {
                  return u
                },
                createDefaultConfig: function () {
                  return c
                }
              })
            var u = {
              enableWorker: !1,
              enableStashBuffer: !0,
              stashInitialSize: void 0,
              isLive: !1,
              lazyLoad: !0,
              lazyLoadMaxDuration: 3 * 60,
              lazyLoadRecoverDuration: 30,
              deferLoadAfterSourceOpen: !0,
              autoCleanupMaxBackwardDuration: 3 * 60,
              autoCleanupMinBackwardDuration: 2 * 60,
              statisticsInfoReportInterval: 600,
              fixAudioTimestampGap: !0,
              accurateSeek: !1,
              seekType: 'range',
              seekParamStart: 'bstart',
              seekParamEnd: 'bend',
              rangeLoadZeroStart: !1,
              customSeekHandler: void 0,
              reuseRedirectedURL: !1,
              headers: void 0,
              customLoader: void 0
            }
            function c() {
              return Object.assign({}, u)
            }
          },
          './src/core/features.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/io/io-controller.js'),
              c = l('./src/config.js'),
              f = (function () {
                function d() {}
                return (
                  (d.supportMSEH264Playback = function () {
                    return (
                      window.MediaSource &&
                      window.MediaSource.isTypeSupported(
                        'video/mp4; codecs="avc1.42E01E,mp4a.40.2"'
                      )
                    )
                  }),
                  (d.supportNetworkStreamIO = function () {
                    var m = new u.default({}, (0, c.createDefaultConfig)()),
                      p = m.loaderType
                    return m.destroy(), p == 'fetch-stream-loader' || p == 'xhr-moz-chunked-loader'
                  }),
                  (d.getNetworkLoaderTypeName = function () {
                    var m = new u.default({}, (0, c.createDefaultConfig)()),
                      p = m.loaderType
                    return m.destroy(), p
                  }),
                  (d.supportNativeMediaPlayback = function (m) {
                    d.videoElement == null &&
                      (d.videoElement = window.document.createElement('video'))
                    var p = d.videoElement.canPlayType(m)
                    return p === 'probably' || p == 'maybe'
                  }),
                  (d.getFeatureList = function () {
                    var m = {
                      mseFlvPlayback: !1,
                      mseLiveFlvPlayback: !1,
                      networkStreamIO: !1,
                      networkLoaderName: '',
                      nativeMP4H264Playback: !1,
                      nativeWebmVP8Playback: !1,
                      nativeWebmVP9Playback: !1
                    }
                    return (
                      (m.mseFlvPlayback = d.supportMSEH264Playback()),
                      (m.networkStreamIO = d.supportNetworkStreamIO()),
                      (m.networkLoaderName = d.getNetworkLoaderTypeName()),
                      (m.mseLiveFlvPlayback = m.mseFlvPlayback && m.networkStreamIO),
                      (m.nativeMP4H264Playback = d.supportNativeMediaPlayback(
                        'video/mp4; codecs="avc1.42001E, mp4a.40.2"'
                      )),
                      (m.nativeWebmVP8Playback = d.supportNativeMediaPlayback(
                        'video/webm; codecs="vp8.0, vorbis"'
                      )),
                      (m.nativeWebmVP9Playback = d.supportNativeMediaPlayback(
                        'video/webm; codecs="vp9"'
                      )),
                      m
                    )
                  }),
                  d
                )
              })()
            o.default = f
          },
          './src/core/media-info.js': function (a, o, l) {
            l.r(o)
            var u = (function () {
              function c() {
                ;(this.mimeType = null),
                  (this.duration = null),
                  (this.hasAudio = null),
                  (this.hasVideo = null),
                  (this.audioCodec = null),
                  (this.videoCodec = null),
                  (this.audioDataRate = null),
                  (this.videoDataRate = null),
                  (this.audioSampleRate = null),
                  (this.audioChannelCount = null),
                  (this.width = null),
                  (this.height = null),
                  (this.fps = null),
                  (this.profile = null),
                  (this.level = null),
                  (this.refFrames = null),
                  (this.chromaFormat = null),
                  (this.sarNum = null),
                  (this.sarDen = null),
                  (this.metadata = null),
                  (this.segments = null),
                  (this.segmentCount = null),
                  (this.hasKeyframesIndex = null),
                  (this.keyframesIndex = null)
              }
              return (
                (c.prototype.isComplete = function () {
                  var f =
                      this.hasAudio === !1 ||
                      (this.hasAudio === !0 &&
                        this.audioCodec != null &&
                        this.audioSampleRate != null &&
                        this.audioChannelCount != null),
                    d =
                      this.hasVideo === !1 ||
                      (this.hasVideo === !0 &&
                        this.videoCodec != null &&
                        this.width != null &&
                        this.height != null &&
                        this.fps != null &&
                        this.profile != null &&
                        this.level != null &&
                        this.refFrames != null &&
                        this.chromaFormat != null &&
                        this.sarNum != null &&
                        this.sarDen != null)
                  return (
                    this.mimeType != null &&
                    this.duration != null &&
                    this.metadata != null &&
                    this.hasKeyframesIndex != null &&
                    f &&
                    d
                  )
                }),
                (c.prototype.isSeekable = function () {
                  return this.hasKeyframesIndex === !0
                }),
                (c.prototype.getNearestKeyframe = function (f) {
                  if (this.keyframesIndex == null) return null
                  var d = this.keyframesIndex,
                    m = this._search(d.times, f)
                  return { index: m, milliseconds: d.times[m], fileposition: d.filepositions[m] }
                }),
                (c.prototype._search = function (f, d) {
                  var m = 0,
                    p = f.length - 1,
                    v = 0,
                    E = 0,
                    x = p
                  for (d < f[0] && ((m = 0), (E = x + 1)); E <= x; )
                    if (
                      ((v = E + Math.floor((x - E) / 2)), v === p || (d >= f[v] && d < f[v + 1]))
                    ) {
                      m = v
                      break
                    } else f[v] < d ? (E = v + 1) : (x = v - 1)
                  return m
                }),
                c
              )
            })()
            o.default = u
          },
          './src/core/media-segment-info.js': function (a, o, l) {
            l.r(o),
              l.d(o, {
                SampleInfo: function () {
                  return u
                },
                MediaSegmentInfo: function () {
                  return c
                },
                IDRSampleList: function () {
                  return f
                },
                MediaSegmentInfoList: function () {
                  return d
                }
              })
            var u = (function () {
                function m(p, v, E, x, T) {
                  ;(this.dts = p),
                    (this.pts = v),
                    (this.duration = E),
                    (this.originalDts = x),
                    (this.isSyncPoint = T),
                    (this.fileposition = null)
                }
                return m
              })(),
              c = (function () {
                function m() {
                  ;(this.beginDts = 0),
                    (this.endDts = 0),
                    (this.beginPts = 0),
                    (this.endPts = 0),
                    (this.originalBeginDts = 0),
                    (this.originalEndDts = 0),
                    (this.syncPoints = []),
                    (this.firstSample = null),
                    (this.lastSample = null)
                }
                return (
                  (m.prototype.appendSyncPoint = function (p) {
                    ;(p.isSyncPoint = !0), this.syncPoints.push(p)
                  }),
                  m
                )
              })(),
              f = (function () {
                function m() {
                  this._list = []
                }
                return (
                  (m.prototype.clear = function () {
                    this._list = []
                  }),
                  (m.prototype.appendArray = function (p) {
                    var v = this._list
                    p.length !== 0 &&
                      (v.length > 0 &&
                        p[0].originalDts < v[v.length - 1].originalDts &&
                        this.clear(),
                      Array.prototype.push.apply(v, p))
                  }),
                  (m.prototype.getLastSyncPointBeforeDts = function (p) {
                    if (this._list.length == 0) return null
                    var v = this._list,
                      E = 0,
                      x = v.length - 1,
                      T = 0,
                      b = 0,
                      R = x
                    for (p < v[0].dts && ((E = 0), (b = R + 1)); b <= R; )
                      if (
                        ((T = b + Math.floor((R - b) / 2)),
                        T === x || (p >= v[T].dts && p < v[T + 1].dts))
                      ) {
                        E = T
                        break
                      } else v[T].dts < p ? (b = T + 1) : (R = T - 1)
                    return this._list[E]
                  }),
                  m
                )
              })(),
              d = (function () {
                function m(p) {
                  ;(this._type = p), (this._list = []), (this._lastAppendLocation = -1)
                }
                return (
                  Object.defineProperty(m.prototype, 'type', {
                    get: function () {
                      return this._type
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m.prototype, 'length', {
                    get: function () {
                      return this._list.length
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  (m.prototype.isEmpty = function () {
                    return this._list.length === 0
                  }),
                  (m.prototype.clear = function () {
                    ;(this._list = []), (this._lastAppendLocation = -1)
                  }),
                  (m.prototype._searchNearestSegmentBefore = function (p) {
                    var v = this._list
                    if (v.length === 0) return -2
                    var E = v.length - 1,
                      x = 0,
                      T = 0,
                      b = E,
                      R = 0
                    if (p < v[0].originalBeginDts) return (R = -1), R
                    for (; T <= b; )
                      if (
                        ((x = T + Math.floor((b - T) / 2)),
                        x === E ||
                          (p > v[x].lastSample.originalDts && p < v[x + 1].originalBeginDts))
                      ) {
                        R = x
                        break
                      } else v[x].originalBeginDts < p ? (T = x + 1) : (b = x - 1)
                    return R
                  }),
                  (m.prototype._searchNearestSegmentAfter = function (p) {
                    return this._searchNearestSegmentBefore(p) + 1
                  }),
                  (m.prototype.append = function (p) {
                    var v = this._list,
                      E = p,
                      x = this._lastAppendLocation,
                      T = 0
                    x !== -1 &&
                    x < v.length &&
                    E.originalBeginDts >= v[x].lastSample.originalDts &&
                    (x === v.length - 1 ||
                      (x < v.length - 1 && E.originalBeginDts < v[x + 1].originalBeginDts))
                      ? (T = x + 1)
                      : v.length > 0 &&
                        (T = this._searchNearestSegmentBefore(E.originalBeginDts) + 1),
                      (this._lastAppendLocation = T),
                      this._list.splice(T, 0, E)
                  }),
                  (m.prototype.getLastSegmentBefore = function (p) {
                    var v = this._searchNearestSegmentBefore(p)
                    return v >= 0 ? this._list[v] : null
                  }),
                  (m.prototype.getLastSampleBefore = function (p) {
                    var v = this.getLastSegmentBefore(p)
                    return v != null ? v.lastSample : null
                  }),
                  (m.prototype.getLastSyncPointBefore = function (p) {
                    for (
                      var v = this._searchNearestSegmentBefore(p), E = this._list[v].syncPoints;
                      E.length === 0 && v > 0;

                    )
                      v--, (E = this._list[v].syncPoints)
                    return E.length > 0 ? E[E.length - 1] : null
                  }),
                  m
                )
              })()
          },
          './src/core/mse-controller.js': function (a, o, l) {
            l.r(o)
            var u = l('./node_modules/events/events.js'),
              c = l.n(u),
              f = l('./src/utils/logger.js'),
              d = l('./src/utils/browser.js'),
              m = l('./src/core/mse-events.js'),
              p = l('./src/core/media-segment-info.js'),
              v = l('./src/utils/exception.js'),
              E = (function () {
                function x(T) {
                  ;(this.TAG = 'MSEController'),
                    (this._config = T),
                    (this._emitter = new (c())()),
                    this._config.isLive &&
                      this._config.autoCleanupSourceBuffer == null &&
                      (this._config.autoCleanupSourceBuffer = !0),
                    (this.e = {
                      onSourceOpen: this._onSourceOpen.bind(this),
                      onSourceEnded: this._onSourceEnded.bind(this),
                      onSourceClose: this._onSourceClose.bind(this),
                      onSourceBufferError: this._onSourceBufferError.bind(this),
                      onSourceBufferUpdateEnd: this._onSourceBufferUpdateEnd.bind(this)
                    }),
                    (this._mediaSource = null),
                    (this._mediaSourceObjectURL = null),
                    (this._mediaElement = null),
                    (this._isBufferFull = !1),
                    (this._hasPendingEos = !1),
                    (this._requireSetMediaDuration = !1),
                    (this._pendingMediaDuration = 0),
                    (this._pendingSourceBufferInit = []),
                    (this._mimeTypes = { video: null, audio: null }),
                    (this._sourceBuffers = { video: null, audio: null }),
                    (this._lastInitSegments = { video: null, audio: null }),
                    (this._pendingSegments = { video: [], audio: [] }),
                    (this._pendingRemoveRanges = { video: [], audio: [] }),
                    (this._idrList = new p.IDRSampleList())
                }
                return (
                  (x.prototype.destroy = function () {
                    ;(this._mediaElement || this._mediaSource) && this.detachMediaElement(),
                      (this.e = null),
                      this._emitter.removeAllListeners(),
                      (this._emitter = null)
                  }),
                  (x.prototype.on = function (T, b) {
                    this._emitter.addListener(T, b)
                  }),
                  (x.prototype.off = function (T, b) {
                    this._emitter.removeListener(T, b)
                  }),
                  (x.prototype.attachMediaElement = function (T) {
                    if (this._mediaSource)
                      throw new v.IllegalStateException(
                        'MediaSource has been attached to an HTMLMediaElement!'
                      )
                    var b = (this._mediaSource = new window.MediaSource())
                    b.addEventListener('sourceopen', this.e.onSourceOpen),
                      b.addEventListener('sourceended', this.e.onSourceEnded),
                      b.addEventListener('sourceclose', this.e.onSourceClose),
                      (this._mediaElement = T),
                      (this._mediaSourceObjectURL = window.URL.createObjectURL(this._mediaSource)),
                      (T.src = this._mediaSourceObjectURL)
                  }),
                  (x.prototype.detachMediaElement = function () {
                    if (this._mediaSource) {
                      var T = this._mediaSource
                      for (var b in this._sourceBuffers) {
                        var R = this._pendingSegments[b]
                        R.splice(0, R.length),
                          (this._pendingSegments[b] = null),
                          (this._pendingRemoveRanges[b] = null),
                          (this._lastInitSegments[b] = null)
                        var g = this._sourceBuffers[b]
                        if (g) {
                          if (T.readyState !== 'closed') {
                            try {
                              T.removeSourceBuffer(g)
                            } catch (A) {
                              f.default.e(this.TAG, A.message)
                            }
                            g.removeEventListener('error', this.e.onSourceBufferError),
                              g.removeEventListener('updateend', this.e.onSourceBufferUpdateEnd)
                          }
                          ;(this._mimeTypes[b] = null), (this._sourceBuffers[b] = null)
                        }
                      }
                      if (T.readyState === 'open')
                        try {
                          T.endOfStream()
                        } catch (A) {
                          f.default.e(this.TAG, A.message)
                        }
                      T.removeEventListener('sourceopen', this.e.onSourceOpen),
                        T.removeEventListener('sourceended', this.e.onSourceEnded),
                        T.removeEventListener('sourceclose', this.e.onSourceClose),
                        (this._pendingSourceBufferInit = []),
                        (this._isBufferFull = !1),
                        this._idrList.clear(),
                        (this._mediaSource = null)
                    }
                    this._mediaElement &&
                      ((this._mediaElement.src = ''),
                      this._mediaElement.removeAttribute('src'),
                      (this._mediaElement = null)),
                      this._mediaSourceObjectURL &&
                        (window.URL.revokeObjectURL(this._mediaSourceObjectURL),
                        (this._mediaSourceObjectURL = null))
                  }),
                  (x.prototype.appendInitSegment = function (T, b) {
                    if (!this._mediaSource || this._mediaSource.readyState !== 'open') {
                      this._pendingSourceBufferInit.push(T), this._pendingSegments[T.type].push(T)
                      return
                    }
                    var R = T,
                      g = '' + R.container
                    R.codec && R.codec.length > 0 && (g += ';codecs=' + R.codec)
                    var A = !1
                    if (
                      (f.default.v(this.TAG, 'Received Initialization Segment, mimeType: ' + g),
                      (this._lastInitSegments[R.type] = R),
                      g !== this._mimeTypes[R.type])
                    ) {
                      if (this._mimeTypes[R.type])
                        f.default.v(
                          this.TAG,
                          'Notice: ' +
                            R.type +
                            ' mimeType changed, origin: ' +
                            this._mimeTypes[R.type] +
                            ', target: ' +
                            g
                        )
                      else {
                        A = !0
                        try {
                          var S = (this._sourceBuffers[R.type] =
                            this._mediaSource.addSourceBuffer(g))
                          S.addEventListener('error', this.e.onSourceBufferError),
                            S.addEventListener('updateend', this.e.onSourceBufferUpdateEnd)
                        } catch (h) {
                          f.default.e(this.TAG, h.message),
                            this._emitter.emit(m.default.ERROR, { code: h.code, msg: h.message })
                          return
                        }
                      }
                      this._mimeTypes[R.type] = g
                    }
                    b || this._pendingSegments[R.type].push(R),
                      A ||
                        (this._sourceBuffers[R.type] &&
                          !this._sourceBuffers[R.type].updating &&
                          this._doAppendSegments()),
                      d.default.safari &&
                        R.container === 'audio/mpeg' &&
                        R.mediaDuration > 0 &&
                        ((this._requireSetMediaDuration = !0),
                        (this._pendingMediaDuration = R.mediaDuration / 1e3),
                        this._updateMediaSourceDuration())
                  }),
                  (x.prototype.appendMediaSegment = function (T) {
                    var b = T
                    this._pendingSegments[b.type].push(b),
                      this._config.autoCleanupSourceBuffer &&
                        this._needCleanupSourceBuffer() &&
                        this._doCleanupSourceBuffer()
                    var R = this._sourceBuffers[b.type]
                    R && !R.updating && !this._hasPendingRemoveRanges() && this._doAppendSegments()
                  }),
                  (x.prototype.seek = function (T) {
                    for (var b in this._sourceBuffers)
                      if (this._sourceBuffers[b]) {
                        var R = this._sourceBuffers[b]
                        if (this._mediaSource.readyState === 'open')
                          try {
                            R.abort()
                          } catch (y) {
                            f.default.e(this.TAG, y.message)
                          }
                        this._idrList.clear()
                        var g = this._pendingSegments[b]
                        if ((g.splice(0, g.length), this._mediaSource.readyState !== 'closed')) {
                          for (var A = 0; A < R.buffered.length; A++) {
                            var S = R.buffered.start(A),
                              h = R.buffered.end(A)
                            this._pendingRemoveRanges[b].push({ start: S, end: h })
                          }
                          if ((R.updating || this._doRemoveRanges(), d.default.safari)) {
                            var _ = this._lastInitSegments[b]
                            _ &&
                              (this._pendingSegments[b].push(_),
                              R.updating || this._doAppendSegments())
                          }
                        }
                      }
                  }),
                  (x.prototype.endOfStream = function () {
                    var T = this._mediaSource,
                      b = this._sourceBuffers
                    if (!T || T.readyState !== 'open') {
                      T &&
                        T.readyState === 'closed' &&
                        this._hasPendingSegments() &&
                        (this._hasPendingEos = !0)
                      return
                    }
                    ;(b.video && b.video.updating) || (b.audio && b.audio.updating)
                      ? (this._hasPendingEos = !0)
                      : ((this._hasPendingEos = !1), T.endOfStream())
                  }),
                  (x.prototype.getNearestKeyframe = function (T) {
                    return this._idrList.getLastSyncPointBeforeDts(T)
                  }),
                  (x.prototype._needCleanupSourceBuffer = function () {
                    if (!this._config.autoCleanupSourceBuffer) return !1
                    var T = this._mediaElement.currentTime
                    for (var b in this._sourceBuffers) {
                      var R = this._sourceBuffers[b]
                      if (R) {
                        var g = R.buffered
                        if (
                          g.length >= 1 &&
                          T - g.start(0) >= this._config.autoCleanupMaxBackwardDuration
                        )
                          return !0
                      }
                    }
                    return !1
                  }),
                  (x.prototype._doCleanupSourceBuffer = function () {
                    var T = this._mediaElement.currentTime
                    for (var b in this._sourceBuffers) {
                      var R = this._sourceBuffers[b]
                      if (R) {
                        for (var g = R.buffered, A = !1, S = 0; S < g.length; S++) {
                          var h = g.start(S),
                            _ = g.end(S)
                          if (h <= T && T < _ + 3) {
                            if (T - h >= this._config.autoCleanupMaxBackwardDuration) {
                              A = !0
                              var y = T - this._config.autoCleanupMinBackwardDuration
                              this._pendingRemoveRanges[b].push({ start: h, end: y })
                            }
                          } else
                            _ < T &&
                              ((A = !0), this._pendingRemoveRanges[b].push({ start: h, end: _ }))
                        }
                        A && !R.updating && this._doRemoveRanges()
                      }
                    }
                  }),
                  (x.prototype._updateMediaSourceDuration = function () {
                    var T = this._sourceBuffers
                    if (
                      !(
                        this._mediaElement.readyState === 0 ||
                        this._mediaSource.readyState !== 'open'
                      ) &&
                      !((T.video && T.video.updating) || (T.audio && T.audio.updating))
                    ) {
                      var b = this._mediaSource.duration,
                        R = this._pendingMediaDuration
                      R > 0 &&
                        (isNaN(b) || R > b) &&
                        (f.default.v(
                          this.TAG,
                          'Update MediaSource duration from ' + b + ' to ' + R
                        ),
                        (this._mediaSource.duration = R)),
                        (this._requireSetMediaDuration = !1),
                        (this._pendingMediaDuration = 0)
                    }
                  }),
                  (x.prototype._doRemoveRanges = function () {
                    for (var T in this._pendingRemoveRanges)
                      if (!(!this._sourceBuffers[T] || this._sourceBuffers[T].updating))
                        for (
                          var b = this._sourceBuffers[T], R = this._pendingRemoveRanges[T];
                          R.length && !b.updating;

                        ) {
                          var g = R.shift()
                          b.remove(g.start, g.end)
                        }
                  }),
                  (x.prototype._doAppendSegments = function () {
                    var T = this._pendingSegments
                    for (var b in T)
                      if (
                        !(!this._sourceBuffers[b] || this._sourceBuffers[b].updating) &&
                        T[b].length > 0
                      ) {
                        var R = T[b].shift()
                        if (R.timestampOffset) {
                          var g = this._sourceBuffers[b].timestampOffset,
                            A = R.timestampOffset / 1e3,
                            S = Math.abs(g - A)
                          S > 0.1 &&
                            (f.default.v(
                              this.TAG,
                              'Update MPEG audio timestampOffset from ' + g + ' to ' + A
                            ),
                            (this._sourceBuffers[b].timestampOffset = A)),
                            delete R.timestampOffset
                        }
                        if (!R.data || R.data.byteLength === 0) continue
                        try {
                          this._sourceBuffers[b].appendBuffer(R.data),
                            (this._isBufferFull = !1),
                            b === 'video' &&
                              R.hasOwnProperty('info') &&
                              this._idrList.appendArray(R.info.syncPoints)
                        } catch (h) {
                          this._pendingSegments[b].unshift(R),
                            h.code === 22
                              ? (this._isBufferFull || this._emitter.emit(m.default.BUFFER_FULL),
                                (this._isBufferFull = !0))
                              : (f.default.e(this.TAG, h.message),
                                this._emitter.emit(m.default.ERROR, {
                                  code: h.code,
                                  msg: h.message
                                }))
                        }
                      }
                  }),
                  (x.prototype._onSourceOpen = function () {
                    if (
                      (f.default.v(this.TAG, 'MediaSource onSourceOpen'),
                      this._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen),
                      this._pendingSourceBufferInit.length > 0)
                    )
                      for (var T = this._pendingSourceBufferInit; T.length; ) {
                        var b = T.shift()
                        this.appendInitSegment(b, !0)
                      }
                    this._hasPendingSegments() && this._doAppendSegments(),
                      this._emitter.emit(m.default.SOURCE_OPEN)
                  }),
                  (x.prototype._onSourceEnded = function () {
                    f.default.v(this.TAG, 'MediaSource onSourceEnded')
                  }),
                  (x.prototype._onSourceClose = function () {
                    f.default.v(this.TAG, 'MediaSource onSourceClose'),
                      this._mediaSource &&
                        this.e != null &&
                        (this._mediaSource.removeEventListener('sourceopen', this.e.onSourceOpen),
                        this._mediaSource.removeEventListener('sourceended', this.e.onSourceEnded),
                        this._mediaSource.removeEventListener('sourceclose', this.e.onSourceClose))
                  }),
                  (x.prototype._hasPendingSegments = function () {
                    var T = this._pendingSegments
                    return T.video.length > 0 || T.audio.length > 0
                  }),
                  (x.prototype._hasPendingRemoveRanges = function () {
                    var T = this._pendingRemoveRanges
                    return T.video.length > 0 || T.audio.length > 0
                  }),
                  (x.prototype._onSourceBufferUpdateEnd = function () {
                    this._requireSetMediaDuration
                      ? this._updateMediaSourceDuration()
                      : this._hasPendingRemoveRanges()
                      ? this._doRemoveRanges()
                      : this._hasPendingSegments()
                      ? this._doAppendSegments()
                      : this._hasPendingEos && this.endOfStream(),
                      this._emitter.emit(m.default.UPDATE_END)
                  }),
                  (x.prototype._onSourceBufferError = function (T) {
                    f.default.e(this.TAG, 'SourceBuffer Error: ' + T)
                  }),
                  x
                )
              })()
            o.default = E
          },
          './src/core/mse-events.js': function (a, o, l) {
            l.r(o)
            var u = {
              ERROR: 'error',
              SOURCE_OPEN: 'source_open',
              UPDATE_END: 'update_end',
              BUFFER_FULL: 'buffer_full'
            }
            o.default = u
          },
          './src/core/transmuxer.js': function (a, o, l) {
            l.r(o)
            var u = l('./node_modules/events/events.js'),
              c = l.n(u),
              f = l('./node_modules/webworkify-webpack/index.js'),
              d = l.n(f),
              m = l('./src/utils/logger.js'),
              p = l('./src/utils/logging-control.js'),
              v = l('./src/core/transmuxing-controller.js'),
              E = l('./src/core/transmuxing-events.js'),
              x = l('./src/core/media-info.js'),
              T = (function () {
                function b(R, g) {
                  if (
                    ((this.TAG = 'Transmuxer'),
                    (this._emitter = new (c())()),
                    g.enableWorker && typeof Worker < 'u')
                  )
                    try {
                      ;(this._worker = d()('./src/core/transmuxing-worker.js')),
                        (this._workerDestroying = !1),
                        this._worker.addEventListener('message', this._onWorkerMessage.bind(this)),
                        this._worker.postMessage({ cmd: 'init', param: [R, g] }),
                        (this.e = {
                          onLoggingConfigChanged: this._onLoggingConfigChanged.bind(this)
                        }),
                        p.default.registerListener(this.e.onLoggingConfigChanged),
                        this._worker.postMessage({
                          cmd: 'logging_config',
                          param: p.default.getConfig()
                        })
                    } catch {
                      m.default.e(
                        this.TAG,
                        'Error while initialize transmuxing worker, fallback to inline transmuxing'
                      ),
                        (this._worker = null),
                        (this._controller = new v.default(R, g))
                    }
                  else this._controller = new v.default(R, g)
                  if (this._controller) {
                    var A = this._controller
                    A.on(E.default.IO_ERROR, this._onIOError.bind(this)),
                      A.on(E.default.DEMUX_ERROR, this._onDemuxError.bind(this)),
                      A.on(E.default.INIT_SEGMENT, this._onInitSegment.bind(this)),
                      A.on(E.default.MEDIA_SEGMENT, this._onMediaSegment.bind(this)),
                      A.on(E.default.LOADING_COMPLETE, this._onLoadingComplete.bind(this)),
                      A.on(E.default.RECOVERED_EARLY_EOF, this._onRecoveredEarlyEof.bind(this)),
                      A.on(E.default.MEDIA_INFO, this._onMediaInfo.bind(this)),
                      A.on(E.default.METADATA_ARRIVED, this._onMetaDataArrived.bind(this)),
                      A.on(E.default.SCRIPTDATA_ARRIVED, this._onScriptDataArrived.bind(this)),
                      A.on(E.default.STATISTICS_INFO, this._onStatisticsInfo.bind(this)),
                      A.on(E.default.RECOMMEND_SEEKPOINT, this._onRecommendSeekpoint.bind(this))
                  }
                }
                return (
                  (b.prototype.destroy = function () {
                    this._worker
                      ? this._workerDestroying ||
                        ((this._workerDestroying = !0),
                        this._worker.postMessage({ cmd: 'destroy' }),
                        p.default.removeListener(this.e.onLoggingConfigChanged),
                        (this.e = null))
                      : (this._controller.destroy(), (this._controller = null)),
                      this._emitter.removeAllListeners(),
                      (this._emitter = null)
                  }),
                  (b.prototype.on = function (R, g) {
                    this._emitter.addListener(R, g)
                  }),
                  (b.prototype.off = function (R, g) {
                    this._emitter.removeListener(R, g)
                  }),
                  (b.prototype.hasWorker = function () {
                    return this._worker != null
                  }),
                  (b.prototype.open = function () {
                    this._worker
                      ? this._worker.postMessage({ cmd: 'start' })
                      : this._controller.start()
                  }),
                  (b.prototype.close = function () {
                    this._worker
                      ? this._worker.postMessage({ cmd: 'stop' })
                      : this._controller.stop()
                  }),
                  (b.prototype.seek = function (R) {
                    this._worker
                      ? this._worker.postMessage({ cmd: 'seek', param: R })
                      : this._controller.seek(R)
                  }),
                  (b.prototype.pause = function () {
                    this._worker
                      ? this._worker.postMessage({ cmd: 'pause' })
                      : this._controller.pause()
                  }),
                  (b.prototype.resume = function () {
                    this._worker
                      ? this._worker.postMessage({ cmd: 'resume' })
                      : this._controller.resume()
                  }),
                  (b.prototype._onInitSegment = function (R, g) {
                    var A = this
                    Promise.resolve().then(function () {
                      A._emitter.emit(E.default.INIT_SEGMENT, R, g)
                    })
                  }),
                  (b.prototype._onMediaSegment = function (R, g) {
                    var A = this
                    Promise.resolve().then(function () {
                      A._emitter.emit(E.default.MEDIA_SEGMENT, R, g)
                    })
                  }),
                  (b.prototype._onLoadingComplete = function () {
                    var R = this
                    Promise.resolve().then(function () {
                      R._emitter.emit(E.default.LOADING_COMPLETE)
                    })
                  }),
                  (b.prototype._onRecoveredEarlyEof = function () {
                    var R = this
                    Promise.resolve().then(function () {
                      R._emitter.emit(E.default.RECOVERED_EARLY_EOF)
                    })
                  }),
                  (b.prototype._onMediaInfo = function (R) {
                    var g = this
                    Promise.resolve().then(function () {
                      g._emitter.emit(E.default.MEDIA_INFO, R)
                    })
                  }),
                  (b.prototype._onMetaDataArrived = function (R) {
                    var g = this
                    Promise.resolve().then(function () {
                      g._emitter.emit(E.default.METADATA_ARRIVED, R)
                    })
                  }),
                  (b.prototype._onScriptDataArrived = function (R) {
                    var g = this
                    Promise.resolve().then(function () {
                      g._emitter.emit(E.default.SCRIPTDATA_ARRIVED, R)
                    })
                  }),
                  (b.prototype._onStatisticsInfo = function (R) {
                    var g = this
                    Promise.resolve().then(function () {
                      g._emitter.emit(E.default.STATISTICS_INFO, R)
                    })
                  }),
                  (b.prototype._onIOError = function (R, g) {
                    var A = this
                    Promise.resolve().then(function () {
                      A._emitter.emit(E.default.IO_ERROR, R, g)
                    })
                  }),
                  (b.prototype._onDemuxError = function (R, g) {
                    var A = this
                    Promise.resolve().then(function () {
                      A._emitter.emit(E.default.DEMUX_ERROR, R, g)
                    })
                  }),
                  (b.prototype._onRecommendSeekpoint = function (R) {
                    var g = this
                    Promise.resolve().then(function () {
                      g._emitter.emit(E.default.RECOMMEND_SEEKPOINT, R)
                    })
                  }),
                  (b.prototype._onLoggingConfigChanged = function (R) {
                    this._worker && this._worker.postMessage({ cmd: 'logging_config', param: R })
                  }),
                  (b.prototype._onWorkerMessage = function (R) {
                    var g = R.data,
                      A = g.data
                    if (g.msg === 'destroyed' || this._workerDestroying) {
                      ;(this._workerDestroying = !1),
                        this._worker.terminate(),
                        (this._worker = null)
                      return
                    }
                    switch (g.msg) {
                      case E.default.INIT_SEGMENT:
                      case E.default.MEDIA_SEGMENT:
                        this._emitter.emit(g.msg, A.type, A.data)
                        break
                      case E.default.LOADING_COMPLETE:
                      case E.default.RECOVERED_EARLY_EOF:
                        this._emitter.emit(g.msg)
                        break
                      case E.default.MEDIA_INFO:
                        Object.setPrototypeOf(A, x.default.prototype), this._emitter.emit(g.msg, A)
                        break
                      case E.default.METADATA_ARRIVED:
                      case E.default.SCRIPTDATA_ARRIVED:
                      case E.default.STATISTICS_INFO:
                        this._emitter.emit(g.msg, A)
                        break
                      case E.default.IO_ERROR:
                      case E.default.DEMUX_ERROR:
                        this._emitter.emit(g.msg, A.type, A.info)
                        break
                      case E.default.RECOMMEND_SEEKPOINT:
                        this._emitter.emit(g.msg, A)
                        break
                      case 'logcat_callback':
                        m.default.emitter.emit('log', A.type, A.logcat)
                        break
                    }
                  }),
                  b
                )
              })()
            o.default = T
          },
          './src/core/transmuxing-controller.js': function (a, o, l) {
            l.r(o)
            var u = l('./node_modules/events/events.js'),
              c = l.n(u),
              f = l('./src/utils/logger.js'),
              d = l('./src/utils/browser.js'),
              m = l('./src/core/media-info.js'),
              p = l('./src/demux/flv-demuxer.js'),
              v = l('./src/remux/mp4-remuxer.js'),
              E = l('./src/demux/demux-errors.js'),
              x = l('./src/io/io-controller.js'),
              T = l('./src/core/transmuxing-events.js'),
              b = (function () {
                function R(g, A) {
                  ;(this.TAG = 'TransmuxingController'),
                    (this._emitter = new (c())()),
                    (this._config = A),
                    g.segments ||
                      (g.segments = [{ duration: g.duration, filesize: g.filesize, url: g.url }]),
                    typeof g.cors != 'boolean' && (g.cors = !0),
                    typeof g.withCredentials != 'boolean' && (g.withCredentials = !1),
                    (this._mediaDataSource = g),
                    (this._currentSegmentIndex = 0)
                  var S = 0
                  this._mediaDataSource.segments.forEach(function (h) {
                    ;(h.timestampBase = S),
                      (S += h.duration),
                      (h.cors = g.cors),
                      (h.withCredentials = g.withCredentials),
                      A.referrerPolicy && (h.referrerPolicy = A.referrerPolicy)
                  }),
                    !isNaN(S) &&
                      this._mediaDataSource.duration !== S &&
                      (this._mediaDataSource.duration = S),
                    (this._mediaInfo = null),
                    (this._demuxer = null),
                    (this._remuxer = null),
                    (this._ioctl = null),
                    (this._pendingSeekTime = null),
                    (this._pendingResolveSeekPoint = null),
                    (this._statisticsReporter = null)
                }
                return (
                  (R.prototype.destroy = function () {
                    ;(this._mediaInfo = null),
                      (this._mediaDataSource = null),
                      this._statisticsReporter && this._disableStatisticsReporter(),
                      this._ioctl && (this._ioctl.destroy(), (this._ioctl = null)),
                      this._demuxer && (this._demuxer.destroy(), (this._demuxer = null)),
                      this._remuxer && (this._remuxer.destroy(), (this._remuxer = null)),
                      this._emitter.removeAllListeners(),
                      (this._emitter = null)
                  }),
                  (R.prototype.on = function (g, A) {
                    this._emitter.addListener(g, A)
                  }),
                  (R.prototype.off = function (g, A) {
                    this._emitter.removeListener(g, A)
                  }),
                  (R.prototype.start = function () {
                    this._loadSegment(0), this._enableStatisticsReporter()
                  }),
                  (R.prototype._loadSegment = function (g, A) {
                    this._currentSegmentIndex = g
                    var S = this._mediaDataSource.segments[g],
                      h = (this._ioctl = new x.default(S, this._config, g))
                    ;(h.onError = this._onIOException.bind(this)),
                      (h.onSeeked = this._onIOSeeked.bind(this)),
                      (h.onComplete = this._onIOComplete.bind(this)),
                      (h.onRedirect = this._onIORedirect.bind(this)),
                      (h.onRecoveredEarlyEof = this._onIORecoveredEarlyEof.bind(this)),
                      A
                        ? this._demuxer.bindDataSource(this._ioctl)
                        : (h.onDataArrival = this._onInitChunkArrival.bind(this)),
                      h.open(A)
                  }),
                  (R.prototype.stop = function () {
                    this._internalAbort(), this._disableStatisticsReporter()
                  }),
                  (R.prototype._internalAbort = function () {
                    this._ioctl && (this._ioctl.destroy(), (this._ioctl = null))
                  }),
                  (R.prototype.pause = function () {
                    this._ioctl &&
                      this._ioctl.isWorking() &&
                      (this._ioctl.pause(), this._disableStatisticsReporter())
                  }),
                  (R.prototype.resume = function () {
                    this._ioctl &&
                      this._ioctl.isPaused() &&
                      (this._ioctl.resume(), this._enableStatisticsReporter())
                  }),
                  (R.prototype.seek = function (g) {
                    if (!(this._mediaInfo == null || !this._mediaInfo.isSeekable())) {
                      var A = this._searchSegmentIndexContains(g)
                      if (A === this._currentSegmentIndex) {
                        var S = this._mediaInfo.segments[A]
                        if (S == null) this._pendingSeekTime = g
                        else {
                          var h = S.getNearestKeyframe(g)
                          this._remuxer.seek(h.milliseconds),
                            this._ioctl.seek(h.fileposition),
                            (this._pendingResolveSeekPoint = h.milliseconds)
                        }
                      } else {
                        var _ = this._mediaInfo.segments[A]
                        if (_ == null)
                          (this._pendingSeekTime = g),
                            this._internalAbort(),
                            this._remuxer.seek(),
                            this._remuxer.insertDiscontinuity(),
                            this._loadSegment(A)
                        else {
                          var h = _.getNearestKeyframe(g)
                          this._internalAbort(),
                            this._remuxer.seek(g),
                            this._remuxer.insertDiscontinuity(),
                            this._demuxer.resetMediaInfo(),
                            (this._demuxer.timestampBase =
                              this._mediaDataSource.segments[A].timestampBase),
                            this._loadSegment(A, h.fileposition),
                            (this._pendingResolveSeekPoint = h.milliseconds),
                            this._reportSegmentMediaInfo(A)
                        }
                      }
                      this._enableStatisticsReporter()
                    }
                  }),
                  (R.prototype._searchSegmentIndexContains = function (g) {
                    for (
                      var A = this._mediaDataSource.segments, S = A.length - 1, h = 0;
                      h < A.length;
                      h++
                    )
                      if (g < A[h].timestampBase) {
                        S = h - 1
                        break
                      }
                    return S
                  }),
                  (R.prototype._onInitChunkArrival = function (g, A) {
                    var S = this,
                      h = null,
                      _ = 0
                    if (A > 0)
                      this._demuxer.bindDataSource(this._ioctl),
                        (this._demuxer.timestampBase =
                          this._mediaDataSource.segments[this._currentSegmentIndex].timestampBase),
                        (_ = this._demuxer.parseChunks(g, A))
                    else if ((h = p.default.probe(g)).match) {
                      ;(this._demuxer = new p.default(h, this._config)),
                        this._remuxer || (this._remuxer = new v.default(this._config))
                      var y = this._mediaDataSource
                      y.duration != null &&
                        !isNaN(y.duration) &&
                        (this._demuxer.overridedDuration = y.duration),
                        typeof y.hasAudio == 'boolean' &&
                          (this._demuxer.overridedHasAudio = y.hasAudio),
                        typeof y.hasVideo == 'boolean' &&
                          (this._demuxer.overridedHasVideo = y.hasVideo),
                        (this._demuxer.timestampBase =
                          y.segments[this._currentSegmentIndex].timestampBase),
                        (this._demuxer.onError = this._onDemuxException.bind(this)),
                        (this._demuxer.onMediaInfo = this._onMediaInfo.bind(this)),
                        (this._demuxer.onMetaDataArrived = this._onMetaDataArrived.bind(this)),
                        (this._demuxer.onScriptDataArrived = this._onScriptDataArrived.bind(this)),
                        this._remuxer.bindDataSource(this._demuxer.bindDataSource(this._ioctl)),
                        (this._remuxer.onInitSegment =
                          this._onRemuxerInitSegmentArrival.bind(this)),
                        (this._remuxer.onMediaSegment =
                          this._onRemuxerMediaSegmentArrival.bind(this)),
                        (_ = this._demuxer.parseChunks(g, A))
                    } else
                      (h = null),
                        f.default.e(this.TAG, 'Non-FLV, Unsupported media type!'),
                        Promise.resolve().then(function () {
                          S._internalAbort()
                        }),
                        this._emitter.emit(
                          T.default.DEMUX_ERROR,
                          E.default.FORMAT_UNSUPPORTED,
                          'Non-FLV, Unsupported media type'
                        ),
                        (_ = 0)
                    return _
                  }),
                  (R.prototype._onMediaInfo = function (g) {
                    var A = this
                    this._mediaInfo == null &&
                      ((this._mediaInfo = Object.assign({}, g)),
                      (this._mediaInfo.keyframesIndex = null),
                      (this._mediaInfo.segments = []),
                      (this._mediaInfo.segmentCount = this._mediaDataSource.segments.length),
                      Object.setPrototypeOf(this._mediaInfo, m.default.prototype))
                    var S = Object.assign({}, g)
                    Object.setPrototypeOf(S, m.default.prototype),
                      (this._mediaInfo.segments[this._currentSegmentIndex] = S),
                      this._reportSegmentMediaInfo(this._currentSegmentIndex),
                      this._pendingSeekTime != null &&
                        Promise.resolve().then(function () {
                          var h = A._pendingSeekTime
                          ;(A._pendingSeekTime = null), A.seek(h)
                        })
                  }),
                  (R.prototype._onMetaDataArrived = function (g) {
                    this._emitter.emit(T.default.METADATA_ARRIVED, g)
                  }),
                  (R.prototype._onScriptDataArrived = function (g) {
                    this._emitter.emit(T.default.SCRIPTDATA_ARRIVED, g)
                  }),
                  (R.prototype._onIOSeeked = function () {
                    this._remuxer.insertDiscontinuity()
                  }),
                  (R.prototype._onIOComplete = function (g) {
                    var A = g,
                      S = A + 1
                    S < this._mediaDataSource.segments.length
                      ? (this._internalAbort(),
                        this._remuxer.flushStashedSamples(),
                        this._loadSegment(S))
                      : (this._remuxer.flushStashedSamples(),
                        this._emitter.emit(T.default.LOADING_COMPLETE),
                        this._disableStatisticsReporter())
                  }),
                  (R.prototype._onIORedirect = function (g) {
                    var A = this._ioctl.extraData
                    this._mediaDataSource.segments[A].redirectedURL = g
                  }),
                  (R.prototype._onIORecoveredEarlyEof = function () {
                    this._emitter.emit(T.default.RECOVERED_EARLY_EOF)
                  }),
                  (R.prototype._onIOException = function (g, A) {
                    f.default.e(
                      this.TAG,
                      'IOException: type = ' + g + ', code = ' + A.code + ', msg = ' + A.msg
                    ),
                      this._emitter.emit(T.default.IO_ERROR, g, A),
                      this._disableStatisticsReporter()
                  }),
                  (R.prototype._onDemuxException = function (g, A) {
                    f.default.e(this.TAG, 'DemuxException: type = ' + g + ', info = ' + A),
                      this._emitter.emit(T.default.DEMUX_ERROR, g, A)
                  }),
                  (R.prototype._onRemuxerInitSegmentArrival = function (g, A) {
                    this._emitter.emit(T.default.INIT_SEGMENT, g, A)
                  }),
                  (R.prototype._onRemuxerMediaSegmentArrival = function (g, A) {
                    if (
                      this._pendingSeekTime == null &&
                      (this._emitter.emit(T.default.MEDIA_SEGMENT, g, A),
                      this._pendingResolveSeekPoint != null && g === 'video')
                    ) {
                      var S = A.info.syncPoints,
                        h = this._pendingResolveSeekPoint
                      ;(this._pendingResolveSeekPoint = null),
                        d.default.safari &&
                          S.length > 0 &&
                          S[0].originalDts === h &&
                          (h = S[0].pts),
                        this._emitter.emit(T.default.RECOMMEND_SEEKPOINT, h)
                    }
                  }),
                  (R.prototype._enableStatisticsReporter = function () {
                    this._statisticsReporter == null &&
                      (this._statisticsReporter = self.setInterval(
                        this._reportStatisticsInfo.bind(this),
                        this._config.statisticsInfoReportInterval
                      ))
                  }),
                  (R.prototype._disableStatisticsReporter = function () {
                    this._statisticsReporter &&
                      (self.clearInterval(this._statisticsReporter),
                      (this._statisticsReporter = null))
                  }),
                  (R.prototype._reportSegmentMediaInfo = function (g) {
                    var A = this._mediaInfo.segments[g],
                      S = Object.assign({}, A)
                    ;(S.duration = this._mediaInfo.duration),
                      (S.segmentCount = this._mediaInfo.segmentCount),
                      delete S.segments,
                      delete S.keyframesIndex,
                      this._emitter.emit(T.default.MEDIA_INFO, S)
                  }),
                  (R.prototype._reportStatisticsInfo = function () {
                    var g = {}
                    ;(g.url = this._ioctl.currentURL),
                      (g.hasRedirect = this._ioctl.hasRedirect),
                      g.hasRedirect && (g.redirectedURL = this._ioctl.currentRedirectedURL),
                      (g.speed = this._ioctl.currentSpeed),
                      (g.loaderType = this._ioctl.loaderType),
                      (g.currentSegmentIndex = this._currentSegmentIndex),
                      (g.totalSegmentCount = this._mediaDataSource.segments.length),
                      this._emitter.emit(T.default.STATISTICS_INFO, g)
                  }),
                  R
                )
              })()
            o.default = b
          },
          './src/core/transmuxing-events.js': function (a, o, l) {
            l.r(o)
            var u = {
              IO_ERROR: 'io_error',
              DEMUX_ERROR: 'demux_error',
              INIT_SEGMENT: 'init_segment',
              MEDIA_SEGMENT: 'media_segment',
              LOADING_COMPLETE: 'loading_complete',
              RECOVERED_EARLY_EOF: 'recovered_early_eof',
              MEDIA_INFO: 'media_info',
              METADATA_ARRIVED: 'metadata_arrived',
              SCRIPTDATA_ARRIVED: 'scriptdata_arrived',
              STATISTICS_INFO: 'statistics_info',
              RECOMMEND_SEEKPOINT: 'recommend_seekpoint'
            }
            o.default = u
          },
          './src/core/transmuxing-worker.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/utils/logging-control.js'),
              c = l('./src/utils/polyfill.js'),
              f = l('./src/core/transmuxing-controller.js'),
              d = l('./src/core/transmuxing-events.js'),
              m = function (p) {
                var v = null,
                  E = I.bind(this)
                c.default.install(),
                  p.addEventListener('message', function (P) {
                    switch (P.data.cmd) {
                      case 'init':
                        ;(v = new f.default(P.data.param[0], P.data.param[1])),
                          v.on(d.default.IO_ERROR, _.bind(this)),
                          v.on(d.default.DEMUX_ERROR, y.bind(this)),
                          v.on(d.default.INIT_SEGMENT, x.bind(this)),
                          v.on(d.default.MEDIA_SEGMENT, T.bind(this)),
                          v.on(d.default.LOADING_COMPLETE, b.bind(this)),
                          v.on(d.default.RECOVERED_EARLY_EOF, R.bind(this)),
                          v.on(d.default.MEDIA_INFO, g.bind(this)),
                          v.on(d.default.METADATA_ARRIVED, A.bind(this)),
                          v.on(d.default.SCRIPTDATA_ARRIVED, S.bind(this)),
                          v.on(d.default.STATISTICS_INFO, h.bind(this)),
                          v.on(d.default.RECOMMEND_SEEKPOINT, L.bind(this))
                        break
                      case 'destroy':
                        v && (v.destroy(), (v = null)), p.postMessage({ msg: 'destroyed' })
                        break
                      case 'start':
                        v.start()
                        break
                      case 'stop':
                        v.stop()
                        break
                      case 'seek':
                        v.seek(P.data.param)
                        break
                      case 'pause':
                        v.pause()
                        break
                      case 'resume':
                        v.resume()
                        break
                      case 'logging_config': {
                        var D = P.data.param
                        u.default.applyConfig(D),
                          D.enableCallback === !0
                            ? u.default.addLogListener(E)
                            : u.default.removeLogListener(E)
                        break
                      }
                    }
                  })
                function x(P, D) {
                  var C = { msg: d.default.INIT_SEGMENT, data: { type: P, data: D } }
                  p.postMessage(C, [D.data])
                }
                function T(P, D) {
                  var C = { msg: d.default.MEDIA_SEGMENT, data: { type: P, data: D } }
                  p.postMessage(C, [D.data])
                }
                function b() {
                  var P = { msg: d.default.LOADING_COMPLETE }
                  p.postMessage(P)
                }
                function R() {
                  var P = { msg: d.default.RECOVERED_EARLY_EOF }
                  p.postMessage(P)
                }
                function g(P) {
                  var D = { msg: d.default.MEDIA_INFO, data: P }
                  p.postMessage(D)
                }
                function A(P) {
                  var D = { msg: d.default.METADATA_ARRIVED, data: P }
                  p.postMessage(D)
                }
                function S(P) {
                  var D = { msg: d.default.SCRIPTDATA_ARRIVED, data: P }
                  p.postMessage(D)
                }
                function h(P) {
                  var D = { msg: d.default.STATISTICS_INFO, data: P }
                  p.postMessage(D)
                }
                function _(P, D) {
                  p.postMessage({ msg: d.default.IO_ERROR, data: { type: P, info: D } })
                }
                function y(P, D) {
                  p.postMessage({ msg: d.default.DEMUX_ERROR, data: { type: P, info: D } })
                }
                function L(P) {
                  p.postMessage({ msg: d.default.RECOMMEND_SEEKPOINT, data: P })
                }
                function I(P, D) {
                  p.postMessage({ msg: 'logcat_callback', data: { type: P, logcat: D } })
                }
              }
            o.default = m
          },
          './src/demux/amf-parser.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/utils/logger.js'),
              c = l('./src/utils/utf8-conv.js'),
              f = l('./src/utils/exception.js'),
              d = (function () {
                var p = new ArrayBuffer(2)
                return new DataView(p).setInt16(0, 256, !0), new Int16Array(p)[0] === 256
              })(),
              m = (function () {
                function p() {}
                return (
                  (p.parseScriptData = function (v, E, x) {
                    var T = {}
                    try {
                      var b = p.parseValue(v, E, x),
                        R = p.parseValue(v, E + b.size, x - b.size)
                      T[b.data] = R.data
                    } catch (g) {
                      u.default.e('AMF', g.toString())
                    }
                    return T
                  }),
                  (p.parseObject = function (v, E, x) {
                    if (x < 3)
                      throw new f.IllegalStateException(
                        'Data not enough when parse ScriptDataObject'
                      )
                    var T = p.parseString(v, E, x),
                      b = p.parseValue(v, E + T.size, x - T.size),
                      R = b.objectEnd
                    return {
                      data: { name: T.data, value: b.data },
                      size: T.size + b.size,
                      objectEnd: R
                    }
                  }),
                  (p.parseVariable = function (v, E, x) {
                    return p.parseObject(v, E, x)
                  }),
                  (p.parseString = function (v, E, x) {
                    if (x < 2)
                      throw new f.IllegalStateException('Data not enough when parse String')
                    var T = new DataView(v, E, x),
                      b = T.getUint16(0, !d),
                      R
                    return (
                      b > 0 ? (R = (0, c.default)(new Uint8Array(v, E + 2, b))) : (R = ''),
                      { data: R, size: 2 + b }
                    )
                  }),
                  (p.parseLongString = function (v, E, x) {
                    if (x < 4)
                      throw new f.IllegalStateException('Data not enough when parse LongString')
                    var T = new DataView(v, E, x),
                      b = T.getUint32(0, !d),
                      R
                    return (
                      b > 0 ? (R = (0, c.default)(new Uint8Array(v, E + 4, b))) : (R = ''),
                      { data: R, size: 4 + b }
                    )
                  }),
                  (p.parseDate = function (v, E, x) {
                    if (x < 10)
                      throw new f.IllegalStateException('Data size invalid when parse Date')
                    var T = new DataView(v, E, x),
                      b = T.getFloat64(0, !d),
                      R = T.getInt16(8, !d)
                    return (b += R * 60 * 1e3), { data: new Date(b), size: 8 + 2 }
                  }),
                  (p.parseValue = function (v, E, x) {
                    if (x < 1) throw new f.IllegalStateException('Data not enough when parse Value')
                    var T = new DataView(v, E, x),
                      b = 1,
                      R = T.getUint8(0),
                      g,
                      A = !1
                    try {
                      switch (R) {
                        case 0:
                          ;(g = T.getFloat64(1, !d)), (b += 8)
                          break
                        case 1: {
                          var S = T.getUint8(1)
                          ;(g = !!S), (b += 1)
                          break
                        }
                        case 2: {
                          var h = p.parseString(v, E + 1, x - 1)
                          ;(g = h.data), (b += h.size)
                          break
                        }
                        case 3: {
                          g = {}
                          var _ = 0
                          for ((T.getUint32(x - 4, !d) & 16777215) === 9 && (_ = 3); b < x - 4; ) {
                            var y = p.parseObject(v, E + b, x - b - _)
                            if (y.objectEnd) break
                            ;(g[y.data.name] = y.data.value), (b += y.size)
                          }
                          if (b <= x - 3) {
                            var L = T.getUint32(b - 1, !d) & 16777215
                            L === 9 && (b += 3)
                          }
                          break
                        }
                        case 8: {
                          ;(g = {}), (b += 4)
                          var _ = 0
                          for ((T.getUint32(x - 4, !d) & 16777215) === 9 && (_ = 3); b < x - 8; ) {
                            var I = p.parseVariable(v, E + b, x - b - _)
                            if (I.objectEnd) break
                            ;(g[I.data.name] = I.data.value), (b += I.size)
                          }
                          if (b <= x - 3) {
                            var L = T.getUint32(b - 1, !d) & 16777215
                            L === 9 && (b += 3)
                          }
                          break
                        }
                        case 9:
                          ;(g = void 0), (b = 1), (A = !0)
                          break
                        case 10: {
                          g = []
                          var P = T.getUint32(1, !d)
                          b += 4
                          for (var D = 0; D < P; D++) {
                            var C = p.parseValue(v, E + b, x - b)
                            g.push(C.data), (b += C.size)
                          }
                          break
                        }
                        case 11: {
                          var N = p.parseDate(v, E + 1, x - 1)
                          ;(g = N.data), (b += N.size)
                          break
                        }
                        case 12: {
                          var M = p.parseString(v, E + 1, x - 1)
                          ;(g = M.data), (b += M.size)
                          break
                        }
                        default:
                          ;(b = x), u.default.w('AMF', 'Unsupported AMF value type ' + R)
                      }
                    } catch (w) {
                      u.default.e('AMF', w.toString())
                    }
                    return { data: g, size: b, objectEnd: A }
                  }),
                  p
                )
              })()
            o.default = m
          },
          './src/demux/demux-errors.js': function (a, o, l) {
            l.r(o)
            var u = {
              OK: 'OK',
              FORMAT_ERROR: 'FormatError',
              FORMAT_UNSUPPORTED: 'FormatUnsupported',
              CODEC_UNSUPPORTED: 'CodecUnsupported'
            }
            o.default = u
          },
          './src/demux/exp-golomb.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/utils/exception.js'),
              c = (function () {
                function f(d) {
                  ;(this.TAG = 'ExpGolomb'),
                    (this._buffer = d),
                    (this._buffer_index = 0),
                    (this._total_bytes = d.byteLength),
                    (this._total_bits = d.byteLength * 8),
                    (this._current_word = 0),
                    (this._current_word_bits_left = 0)
                }
                return (
                  (f.prototype.destroy = function () {
                    this._buffer = null
                  }),
                  (f.prototype._fillCurrentWord = function () {
                    var d = this._total_bytes - this._buffer_index
                    if (d <= 0)
                      throw new u.IllegalStateException(
                        'ExpGolomb: _fillCurrentWord() but no bytes available'
                      )
                    var m = Math.min(4, d),
                      p = new Uint8Array(4)
                    p.set(this._buffer.subarray(this._buffer_index, this._buffer_index + m)),
                      (this._current_word = new DataView(p.buffer).getUint32(0, !1)),
                      (this._buffer_index += m),
                      (this._current_word_bits_left = m * 8)
                  }),
                  (f.prototype.readBits = function (d) {
                    if (d > 32)
                      throw new u.InvalidArgumentException(
                        'ExpGolomb: readBits() bits exceeded max 32bits!'
                      )
                    if (d <= this._current_word_bits_left) {
                      var m = this._current_word >>> (32 - d)
                      return (this._current_word <<= d), (this._current_word_bits_left -= d), m
                    }
                    var p = this._current_word_bits_left ? this._current_word : 0
                    p = p >>> (32 - this._current_word_bits_left)
                    var v = d - this._current_word_bits_left
                    this._fillCurrentWord()
                    var E = Math.min(v, this._current_word_bits_left),
                      x = this._current_word >>> (32 - E)
                    return (
                      (this._current_word <<= E),
                      (this._current_word_bits_left -= E),
                      (p = (p << E) | x),
                      p
                    )
                  }),
                  (f.prototype.readBool = function () {
                    return this.readBits(1) === 1
                  }),
                  (f.prototype.readByte = function () {
                    return this.readBits(8)
                  }),
                  (f.prototype._skipLeadingZero = function () {
                    var d
                    for (d = 0; d < this._current_word_bits_left; d++)
                      if (this._current_word & (2147483648 >>> d))
                        return (this._current_word <<= d), (this._current_word_bits_left -= d), d
                    return this._fillCurrentWord(), d + this._skipLeadingZero()
                  }),
                  (f.prototype.readUEG = function () {
                    var d = this._skipLeadingZero()
                    return this.readBits(d + 1) - 1
                  }),
                  (f.prototype.readSEG = function () {
                    var d = this.readUEG()
                    return d & 1 ? (d + 1) >>> 1 : -1 * (d >>> 1)
                  }),
                  f
                )
              })()
            o.default = c
          },
          './src/demux/flv-demuxer.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/utils/logger.js'),
              c = l('./src/demux/amf-parser.js'),
              f = l('./src/demux/sps-parser.js'),
              d = l('./src/demux/demux-errors.js'),
              m = l('./src/core/media-info.js'),
              p = l('./src/utils/exception.js')
            function v(x, T) {
              return (x[T] << 24) | (x[T + 1] << 16) | (x[T + 2] << 8) | x[T + 3]
            }
            var E = (function () {
              function x(T, b) {
                ;(this.TAG = 'FLVDemuxer'),
                  (this._config = b),
                  (this._onError = null),
                  (this._onMediaInfo = null),
                  (this._onMetaDataArrived = null),
                  (this._onScriptDataArrived = null),
                  (this._onTrackMetadata = null),
                  (this._onDataAvailable = null),
                  (this._dataOffset = T.dataOffset),
                  (this._firstParse = !0),
                  (this._dispatch = !1),
                  (this._hasAudio = T.hasAudioTrack),
                  (this._hasVideo = T.hasVideoTrack),
                  (this._hasAudioFlagOverrided = !1),
                  (this._hasVideoFlagOverrided = !1),
                  (this._audioInitialMetadataDispatched = !1),
                  (this._videoInitialMetadataDispatched = !1),
                  (this._mediaInfo = new m.default()),
                  (this._mediaInfo.hasAudio = this._hasAudio),
                  (this._mediaInfo.hasVideo = this._hasVideo),
                  (this._metadata = null),
                  (this._audioMetadata = null),
                  (this._videoMetadata = null),
                  (this._naluLengthSize = 4),
                  (this._timestampBase = 0),
                  (this._timescale = 1e3),
                  (this._duration = 0),
                  (this._durationOverrided = !1),
                  (this._referenceFrameRate = {
                    fixed: !0,
                    fps: 23.976,
                    fps_num: 23976,
                    fps_den: 1e3
                  }),
                  (this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48e3]),
                  (this._mpegSamplingRates = [
                    96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350
                  ]),
                  (this._mpegAudioV10SampleRateTable = [44100, 48e3, 32e3, 0]),
                  (this._mpegAudioV20SampleRateTable = [22050, 24e3, 16e3, 0]),
                  (this._mpegAudioV25SampleRateTable = [11025, 12e3, 8e3, 0]),
                  (this._mpegAudioL1BitRateTable = [
                    0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1
                  ]),
                  (this._mpegAudioL2BitRateTable = [
                    0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1
                  ]),
                  (this._mpegAudioL3BitRateTable = [
                    0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1
                  ]),
                  (this._videoTrack = {
                    type: 'video',
                    id: 1,
                    sequenceNumber: 0,
                    samples: [],
                    length: 0
                  }),
                  (this._audioTrack = {
                    type: 'audio',
                    id: 2,
                    sequenceNumber: 0,
                    samples: [],
                    length: 0
                  }),
                  (this._littleEndian = (function () {
                    var R = new ArrayBuffer(2)
                    return new DataView(R).setInt16(0, 256, !0), new Int16Array(R)[0] === 256
                  })())
              }
              return (
                (x.prototype.destroy = function () {
                  ;(this._mediaInfo = null),
                    (this._metadata = null),
                    (this._audioMetadata = null),
                    (this._videoMetadata = null),
                    (this._videoTrack = null),
                    (this._audioTrack = null),
                    (this._onError = null),
                    (this._onMediaInfo = null),
                    (this._onMetaDataArrived = null),
                    (this._onScriptDataArrived = null),
                    (this._onTrackMetadata = null),
                    (this._onDataAvailable = null)
                }),
                (x.probe = function (T) {
                  var b = new Uint8Array(T),
                    R = { match: !1 }
                  if (b[0] !== 70 || b[1] !== 76 || b[2] !== 86 || b[3] !== 1) return R
                  var g = (b[4] & 4) >>> 2 !== 0,
                    A = (b[4] & 1) !== 0,
                    S = v(b, 5)
                  return S < 9
                    ? R
                    : { match: !0, consumed: S, dataOffset: S, hasAudioTrack: g, hasVideoTrack: A }
                }),
                (x.prototype.bindDataSource = function (T) {
                  return (T.onDataArrival = this.parseChunks.bind(this)), this
                }),
                Object.defineProperty(x.prototype, 'onTrackMetadata', {
                  get: function () {
                    return this._onTrackMetadata
                  },
                  set: function (T) {
                    this._onTrackMetadata = T
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(x.prototype, 'onMediaInfo', {
                  get: function () {
                    return this._onMediaInfo
                  },
                  set: function (T) {
                    this._onMediaInfo = T
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(x.prototype, 'onMetaDataArrived', {
                  get: function () {
                    return this._onMetaDataArrived
                  },
                  set: function (T) {
                    this._onMetaDataArrived = T
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(x.prototype, 'onScriptDataArrived', {
                  get: function () {
                    return this._onScriptDataArrived
                  },
                  set: function (T) {
                    this._onScriptDataArrived = T
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(x.prototype, 'onError', {
                  get: function () {
                    return this._onError
                  },
                  set: function (T) {
                    this._onError = T
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(x.prototype, 'onDataAvailable', {
                  get: function () {
                    return this._onDataAvailable
                  },
                  set: function (T) {
                    this._onDataAvailable = T
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(x.prototype, 'timestampBase', {
                  get: function () {
                    return this._timestampBase
                  },
                  set: function (T) {
                    this._timestampBase = T
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(x.prototype, 'overridedDuration', {
                  get: function () {
                    return this._duration
                  },
                  set: function (T) {
                    ;(this._durationOverrided = !0),
                      (this._duration = T),
                      (this._mediaInfo.duration = T)
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(x.prototype, 'overridedHasAudio', {
                  set: function (T) {
                    ;(this._hasAudioFlagOverrided = !0),
                      (this._hasAudio = T),
                      (this._mediaInfo.hasAudio = T)
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(x.prototype, 'overridedHasVideo', {
                  set: function (T) {
                    ;(this._hasVideoFlagOverrided = !0),
                      (this._hasVideo = T),
                      (this._mediaInfo.hasVideo = T)
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                (x.prototype.resetMediaInfo = function () {
                  this._mediaInfo = new m.default()
                }),
                (x.prototype._isInitialMetadataDispatched = function () {
                  return this._hasAudio && this._hasVideo
                    ? this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched
                    : this._hasAudio && !this._hasVideo
                    ? this._audioInitialMetadataDispatched
                    : !this._hasAudio && this._hasVideo
                    ? this._videoInitialMetadataDispatched
                    : !1
                }),
                (x.prototype.parseChunks = function (T, b) {
                  if (
                    !this._onError ||
                    !this._onMediaInfo ||
                    !this._onTrackMetadata ||
                    !this._onDataAvailable
                  )
                    throw new p.IllegalStateException(
                      'Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified'
                    )
                  var R = 0,
                    g = this._littleEndian
                  if (b === 0)
                    if (T.byteLength > 13) {
                      var A = x.probe(T)
                      R = A.dataOffset
                    } else return 0
                  if (this._firstParse) {
                    ;(this._firstParse = !1),
                      b + R !== this._dataOffset &&
                        u.default.w(this.TAG, 'First time parsing but chunk byteStart invalid!')
                    var S = new DataView(T, R),
                      h = S.getUint32(0, !g)
                    h !== 0 && u.default.w(this.TAG, 'PrevTagSize0 !== 0 !!!'), (R += 4)
                  }
                  for (; R < T.byteLength; ) {
                    this._dispatch = !0
                    var S = new DataView(T, R)
                    if (R + 11 + 4 > T.byteLength) break
                    var _ = S.getUint8(0),
                      y = S.getUint32(0, !g) & 16777215
                    if (R + 11 + y + 4 > T.byteLength) break
                    if (_ !== 8 && _ !== 9 && _ !== 18) {
                      u.default.w(this.TAG, 'Unsupported tag type ' + _ + ', skipped'),
                        (R += 11 + y + 4)
                      continue
                    }
                    var L = S.getUint8(4),
                      I = S.getUint8(5),
                      P = S.getUint8(6),
                      D = S.getUint8(7),
                      C = P | (I << 8) | (L << 16) | (D << 24),
                      N = S.getUint32(7, !g) & 16777215
                    N !== 0 && u.default.w(this.TAG, 'Meet tag which has StreamID != 0!')
                    var M = R + 11
                    switch (_) {
                      case 8:
                        this._parseAudioData(T, M, y, C)
                        break
                      case 9:
                        this._parseVideoData(T, M, y, C, b + R)
                        break
                      case 18:
                        this._parseScriptData(T, M, y)
                        break
                    }
                    var w = S.getUint32(11 + y, !g)
                    w !== 11 + y && u.default.w(this.TAG, 'Invalid PrevTagSize ' + w),
                      (R += 11 + y + 4)
                  }
                  return (
                    this._isInitialMetadataDispatched() &&
                      this._dispatch &&
                      (this._audioTrack.length || this._videoTrack.length) &&
                      this._onDataAvailable(this._audioTrack, this._videoTrack),
                    R
                  )
                }),
                (x.prototype._parseScriptData = function (T, b, R) {
                  var g = c.default.parseScriptData(T, b, R)
                  if (g.hasOwnProperty('onMetaData')) {
                    if (g.onMetaData == null || typeof g.onMetaData != 'object') {
                      u.default.w(this.TAG, 'Invalid onMetaData structure!')
                      return
                    }
                    this._metadata && u.default.w(this.TAG, 'Found another onMetaData tag!'),
                      (this._metadata = g)
                    var A = this._metadata.onMetaData
                    if (
                      (this._onMetaDataArrived && this._onMetaDataArrived(Object.assign({}, A)),
                      typeof A.hasAudio == 'boolean' &&
                        this._hasAudioFlagOverrided === !1 &&
                        ((this._hasAudio = A.hasAudio),
                        (this._mediaInfo.hasAudio = this._hasAudio)),
                      typeof A.hasVideo == 'boolean' &&
                        this._hasVideoFlagOverrided === !1 &&
                        ((this._hasVideo = A.hasVideo),
                        (this._mediaInfo.hasVideo = this._hasVideo)),
                      typeof A.audiodatarate == 'number' &&
                        (this._mediaInfo.audioDataRate = A.audiodatarate),
                      typeof A.videodatarate == 'number' &&
                        (this._mediaInfo.videoDataRate = A.videodatarate),
                      typeof A.width == 'number' && (this._mediaInfo.width = A.width),
                      typeof A.height == 'number' && (this._mediaInfo.height = A.height),
                      typeof A.duration == 'number')
                    ) {
                      if (!this._durationOverrided) {
                        var S = Math.floor(A.duration * this._timescale)
                        ;(this._duration = S), (this._mediaInfo.duration = S)
                      }
                    } else this._mediaInfo.duration = 0
                    if (typeof A.framerate == 'number') {
                      var h = Math.floor(A.framerate * 1e3)
                      if (h > 0) {
                        var _ = h / 1e3
                        ;(this._referenceFrameRate.fixed = !0),
                          (this._referenceFrameRate.fps = _),
                          (this._referenceFrameRate.fps_num = h),
                          (this._referenceFrameRate.fps_den = 1e3),
                          (this._mediaInfo.fps = _)
                      }
                    }
                    if (typeof A.keyframes == 'object') {
                      this._mediaInfo.hasKeyframesIndex = !0
                      var y = A.keyframes
                      ;(this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(y)),
                        (A.keyframes = null)
                    } else this._mediaInfo.hasKeyframesIndex = !1
                    ;(this._dispatch = !1),
                      (this._mediaInfo.metadata = A),
                      u.default.v(this.TAG, 'Parsed onMetaData'),
                      this._mediaInfo.isComplete() && this._onMediaInfo(this._mediaInfo)
                  }
                  Object.keys(g).length > 0 &&
                    this._onScriptDataArrived &&
                    this._onScriptDataArrived(Object.assign({}, g))
                }),
                (x.prototype._parseKeyframesIndex = function (T) {
                  for (var b = [], R = [], g = 1; g < T.times.length; g++) {
                    var A = this._timestampBase + Math.floor(T.times[g] * 1e3)
                    b.push(A), R.push(T.filepositions[g])
                  }
                  return { times: b, filepositions: R }
                }),
                (x.prototype._parseAudioData = function (T, b, R, g) {
                  if (R <= 1) {
                    u.default.w(this.TAG, 'Flv: Invalid audio packet, missing SoundData payload!')
                    return
                  }
                  if (!(this._hasAudioFlagOverrided === !0 && this._hasAudio === !1)) {
                    this._littleEndian
                    var A = new DataView(T, b, R),
                      S = A.getUint8(0),
                      h = S >>> 4
                    if (h !== 2 && h !== 10) {
                      this._onError(
                        d.default.CODEC_UNSUPPORTED,
                        'Flv: Unsupported audio codec idx: ' + h
                      )
                      return
                    }
                    var _ = 0,
                      y = (S & 12) >>> 2
                    if (y >= 0 && y <= 4) _ = this._flvSoundRateTable[y]
                    else {
                      this._onError(
                        d.default.FORMAT_ERROR,
                        'Flv: Invalid audio sample rate idx: ' + y
                      )
                      return
                    }
                    var L = S & 1,
                      I = this._audioMetadata,
                      P = this._audioTrack
                    if (
                      (I ||
                        (this._hasAudio === !1 &&
                          this._hasAudioFlagOverrided === !1 &&
                          ((this._hasAudio = !0), (this._mediaInfo.hasAudio = !0)),
                        (I = this._audioMetadata = {}),
                        (I.type = 'audio'),
                        (I.id = P.id),
                        (I.timescale = this._timescale),
                        (I.duration = this._duration),
                        (I.audioSampleRate = _),
                        (I.channelCount = L === 0 ? 1 : 2)),
                      h === 10)
                    ) {
                      var D = this._parseAACAudioData(T, b + 1, R - 1)
                      if (D == null) return
                      if (D.packetType === 0) {
                        I.config && u.default.w(this.TAG, 'Found another AudioSpecificConfig!')
                        var C = D.data
                        ;(I.audioSampleRate = C.samplingRate),
                          (I.channelCount = C.channelCount),
                          (I.codec = C.codec),
                          (I.originalCodec = C.originalCodec),
                          (I.config = C.config),
                          (I.refSampleDuration = (1024 / I.audioSampleRate) * I.timescale),
                          u.default.v(this.TAG, 'Parsed AudioSpecificConfig'),
                          this._isInitialMetadataDispatched()
                            ? this._dispatch &&
                              (this._audioTrack.length || this._videoTrack.length) &&
                              this._onDataAvailable(this._audioTrack, this._videoTrack)
                            : (this._audioInitialMetadataDispatched = !0),
                          (this._dispatch = !1),
                          this._onTrackMetadata('audio', I)
                        var N = this._mediaInfo
                        ;(N.audioCodec = I.originalCodec),
                          (N.audioSampleRate = I.audioSampleRate),
                          (N.audioChannelCount = I.channelCount),
                          N.hasVideo
                            ? N.videoCodec != null &&
                              (N.mimeType =
                                'video/x-flv; codecs="' + N.videoCodec + ',' + N.audioCodec + '"')
                            : (N.mimeType = 'video/x-flv; codecs="' + N.audioCodec + '"'),
                          N.isComplete() && this._onMediaInfo(N)
                      } else if (D.packetType === 1) {
                        var M = this._timestampBase + g,
                          w = { unit: D.data, length: D.data.byteLength, dts: M, pts: M }
                        P.samples.push(w), (P.length += D.data.length)
                      } else u.default.e(this.TAG, 'Flv: Unsupported AAC data type ' + D.packetType)
                    } else if (h === 2) {
                      if (!I.codec) {
                        var C = this._parseMP3AudioData(T, b + 1, R - 1, !0)
                        if (C == null) return
                        ;(I.audioSampleRate = C.samplingRate),
                          (I.channelCount = C.channelCount),
                          (I.codec = C.codec),
                          (I.originalCodec = C.originalCodec),
                          (I.refSampleDuration = (1152 / I.audioSampleRate) * I.timescale),
                          u.default.v(this.TAG, 'Parsed MPEG Audio Frame Header'),
                          (this._audioInitialMetadataDispatched = !0),
                          this._onTrackMetadata('audio', I)
                        var N = this._mediaInfo
                        ;(N.audioCodec = I.codec),
                          (N.audioSampleRate = I.audioSampleRate),
                          (N.audioChannelCount = I.channelCount),
                          (N.audioDataRate = C.bitRate),
                          N.hasVideo
                            ? N.videoCodec != null &&
                              (N.mimeType =
                                'video/x-flv; codecs="' + N.videoCodec + ',' + N.audioCodec + '"')
                            : (N.mimeType = 'video/x-flv; codecs="' + N.audioCodec + '"'),
                          N.isComplete() && this._onMediaInfo(N)
                      }
                      var U = this._parseMP3AudioData(T, b + 1, R - 1, !1)
                      if (U == null) return
                      var M = this._timestampBase + g,
                        F = { unit: U, length: U.byteLength, dts: M, pts: M }
                      P.samples.push(F), (P.length += U.length)
                    }
                  }
                }),
                (x.prototype._parseAACAudioData = function (T, b, R) {
                  if (R <= 1) {
                    u.default.w(
                      this.TAG,
                      'Flv: Invalid AAC packet, missing AACPacketType or/and Data!'
                    )
                    return
                  }
                  var g = {},
                    A = new Uint8Array(T, b, R)
                  return (
                    (g.packetType = A[0]),
                    A[0] === 0
                      ? (g.data = this._parseAACAudioSpecificConfig(T, b + 1, R - 1))
                      : (g.data = A.subarray(1)),
                    g
                  )
                }),
                (x.prototype._parseAACAudioSpecificConfig = function (T, b, R) {
                  var g = new Uint8Array(T, b, R),
                    A = null,
                    S = 0,
                    h = 0,
                    _ = 0,
                    y = null
                  if (
                    ((S = h = g[0] >>> 3),
                    (_ = ((g[0] & 7) << 1) | (g[1] >>> 7)),
                    _ < 0 || _ >= this._mpegSamplingRates.length)
                  ) {
                    this._onError(
                      d.default.FORMAT_ERROR,
                      'Flv: AAC invalid sampling frequency index!'
                    )
                    return
                  }
                  var L = this._mpegSamplingRates[_],
                    I = (g[1] & 120) >>> 3
                  if (I < 0 || I >= 8) {
                    this._onError(d.default.FORMAT_ERROR, 'Flv: AAC invalid channel configuration')
                    return
                  }
                  S === 5 && ((y = ((g[1] & 7) << 1) | (g[2] >>> 7)), (g[2] & 124) >>> 2)
                  var P = self.navigator.userAgent.toLowerCase()
                  return (
                    P.indexOf('firefox') !== -1
                      ? _ >= 6
                        ? ((S = 5), (A = new Array(4)), (y = _ - 3))
                        : ((S = 2), (A = new Array(2)), (y = _))
                      : P.indexOf('android') !== -1
                      ? ((S = 2), (A = new Array(2)), (y = _))
                      : ((S = 5),
                        (y = _),
                        (A = new Array(4)),
                        _ >= 6 ? (y = _ - 3) : I === 1 && ((S = 2), (A = new Array(2)), (y = _))),
                    (A[0] = S << 3),
                    (A[0] |= (_ & 15) >>> 1),
                    (A[1] = (_ & 15) << 7),
                    (A[1] |= (I & 15) << 3),
                    S === 5 &&
                      ((A[1] |= (y & 15) >>> 1), (A[2] = (y & 1) << 7), (A[2] |= 8), (A[3] = 0)),
                    {
                      config: A,
                      samplingRate: L,
                      channelCount: I,
                      codec: 'mp4a.40.' + S,
                      originalCodec: 'mp4a.40.' + h
                    }
                  )
                }),
                (x.prototype._parseMP3AudioData = function (T, b, R, g) {
                  if (R < 4) {
                    u.default.w(this.TAG, 'Flv: Invalid MP3 packet, header missing!')
                    return
                  }
                  this._littleEndian
                  var A = new Uint8Array(T, b, R),
                    S = null
                  if (g) {
                    if (A[0] !== 255) return
                    var h = (A[1] >>> 3) & 3,
                      _ = (A[1] & 6) >> 1,
                      y = (A[2] & 240) >>> 4,
                      L = (A[2] & 12) >>> 2,
                      I = (A[3] >>> 6) & 3,
                      P = I !== 3 ? 2 : 1,
                      D = 0,
                      C = 0,
                      N = 'mp3'
                    switch (h) {
                      case 0:
                        D = this._mpegAudioV25SampleRateTable[L]
                        break
                      case 2:
                        D = this._mpegAudioV20SampleRateTable[L]
                        break
                      case 3:
                        D = this._mpegAudioV10SampleRateTable[L]
                        break
                    }
                    switch (_) {
                      case 1:
                        y < this._mpegAudioL3BitRateTable.length &&
                          (C = this._mpegAudioL3BitRateTable[y])
                        break
                      case 2:
                        y < this._mpegAudioL2BitRateTable.length &&
                          (C = this._mpegAudioL2BitRateTable[y])
                        break
                      case 3:
                        y < this._mpegAudioL1BitRateTable.length &&
                          (C = this._mpegAudioL1BitRateTable[y])
                        break
                    }
                    S = { bitRate: C, samplingRate: D, channelCount: P, codec: N, originalCodec: N }
                  } else S = A
                  return S
                }),
                (x.prototype._parseVideoData = function (T, b, R, g, A) {
                  if (R <= 1) {
                    u.default.w(this.TAG, 'Flv: Invalid video packet, missing VideoData payload!')
                    return
                  }
                  if (!(this._hasVideoFlagOverrided === !0 && this._hasVideo === !1)) {
                    var S = new Uint8Array(T, b, R)[0],
                      h = (S & 240) >>> 4,
                      _ = S & 15
                    if (_ !== 7) {
                      this._onError(
                        d.default.CODEC_UNSUPPORTED,
                        'Flv: Unsupported codec in video frame: ' + _
                      )
                      return
                    }
                    this._parseAVCVideoPacket(T, b + 1, R - 1, g, A, h)
                  }
                }),
                (x.prototype._parseAVCVideoPacket = function (T, b, R, g, A, S) {
                  if (R < 4) {
                    u.default.w(
                      this.TAG,
                      'Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime'
                    )
                    return
                  }
                  var h = this._littleEndian,
                    _ = new DataView(T, b, R),
                    y = _.getUint8(0),
                    L = _.getUint32(0, !h) & 16777215,
                    I = (L << 8) >> 8
                  if (y === 0) this._parseAVCDecoderConfigurationRecord(T, b + 4, R - 4)
                  else if (y === 1) this._parseAVCVideoData(T, b + 4, R - 4, g, A, S, I)
                  else if (y !== 2) {
                    this._onError(d.default.FORMAT_ERROR, 'Flv: Invalid video packet type ' + y)
                    return
                  }
                }),
                (x.prototype._parseAVCDecoderConfigurationRecord = function (T, b, R) {
                  if (R < 7) {
                    u.default.w(
                      this.TAG,
                      'Flv: Invalid AVCDecoderConfigurationRecord, lack of data!'
                    )
                    return
                  }
                  var g = this._videoMetadata,
                    A = this._videoTrack,
                    S = this._littleEndian,
                    h = new DataView(T, b, R)
                  g
                    ? typeof g.avcc < 'u' &&
                      u.default.w(this.TAG, 'Found another AVCDecoderConfigurationRecord!')
                    : (this._hasVideo === !1 &&
                        this._hasVideoFlagOverrided === !1 &&
                        ((this._hasVideo = !0), (this._mediaInfo.hasVideo = !0)),
                      (g = this._videoMetadata = {}),
                      (g.type = 'video'),
                      (g.id = A.id),
                      (g.timescale = this._timescale),
                      (g.duration = this._duration))
                  var _ = h.getUint8(0),
                    y = h.getUint8(1)
                  if ((h.getUint8(2), h.getUint8(3), _ !== 1 || y === 0)) {
                    this._onError(
                      d.default.FORMAT_ERROR,
                      'Flv: Invalid AVCDecoderConfigurationRecord'
                    )
                    return
                  }
                  if (
                    ((this._naluLengthSize = (h.getUint8(4) & 3) + 1),
                    this._naluLengthSize !== 3 && this._naluLengthSize !== 4)
                  ) {
                    this._onError(
                      d.default.FORMAT_ERROR,
                      'Flv: Strange NaluLengthSizeMinusOne: ' + (this._naluLengthSize - 1)
                    )
                    return
                  }
                  var L = h.getUint8(5) & 31
                  if (L === 0) {
                    this._onError(
                      d.default.FORMAT_ERROR,
                      'Flv: Invalid AVCDecoderConfigurationRecord: No SPS'
                    )
                    return
                  } else
                    L > 1 &&
                      u.default.w(
                        this.TAG,
                        'Flv: Strange AVCDecoderConfigurationRecord: SPS Count = ' + L
                      )
                  for (var I = 6, P = 0; P < L; P++) {
                    var D = h.getUint16(I, !S)
                    if (((I += 2), D !== 0)) {
                      var C = new Uint8Array(T, b + I, D)
                      I += D
                      var N = f.default.parseSPS(C)
                      if (P === 0) {
                        ;(g.codecWidth = N.codec_size.width),
                          (g.codecHeight = N.codec_size.height),
                          (g.presentWidth = N.present_size.width),
                          (g.presentHeight = N.present_size.height),
                          (g.profile = N.profile_string),
                          (g.level = N.level_string),
                          (g.bitDepth = N.bit_depth),
                          (g.chromaFormat = N.chroma_format),
                          (g.sarRatio = N.sar_ratio),
                          (g.frameRate = N.frame_rate),
                          (N.frame_rate.fixed === !1 ||
                            N.frame_rate.fps_num === 0 ||
                            N.frame_rate.fps_den === 0) &&
                            (g.frameRate = this._referenceFrameRate)
                        var M = g.frameRate.fps_den,
                          w = g.frameRate.fps_num
                        g.refSampleDuration = g.timescale * (M / w)
                        for (var U = C.subarray(1, 4), F = 'avc1.', k = 0; k < 3; k++) {
                          var B = U[k].toString(16)
                          B.length < 2 && (B = '0' + B), (F += B)
                        }
                        g.codec = F
                        var V = this._mediaInfo
                        ;(V.width = g.codecWidth),
                          (V.height = g.codecHeight),
                          (V.fps = g.frameRate.fps),
                          (V.profile = g.profile),
                          (V.level = g.level),
                          (V.refFrames = N.ref_frames),
                          (V.chromaFormat = N.chroma_format_string),
                          (V.sarNum = g.sarRatio.width),
                          (V.sarDen = g.sarRatio.height),
                          (V.videoCodec = F),
                          V.hasAudio
                            ? V.audioCodec != null &&
                              (V.mimeType =
                                'video/x-flv; codecs="' + V.videoCodec + ',' + V.audioCodec + '"')
                            : (V.mimeType = 'video/x-flv; codecs="' + V.videoCodec + '"'),
                          V.isComplete() && this._onMediaInfo(V)
                      }
                    }
                  }
                  var H = h.getUint8(I)
                  if (H === 0) {
                    this._onError(
                      d.default.FORMAT_ERROR,
                      'Flv: Invalid AVCDecoderConfigurationRecord: No PPS'
                    )
                    return
                  } else
                    H > 1 &&
                      u.default.w(
                        this.TAG,
                        'Flv: Strange AVCDecoderConfigurationRecord: PPS Count = ' + H
                      )
                  I++
                  for (var P = 0; P < H; P++) {
                    var D = h.getUint16(I, !S)
                    ;(I += 2), D !== 0 && (I += D)
                  }
                  ;(g.avcc = new Uint8Array(R)),
                    g.avcc.set(new Uint8Array(T, b, R), 0),
                    u.default.v(this.TAG, 'Parsed AVCDecoderConfigurationRecord'),
                    this._isInitialMetadataDispatched()
                      ? this._dispatch &&
                        (this._audioTrack.length || this._videoTrack.length) &&
                        this._onDataAvailable(this._audioTrack, this._videoTrack)
                      : (this._videoInitialMetadataDispatched = !0),
                    (this._dispatch = !1),
                    this._onTrackMetadata('video', g)
                }),
                (x.prototype._parseAVCVideoData = function (T, b, R, g, A, S, h) {
                  for (
                    var _ = this._littleEndian,
                      y = new DataView(T, b, R),
                      L = [],
                      I = 0,
                      P = 0,
                      D = this._naluLengthSize,
                      C = this._timestampBase + g,
                      N = S === 1;
                    P < R;

                  ) {
                    if (P + 4 >= R) {
                      u.default.w(
                        this.TAG,
                        'Malformed Nalu near timestamp ' +
                          C +
                          ', offset = ' +
                          P +
                          ', dataSize = ' +
                          R
                      )
                      break
                    }
                    var M = y.getUint32(P, !_)
                    if ((D === 3 && (M >>>= 8), M > R - D)) {
                      u.default.w(
                        this.TAG,
                        'Malformed Nalus near timestamp ' + C + ', NaluSize > DataSize!'
                      )
                      return
                    }
                    var w = y.getUint8(P + D) & 31
                    w === 5 && (N = !0)
                    var U = new Uint8Array(T, b + P, D + M),
                      F = { type: w, data: U }
                    L.push(F), (I += U.byteLength), (P += D + M)
                  }
                  if (L.length) {
                    var k = this._videoTrack,
                      B = { units: L, length: I, isKeyframe: N, dts: C, cts: h, pts: C + h }
                    N && (B.fileposition = A), k.samples.push(B), (k.length += I)
                  }
                }),
                x
              )
            })()
            o.default = E
          },
          './src/demux/sps-parser.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/demux/exp-golomb.js'),
              c = (function () {
                function f() {}
                return (
                  (f._ebsp2rbsp = function (d) {
                    for (
                      var m = d, p = m.byteLength, v = new Uint8Array(p), E = 0, x = 0;
                      x < p;
                      x++
                    )
                      (x >= 2 && m[x] === 3 && m[x - 1] === 0 && m[x - 2] === 0) ||
                        ((v[E] = m[x]), E++)
                    return new Uint8Array(v.buffer, 0, E)
                  }),
                  (f.parseSPS = function (d) {
                    var m = f._ebsp2rbsp(d),
                      p = new u.default(m)
                    p.readByte()
                    var v = p.readByte()
                    p.readByte()
                    var E = p.readByte()
                    p.readUEG()
                    var x = f.getProfileString(v),
                      T = f.getLevelString(E),
                      b = 1,
                      R = 420,
                      g = [0, 420, 422, 444],
                      A = 8
                    if (
                      (v === 100 ||
                        v === 110 ||
                        v === 122 ||
                        v === 244 ||
                        v === 44 ||
                        v === 83 ||
                        v === 86 ||
                        v === 118 ||
                        v === 128 ||
                        v === 138 ||
                        v === 144) &&
                      ((b = p.readUEG()),
                      b === 3 && p.readBits(1),
                      b <= 3 && (R = g[b]),
                      (A = p.readUEG() + 8),
                      p.readUEG(),
                      p.readBits(1),
                      p.readBool())
                    )
                      for (var S = b !== 3 ? 8 : 12, h = 0; h < S; h++)
                        p.readBool() &&
                          (h < 6 ? f._skipScalingList(p, 16) : f._skipScalingList(p, 64))
                    p.readUEG()
                    var _ = p.readUEG()
                    if (_ === 0) p.readUEG()
                    else if (_ === 1) {
                      p.readBits(1), p.readSEG(), p.readSEG()
                      for (var y = p.readUEG(), h = 0; h < y; h++) p.readSEG()
                    }
                    var L = p.readUEG()
                    p.readBits(1)
                    var I = p.readUEG(),
                      P = p.readUEG(),
                      D = p.readBits(1)
                    D === 0 && p.readBits(1), p.readBits(1)
                    var C = 0,
                      N = 0,
                      M = 0,
                      w = 0,
                      U = p.readBool()
                    U &&
                      ((C = p.readUEG()), (N = p.readUEG()), (M = p.readUEG()), (w = p.readUEG()))
                    var F = 1,
                      k = 1,
                      B = 0,
                      V = !0,
                      H = 0,
                      q = 0,
                      X = p.readBool()
                    if (X) {
                      if (p.readBool()) {
                        var Q = p.readByte(),
                          ae = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2],
                          ue = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1]
                        Q > 0 && Q < 16
                          ? ((F = ae[Q - 1]), (k = ue[Q - 1]))
                          : Q === 255 &&
                            ((F = (p.readByte() << 8) | p.readByte()),
                            (k = (p.readByte() << 8) | p.readByte()))
                      }
                      if (
                        (p.readBool() && p.readBool(),
                        p.readBool() && (p.readBits(4), p.readBool() && p.readBits(24)),
                        p.readBool() && (p.readUEG(), p.readUEG()),
                        p.readBool())
                      ) {
                        var he = p.readBits(32),
                          _e = p.readBits(32)
                        ;(V = p.readBool()), (H = _e), (q = he * 2), (B = H / q)
                      }
                    }
                    var de = 1
                    ;(F !== 1 || k !== 1) && (de = F / k)
                    var te = 0,
                      be = 0
                    if (b === 0) (te = 1), (be = 2 - D)
                    else {
                      var De = b === 3 ? 1 : 2,
                        Ue = b === 1 ? 2 : 1
                      ;(te = De), (be = Ue * (2 - D))
                    }
                    var ke = (I + 1) * 16,
                      xe = (2 - D) * ((P + 1) * 16)
                    ;(ke -= (C + N) * te), (xe -= (M + w) * be)
                    var at = Math.ceil(ke * de)
                    return (
                      p.destroy(),
                      (p = null),
                      {
                        profile_string: x,
                        level_string: T,
                        bit_depth: A,
                        ref_frames: L,
                        chroma_format: R,
                        chroma_format_string: f.getChromaFormatString(R),
                        frame_rate: { fixed: V, fps: B, fps_den: q, fps_num: H },
                        sar_ratio: { width: F, height: k },
                        codec_size: { width: ke, height: xe },
                        present_size: { width: at, height: xe }
                      }
                    )
                  }),
                  (f._skipScalingList = function (d, m) {
                    for (var p = 8, v = 8, E = 0, x = 0; x < m; x++)
                      v !== 0 && ((E = d.readSEG()), (v = (p + E + 256) % 256)),
                        (p = v === 0 ? p : v)
                  }),
                  (f.getProfileString = function (d) {
                    switch (d) {
                      case 66:
                        return 'Baseline'
                      case 77:
                        return 'Main'
                      case 88:
                        return 'Extended'
                      case 100:
                        return 'High'
                      case 110:
                        return 'High10'
                      case 122:
                        return 'High422'
                      case 244:
                        return 'High444'
                      default:
                        return 'Unknown'
                    }
                  }),
                  (f.getLevelString = function (d) {
                    return (d / 10).toFixed(1)
                  }),
                  (f.getChromaFormatString = function (d) {
                    switch (d) {
                      case 420:
                        return '4:2:0'
                      case 422:
                        return '4:2:2'
                      case 444:
                        return '4:4:4'
                      default:
                        return 'Unknown'
                    }
                  }),
                  f
                )
              })()
            o.default = c
          },
          './src/flv.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/utils/polyfill.js'),
              c = l('./src/core/features.js'),
              f = l('./src/io/loader.js'),
              d = l('./src/player/flv-player.js'),
              m = l('./src/player/native-player.js'),
              p = l('./src/player/player-events.js'),
              v = l('./src/player/player-errors.js'),
              E = l('./src/utils/logging-control.js'),
              x = l('./src/utils/exception.js')
            u.default.install()
            function T(A, S) {
              var h = A
              if (h == null || typeof h != 'object')
                throw new x.InvalidArgumentException(
                  'MediaDataSource must be an javascript object!'
                )
              if (!h.hasOwnProperty('type'))
                throw new x.InvalidArgumentException(
                  'MediaDataSource must has type field to indicate video file type!'
                )
              switch (h.type) {
                case 'flv':
                  return new d.default(h, S)
                default:
                  return new m.default(h, S)
              }
            }
            function b() {
              return c.default.supportMSEH264Playback()
            }
            function R() {
              return c.default.getFeatureList()
            }
            var g = {}
            ;(g.createPlayer = T),
              (g.isSupported = b),
              (g.getFeatureList = R),
              (g.BaseLoader = f.BaseLoader),
              (g.LoaderStatus = f.LoaderStatus),
              (g.LoaderErrors = f.LoaderErrors),
              (g.Events = p.default),
              (g.ErrorTypes = v.ErrorTypes),
              (g.ErrorDetails = v.ErrorDetails),
              (g.FlvPlayer = d.default),
              (g.NativePlayer = m.default),
              (g.LoggingControl = E.default),
              Object.defineProperty(g, 'version', {
                enumerable: !0,
                get: function () {
                  return '1.6.2'
                }
              }),
              (o.default = g)
          },
          './src/index.js': function (a, o, l) {
            a.exports = l('./src/flv.js').default
          },
          './src/io/fetch-stream-loader.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/utils/browser.js'),
              c = l('./src/io/loader.js'),
              f = l('./src/utils/exception.js'),
              d = (function () {
                var p = function (v, E) {
                  return (
                    (p =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (x, T) {
                          x.__proto__ = T
                        }) ||
                      function (x, T) {
                        for (var b in T) Object.prototype.hasOwnProperty.call(T, b) && (x[b] = T[b])
                      }),
                    p(v, E)
                  )
                }
                return function (v, E) {
                  if (typeof E != 'function' && E !== null)
                    throw new TypeError(
                      'Class extends value ' + String(E) + ' is not a constructor or null'
                    )
                  p(v, E)
                  function x() {
                    this.constructor = v
                  }
                  v.prototype =
                    E === null ? Object.create(E) : ((x.prototype = E.prototype), new x())
                }
              })(),
              m = (function (p) {
                d(v, p)
                function v(E, x) {
                  var T = p.call(this, 'fetch-stream-loader') || this
                  return (
                    (T.TAG = 'FetchStreamLoader'),
                    (T._seekHandler = E),
                    (T._config = x),
                    (T._needStash = !0),
                    (T._requestAbort = !1),
                    (T._contentLength = null),
                    (T._receivedLength = 0),
                    T
                  )
                }
                return (
                  (v.isSupported = function () {
                    try {
                      var E = u.default.msedge && u.default.version.minor >= 15048,
                        x = u.default.msedge ? E : !0
                      return self.fetch && self.ReadableStream && x
                    } catch {
                      return !1
                    }
                  }),
                  (v.prototype.destroy = function () {
                    this.isWorking() && this.abort(), p.prototype.destroy.call(this)
                  }),
                  (v.prototype.open = function (E, x) {
                    var T = this
                    ;(this._dataSource = E), (this._range = x)
                    var b = E.url
                    this._config.reuseRedirectedURL &&
                      E.redirectedURL != null &&
                      (b = E.redirectedURL)
                    var R = this._seekHandler.getConfig(b, x),
                      g = new self.Headers()
                    if (typeof R.headers == 'object') {
                      var A = R.headers
                      for (var S in A) A.hasOwnProperty(S) && g.append(S, A[S])
                    }
                    var h = {
                      method: 'GET',
                      headers: g,
                      mode: 'cors',
                      cache: 'default',
                      referrerPolicy: 'no-referrer-when-downgrade'
                    }
                    if (typeof this._config.headers == 'object')
                      for (var S in this._config.headers) g.append(S, this._config.headers[S])
                    E.cors === !1 && (h.mode = 'same-origin'),
                      E.withCredentials && (h.credentials = 'include'),
                      E.referrerPolicy && (h.referrerPolicy = E.referrerPolicy),
                      self.AbortController &&
                        ((this._abortController = new self.AbortController()),
                        (h.signal = this._abortController.signal)),
                      (this._status = c.LoaderStatus.kConnecting),
                      self
                        .fetch(R.url, h)
                        .then(function (_) {
                          if (T._requestAbort) {
                            ;(T._status = c.LoaderStatus.kIdle), _.body.cancel()
                            return
                          }
                          if (_.ok && _.status >= 200 && _.status <= 299) {
                            if (_.url !== R.url && T._onURLRedirect) {
                              var y = T._seekHandler.removeURLParameters(_.url)
                              T._onURLRedirect(y)
                            }
                            var L = _.headers.get('Content-Length')
                            return (
                              L != null &&
                                ((T._contentLength = parseInt(L)),
                                T._contentLength !== 0 &&
                                  T._onContentLengthKnown &&
                                  T._onContentLengthKnown(T._contentLength)),
                              T._pump.call(T, _.body.getReader())
                            )
                          } else if (((T._status = c.LoaderStatus.kError), T._onError))
                            T._onError(c.LoaderErrors.HTTP_STATUS_CODE_INVALID, {
                              code: _.status,
                              msg: _.statusText
                            })
                          else
                            throw new f.RuntimeException(
                              'FetchStreamLoader: Http code invalid, ' +
                                _.status +
                                ' ' +
                                _.statusText
                            )
                        })
                        .catch(function (_) {
                          if (!(T._abortController && T._abortController.signal.aborted))
                            if (((T._status = c.LoaderStatus.kError), T._onError))
                              T._onError(c.LoaderErrors.EXCEPTION, { code: -1, msg: _.message })
                            else throw _
                        })
                  }),
                  (v.prototype.abort = function () {
                    if (
                      ((this._requestAbort = !0),
                      (this._status !== c.LoaderStatus.kBuffering || !u.default.chrome) &&
                        this._abortController)
                    )
                      try {
                        this._abortController.abort()
                      } catch {}
                  }),
                  (v.prototype._pump = function (E) {
                    var x = this
                    return E.read()
                      .then(function (T) {
                        if (T.done)
                          if (x._contentLength !== null && x._receivedLength < x._contentLength) {
                            x._status = c.LoaderStatus.kError
                            var b = c.LoaderErrors.EARLY_EOF,
                              R = { code: -1, msg: 'Fetch stream meet Early-EOF' }
                            if (x._onError) x._onError(b, R)
                            else throw new f.RuntimeException(R.msg)
                          } else
                            (x._status = c.LoaderStatus.kComplete),
                              x._onComplete &&
                                x._onComplete(x._range.from, x._range.from + x._receivedLength - 1)
                        else {
                          if (x._abortController && x._abortController.signal.aborted) {
                            x._status = c.LoaderStatus.kComplete
                            return
                          } else if (x._requestAbort === !0)
                            return (x._status = c.LoaderStatus.kComplete), E.cancel()
                          x._status = c.LoaderStatus.kBuffering
                          var g = T.value.buffer,
                            A = x._range.from + x._receivedLength
                          ;(x._receivedLength += g.byteLength),
                            x._onDataArrival && x._onDataArrival(g, A, x._receivedLength),
                            x._pump(E)
                        }
                      })
                      .catch(function (T) {
                        if (x._abortController && x._abortController.signal.aborted) {
                          x._status = c.LoaderStatus.kComplete
                          return
                        }
                        if (!(T.code === 11 && u.default.msedge)) {
                          x._status = c.LoaderStatus.kError
                          var b = 0,
                            R = null
                          if (
                            ((T.code === 19 || T.message === 'network error') &&
                            (x._contentLength === null ||
                              (x._contentLength !== null && x._receivedLength < x._contentLength))
                              ? ((b = c.LoaderErrors.EARLY_EOF),
                                (R = { code: T.code, msg: 'Fetch stream meet Early-EOF' }))
                              : ((b = c.LoaderErrors.EXCEPTION),
                                (R = { code: T.code, msg: T.message })),
                            x._onError)
                          )
                            x._onError(b, R)
                          else throw new f.RuntimeException(R.msg)
                        }
                      })
                  }),
                  v
                )
              })(c.BaseLoader)
            o.default = m
          },
          './src/io/io-controller.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/utils/logger.js'),
              c = l('./src/io/speed-sampler.js'),
              f = l('./src/io/loader.js'),
              d = l('./src/io/fetch-stream-loader.js'),
              m = l('./src/io/xhr-moz-chunked-loader.js'),
              p = l('./src/io/xhr-range-loader.js'),
              v = l('./src/io/websocket-loader.js'),
              E = l('./src/io/range-seek-handler.js'),
              x = l('./src/io/param-seek-handler.js'),
              T = l('./src/utils/exception.js'),
              b = (function () {
                function R(g, A, S) {
                  ;(this.TAG = 'IOController'),
                    (this._config = A),
                    (this._extraData = S),
                    (this._stashInitialSize = 1024 * 384),
                    A.stashInitialSize != null &&
                      A.stashInitialSize > 0 &&
                      (this._stashInitialSize = A.stashInitialSize),
                    (this._stashUsed = 0),
                    (this._stashSize = this._stashInitialSize),
                    (this._bufferSize = 1024 * 1024 * 3),
                    (this._stashBuffer = new ArrayBuffer(this._bufferSize)),
                    (this._stashByteStart = 0),
                    (this._enableStash = !0),
                    A.enableStashBuffer === !1 && (this._enableStash = !1),
                    (this._loader = null),
                    (this._loaderClass = null),
                    (this._seekHandler = null),
                    (this._dataSource = g),
                    (this._isWebSocketURL = /wss?:\/\/(.+?)/.test(g.url)),
                    (this._refTotalLength = g.filesize ? g.filesize : null),
                    (this._totalLength = this._refTotalLength),
                    (this._fullRequestFlag = !1),
                    (this._currentRange = null),
                    (this._redirectedURL = null),
                    (this._speedNormalized = 0),
                    (this._speedSampler = new c.default()),
                    (this._speedNormalizeList = [
                      64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096
                    ]),
                    (this._isEarlyEofReconnecting = !1),
                    (this._paused = !1),
                    (this._resumeFrom = 0),
                    (this._onDataArrival = null),
                    (this._onSeeked = null),
                    (this._onError = null),
                    (this._onComplete = null),
                    (this._onRedirect = null),
                    (this._onRecoveredEarlyEof = null),
                    this._selectSeekHandler(),
                    this._selectLoader(),
                    this._createLoader()
                }
                return (
                  (R.prototype.destroy = function () {
                    this._loader.isWorking() && this._loader.abort(),
                      this._loader.destroy(),
                      (this._loader = null),
                      (this._loaderClass = null),
                      (this._dataSource = null),
                      (this._stashBuffer = null),
                      (this._stashUsed =
                        this._stashSize =
                        this._bufferSize =
                        this._stashByteStart =
                          0),
                      (this._currentRange = null),
                      (this._speedSampler = null),
                      (this._isEarlyEofReconnecting = !1),
                      (this._onDataArrival = null),
                      (this._onSeeked = null),
                      (this._onError = null),
                      (this._onComplete = null),
                      (this._onRedirect = null),
                      (this._onRecoveredEarlyEof = null),
                      (this._extraData = null)
                  }),
                  (R.prototype.isWorking = function () {
                    return this._loader && this._loader.isWorking() && !this._paused
                  }),
                  (R.prototype.isPaused = function () {
                    return this._paused
                  }),
                  Object.defineProperty(R.prototype, 'status', {
                    get: function () {
                      return this._loader.status
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(R.prototype, 'extraData', {
                    get: function () {
                      return this._extraData
                    },
                    set: function (g) {
                      this._extraData = g
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(R.prototype, 'onDataArrival', {
                    get: function () {
                      return this._onDataArrival
                    },
                    set: function (g) {
                      this._onDataArrival = g
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(R.prototype, 'onSeeked', {
                    get: function () {
                      return this._onSeeked
                    },
                    set: function (g) {
                      this._onSeeked = g
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(R.prototype, 'onError', {
                    get: function () {
                      return this._onError
                    },
                    set: function (g) {
                      this._onError = g
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(R.prototype, 'onComplete', {
                    get: function () {
                      return this._onComplete
                    },
                    set: function (g) {
                      this._onComplete = g
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(R.prototype, 'onRedirect', {
                    get: function () {
                      return this._onRedirect
                    },
                    set: function (g) {
                      this._onRedirect = g
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(R.prototype, 'onRecoveredEarlyEof', {
                    get: function () {
                      return this._onRecoveredEarlyEof
                    },
                    set: function (g) {
                      this._onRecoveredEarlyEof = g
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(R.prototype, 'currentURL', {
                    get: function () {
                      return this._dataSource.url
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(R.prototype, 'hasRedirect', {
                    get: function () {
                      return this._redirectedURL != null || this._dataSource.redirectedURL != null
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(R.prototype, 'currentRedirectedURL', {
                    get: function () {
                      return this._redirectedURL || this._dataSource.redirectedURL
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(R.prototype, 'currentSpeed', {
                    get: function () {
                      return this._loaderClass === p.default
                        ? this._loader.currentSpeed
                        : this._speedSampler.lastSecondKBps
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(R.prototype, 'loaderType', {
                    get: function () {
                      return this._loader.type
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  (R.prototype._selectSeekHandler = function () {
                    var g = this._config
                    if (g.seekType === 'range')
                      this._seekHandler = new E.default(this._config.rangeLoadZeroStart)
                    else if (g.seekType === 'param') {
                      var A = g.seekParamStart || 'bstart',
                        S = g.seekParamEnd || 'bend'
                      this._seekHandler = new x.default(A, S)
                    } else if (g.seekType === 'custom') {
                      if (typeof g.customSeekHandler != 'function')
                        throw new T.InvalidArgumentException(
                          'Custom seekType specified in config but invalid customSeekHandler!'
                        )
                      this._seekHandler = new g.customSeekHandler()
                    } else
                      throw new T.InvalidArgumentException(
                        'Invalid seekType in config: ' + g.seekType
                      )
                  }),
                  (R.prototype._selectLoader = function () {
                    if (this._config.customLoader != null)
                      this._loaderClass = this._config.customLoader
                    else if (this._isWebSocketURL) this._loaderClass = v.default
                    else if (d.default.isSupported()) this._loaderClass = d.default
                    else if (m.default.isSupported()) this._loaderClass = m.default
                    else if (p.default.isSupported()) this._loaderClass = p.default
                    else
                      throw new T.RuntimeException(
                        "Your browser doesn't support xhr with arraybuffer responseType!"
                      )
                  }),
                  (R.prototype._createLoader = function () {
                    ;(this._loader = new this._loaderClass(this._seekHandler, this._config)),
                      this._loader.needStashBuffer === !1 && (this._enableStash = !1),
                      (this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this)),
                      (this._loader.onURLRedirect = this._onURLRedirect.bind(this)),
                      (this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this)),
                      (this._loader.onComplete = this._onLoaderComplete.bind(this)),
                      (this._loader.onError = this._onLoaderError.bind(this))
                  }),
                  (R.prototype.open = function (g) {
                    ;(this._currentRange = { from: 0, to: -1 }),
                      g && (this._currentRange.from = g),
                      this._speedSampler.reset(),
                      g || (this._fullRequestFlag = !0),
                      this._loader.open(this._dataSource, Object.assign({}, this._currentRange))
                  }),
                  (R.prototype.abort = function () {
                    this._loader.abort(),
                      this._paused && ((this._paused = !1), (this._resumeFrom = 0))
                  }),
                  (R.prototype.pause = function () {
                    this.isWorking() &&
                      (this._loader.abort(),
                      this._stashUsed !== 0
                        ? ((this._resumeFrom = this._stashByteStart),
                          (this._currentRange.to = this._stashByteStart - 1))
                        : (this._resumeFrom = this._currentRange.to + 1),
                      (this._stashUsed = 0),
                      (this._stashByteStart = 0),
                      (this._paused = !0))
                  }),
                  (R.prototype.resume = function () {
                    if (this._paused) {
                      this._paused = !1
                      var g = this._resumeFrom
                      ;(this._resumeFrom = 0), this._internalSeek(g, !0)
                    }
                  }),
                  (R.prototype.seek = function (g) {
                    ;(this._paused = !1),
                      (this._stashUsed = 0),
                      (this._stashByteStart = 0),
                      this._internalSeek(g, !0)
                  }),
                  (R.prototype._internalSeek = function (g, A) {
                    this._loader.isWorking() && this._loader.abort(),
                      this._flushStashBuffer(A),
                      this._loader.destroy(),
                      (this._loader = null)
                    var S = { from: g, to: -1 }
                    ;(this._currentRange = { from: S.from, to: -1 }),
                      this._speedSampler.reset(),
                      (this._stashSize = this._stashInitialSize),
                      this._createLoader(),
                      this._loader.open(this._dataSource, S),
                      this._onSeeked && this._onSeeked()
                  }),
                  (R.prototype.updateUrl = function (g) {
                    if (!g || typeof g != 'string' || g.length === 0)
                      throw new T.InvalidArgumentException('Url must be a non-empty string!')
                    this._dataSource.url = g
                  }),
                  (R.prototype._expandBuffer = function (g) {
                    for (var A = this._stashSize; A + 1024 * 1024 * 1 < g; ) A *= 2
                    if (((A += 1024 * 1024 * 1), A !== this._bufferSize)) {
                      var S = new ArrayBuffer(A)
                      if (this._stashUsed > 0) {
                        var h = new Uint8Array(this._stashBuffer, 0, this._stashUsed),
                          _ = new Uint8Array(S, 0, A)
                        _.set(h, 0)
                      }
                      ;(this._stashBuffer = S), (this._bufferSize = A)
                    }
                  }),
                  (R.prototype._normalizeSpeed = function (g) {
                    var A = this._speedNormalizeList,
                      S = A.length - 1,
                      h = 0,
                      _ = 0,
                      y = S
                    if (g < A[0]) return A[0]
                    for (; _ <= y; ) {
                      if (
                        ((h = _ + Math.floor((y - _) / 2)), h === S || (g >= A[h] && g < A[h + 1]))
                      )
                        return A[h]
                      A[h] < g ? (_ = h + 1) : (y = h - 1)
                    }
                  }),
                  (R.prototype._adjustStashSize = function (g) {
                    var A = 0
                    this._config.isLive || g < 512
                      ? (A = g)
                      : g >= 512 && g <= 1024
                      ? (A = Math.floor(g * 1.5))
                      : (A = g * 2),
                      A > 8192 && (A = 8192)
                    var S = A * 1024 + 1024 * 1024 * 1
                    this._bufferSize < S && this._expandBuffer(S), (this._stashSize = A * 1024)
                  }),
                  (R.prototype._dispatchChunks = function (g, A) {
                    return (this._currentRange.to = A + g.byteLength - 1), this._onDataArrival(g, A)
                  }),
                  (R.prototype._onURLRedirect = function (g) {
                    ;(this._redirectedURL = g), this._onRedirect && this._onRedirect(g)
                  }),
                  (R.prototype._onContentLengthKnown = function (g) {
                    g &&
                      this._fullRequestFlag &&
                      ((this._totalLength = g), (this._fullRequestFlag = !1))
                  }),
                  (R.prototype._onLoaderChunkArrival = function (g, A, S) {
                    if (!this._onDataArrival)
                      throw new T.IllegalStateException(
                        'IOController: No existing consumer (onDataArrival) callback!'
                      )
                    if (!this._paused) {
                      this._isEarlyEofReconnecting &&
                        ((this._isEarlyEofReconnecting = !1),
                        this._onRecoveredEarlyEof && this._onRecoveredEarlyEof()),
                        this._speedSampler.addBytes(g.byteLength)
                      var h = this._speedSampler.lastSecondKBps
                      if (h !== 0) {
                        var _ = this._normalizeSpeed(h)
                        this._speedNormalized !== _ &&
                          ((this._speedNormalized = _), this._adjustStashSize(_))
                      }
                      if (this._enableStash)
                        if (
                          (this._stashUsed === 0 &&
                            this._stashByteStart === 0 &&
                            (this._stashByteStart = A),
                          this._stashUsed + g.byteLength <= this._stashSize)
                        ) {
                          var I = new Uint8Array(this._stashBuffer, 0, this._stashSize)
                          I.set(new Uint8Array(g), this._stashUsed),
                            (this._stashUsed += g.byteLength)
                        } else {
                          var I = new Uint8Array(this._stashBuffer, 0, this._bufferSize)
                          if (this._stashUsed > 0) {
                            var D = this._stashBuffer.slice(0, this._stashUsed),
                              y = this._dispatchChunks(D, this._stashByteStart)
                            if (y < D.byteLength) {
                              if (y > 0) {
                                var P = new Uint8Array(D, y)
                                I.set(P, 0),
                                  (this._stashUsed = P.byteLength),
                                  (this._stashByteStart += y)
                              }
                            } else (this._stashUsed = 0), (this._stashByteStart += y)
                            this._stashUsed + g.byteLength > this._bufferSize &&
                              (this._expandBuffer(this._stashUsed + g.byteLength),
                              (I = new Uint8Array(this._stashBuffer, 0, this._bufferSize))),
                              I.set(new Uint8Array(g), this._stashUsed),
                              (this._stashUsed += g.byteLength)
                          } else {
                            var y = this._dispatchChunks(g, A)
                            if (y < g.byteLength) {
                              var L = g.byteLength - y
                              L > this._bufferSize &&
                                (this._expandBuffer(L),
                                (I = new Uint8Array(this._stashBuffer, 0, this._bufferSize))),
                                I.set(new Uint8Array(g, y), 0),
                                (this._stashUsed += L),
                                (this._stashByteStart = A + y)
                            }
                          }
                        }
                      else if (this._stashUsed === 0) {
                        var y = this._dispatchChunks(g, A)
                        if (y < g.byteLength) {
                          var L = g.byteLength - y
                          L > this._bufferSize && this._expandBuffer(L)
                          var I = new Uint8Array(this._stashBuffer, 0, this._bufferSize)
                          I.set(new Uint8Array(g, y), 0),
                            (this._stashUsed += L),
                            (this._stashByteStart = A + y)
                        }
                      } else {
                        this._stashUsed + g.byteLength > this._bufferSize &&
                          this._expandBuffer(this._stashUsed + g.byteLength)
                        var I = new Uint8Array(this._stashBuffer, 0, this._bufferSize)
                        I.set(new Uint8Array(g), this._stashUsed), (this._stashUsed += g.byteLength)
                        var y = this._dispatchChunks(
                          this._stashBuffer.slice(0, this._stashUsed),
                          this._stashByteStart
                        )
                        if (y < this._stashUsed && y > 0) {
                          var P = new Uint8Array(this._stashBuffer, y)
                          I.set(P, 0)
                        }
                        ;(this._stashUsed -= y), (this._stashByteStart += y)
                      }
                    }
                  }),
                  (R.prototype._flushStashBuffer = function (g) {
                    if (this._stashUsed > 0) {
                      var A = this._stashBuffer.slice(0, this._stashUsed),
                        S = this._dispatchChunks(A, this._stashByteStart),
                        h = A.byteLength - S
                      if (S < A.byteLength)
                        if (g)
                          u.default.w(
                            this.TAG,
                            h + ' bytes unconsumed data remain when flush buffer, dropped'
                          )
                        else {
                          if (S > 0) {
                            var _ = new Uint8Array(this._stashBuffer, 0, this._bufferSize),
                              y = new Uint8Array(A, S)
                            _.set(y, 0),
                              (this._stashUsed = y.byteLength),
                              (this._stashByteStart += S)
                          }
                          return 0
                        }
                      return (this._stashUsed = 0), (this._stashByteStart = 0), h
                    }
                    return 0
                  }),
                  (R.prototype._onLoaderComplete = function (g, A) {
                    this._flushStashBuffer(!0),
                      this._onComplete && this._onComplete(this._extraData)
                  }),
                  (R.prototype._onLoaderError = function (g, A) {
                    switch (
                      (u.default.e(this.TAG, 'Loader error, code = ' + A.code + ', msg = ' + A.msg),
                      this._flushStashBuffer(!1),
                      this._isEarlyEofReconnecting &&
                        ((this._isEarlyEofReconnecting = !1),
                        (g = f.LoaderErrors.UNRECOVERABLE_EARLY_EOF)),
                      g)
                    ) {
                      case f.LoaderErrors.EARLY_EOF: {
                        if (!this._config.isLive && this._totalLength) {
                          var S = this._currentRange.to + 1
                          S < this._totalLength &&
                            (u.default.w(this.TAG, 'Connection lost, trying reconnect...'),
                            (this._isEarlyEofReconnecting = !0),
                            this._internalSeek(S, !1))
                          return
                        }
                        g = f.LoaderErrors.UNRECOVERABLE_EARLY_EOF
                        break
                      }
                      case f.LoaderErrors.UNRECOVERABLE_EARLY_EOF:
                      case f.LoaderErrors.CONNECTING_TIMEOUT:
                      case f.LoaderErrors.HTTP_STATUS_CODE_INVALID:
                      case f.LoaderErrors.EXCEPTION:
                        break
                    }
                    if (this._onError) this._onError(g, A)
                    else throw new T.RuntimeException('IOException: ' + A.msg)
                  }),
                  R
                )
              })()
            o.default = b
          },
          './src/io/loader.js': function (a, o, l) {
            l.r(o),
              l.d(o, {
                LoaderStatus: function () {
                  return c
                },
                LoaderErrors: function () {
                  return f
                },
                BaseLoader: function () {
                  return d
                }
              })
            var u = l('./src/utils/exception.js'),
              c = { kIdle: 0, kConnecting: 1, kBuffering: 2, kError: 3, kComplete: 4 },
              f = {
                OK: 'OK',
                EXCEPTION: 'Exception',
                HTTP_STATUS_CODE_INVALID: 'HttpStatusCodeInvalid',
                CONNECTING_TIMEOUT: 'ConnectingTimeout',
                EARLY_EOF: 'EarlyEof',
                UNRECOVERABLE_EARLY_EOF: 'UnrecoverableEarlyEof'
              },
              d = (function () {
                function m(p) {
                  ;(this._type = p || 'undefined'),
                    (this._status = c.kIdle),
                    (this._needStash = !1),
                    (this._onContentLengthKnown = null),
                    (this._onURLRedirect = null),
                    (this._onDataArrival = null),
                    (this._onError = null),
                    (this._onComplete = null)
                }
                return (
                  (m.prototype.destroy = function () {
                    ;(this._status = c.kIdle),
                      (this._onContentLengthKnown = null),
                      (this._onURLRedirect = null),
                      (this._onDataArrival = null),
                      (this._onError = null),
                      (this._onComplete = null)
                  }),
                  (m.prototype.isWorking = function () {
                    return this._status === c.kConnecting || this._status === c.kBuffering
                  }),
                  Object.defineProperty(m.prototype, 'type', {
                    get: function () {
                      return this._type
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m.prototype, 'status', {
                    get: function () {
                      return this._status
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m.prototype, 'needStashBuffer', {
                    get: function () {
                      return this._needStash
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m.prototype, 'onContentLengthKnown', {
                    get: function () {
                      return this._onContentLengthKnown
                    },
                    set: function (p) {
                      this._onContentLengthKnown = p
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m.prototype, 'onURLRedirect', {
                    get: function () {
                      return this._onURLRedirect
                    },
                    set: function (p) {
                      this._onURLRedirect = p
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m.prototype, 'onDataArrival', {
                    get: function () {
                      return this._onDataArrival
                    },
                    set: function (p) {
                      this._onDataArrival = p
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m.prototype, 'onError', {
                    get: function () {
                      return this._onError
                    },
                    set: function (p) {
                      this._onError = p
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m.prototype, 'onComplete', {
                    get: function () {
                      return this._onComplete
                    },
                    set: function (p) {
                      this._onComplete = p
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  (m.prototype.open = function (p, v) {
                    throw new u.NotImplementedException('Unimplemented abstract function!')
                  }),
                  (m.prototype.abort = function () {
                    throw new u.NotImplementedException('Unimplemented abstract function!')
                  }),
                  m
                )
              })()
          },
          './src/io/param-seek-handler.js': function (a, o, l) {
            l.r(o)
            var u = (function () {
              function c(f, d) {
                ;(this._startName = f), (this._endName = d)
              }
              return (
                (c.prototype.getConfig = function (f, d) {
                  var m = f
                  if (d.from !== 0 || d.to !== -1) {
                    var p = !0
                    m.indexOf('?') === -1 && ((m += '?'), (p = !1)),
                      p && (m += '&'),
                      (m += this._startName + '=' + d.from.toString()),
                      d.to !== -1 && (m += '&' + this._endName + '=' + d.to.toString())
                  }
                  return { url: m, headers: {} }
                }),
                (c.prototype.removeURLParameters = function (f) {
                  var d = f.split('?')[0],
                    m = void 0,
                    p = f.indexOf('?')
                  p !== -1 && (m = f.substring(p + 1))
                  var v = ''
                  if (m != null && m.length > 0)
                    for (var E = m.split('&'), x = 0; x < E.length; x++) {
                      var T = E[x].split('='),
                        b = x > 0
                      T[0] !== this._startName &&
                        T[0] !== this._endName &&
                        (b && (v += '&'), (v += E[x]))
                    }
                  return v.length === 0 ? d : d + '?' + v
                }),
                c
              )
            })()
            o.default = u
          },
          './src/io/range-seek-handler.js': function (a, o, l) {
            l.r(o)
            var u = (function () {
              function c(f) {
                this._zeroStart = f || !1
              }
              return (
                (c.prototype.getConfig = function (f, d) {
                  var m = {}
                  if (d.from !== 0 || d.to !== -1) {
                    var p = void 0
                    d.to !== -1
                      ? (p = 'bytes=' + d.from.toString() + '-' + d.to.toString())
                      : (p = 'bytes=' + d.from.toString() + '-'),
                      (m.Range = p)
                  } else this._zeroStart && (m.Range = 'bytes=0-')
                  return { url: f, headers: m }
                }),
                (c.prototype.removeURLParameters = function (f) {
                  return f
                }),
                c
              )
            })()
            o.default = u
          },
          './src/io/speed-sampler.js': function (a, o, l) {
            l.r(o)
            var u = (function () {
              function c() {
                ;(this._firstCheckpoint = 0),
                  (this._lastCheckpoint = 0),
                  (this._intervalBytes = 0),
                  (this._totalBytes = 0),
                  (this._lastSecondBytes = 0),
                  self.performance && self.performance.now
                    ? (this._now = self.performance.now.bind(self.performance))
                    : (this._now = Date.now)
              }
              return (
                (c.prototype.reset = function () {
                  ;(this._firstCheckpoint = this._lastCheckpoint = 0),
                    (this._totalBytes = this._intervalBytes = 0),
                    (this._lastSecondBytes = 0)
                }),
                (c.prototype.addBytes = function (f) {
                  this._firstCheckpoint === 0
                    ? ((this._firstCheckpoint = this._now()),
                      (this._lastCheckpoint = this._firstCheckpoint),
                      (this._intervalBytes += f),
                      (this._totalBytes += f))
                    : this._now() - this._lastCheckpoint < 1e3
                    ? ((this._intervalBytes += f), (this._totalBytes += f))
                    : ((this._lastSecondBytes = this._intervalBytes),
                      (this._intervalBytes = f),
                      (this._totalBytes += f),
                      (this._lastCheckpoint = this._now()))
                }),
                Object.defineProperty(c.prototype, 'currentKBps', {
                  get: function () {
                    this.addBytes(0)
                    var f = (this._now() - this._lastCheckpoint) / 1e3
                    return f == 0 && (f = 1), this._intervalBytes / f / 1024
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(c.prototype, 'lastSecondKBps', {
                  get: function () {
                    return (
                      this.addBytes(0),
                      this._lastSecondBytes !== 0
                        ? this._lastSecondBytes / 1024
                        : this._now() - this._lastCheckpoint >= 500
                        ? this.currentKBps
                        : 0
                    )
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                Object.defineProperty(c.prototype, 'averageKBps', {
                  get: function () {
                    var f = (this._now() - this._firstCheckpoint) / 1e3
                    return this._totalBytes / f / 1024
                  },
                  enumerable: !1,
                  configurable: !0
                }),
                c
              )
            })()
            o.default = u
          },
          './src/io/websocket-loader.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/io/loader.js'),
              c = l('./src/utils/exception.js'),
              f = (function () {
                var m = function (p, v) {
                  return (
                    (m =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (E, x) {
                          E.__proto__ = x
                        }) ||
                      function (E, x) {
                        for (var T in x) Object.prototype.hasOwnProperty.call(x, T) && (E[T] = x[T])
                      }),
                    m(p, v)
                  )
                }
                return function (p, v) {
                  if (typeof v != 'function' && v !== null)
                    throw new TypeError(
                      'Class extends value ' + String(v) + ' is not a constructor or null'
                    )
                  m(p, v)
                  function E() {
                    this.constructor = p
                  }
                  p.prototype =
                    v === null ? Object.create(v) : ((E.prototype = v.prototype), new E())
                }
              })(),
              d = (function (m) {
                f(p, m)
                function p() {
                  var v = m.call(this, 'websocket-loader') || this
                  return (
                    (v.TAG = 'WebSocketLoader'),
                    (v._needStash = !0),
                    (v._ws = null),
                    (v._requestAbort = !1),
                    (v._receivedLength = 0),
                    v
                  )
                }
                return (
                  (p.isSupported = function () {
                    try {
                      return typeof self.WebSocket < 'u'
                    } catch {
                      return !1
                    }
                  }),
                  (p.prototype.destroy = function () {
                    this._ws && this.abort(), m.prototype.destroy.call(this)
                  }),
                  (p.prototype.open = function (v) {
                    try {
                      var E = (this._ws = new self.WebSocket(v.url))
                      ;(E.binaryType = 'arraybuffer'),
                        (E.onopen = this._onWebSocketOpen.bind(this)),
                        (E.onclose = this._onWebSocketClose.bind(this)),
                        (E.onmessage = this._onWebSocketMessage.bind(this)),
                        (E.onerror = this._onWebSocketError.bind(this)),
                        (this._status = u.LoaderStatus.kConnecting)
                    } catch (T) {
                      this._status = u.LoaderStatus.kError
                      var x = { code: T.code, msg: T.message }
                      if (this._onError) this._onError(u.LoaderErrors.EXCEPTION, x)
                      else throw new c.RuntimeException(x.msg)
                    }
                  }),
                  (p.prototype.abort = function () {
                    var v = this._ws
                    v &&
                      (v.readyState === 0 || v.readyState === 1) &&
                      ((this._requestAbort = !0), v.close()),
                      (this._ws = null),
                      (this._status = u.LoaderStatus.kComplete)
                  }),
                  (p.prototype._onWebSocketOpen = function (v) {
                    this._status = u.LoaderStatus.kBuffering
                  }),
                  (p.prototype._onWebSocketClose = function (v) {
                    if (this._requestAbort === !0) {
                      this._requestAbort = !1
                      return
                    }
                    ;(this._status = u.LoaderStatus.kComplete),
                      this._onComplete && this._onComplete(0, this._receivedLength - 1)
                  }),
                  (p.prototype._onWebSocketMessage = function (v) {
                    var E = this
                    if (v.data instanceof ArrayBuffer) this._dispatchArrayBuffer(v.data)
                    else if (v.data instanceof Blob) {
                      var x = new FileReader()
                      ;(x.onload = function () {
                        E._dispatchArrayBuffer(x.result)
                      }),
                        x.readAsArrayBuffer(v.data)
                    } else {
                      this._status = u.LoaderStatus.kError
                      var T = {
                        code: -1,
                        msg: 'Unsupported WebSocket message type: ' + v.data.constructor.name
                      }
                      if (this._onError) this._onError(u.LoaderErrors.EXCEPTION, T)
                      else throw new c.RuntimeException(T.msg)
                    }
                  }),
                  (p.prototype._dispatchArrayBuffer = function (v) {
                    var E = v,
                      x = this._receivedLength
                    ;(this._receivedLength += E.byteLength),
                      this._onDataArrival && this._onDataArrival(E, x, this._receivedLength)
                  }),
                  (p.prototype._onWebSocketError = function (v) {
                    this._status = u.LoaderStatus.kError
                    var E = { code: v.code, msg: v.message }
                    if (this._onError) this._onError(u.LoaderErrors.EXCEPTION, E)
                    else throw new c.RuntimeException(E.msg)
                  }),
                  p
                )
              })(u.BaseLoader)
            o.default = d
          },
          './src/io/xhr-moz-chunked-loader.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/utils/logger.js'),
              c = l('./src/io/loader.js'),
              f = l('./src/utils/exception.js'),
              d = (function () {
                var p = function (v, E) {
                  return (
                    (p =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (x, T) {
                          x.__proto__ = T
                        }) ||
                      function (x, T) {
                        for (var b in T) Object.prototype.hasOwnProperty.call(T, b) && (x[b] = T[b])
                      }),
                    p(v, E)
                  )
                }
                return function (v, E) {
                  if (typeof E != 'function' && E !== null)
                    throw new TypeError(
                      'Class extends value ' + String(E) + ' is not a constructor or null'
                    )
                  p(v, E)
                  function x() {
                    this.constructor = v
                  }
                  v.prototype =
                    E === null ? Object.create(E) : ((x.prototype = E.prototype), new x())
                }
              })(),
              m = (function (p) {
                d(v, p)
                function v(E, x) {
                  var T = p.call(this, 'xhr-moz-chunked-loader') || this
                  return (
                    (T.TAG = 'MozChunkedLoader'),
                    (T._seekHandler = E),
                    (T._config = x),
                    (T._needStash = !0),
                    (T._xhr = null),
                    (T._requestAbort = !1),
                    (T._contentLength = null),
                    (T._receivedLength = 0),
                    T
                  )
                }
                return (
                  (v.isSupported = function () {
                    try {
                      var E = new XMLHttpRequest()
                      return (
                        E.open('GET', 'https://example.com', !0),
                        (E.responseType = 'moz-chunked-arraybuffer'),
                        E.responseType === 'moz-chunked-arraybuffer'
                      )
                    } catch (x) {
                      return u.default.w('MozChunkedLoader', x.message), !1
                    }
                  }),
                  (v.prototype.destroy = function () {
                    this.isWorking() && this.abort(),
                      this._xhr &&
                        ((this._xhr.onreadystatechange = null),
                        (this._xhr.onprogress = null),
                        (this._xhr.onloadend = null),
                        (this._xhr.onerror = null),
                        (this._xhr = null)),
                      p.prototype.destroy.call(this)
                  }),
                  (v.prototype.open = function (E, x) {
                    ;(this._dataSource = E), (this._range = x)
                    var T = E.url
                    this._config.reuseRedirectedURL &&
                      E.redirectedURL != null &&
                      (T = E.redirectedURL)
                    var b = this._seekHandler.getConfig(T, x)
                    this._requestURL = b.url
                    var R = (this._xhr = new XMLHttpRequest())
                    if (
                      (R.open('GET', b.url, !0),
                      (R.responseType = 'moz-chunked-arraybuffer'),
                      (R.onreadystatechange = this._onReadyStateChange.bind(this)),
                      (R.onprogress = this._onProgress.bind(this)),
                      (R.onloadend = this._onLoadEnd.bind(this)),
                      (R.onerror = this._onXhrError.bind(this)),
                      E.withCredentials && (R.withCredentials = !0),
                      typeof b.headers == 'object')
                    ) {
                      var g = b.headers
                      for (var A in g) g.hasOwnProperty(A) && R.setRequestHeader(A, g[A])
                    }
                    if (typeof this._config.headers == 'object') {
                      var g = this._config.headers
                      for (var A in g) g.hasOwnProperty(A) && R.setRequestHeader(A, g[A])
                    }
                    ;(this._status = c.LoaderStatus.kConnecting), R.send()
                  }),
                  (v.prototype.abort = function () {
                    ;(this._requestAbort = !0),
                      this._xhr && this._xhr.abort(),
                      (this._status = c.LoaderStatus.kComplete)
                  }),
                  (v.prototype._onReadyStateChange = function (E) {
                    var x = E.target
                    if (x.readyState === 2) {
                      if (
                        x.responseURL != null &&
                        x.responseURL !== this._requestURL &&
                        this._onURLRedirect
                      ) {
                        var T = this._seekHandler.removeURLParameters(x.responseURL)
                        this._onURLRedirect(T)
                      }
                      if (x.status !== 0 && (x.status < 200 || x.status > 299))
                        if (((this._status = c.LoaderStatus.kError), this._onError))
                          this._onError(c.LoaderErrors.HTTP_STATUS_CODE_INVALID, {
                            code: x.status,
                            msg: x.statusText
                          })
                        else
                          throw new f.RuntimeException(
                            'MozChunkedLoader: Http code invalid, ' + x.status + ' ' + x.statusText
                          )
                      else this._status = c.LoaderStatus.kBuffering
                    }
                  }),
                  (v.prototype._onProgress = function (E) {
                    if (this._status !== c.LoaderStatus.kError) {
                      this._contentLength === null &&
                        E.total !== null &&
                        E.total !== 0 &&
                        ((this._contentLength = E.total),
                        this._onContentLengthKnown &&
                          this._onContentLengthKnown(this._contentLength))
                      var x = E.target.response,
                        T = this._range.from + this._receivedLength
                      ;(this._receivedLength += x.byteLength),
                        this._onDataArrival && this._onDataArrival(x, T, this._receivedLength)
                    }
                  }),
                  (v.prototype._onLoadEnd = function (E) {
                    if (this._requestAbort === !0) {
                      this._requestAbort = !1
                      return
                    } else if (this._status === c.LoaderStatus.kError) return
                    ;(this._status = c.LoaderStatus.kComplete),
                      this._onComplete &&
                        this._onComplete(
                          this._range.from,
                          this._range.from + this._receivedLength - 1
                        )
                  }),
                  (v.prototype._onXhrError = function (E) {
                    this._status = c.LoaderStatus.kError
                    var x = 0,
                      T = null
                    if (
                      (this._contentLength && E.loaded < this._contentLength
                        ? ((x = c.LoaderErrors.EARLY_EOF),
                          (T = { code: -1, msg: 'Moz-Chunked stream meet Early-Eof' }))
                        : ((x = c.LoaderErrors.EXCEPTION),
                          (T = { code: -1, msg: E.constructor.name + ' ' + E.type })),
                      this._onError)
                    )
                      this._onError(x, T)
                    else throw new f.RuntimeException(T.msg)
                  }),
                  v
                )
              })(c.BaseLoader)
            o.default = m
          },
          './src/io/xhr-range-loader.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/utils/logger.js'),
              c = l('./src/io/speed-sampler.js'),
              f = l('./src/io/loader.js'),
              d = l('./src/utils/exception.js'),
              m = (function () {
                var v = function (E, x) {
                  return (
                    (v =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (T, b) {
                          T.__proto__ = b
                        }) ||
                      function (T, b) {
                        for (var R in b) Object.prototype.hasOwnProperty.call(b, R) && (T[R] = b[R])
                      }),
                    v(E, x)
                  )
                }
                return function (E, x) {
                  if (typeof x != 'function' && x !== null)
                    throw new TypeError(
                      'Class extends value ' + String(x) + ' is not a constructor or null'
                    )
                  v(E, x)
                  function T() {
                    this.constructor = E
                  }
                  E.prototype =
                    x === null ? Object.create(x) : ((T.prototype = x.prototype), new T())
                }
              })(),
              p = (function (v) {
                m(E, v)
                function E(x, T) {
                  var b = v.call(this, 'xhr-range-loader') || this
                  return (
                    (b.TAG = 'RangeLoader'),
                    (b._seekHandler = x),
                    (b._config = T),
                    (b._needStash = !1),
                    (b._chunkSizeKBList = [
                      128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 5120, 6144, 7168, 8192
                    ]),
                    (b._currentChunkSizeKB = 384),
                    (b._currentSpeedNormalized = 0),
                    (b._zeroSpeedChunkCount = 0),
                    (b._xhr = null),
                    (b._speedSampler = new c.default()),
                    (b._requestAbort = !1),
                    (b._waitForTotalLength = !1),
                    (b._totalLengthReceived = !1),
                    (b._currentRequestURL = null),
                    (b._currentRedirectedURL = null),
                    (b._currentRequestRange = null),
                    (b._totalLength = null),
                    (b._contentLength = null),
                    (b._receivedLength = 0),
                    (b._lastTimeLoaded = 0),
                    b
                  )
                }
                return (
                  (E.isSupported = function () {
                    try {
                      var x = new XMLHttpRequest()
                      return (
                        x.open('GET', 'https://example.com', !0),
                        (x.responseType = 'arraybuffer'),
                        x.responseType === 'arraybuffer'
                      )
                    } catch (T) {
                      return u.default.w('RangeLoader', T.message), !1
                    }
                  }),
                  (E.prototype.destroy = function () {
                    this.isWorking() && this.abort(),
                      this._xhr &&
                        ((this._xhr.onreadystatechange = null),
                        (this._xhr.onprogress = null),
                        (this._xhr.onload = null),
                        (this._xhr.onerror = null),
                        (this._xhr = null)),
                      v.prototype.destroy.call(this)
                  }),
                  Object.defineProperty(E.prototype, 'currentSpeed', {
                    get: function () {
                      return this._speedSampler.lastSecondKBps
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  (E.prototype.open = function (x, T) {
                    ;(this._dataSource = x),
                      (this._range = T),
                      (this._status = f.LoaderStatus.kConnecting)
                    var b = !1
                    this._dataSource.filesize != null &&
                      this._dataSource.filesize !== 0 &&
                      ((b = !0), (this._totalLength = this._dataSource.filesize)),
                      !this._totalLengthReceived && !b
                        ? ((this._waitForTotalLength = !0),
                          this._internalOpen(this._dataSource, { from: 0, to: -1 }))
                        : this._openSubRange()
                  }),
                  (E.prototype._openSubRange = function () {
                    var x = this._currentChunkSizeKB * 1024,
                      T = this._range.from + this._receivedLength,
                      b = T + x
                    this._contentLength != null &&
                      b - this._range.from >= this._contentLength &&
                      (b = this._range.from + this._contentLength - 1),
                      (this._currentRequestRange = { from: T, to: b }),
                      this._internalOpen(this._dataSource, this._currentRequestRange)
                  }),
                  (E.prototype._internalOpen = function (x, T) {
                    this._lastTimeLoaded = 0
                    var b = x.url
                    this._config.reuseRedirectedURL &&
                      (this._currentRedirectedURL != null
                        ? (b = this._currentRedirectedURL)
                        : x.redirectedURL != null && (b = x.redirectedURL))
                    var R = this._seekHandler.getConfig(b, T)
                    this._currentRequestURL = R.url
                    var g = (this._xhr = new XMLHttpRequest())
                    if (
                      (g.open('GET', R.url, !0),
                      (g.responseType = 'arraybuffer'),
                      (g.onreadystatechange = this._onReadyStateChange.bind(this)),
                      (g.onprogress = this._onProgress.bind(this)),
                      (g.onload = this._onLoad.bind(this)),
                      (g.onerror = this._onXhrError.bind(this)),
                      x.withCredentials && (g.withCredentials = !0),
                      typeof R.headers == 'object')
                    ) {
                      var A = R.headers
                      for (var S in A) A.hasOwnProperty(S) && g.setRequestHeader(S, A[S])
                    }
                    if (typeof this._config.headers == 'object') {
                      var A = this._config.headers
                      for (var S in A) A.hasOwnProperty(S) && g.setRequestHeader(S, A[S])
                    }
                    g.send()
                  }),
                  (E.prototype.abort = function () {
                    ;(this._requestAbort = !0),
                      this._internalAbort(),
                      (this._status = f.LoaderStatus.kComplete)
                  }),
                  (E.prototype._internalAbort = function () {
                    this._xhr &&
                      ((this._xhr.onreadystatechange = null),
                      (this._xhr.onprogress = null),
                      (this._xhr.onload = null),
                      (this._xhr.onerror = null),
                      this._xhr.abort(),
                      (this._xhr = null))
                  }),
                  (E.prototype._onReadyStateChange = function (x) {
                    var T = x.target
                    if (T.readyState === 2) {
                      if (T.responseURL != null) {
                        var b = this._seekHandler.removeURLParameters(T.responseURL)
                        T.responseURL !== this._currentRequestURL &&
                          b !== this._currentRedirectedURL &&
                          ((this._currentRedirectedURL = b),
                          this._onURLRedirect && this._onURLRedirect(b))
                      }
                      if (T.status >= 200 && T.status <= 299) {
                        if (this._waitForTotalLength) return
                        this._status = f.LoaderStatus.kBuffering
                      } else if (((this._status = f.LoaderStatus.kError), this._onError))
                        this._onError(f.LoaderErrors.HTTP_STATUS_CODE_INVALID, {
                          code: T.status,
                          msg: T.statusText
                        })
                      else
                        throw new d.RuntimeException(
                          'RangeLoader: Http code invalid, ' + T.status + ' ' + T.statusText
                        )
                    }
                  }),
                  (E.prototype._onProgress = function (x) {
                    if (this._status !== f.LoaderStatus.kError) {
                      if (this._contentLength === null) {
                        var T = !1
                        if (this._waitForTotalLength) {
                          ;(this._waitForTotalLength = !1),
                            (this._totalLengthReceived = !0),
                            (T = !0)
                          var b = x.total
                          this._internalAbort(), (b != null) & (b !== 0) && (this._totalLength = b)
                        }
                        if (
                          (this._range.to === -1
                            ? (this._contentLength = this._totalLength - this._range.from)
                            : (this._contentLength = this._range.to - this._range.from + 1),
                          T)
                        ) {
                          this._openSubRange()
                          return
                        }
                        this._onContentLengthKnown &&
                          this._onContentLengthKnown(this._contentLength)
                      }
                      var R = x.loaded - this._lastTimeLoaded
                      ;(this._lastTimeLoaded = x.loaded), this._speedSampler.addBytes(R)
                    }
                  }),
                  (E.prototype._normalizeSpeed = function (x) {
                    var T = this._chunkSizeKBList,
                      b = T.length - 1,
                      R = 0,
                      g = 0,
                      A = b
                    if (x < T[0]) return T[0]
                    for (; g <= A; ) {
                      if (
                        ((R = g + Math.floor((A - g) / 2)), R === b || (x >= T[R] && x < T[R + 1]))
                      )
                        return T[R]
                      T[R] < x ? (g = R + 1) : (A = R - 1)
                    }
                  }),
                  (E.prototype._onLoad = function (x) {
                    if (this._status !== f.LoaderStatus.kError) {
                      if (this._waitForTotalLength) {
                        this._waitForTotalLength = !1
                        return
                      }
                      this._lastTimeLoaded = 0
                      var T = this._speedSampler.lastSecondKBps
                      if (
                        (T === 0 &&
                          (this._zeroSpeedChunkCount++,
                          this._zeroSpeedChunkCount >= 3 && (T = this._speedSampler.currentKBps)),
                        T !== 0)
                      ) {
                        var b = this._normalizeSpeed(T)
                        this._currentSpeedNormalized !== b &&
                          ((this._currentSpeedNormalized = b), (this._currentChunkSizeKB = b))
                      }
                      var R = x.target.response,
                        g = this._range.from + this._receivedLength
                      this._receivedLength += R.byteLength
                      var A = !1
                      this._contentLength != null && this._receivedLength < this._contentLength
                        ? this._openSubRange()
                        : (A = !0),
                        this._onDataArrival && this._onDataArrival(R, g, this._receivedLength),
                        A &&
                          ((this._status = f.LoaderStatus.kComplete),
                          this._onComplete &&
                            this._onComplete(
                              this._range.from,
                              this._range.from + this._receivedLength - 1
                            ))
                    }
                  }),
                  (E.prototype._onXhrError = function (x) {
                    this._status = f.LoaderStatus.kError
                    var T = 0,
                      b = null
                    if (
                      (this._contentLength &&
                      this._receivedLength > 0 &&
                      this._receivedLength < this._contentLength
                        ? ((T = f.LoaderErrors.EARLY_EOF),
                          (b = { code: -1, msg: 'RangeLoader meet Early-Eof' }))
                        : ((T = f.LoaderErrors.EXCEPTION),
                          (b = { code: -1, msg: x.constructor.name + ' ' + x.type })),
                      this._onError)
                    )
                      this._onError(T, b)
                    else throw new d.RuntimeException(b.msg)
                  }),
                  E
                )
              })(f.BaseLoader)
            o.default = p
          },
          './src/player/flv-player.js': function (a, o, l) {
            l.r(o)
            var u = l('./node_modules/events/events.js'),
              c = l.n(u),
              f = l('./src/utils/logger.js'),
              d = l('./src/utils/browser.js'),
              m = l('./src/player/player-events.js'),
              p = l('./src/core/transmuxer.js'),
              v = l('./src/core/transmuxing-events.js'),
              E = l('./src/core/mse-controller.js'),
              x = l('./src/core/mse-events.js'),
              T = l('./src/player/player-errors.js'),
              b = l('./src/config.js'),
              R = l('./src/utils/exception.js'),
              g = (function () {
                function A(S, h) {
                  if (
                    ((this.TAG = 'FlvPlayer'),
                    (this._type = 'FlvPlayer'),
                    (this._emitter = new (c())()),
                    (this._config = (0, b.createDefaultConfig)()),
                    typeof h == 'object' && Object.assign(this._config, h),
                    S.type.toLowerCase() !== 'flv')
                  )
                    throw new R.InvalidArgumentException(
                      'FlvPlayer requires an flv MediaDataSource input!'
                    )
                  S.isLive === !0 && (this._config.isLive = !0),
                    (this.e = {
                      onvLoadedMetadata: this._onvLoadedMetadata.bind(this),
                      onvSeeking: this._onvSeeking.bind(this),
                      onvCanPlay: this._onvCanPlay.bind(this),
                      onvStalled: this._onvStalled.bind(this),
                      onvProgress: this._onvProgress.bind(this)
                    }),
                    self.performance && self.performance.now
                      ? (this._now = self.performance.now.bind(self.performance))
                      : (this._now = Date.now),
                    (this._pendingSeekTime = null),
                    (this._requestSetTime = !1),
                    (this._seekpointRecord = null),
                    (this._progressChecker = null),
                    (this._mediaDataSource = S),
                    (this._mediaElement = null),
                    (this._msectl = null),
                    (this._transmuxer = null),
                    (this._mseSourceOpened = !1),
                    (this._hasPendingLoad = !1),
                    (this._receivedCanPlay = !1),
                    (this._mediaInfo = null),
                    (this._statisticsInfo = null)
                  var _ =
                    d.default.chrome &&
                    (d.default.version.major < 50 ||
                      (d.default.version.major === 50 && d.default.version.build < 2661))
                  ;(this._alwaysSeekKeyframe = !!(_ || d.default.msedge || d.default.msie)),
                    this._alwaysSeekKeyframe && (this._config.accurateSeek = !1)
                }
                return (
                  (A.prototype.destroy = function () {
                    this._progressChecker != null &&
                      (window.clearInterval(this._progressChecker), (this._progressChecker = null)),
                      this._transmuxer && this.unload(),
                      this._mediaElement && this.detachMediaElement(),
                      (this.e = null),
                      (this._mediaDataSource = null),
                      this._emitter.removeAllListeners(),
                      (this._emitter = null)
                  }),
                  (A.prototype.on = function (S, h) {
                    var _ = this
                    S === m.default.MEDIA_INFO
                      ? this._mediaInfo != null &&
                        Promise.resolve().then(function () {
                          _._emitter.emit(m.default.MEDIA_INFO, _.mediaInfo)
                        })
                      : S === m.default.STATISTICS_INFO &&
                        this._statisticsInfo != null &&
                        Promise.resolve().then(function () {
                          _._emitter.emit(m.default.STATISTICS_INFO, _.statisticsInfo)
                        }),
                      this._emitter.addListener(S, h)
                  }),
                  (A.prototype.off = function (S, h) {
                    this._emitter.removeListener(S, h)
                  }),
                  (A.prototype.attachMediaElement = function (S) {
                    var h = this
                    if (
                      ((this._mediaElement = S),
                      S.addEventListener('loadedmetadata', this.e.onvLoadedMetadata),
                      S.addEventListener('seeking', this.e.onvSeeking),
                      S.addEventListener('canplay', this.e.onvCanPlay),
                      S.addEventListener('stalled', this.e.onvStalled),
                      S.addEventListener('progress', this.e.onvProgress),
                      (this._msectl = new E.default(this._config)),
                      this._msectl.on(x.default.UPDATE_END, this._onmseUpdateEnd.bind(this)),
                      this._msectl.on(x.default.BUFFER_FULL, this._onmseBufferFull.bind(this)),
                      this._msectl.on(x.default.SOURCE_OPEN, function () {
                        ;(h._mseSourceOpened = !0),
                          h._hasPendingLoad && ((h._hasPendingLoad = !1), h.load())
                      }),
                      this._msectl.on(x.default.ERROR, function (_) {
                        h._emitter.emit(
                          m.default.ERROR,
                          T.ErrorTypes.MEDIA_ERROR,
                          T.ErrorDetails.MEDIA_MSE_ERROR,
                          _
                        )
                      }),
                      this._msectl.attachMediaElement(S),
                      this._pendingSeekTime != null)
                    )
                      try {
                        ;(S.currentTime = this._pendingSeekTime), (this._pendingSeekTime = null)
                      } catch {}
                  }),
                  (A.prototype.detachMediaElement = function () {
                    this._mediaElement &&
                      (this._msectl.detachMediaElement(),
                      this._mediaElement.removeEventListener(
                        'loadedmetadata',
                        this.e.onvLoadedMetadata
                      ),
                      this._mediaElement.removeEventListener('seeking', this.e.onvSeeking),
                      this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay),
                      this._mediaElement.removeEventListener('stalled', this.e.onvStalled),
                      this._mediaElement.removeEventListener('progress', this.e.onvProgress),
                      (this._mediaElement = null)),
                      this._msectl && (this._msectl.destroy(), (this._msectl = null))
                  }),
                  (A.prototype.load = function () {
                    var S = this
                    if (!this._mediaElement)
                      throw new R.IllegalStateException(
                        'HTMLMediaElement must be attached before load()!'
                      )
                    if (this._transmuxer)
                      throw new R.IllegalStateException(
                        'FlvPlayer.load() has been called, please call unload() first!'
                      )
                    if (!this._hasPendingLoad) {
                      if (this._config.deferLoadAfterSourceOpen && this._mseSourceOpened === !1) {
                        this._hasPendingLoad = !0
                        return
                      }
                      this._mediaElement.readyState > 0 &&
                        ((this._requestSetTime = !0), (this._mediaElement.currentTime = 0)),
                        (this._transmuxer = new p.default(this._mediaDataSource, this._config)),
                        this._transmuxer.on(v.default.INIT_SEGMENT, function (h, _) {
                          S._msectl.appendInitSegment(_)
                        }),
                        this._transmuxer.on(v.default.MEDIA_SEGMENT, function (h, _) {
                          if (
                            (S._msectl.appendMediaSegment(_),
                            S._config.lazyLoad && !S._config.isLive)
                          ) {
                            var y = S._mediaElement.currentTime
                            _.info.endDts >= (y + S._config.lazyLoadMaxDuration) * 1e3 &&
                              S._progressChecker == null &&
                              (f.default.v(
                                S.TAG,
                                'Maximum buffering duration exceeded, suspend transmuxing task'
                              ),
                              S._suspendTransmuxer())
                          }
                        }),
                        this._transmuxer.on(v.default.LOADING_COMPLETE, function () {
                          S._msectl.endOfStream(), S._emitter.emit(m.default.LOADING_COMPLETE)
                        }),
                        this._transmuxer.on(v.default.RECOVERED_EARLY_EOF, function () {
                          S._emitter.emit(m.default.RECOVERED_EARLY_EOF)
                        }),
                        this._transmuxer.on(v.default.IO_ERROR, function (h, _) {
                          S._emitter.emit(m.default.ERROR, T.ErrorTypes.NETWORK_ERROR, h, _)
                        }),
                        this._transmuxer.on(v.default.DEMUX_ERROR, function (h, _) {
                          S._emitter.emit(m.default.ERROR, T.ErrorTypes.MEDIA_ERROR, h, {
                            code: -1,
                            msg: _
                          })
                        }),
                        this._transmuxer.on(v.default.MEDIA_INFO, function (h) {
                          ;(S._mediaInfo = h),
                            S._emitter.emit(m.default.MEDIA_INFO, Object.assign({}, h))
                        }),
                        this._transmuxer.on(v.default.METADATA_ARRIVED, function (h) {
                          S._emitter.emit(m.default.METADATA_ARRIVED, h)
                        }),
                        this._transmuxer.on(v.default.SCRIPTDATA_ARRIVED, function (h) {
                          S._emitter.emit(m.default.SCRIPTDATA_ARRIVED, h)
                        }),
                        this._transmuxer.on(v.default.STATISTICS_INFO, function (h) {
                          ;(S._statisticsInfo = S._fillStatisticsInfo(h)),
                            S._emitter.emit(
                              m.default.STATISTICS_INFO,
                              Object.assign({}, S._statisticsInfo)
                            )
                        }),
                        this._transmuxer.on(v.default.RECOMMEND_SEEKPOINT, function (h) {
                          S._mediaElement &&
                            !S._config.accurateSeek &&
                            ((S._requestSetTime = !0), (S._mediaElement.currentTime = h / 1e3))
                        }),
                        this._transmuxer.open()
                    }
                  }),
                  (A.prototype.unload = function () {
                    this._mediaElement && this._mediaElement.pause(),
                      this._msectl && this._msectl.seek(0),
                      this._transmuxer &&
                        (this._transmuxer.close(),
                        this._transmuxer.destroy(),
                        (this._transmuxer = null))
                  }),
                  (A.prototype.play = function () {
                    return this._mediaElement.play()
                  }),
                  (A.prototype.pause = function () {
                    this._mediaElement.pause()
                  }),
                  Object.defineProperty(A.prototype, 'type', {
                    get: function () {
                      return this._type
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(A.prototype, 'buffered', {
                    get: function () {
                      return this._mediaElement.buffered
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(A.prototype, 'duration', {
                    get: function () {
                      return this._mediaElement.duration
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(A.prototype, 'volume', {
                    get: function () {
                      return this._mediaElement.volume
                    },
                    set: function (S) {
                      this._mediaElement.volume = S
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(A.prototype, 'muted', {
                    get: function () {
                      return this._mediaElement.muted
                    },
                    set: function (S) {
                      this._mediaElement.muted = S
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(A.prototype, 'currentTime', {
                    get: function () {
                      return this._mediaElement ? this._mediaElement.currentTime : 0
                    },
                    set: function (S) {
                      this._mediaElement ? this._internalSeek(S) : (this._pendingSeekTime = S)
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(A.prototype, 'mediaInfo', {
                    get: function () {
                      return Object.assign({}, this._mediaInfo)
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(A.prototype, 'statisticsInfo', {
                    get: function () {
                      return (
                        this._statisticsInfo == null && (this._statisticsInfo = {}),
                        (this._statisticsInfo = this._fillStatisticsInfo(this._statisticsInfo)),
                        Object.assign({}, this._statisticsInfo)
                      )
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  (A.prototype._fillStatisticsInfo = function (S) {
                    if (
                      ((S.playerType = this._type),
                      !(this._mediaElement instanceof HTMLVideoElement))
                    )
                      return S
                    var h = !0,
                      _ = 0,
                      y = 0
                    if (this._mediaElement.getVideoPlaybackQuality) {
                      var L = this._mediaElement.getVideoPlaybackQuality()
                      ;(_ = L.totalVideoFrames), (y = L.droppedVideoFrames)
                    } else
                      this._mediaElement.webkitDecodedFrameCount != null
                        ? ((_ = this._mediaElement.webkitDecodedFrameCount),
                          (y = this._mediaElement.webkitDroppedFrameCount))
                        : (h = !1)
                    return h && ((S.decodedFrames = _), (S.droppedFrames = y)), S
                  }),
                  (A.prototype._onmseUpdateEnd = function () {
                    if (!(!this._config.lazyLoad || this._config.isLive)) {
                      for (
                        var S = this._mediaElement.buffered,
                          h = this._mediaElement.currentTime,
                          _ = 0,
                          y = 0;
                        y < S.length;
                        y++
                      ) {
                        var L = S.start(y),
                          I = S.end(y)
                        if (L <= h && h < I) {
                          _ = I
                          break
                        }
                      }
                      _ >= h + this._config.lazyLoadMaxDuration &&
                        this._progressChecker == null &&
                        (f.default.v(
                          this.TAG,
                          'Maximum buffering duration exceeded, suspend transmuxing task'
                        ),
                        this._suspendTransmuxer())
                    }
                  }),
                  (A.prototype._onmseBufferFull = function () {
                    f.default.v(this.TAG, 'MSE SourceBuffer is full, suspend transmuxing task'),
                      this._progressChecker == null && this._suspendTransmuxer()
                  }),
                  (A.prototype._suspendTransmuxer = function () {
                    this._transmuxer &&
                      (this._transmuxer.pause(),
                      this._progressChecker == null &&
                        (this._progressChecker = window.setInterval(
                          this._checkProgressAndResume.bind(this),
                          1e3
                        )))
                  }),
                  (A.prototype._checkProgressAndResume = function () {
                    for (
                      var S = this._mediaElement.currentTime,
                        h = this._mediaElement.buffered,
                        _ = !1,
                        y = 0;
                      y < h.length;
                      y++
                    ) {
                      var L = h.start(y),
                        I = h.end(y)
                      if (S >= L && S < I) {
                        S >= I - this._config.lazyLoadRecoverDuration && (_ = !0)
                        break
                      }
                    }
                    _ &&
                      (window.clearInterval(this._progressChecker),
                      (this._progressChecker = null),
                      _ &&
                        (f.default.v(this.TAG, 'Continue loading from paused position'),
                        this._transmuxer.resume()))
                  }),
                  (A.prototype._isTimepointBuffered = function (S) {
                    for (var h = this._mediaElement.buffered, _ = 0; _ < h.length; _++) {
                      var y = h.start(_),
                        L = h.end(_)
                      if (S >= y && S < L) return !0
                    }
                    return !1
                  }),
                  (A.prototype._internalSeek = function (S) {
                    var h = this._isTimepointBuffered(S),
                      _ = !1,
                      y = 0
                    if (S < 1 && this._mediaElement.buffered.length > 0) {
                      var L = this._mediaElement.buffered.start(0)
                      ;((L < 1 && S < L) || d.default.safari) &&
                        ((_ = !0), (y = d.default.safari ? 0.1 : L))
                    }
                    if (_) (this._requestSetTime = !0), (this._mediaElement.currentTime = y)
                    else if (h) {
                      if (!this._alwaysSeekKeyframe)
                        (this._requestSetTime = !0), (this._mediaElement.currentTime = S)
                      else {
                        var I = this._msectl.getNearestKeyframe(Math.floor(S * 1e3))
                        ;(this._requestSetTime = !0),
                          I != null
                            ? (this._mediaElement.currentTime = I.dts / 1e3)
                            : (this._mediaElement.currentTime = S)
                      }
                      this._progressChecker != null && this._checkProgressAndResume()
                    } else
                      this._progressChecker != null &&
                        (window.clearInterval(this._progressChecker),
                        (this._progressChecker = null)),
                        this._msectl.seek(S),
                        this._transmuxer.seek(Math.floor(S * 1e3)),
                        this._config.accurateSeek &&
                          ((this._requestSetTime = !0), (this._mediaElement.currentTime = S))
                  }),
                  (A.prototype._checkAndApplyUnbufferedSeekpoint = function () {
                    if (this._seekpointRecord)
                      if (this._seekpointRecord.recordTime <= this._now() - 100) {
                        var S = this._mediaElement.currentTime
                        ;(this._seekpointRecord = null),
                          this._isTimepointBuffered(S) ||
                            (this._progressChecker != null &&
                              (window.clearTimeout(this._progressChecker),
                              (this._progressChecker = null)),
                            this._msectl.seek(S),
                            this._transmuxer.seek(Math.floor(S * 1e3)),
                            this._config.accurateSeek &&
                              ((this._requestSetTime = !0), (this._mediaElement.currentTime = S)))
                      } else
                        window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50)
                  }),
                  (A.prototype._checkAndResumeStuckPlayback = function (S) {
                    var h = this._mediaElement
                    if (S || !this._receivedCanPlay || h.readyState < 2) {
                      var _ = h.buffered
                      _.length > 0 &&
                        h.currentTime < _.start(0) &&
                        (f.default.w(
                          this.TAG,
                          'Playback seems stuck at ' + h.currentTime + ', seek to ' + _.start(0)
                        ),
                        (this._requestSetTime = !0),
                        (this._mediaElement.currentTime = _.start(0)),
                        this._mediaElement.removeEventListener('progress', this.e.onvProgress))
                    } else this._mediaElement.removeEventListener('progress', this.e.onvProgress)
                  }),
                  (A.prototype._onvLoadedMetadata = function (S) {
                    this._pendingSeekTime != null &&
                      ((this._mediaElement.currentTime = this._pendingSeekTime),
                      (this._pendingSeekTime = null))
                  }),
                  (A.prototype._onvSeeking = function (S) {
                    var h = this._mediaElement.currentTime,
                      _ = this._mediaElement.buffered
                    if (this._requestSetTime) {
                      this._requestSetTime = !1
                      return
                    }
                    if (h < 1 && _.length > 0) {
                      var y = _.start(0)
                      if ((y < 1 && h < y) || d.default.safari) {
                        ;(this._requestSetTime = !0),
                          (this._mediaElement.currentTime = d.default.safari ? 0.1 : y)
                        return
                      }
                    }
                    if (this._isTimepointBuffered(h)) {
                      if (this._alwaysSeekKeyframe) {
                        var L = this._msectl.getNearestKeyframe(Math.floor(h * 1e3))
                        L != null &&
                          ((this._requestSetTime = !0),
                          (this._mediaElement.currentTime = L.dts / 1e3))
                      }
                      this._progressChecker != null && this._checkProgressAndResume()
                      return
                    }
                    ;(this._seekpointRecord = { seekPoint: h, recordTime: this._now() }),
                      window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50)
                  }),
                  (A.prototype._onvCanPlay = function (S) {
                    ;(this._receivedCanPlay = !0),
                      this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay)
                  }),
                  (A.prototype._onvStalled = function (S) {
                    this._checkAndResumeStuckPlayback(!0)
                  }),
                  (A.prototype._onvProgress = function (S) {
                    this._checkAndResumeStuckPlayback()
                  }),
                  A
                )
              })()
            o.default = g
          },
          './src/player/native-player.js': function (a, o, l) {
            l.r(o)
            var u = l('./node_modules/events/events.js'),
              c = l.n(u),
              f = l('./src/player/player-events.js'),
              d = l('./src/config.js'),
              m = l('./src/utils/exception.js'),
              p = (function () {
                function v(E, x) {
                  if (
                    ((this.TAG = 'NativePlayer'),
                    (this._type = 'NativePlayer'),
                    (this._emitter = new (c())()),
                    (this._config = (0, d.createDefaultConfig)()),
                    typeof x == 'object' && Object.assign(this._config, x),
                    E.type.toLowerCase() === 'flv')
                  )
                    throw new m.InvalidArgumentException(
                      "NativePlayer does't support flv MediaDataSource input!"
                    )
                  if (E.hasOwnProperty('segments'))
                    throw new m.InvalidArgumentException(
                      'NativePlayer(' + E.type + ") doesn't support multipart playback!"
                    )
                  ;(this.e = { onvLoadedMetadata: this._onvLoadedMetadata.bind(this) }),
                    (this._pendingSeekTime = null),
                    (this._statisticsReporter = null),
                    (this._mediaDataSource = E),
                    (this._mediaElement = null)
                }
                return (
                  (v.prototype.destroy = function () {
                    this._mediaElement && (this.unload(), this.detachMediaElement()),
                      (this.e = null),
                      (this._mediaDataSource = null),
                      this._emitter.removeAllListeners(),
                      (this._emitter = null)
                  }),
                  (v.prototype.on = function (E, x) {
                    var T = this
                    E === f.default.MEDIA_INFO
                      ? this._mediaElement != null &&
                        this._mediaElement.readyState !== 0 &&
                        Promise.resolve().then(function () {
                          T._emitter.emit(f.default.MEDIA_INFO, T.mediaInfo)
                        })
                      : E === f.default.STATISTICS_INFO &&
                        this._mediaElement != null &&
                        this._mediaElement.readyState !== 0 &&
                        Promise.resolve().then(function () {
                          T._emitter.emit(f.default.STATISTICS_INFO, T.statisticsInfo)
                        }),
                      this._emitter.addListener(E, x)
                  }),
                  (v.prototype.off = function (E, x) {
                    this._emitter.removeListener(E, x)
                  }),
                  (v.prototype.attachMediaElement = function (E) {
                    if (
                      ((this._mediaElement = E),
                      E.addEventListener('loadedmetadata', this.e.onvLoadedMetadata),
                      this._pendingSeekTime != null)
                    )
                      try {
                        ;(E.currentTime = this._pendingSeekTime), (this._pendingSeekTime = null)
                      } catch {}
                  }),
                  (v.prototype.detachMediaElement = function () {
                    this._mediaElement &&
                      ((this._mediaElement.src = ''),
                      this._mediaElement.removeAttribute('src'),
                      this._mediaElement.removeEventListener(
                        'loadedmetadata',
                        this.e.onvLoadedMetadata
                      ),
                      (this._mediaElement = null)),
                      this._statisticsReporter != null &&
                        (window.clearInterval(this._statisticsReporter),
                        (this._statisticsReporter = null))
                  }),
                  (v.prototype.load = function () {
                    if (!this._mediaElement)
                      throw new m.IllegalStateException(
                        'HTMLMediaElement must be attached before load()!'
                      )
                    ;(this._mediaElement.src = this._mediaDataSource.url),
                      this._mediaElement.readyState > 0 && (this._mediaElement.currentTime = 0),
                      (this._mediaElement.preload = 'auto'),
                      this._mediaElement.load(),
                      (this._statisticsReporter = window.setInterval(
                        this._reportStatisticsInfo.bind(this),
                        this._config.statisticsInfoReportInterval
                      ))
                  }),
                  (v.prototype.unload = function () {
                    this._mediaElement &&
                      ((this._mediaElement.src = ''), this._mediaElement.removeAttribute('src')),
                      this._statisticsReporter != null &&
                        (window.clearInterval(this._statisticsReporter),
                        (this._statisticsReporter = null))
                  }),
                  (v.prototype.play = function () {
                    return this._mediaElement.play()
                  }),
                  (v.prototype.pause = function () {
                    this._mediaElement.pause()
                  }),
                  Object.defineProperty(v.prototype, 'type', {
                    get: function () {
                      return this._type
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(v.prototype, 'buffered', {
                    get: function () {
                      return this._mediaElement.buffered
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(v.prototype, 'duration', {
                    get: function () {
                      return this._mediaElement.duration
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(v.prototype, 'volume', {
                    get: function () {
                      return this._mediaElement.volume
                    },
                    set: function (E) {
                      this._mediaElement.volume = E
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(v.prototype, 'muted', {
                    get: function () {
                      return this._mediaElement.muted
                    },
                    set: function (E) {
                      this._mediaElement.muted = E
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(v.prototype, 'currentTime', {
                    get: function () {
                      return this._mediaElement ? this._mediaElement.currentTime : 0
                    },
                    set: function (E) {
                      this._mediaElement
                        ? (this._mediaElement.currentTime = E)
                        : (this._pendingSeekTime = E)
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(v.prototype, 'mediaInfo', {
                    get: function () {
                      var E = this._mediaElement instanceof HTMLAudioElement ? 'audio/' : 'video/',
                        x = { mimeType: E + this._mediaDataSource.type }
                      return (
                        this._mediaElement &&
                          ((x.duration = Math.floor(this._mediaElement.duration * 1e3)),
                          this._mediaElement instanceof HTMLVideoElement &&
                            ((x.width = this._mediaElement.videoWidth),
                            (x.height = this._mediaElement.videoHeight))),
                        x
                      )
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(v.prototype, 'statisticsInfo', {
                    get: function () {
                      var E = { playerType: this._type, url: this._mediaDataSource.url }
                      if (!(this._mediaElement instanceof HTMLVideoElement)) return E
                      var x = !0,
                        T = 0,
                        b = 0
                      if (this._mediaElement.getVideoPlaybackQuality) {
                        var R = this._mediaElement.getVideoPlaybackQuality()
                        ;(T = R.totalVideoFrames), (b = R.droppedVideoFrames)
                      } else
                        this._mediaElement.webkitDecodedFrameCount != null
                          ? ((T = this._mediaElement.webkitDecodedFrameCount),
                            (b = this._mediaElement.webkitDroppedFrameCount))
                          : (x = !1)
                      return x && ((E.decodedFrames = T), (E.droppedFrames = b)), E
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  (v.prototype._onvLoadedMetadata = function (E) {
                    this._pendingSeekTime != null &&
                      ((this._mediaElement.currentTime = this._pendingSeekTime),
                      (this._pendingSeekTime = null)),
                      this._emitter.emit(f.default.MEDIA_INFO, this.mediaInfo)
                  }),
                  (v.prototype._reportStatisticsInfo = function () {
                    this._emitter.emit(f.default.STATISTICS_INFO, this.statisticsInfo)
                  }),
                  v
                )
              })()
            o.default = p
          },
          './src/player/player-errors.js': function (a, o, l) {
            l.r(o),
              l.d(o, {
                ErrorTypes: function () {
                  return f
                },
                ErrorDetails: function () {
                  return d
                }
              })
            var u = l('./src/io/loader.js'),
              c = l('./src/demux/demux-errors.js'),
              f = {
                NETWORK_ERROR: 'NetworkError',
                MEDIA_ERROR: 'MediaError',
                OTHER_ERROR: 'OtherError'
              },
              d = {
                NETWORK_EXCEPTION: u.LoaderErrors.EXCEPTION,
                NETWORK_STATUS_CODE_INVALID: u.LoaderErrors.HTTP_STATUS_CODE_INVALID,
                NETWORK_TIMEOUT: u.LoaderErrors.CONNECTING_TIMEOUT,
                NETWORK_UNRECOVERABLE_EARLY_EOF: u.LoaderErrors.UNRECOVERABLE_EARLY_EOF,
                MEDIA_MSE_ERROR: 'MediaMSEError',
                MEDIA_FORMAT_ERROR: c.default.FORMAT_ERROR,
                MEDIA_FORMAT_UNSUPPORTED: c.default.FORMAT_UNSUPPORTED,
                MEDIA_CODEC_UNSUPPORTED: c.default.CODEC_UNSUPPORTED
              }
          },
          './src/player/player-events.js': function (a, o, l) {
            l.r(o)
            var u = {
              ERROR: 'error',
              LOADING_COMPLETE: 'loading_complete',
              RECOVERED_EARLY_EOF: 'recovered_early_eof',
              MEDIA_INFO: 'media_info',
              METADATA_ARRIVED: 'metadata_arrived',
              SCRIPTDATA_ARRIVED: 'scriptdata_arrived',
              STATISTICS_INFO: 'statistics_info'
            }
            o.default = u
          },
          './src/remux/aac-silent.js': function (a, o, l) {
            l.r(o)
            var u = (function () {
              function c() {}
              return (
                (c.getSilentFrame = function (f, d) {
                  if (f === 'mp4a.40.2') {
                    if (d === 1) return new Uint8Array([0, 200, 0, 128, 35, 128])
                    if (d === 2) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128])
                    if (d === 3)
                      return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142])
                    if (d === 4)
                      return new Uint8Array([
                        0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56
                      ])
                    if (d === 5)
                      return new Uint8Array([
                        0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144,
                        2, 56
                      ])
                    if (d === 6)
                      return new Uint8Array([
                        0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144,
                        2, 0, 178, 0, 32, 8, 224
                      ])
                  } else {
                    if (d === 1)
                      return new Uint8Array([
                        1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90,
                        90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
                        90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
                        90, 94
                      ])
                    if (d === 2)
                      return new Uint8Array([
                        1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161,
                        10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
                        90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
                        90, 94
                      ])
                    if (d === 3)
                      return new Uint8Array([
                        1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161,
                        10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
                        90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
                        90, 94
                      ])
                  }
                  return null
                }),
                c
              )
            })()
            o.default = u
          },
          './src/remux/mp4-generator.js': function (a, o, l) {
            l.r(o)
            var u = (function () {
              function c() {}
              return (
                (c.init = function () {
                  c.types = {
                    avc1: [],
                    avcC: [],
                    btrt: [],
                    dinf: [],
                    dref: [],
                    esds: [],
                    ftyp: [],
                    hdlr: [],
                    mdat: [],
                    mdhd: [],
                    mdia: [],
                    mfhd: [],
                    minf: [],
                    moof: [],
                    moov: [],
                    mp4a: [],
                    mvex: [],
                    mvhd: [],
                    sdtp: [],
                    stbl: [],
                    stco: [],
                    stsc: [],
                    stsd: [],
                    stsz: [],
                    stts: [],
                    tfdt: [],
                    tfhd: [],
                    traf: [],
                    trak: [],
                    trun: [],
                    trex: [],
                    tkhd: [],
                    vmhd: [],
                    smhd: [],
                    '.mp3': []
                  }
                  for (var f in c.types)
                    c.types.hasOwnProperty(f) &&
                      (c.types[f] = [
                        f.charCodeAt(0),
                        f.charCodeAt(1),
                        f.charCodeAt(2),
                        f.charCodeAt(3)
                      ])
                  var d = (c.constants = {})
                  ;(d.FTYP = new Uint8Array([
                    105, 115, 111, 109, 0, 0, 0, 1, 105, 115, 111, 109, 97, 118, 99, 49
                  ])),
                    (d.STSD_PREFIX = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1])),
                    (d.STTS = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0])),
                    (d.STSC = d.STCO = d.STTS),
                    (d.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])),
                    (d.HDLR_VIDEO = new Uint8Array([
                      0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                      0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0
                    ])),
                    (d.HDLR_AUDIO = new Uint8Array([
                      0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                      0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0
                    ])),
                    (d.DREF = new Uint8Array([
                      0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1
                    ])),
                    (d.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0])),
                    (d.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]))
                }),
                (c.box = function (f) {
                  for (
                    var d = 8,
                      m = null,
                      p = Array.prototype.slice.call(arguments, 1),
                      v = p.length,
                      E = 0;
                    E < v;
                    E++
                  )
                    d += p[E].byteLength
                  ;(m = new Uint8Array(d)),
                    (m[0] = (d >>> 24) & 255),
                    (m[1] = (d >>> 16) & 255),
                    (m[2] = (d >>> 8) & 255),
                    (m[3] = d & 255),
                    m.set(f, 4)
                  for (var x = 8, E = 0; E < v; E++) m.set(p[E], x), (x += p[E].byteLength)
                  return m
                }),
                (c.generateInitSegment = function (f) {
                  var d = c.box(c.types.ftyp, c.constants.FTYP),
                    m = c.moov(f),
                    p = new Uint8Array(d.byteLength + m.byteLength)
                  return p.set(d, 0), p.set(m, d.byteLength), p
                }),
                (c.moov = function (f) {
                  var d = c.mvhd(f.timescale, f.duration),
                    m = c.trak(f),
                    p = c.mvex(f)
                  return c.box(c.types.moov, d, m, p)
                }),
                (c.mvhd = function (f, d) {
                  return c.box(
                    c.types.mvhd,
                    new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      (f >>> 24) & 255,
                      (f >>> 16) & 255,
                      (f >>> 8) & 255,
                      f & 255,
                      (d >>> 24) & 255,
                      (d >>> 16) & 255,
                      (d >>> 8) & 255,
                      d & 255,
                      0,
                      1,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      64,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      255,
                      255,
                      255,
                      255
                    ])
                  )
                }),
                (c.trak = function (f) {
                  return c.box(c.types.trak, c.tkhd(f), c.mdia(f))
                }),
                (c.tkhd = function (f) {
                  var d = f.id,
                    m = f.duration,
                    p = f.presentWidth,
                    v = f.presentHeight
                  return c.box(
                    c.types.tkhd,
                    new Uint8Array([
                      0,
                      0,
                      0,
                      7,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      (d >>> 24) & 255,
                      (d >>> 16) & 255,
                      (d >>> 8) & 255,
                      d & 255,
                      0,
                      0,
                      0,
                      0,
                      (m >>> 24) & 255,
                      (m >>> 16) & 255,
                      (m >>> 8) & 255,
                      m & 255,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      64,
                      0,
                      0,
                      0,
                      (p >>> 8) & 255,
                      p & 255,
                      0,
                      0,
                      (v >>> 8) & 255,
                      v & 255,
                      0,
                      0
                    ])
                  )
                }),
                (c.mdia = function (f) {
                  return c.box(c.types.mdia, c.mdhd(f), c.hdlr(f), c.minf(f))
                }),
                (c.mdhd = function (f) {
                  var d = f.timescale,
                    m = f.duration
                  return c.box(
                    c.types.mdhd,
                    new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      (d >>> 24) & 255,
                      (d >>> 16) & 255,
                      (d >>> 8) & 255,
                      d & 255,
                      (m >>> 24) & 255,
                      (m >>> 16) & 255,
                      (m >>> 8) & 255,
                      m & 255,
                      85,
                      196,
                      0,
                      0
                    ])
                  )
                }),
                (c.hdlr = function (f) {
                  var d = null
                  return (
                    f.type === 'audio'
                      ? (d = c.constants.HDLR_AUDIO)
                      : (d = c.constants.HDLR_VIDEO),
                    c.box(c.types.hdlr, d)
                  )
                }),
                (c.minf = function (f) {
                  var d = null
                  return (
                    f.type === 'audio'
                      ? (d = c.box(c.types.smhd, c.constants.SMHD))
                      : (d = c.box(c.types.vmhd, c.constants.VMHD)),
                    c.box(c.types.minf, d, c.dinf(), c.stbl(f))
                  )
                }),
                (c.dinf = function () {
                  var f = c.box(c.types.dinf, c.box(c.types.dref, c.constants.DREF))
                  return f
                }),
                (c.stbl = function (f) {
                  var d = c.box(
                    c.types.stbl,
                    c.stsd(f),
                    c.box(c.types.stts, c.constants.STTS),
                    c.box(c.types.stsc, c.constants.STSC),
                    c.box(c.types.stsz, c.constants.STSZ),
                    c.box(c.types.stco, c.constants.STCO)
                  )
                  return d
                }),
                (c.stsd = function (f) {
                  return f.type === 'audio'
                    ? f.codec === 'mp3'
                      ? c.box(c.types.stsd, c.constants.STSD_PREFIX, c.mp3(f))
                      : c.box(c.types.stsd, c.constants.STSD_PREFIX, c.mp4a(f))
                    : c.box(c.types.stsd, c.constants.STSD_PREFIX, c.avc1(f))
                }),
                (c.mp3 = function (f) {
                  var d = f.channelCount,
                    m = f.audioSampleRate,
                    p = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      d,
                      0,
                      16,
                      0,
                      0,
                      0,
                      0,
                      (m >>> 8) & 255,
                      m & 255,
                      0,
                      0
                    ])
                  return c.box(c.types['.mp3'], p)
                }),
                (c.mp4a = function (f) {
                  var d = f.channelCount,
                    m = f.audioSampleRate,
                    p = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      d,
                      0,
                      16,
                      0,
                      0,
                      0,
                      0,
                      (m >>> 8) & 255,
                      m & 255,
                      0,
                      0
                    ])
                  return c.box(c.types.mp4a, p, c.esds(f))
                }),
                (c.esds = function (f) {
                  var d = f.config || [],
                    m = d.length,
                    p = new Uint8Array(
                      [
                        0,
                        0,
                        0,
                        0,
                        3,
                        23 + m,
                        0,
                        1,
                        0,
                        4,
                        15 + m,
                        64,
                        21,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        5
                      ]
                        .concat([m])
                        .concat(d)
                        .concat([6, 1, 2])
                    )
                  return c.box(c.types.esds, p)
                }),
                (c.avc1 = function (f) {
                  var d = f.avcc,
                    m = f.codecWidth,
                    p = f.codecHeight,
                    v = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      (m >>> 8) & 255,
                      m & 255,
                      (p >>> 8) & 255,
                      p & 255,
                      0,
                      72,
                      0,
                      0,
                      0,
                      72,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      10,
                      120,
                      113,
                      113,
                      47,
                      102,
                      108,
                      118,
                      46,
                      106,
                      115,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      24,
                      255,
                      255
                    ])
                  return c.box(c.types.avc1, v, c.box(c.types.avcC, d))
                }),
                (c.mvex = function (f) {
                  return c.box(c.types.mvex, c.trex(f))
                }),
                (c.trex = function (f) {
                  var d = f.id,
                    m = new Uint8Array([
                      0,
                      0,
                      0,
                      0,
                      (d >>> 24) & 255,
                      (d >>> 16) & 255,
                      (d >>> 8) & 255,
                      d & 255,
                      0,
                      0,
                      0,
                      1,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      1,
                      0,
                      1
                    ])
                  return c.box(c.types.trex, m)
                }),
                (c.moof = function (f, d) {
                  return c.box(c.types.moof, c.mfhd(f.sequenceNumber), c.traf(f, d))
                }),
                (c.mfhd = function (f) {
                  var d = new Uint8Array([
                    0,
                    0,
                    0,
                    0,
                    (f >>> 24) & 255,
                    (f >>> 16) & 255,
                    (f >>> 8) & 255,
                    f & 255
                  ])
                  return c.box(c.types.mfhd, d)
                }),
                (c.traf = function (f, d) {
                  var m = f.id,
                    p = c.box(
                      c.types.tfhd,
                      new Uint8Array([
                        0,
                        0,
                        0,
                        0,
                        (m >>> 24) & 255,
                        (m >>> 16) & 255,
                        (m >>> 8) & 255,
                        m & 255
                      ])
                    ),
                    v = c.box(
                      c.types.tfdt,
                      new Uint8Array([
                        0,
                        0,
                        0,
                        0,
                        (d >>> 24) & 255,
                        (d >>> 16) & 255,
                        (d >>> 8) & 255,
                        d & 255
                      ])
                    ),
                    E = c.sdtp(f),
                    x = c.trun(f, E.byteLength + 16 + 16 + 8 + 16 + 8 + 8)
                  return c.box(c.types.traf, p, v, x, E)
                }),
                (c.sdtp = function (f) {
                  for (
                    var d = f.samples || [], m = d.length, p = new Uint8Array(4 + m), v = 0;
                    v < m;
                    v++
                  ) {
                    var E = d[v].flags
                    p[v + 4] =
                      (E.isLeading << 6) |
                      (E.dependsOn << 4) |
                      (E.isDependedOn << 2) |
                      E.hasRedundancy
                  }
                  return c.box(c.types.sdtp, p)
                }),
                (c.trun = function (f, d) {
                  var m = f.samples || [],
                    p = m.length,
                    v = 12 + 16 * p,
                    E = new Uint8Array(v)
                  ;(d += 8 + v),
                    E.set(
                      [
                        0,
                        0,
                        15,
                        1,
                        (p >>> 24) & 255,
                        (p >>> 16) & 255,
                        (p >>> 8) & 255,
                        p & 255,
                        (d >>> 24) & 255,
                        (d >>> 16) & 255,
                        (d >>> 8) & 255,
                        d & 255
                      ],
                      0
                    )
                  for (var x = 0; x < p; x++) {
                    var T = m[x].duration,
                      b = m[x].size,
                      R = m[x].flags,
                      g = m[x].cts
                    E.set(
                      [
                        (T >>> 24) & 255,
                        (T >>> 16) & 255,
                        (T >>> 8) & 255,
                        T & 255,
                        (b >>> 24) & 255,
                        (b >>> 16) & 255,
                        (b >>> 8) & 255,
                        b & 255,
                        (R.isLeading << 2) | R.dependsOn,
                        (R.isDependedOn << 6) | (R.hasRedundancy << 4) | R.isNonSync,
                        0,
                        0,
                        (g >>> 24) & 255,
                        (g >>> 16) & 255,
                        (g >>> 8) & 255,
                        g & 255
                      ],
                      12 + 16 * x
                    )
                  }
                  return c.box(c.types.trun, E)
                }),
                (c.mdat = function (f) {
                  return c.box(c.types.mdat, f)
                }),
                c
              )
            })()
            u.init(), (o.default = u)
          },
          './src/remux/mp4-remuxer.js': function (a, o, l) {
            l.r(o)
            var u = l('./src/utils/logger.js'),
              c = l('./src/remux/mp4-generator.js'),
              f = l('./src/remux/aac-silent.js'),
              d = l('./src/utils/browser.js'),
              m = l('./src/core/media-segment-info.js'),
              p = l('./src/utils/exception.js'),
              v = (function () {
                function E(x) {
                  ;(this.TAG = 'MP4Remuxer'),
                    (this._config = x),
                    (this._isLive = x.isLive === !0),
                    (this._dtsBase = -1),
                    (this._dtsBaseInited = !1),
                    (this._audioDtsBase = 1 / 0),
                    (this._videoDtsBase = 1 / 0),
                    (this._audioNextDts = void 0),
                    (this._videoNextDts = void 0),
                    (this._audioStashedLastSample = null),
                    (this._videoStashedLastSample = null),
                    (this._audioMeta = null),
                    (this._videoMeta = null),
                    (this._audioSegmentInfoList = new m.MediaSegmentInfoList('audio')),
                    (this._videoSegmentInfoList = new m.MediaSegmentInfoList('video')),
                    (this._onInitSegment = null),
                    (this._onMediaSegment = null),
                    (this._forceFirstIDR = !!(
                      d.default.chrome &&
                      (d.default.version.major < 50 ||
                        (d.default.version.major === 50 && d.default.version.build < 2661))
                    )),
                    (this._fillSilentAfterSeek = d.default.msedge || d.default.msie),
                    (this._mp3UseMpegAudio = !d.default.firefox),
                    (this._fillAudioTimestampGap = this._config.fixAudioTimestampGap)
                }
                return (
                  (E.prototype.destroy = function () {
                    ;(this._dtsBase = -1),
                      (this._dtsBaseInited = !1),
                      (this._audioMeta = null),
                      (this._videoMeta = null),
                      this._audioSegmentInfoList.clear(),
                      (this._audioSegmentInfoList = null),
                      this._videoSegmentInfoList.clear(),
                      (this._videoSegmentInfoList = null),
                      (this._onInitSegment = null),
                      (this._onMediaSegment = null)
                  }),
                  (E.prototype.bindDataSource = function (x) {
                    return (
                      (x.onDataAvailable = this.remux.bind(this)),
                      (x.onTrackMetadata = this._onTrackMetadataReceived.bind(this)),
                      this
                    )
                  }),
                  Object.defineProperty(E.prototype, 'onInitSegment', {
                    get: function () {
                      return this._onInitSegment
                    },
                    set: function (x) {
                      this._onInitSegment = x
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(E.prototype, 'onMediaSegment', {
                    get: function () {
                      return this._onMediaSegment
                    },
                    set: function (x) {
                      this._onMediaSegment = x
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  (E.prototype.insertDiscontinuity = function () {
                    this._audioNextDts = this._videoNextDts = void 0
                  }),
                  (E.prototype.seek = function (x) {
                    ;(this._audioStashedLastSample = null),
                      (this._videoStashedLastSample = null),
                      this._videoSegmentInfoList.clear(),
                      this._audioSegmentInfoList.clear()
                  }),
                  (E.prototype.remux = function (x, T) {
                    if (!this._onMediaSegment)
                      throw new p.IllegalStateException(
                        'MP4Remuxer: onMediaSegment callback must be specificed!'
                      )
                    this._dtsBaseInited || this._calculateDtsBase(x, T),
                      this._remuxVideo(T),
                      this._remuxAudio(x)
                  }),
                  (E.prototype._onTrackMetadataReceived = function (x, T) {
                    var b = null,
                      R = 'mp4',
                      g = T.codec
                    if (x === 'audio')
                      (this._audioMeta = T),
                        T.codec === 'mp3' && this._mp3UseMpegAudio
                          ? ((R = 'mpeg'), (g = ''), (b = new Uint8Array()))
                          : (b = c.default.generateInitSegment(T))
                    else if (x === 'video')
                      (this._videoMeta = T), (b = c.default.generateInitSegment(T))
                    else return
                    if (!this._onInitSegment)
                      throw new p.IllegalStateException(
                        'MP4Remuxer: onInitSegment callback must be specified!'
                      )
                    this._onInitSegment(x, {
                      type: x,
                      data: b.buffer,
                      codec: g,
                      container: x + '/' + R,
                      mediaDuration: T.duration
                    })
                  }),
                  (E.prototype._calculateDtsBase = function (x, T) {
                    this._dtsBaseInited ||
                      (x.samples && x.samples.length && (this._audioDtsBase = x.samples[0].dts),
                      T.samples && T.samples.length && (this._videoDtsBase = T.samples[0].dts),
                      (this._dtsBase = Math.min(this._audioDtsBase, this._videoDtsBase)),
                      (this._dtsBaseInited = !0))
                  }),
                  (E.prototype.flushStashedSamples = function () {
                    var x = this._videoStashedLastSample,
                      T = this._audioStashedLastSample,
                      b = { type: 'video', id: 1, sequenceNumber: 0, samples: [], length: 0 }
                    x != null && (b.samples.push(x), (b.length = x.length))
                    var R = { type: 'audio', id: 2, sequenceNumber: 0, samples: [], length: 0 }
                    T != null && (R.samples.push(T), (R.length = T.length)),
                      (this._videoStashedLastSample = null),
                      (this._audioStashedLastSample = null),
                      this._remuxVideo(b, !0),
                      this._remuxAudio(R, !0)
                  }),
                  (E.prototype._remuxAudio = function (x, T) {
                    if (this._audioMeta != null) {
                      var b = x,
                        R = b.samples,
                        g = void 0,
                        A = -1,
                        S = -1,
                        h = this._audioMeta.refSampleDuration,
                        _ = this._audioMeta.codec === 'mp3' && this._mp3UseMpegAudio,
                        y = this._dtsBaseInited && this._audioNextDts === void 0,
                        L = !1
                      if (!(!R || R.length === 0) && !(R.length === 1 && !T)) {
                        var I = 0,
                          P = null,
                          D = 0
                        _ ? ((I = 0), (D = b.length)) : ((I = 8), (D = 8 + b.length))
                        var C = null
                        if (
                          (R.length > 1 && ((C = R.pop()), (D -= C.length)),
                          this._audioStashedLastSample != null)
                        ) {
                          var N = this._audioStashedLastSample
                          ;(this._audioStashedLastSample = null), R.unshift(N), (D += N.length)
                        }
                        C != null && (this._audioStashedLastSample = C)
                        var M = R[0].dts - this._dtsBase
                        if (this._audioNextDts) g = M - this._audioNextDts
                        else if (this._audioSegmentInfoList.isEmpty())
                          (g = 0),
                            this._fillSilentAfterSeek &&
                              !this._videoSegmentInfoList.isEmpty() &&
                              this._audioMeta.originalCodec !== 'mp3' &&
                              (L = !0)
                        else {
                          var w = this._audioSegmentInfoList.getLastSampleBefore(M)
                          if (w != null) {
                            var U = M - (w.originalDts + w.duration)
                            U <= 3 && (U = 0)
                            var F = w.dts + w.duration + U
                            g = M - F
                          } else g = 0
                        }
                        if (L) {
                          var k = M - g,
                            B = this._videoSegmentInfoList.getLastSegmentBefore(M)
                          if (B != null && B.beginDts < k) {
                            var V = f.default.getSilentFrame(
                              this._audioMeta.originalCodec,
                              this._audioMeta.channelCount
                            )
                            if (V) {
                              var H = B.beginDts,
                                q = k - B.beginDts
                              u.default.v(
                                this.TAG,
                                'InsertPrefixSilentAudio: dts: ' + H + ', duration: ' + q
                              ),
                                R.unshift({ unit: V, dts: H, pts: H }),
                                (D += V.byteLength)
                            }
                          } else L = !1
                        }
                        for (var X = [], Q = 0; Q < R.length; Q++) {
                          var N = R[Q],
                            ae = N.unit,
                            ue = N.dts - this._dtsBase,
                            H = ue,
                            he = !1,
                            _e = null,
                            de = 0
                          if (!(ue < -0.001)) {
                            if (this._audioMeta.codec !== 'mp3') {
                              var te = ue,
                                be = 3
                              if (
                                (this._audioNextDts && (te = this._audioNextDts),
                                (g = ue - te),
                                g <= -be * h)
                              ) {
                                u.default.w(
                                  this.TAG,
                                  'Dropping 1 audio frame (originalDts: ' +
                                    ue +
                                    ' ms ,curRefDts: ' +
                                    te +
                                    ' ms)  due to dtsCorrection: ' +
                                    g +
                                    ' ms overlap.'
                                )
                                continue
                              } else if (
                                g >= be * h &&
                                this._fillAudioTimestampGap &&
                                !d.default.safari
                              ) {
                                he = !0
                                var De = Math.floor(g / h)
                                u.default.w(
                                  this.TAG,
                                  `Large audio timestamp gap detected, may cause AV sync to drift. Silent frames will be generated to avoid unsync.
` +
                                    ('originalDts: ' + ue + ' ms, curRefDts: ' + te + ' ms, ') +
                                    ('dtsCorrection: ' +
                                      Math.round(g) +
                                      ' ms, generate: ' +
                                      De +
                                      ' frames')
                                ),
                                  (H = Math.floor(te)),
                                  (de = Math.floor(te + h) - H)
                                var V = f.default.getSilentFrame(
                                  this._audioMeta.originalCodec,
                                  this._audioMeta.channelCount
                                )
                                V == null &&
                                  (u.default.w(
                                    this.TAG,
                                    'Unable to generate silent frame for ' +
                                      (this._audioMeta.originalCodec +
                                        ' with ' +
                                        this._audioMeta.channelCount +
                                        ' channels, repeat last frame')
                                  ),
                                  (V = ae)),
                                  (_e = [])
                                for (var Ue = 0; Ue < De; Ue++) {
                                  te = te + h
                                  var ke = Math.floor(te),
                                    xe = Math.floor(te + h) - ke,
                                    at = {
                                      dts: ke,
                                      pts: ke,
                                      cts: 0,
                                      unit: V,
                                      size: V.byteLength,
                                      duration: xe,
                                      originalDts: ue,
                                      flags: {
                                        isLeading: 0,
                                        dependsOn: 1,
                                        isDependedOn: 0,
                                        hasRedundancy: 0
                                      }
                                    }
                                  _e.push(at), (D += at.size)
                                }
                                this._audioNextDts = te + h
                              } else
                                (H = Math.floor(te)),
                                  (de = Math.floor(te + h) - H),
                                  (this._audioNextDts = te + h)
                            } else {
                              if (((H = ue - g), Q !== R.length - 1)) {
                                var ot = R[Q + 1].dts - this._dtsBase - g
                                de = ot - H
                              } else if (C != null) {
                                var ot = C.dts - this._dtsBase - g
                                de = ot - H
                              } else
                                X.length >= 1
                                  ? (de = X[X.length - 1].duration)
                                  : (de = Math.floor(h))
                              this._audioNextDts = H + de
                            }
                            A === -1 && (A = H),
                              X.push({
                                dts: H,
                                pts: H,
                                cts: 0,
                                unit: N.unit,
                                size: N.unit.byteLength,
                                duration: de,
                                originalDts: ue,
                                flags: {
                                  isLeading: 0,
                                  dependsOn: 1,
                                  isDependedOn: 0,
                                  hasRedundancy: 0
                                }
                              }),
                              he && X.push.apply(X, _e)
                          }
                        }
                        if (X.length === 0) {
                          ;(b.samples = []), (b.length = 0)
                          return
                        }
                        _
                          ? (P = new Uint8Array(D))
                          : ((P = new Uint8Array(D)),
                            (P[0] = (D >>> 24) & 255),
                            (P[1] = (D >>> 16) & 255),
                            (P[2] = (D >>> 8) & 255),
                            (P[3] = D & 255),
                            P.set(c.default.types.mdat, 4))
                        for (var Q = 0; Q < X.length; Q++) {
                          var ae = X[Q].unit
                          P.set(ae, I), (I += ae.byteLength)
                        }
                        var He = X[X.length - 1]
                        S = He.dts + He.duration
                        var Be = new m.MediaSegmentInfo()
                        ;(Be.beginDts = A),
                          (Be.endDts = S),
                          (Be.beginPts = A),
                          (Be.endPts = S),
                          (Be.originalBeginDts = X[0].originalDts),
                          (Be.originalEndDts = He.originalDts + He.duration),
                          (Be.firstSample = new m.SampleInfo(
                            X[0].dts,
                            X[0].pts,
                            X[0].duration,
                            X[0].originalDts,
                            !1
                          )),
                          (Be.lastSample = new m.SampleInfo(
                            He.dts,
                            He.pts,
                            He.duration,
                            He.originalDts,
                            !1
                          )),
                          this._isLive || this._audioSegmentInfoList.append(Be),
                          (b.samples = X),
                          b.sequenceNumber++
                        var ft = null
                        _ ? (ft = new Uint8Array()) : (ft = c.default.moof(b, A)),
                          (b.samples = []),
                          (b.length = 0)
                        var _t = {
                          type: 'audio',
                          data: this._mergeBoxes(ft, P).buffer,
                          sampleCount: X.length,
                          info: Be
                        }
                        _ && y && (_t.timestampOffset = A), this._onMediaSegment('audio', _t)
                      }
                    }
                  }),
                  (E.prototype._remuxVideo = function (x, T) {
                    if (this._videoMeta != null) {
                      var b = x,
                        R = b.samples,
                        g = void 0,
                        A = -1,
                        S = -1,
                        h = -1,
                        _ = -1
                      if (!(!R || R.length === 0) && !(R.length === 1 && !T)) {
                        var y = 8,
                          L = null,
                          I = 8 + x.length,
                          P = null
                        if (
                          (R.length > 1 && ((P = R.pop()), (I -= P.length)),
                          this._videoStashedLastSample != null)
                        ) {
                          var D = this._videoStashedLastSample
                          ;(this._videoStashedLastSample = null), R.unshift(D), (I += D.length)
                        }
                        P != null && (this._videoStashedLastSample = P)
                        var C = R[0].dts - this._dtsBase
                        if (this._videoNextDts) g = C - this._videoNextDts
                        else if (this._videoSegmentInfoList.isEmpty()) g = 0
                        else {
                          var N = this._videoSegmentInfoList.getLastSampleBefore(C)
                          if (N != null) {
                            var M = C - (N.originalDts + N.duration)
                            M <= 3 && (M = 0)
                            var w = N.dts + N.duration + M
                            g = C - w
                          } else g = 0
                        }
                        for (var U = new m.MediaSegmentInfo(), F = [], k = 0; k < R.length; k++) {
                          var D = R[k],
                            B = D.dts - this._dtsBase,
                            V = D.isKeyframe,
                            H = B - g,
                            q = D.cts,
                            X = H + q
                          A === -1 && ((A = H), (h = X))
                          var Q = 0
                          if (k !== R.length - 1) {
                            var ae = R[k + 1].dts - this._dtsBase - g
                            Q = ae - H
                          } else if (P != null) {
                            var ae = P.dts - this._dtsBase - g
                            Q = ae - H
                          } else
                            F.length >= 1
                              ? (Q = F[F.length - 1].duration)
                              : (Q = Math.floor(this._videoMeta.refSampleDuration))
                          if (V) {
                            var ue = new m.SampleInfo(H, X, Q, D.dts, !0)
                            ;(ue.fileposition = D.fileposition), U.appendSyncPoint(ue)
                          }
                          F.push({
                            dts: H,
                            pts: X,
                            cts: q,
                            units: D.units,
                            size: D.length,
                            isKeyframe: V,
                            duration: Q,
                            originalDts: B,
                            flags: {
                              isLeading: 0,
                              dependsOn: V ? 2 : 1,
                              isDependedOn: V ? 1 : 0,
                              hasRedundancy: 0,
                              isNonSync: V ? 0 : 1
                            }
                          })
                        }
                        ;(L = new Uint8Array(I)),
                          (L[0] = (I >>> 24) & 255),
                          (L[1] = (I >>> 16) & 255),
                          (L[2] = (I >>> 8) & 255),
                          (L[3] = I & 255),
                          L.set(c.default.types.mdat, 4)
                        for (var k = 0; k < F.length; k++)
                          for (var he = F[k].units; he.length; ) {
                            var _e = he.shift(),
                              de = _e.data
                            L.set(de, y), (y += de.byteLength)
                          }
                        var te = F[F.length - 1]
                        if (
                          ((S = te.dts + te.duration),
                          (_ = te.pts + te.duration),
                          (this._videoNextDts = S),
                          (U.beginDts = A),
                          (U.endDts = S),
                          (U.beginPts = h),
                          (U.endPts = _),
                          (U.originalBeginDts = F[0].originalDts),
                          (U.originalEndDts = te.originalDts + te.duration),
                          (U.firstSample = new m.SampleInfo(
                            F[0].dts,
                            F[0].pts,
                            F[0].duration,
                            F[0].originalDts,
                            F[0].isKeyframe
                          )),
                          (U.lastSample = new m.SampleInfo(
                            te.dts,
                            te.pts,
                            te.duration,
                            te.originalDts,
                            te.isKeyframe
                          )),
                          this._isLive || this._videoSegmentInfoList.append(U),
                          (b.samples = F),
                          b.sequenceNumber++,
                          this._forceFirstIDR)
                        ) {
                          var be = F[0].flags
                          ;(be.dependsOn = 2), (be.isNonSync = 0)
                        }
                        var De = c.default.moof(b, A)
                        ;(b.samples = []),
                          (b.length = 0),
                          this._onMediaSegment('video', {
                            type: 'video',
                            data: this._mergeBoxes(De, L).buffer,
                            sampleCount: F.length,
                            info: U
                          })
                      }
                    }
                  }),
                  (E.prototype._mergeBoxes = function (x, T) {
                    var b = new Uint8Array(x.byteLength + T.byteLength)
                    return b.set(x, 0), b.set(T, x.byteLength), b
                  }),
                  E
                )
              })()
            o.default = v
          },
          './src/utils/browser.js': function (a, o, l) {
            l.r(o)
            var u = {}
            function c() {
              var f = self.navigator.userAgent.toLowerCase(),
                d =
                  /(edge)\/([\w.]+)/.exec(f) ||
                  /(opr)[\/]([\w.]+)/.exec(f) ||
                  /(chrome)[ \/]([\w.]+)/.exec(f) ||
                  /(iemobile)[\/]([\w.]+)/.exec(f) ||
                  /(version)(applewebkit)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(f) ||
                  /(webkit)[ \/]([\w.]+).*(version)[ \/]([\w.]+).*(safari)[ \/]([\w.]+)/.exec(f) ||
                  /(webkit)[ \/]([\w.]+)/.exec(f) ||
                  /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(f) ||
                  /(msie) ([\w.]+)/.exec(f) ||
                  (f.indexOf('trident') >= 0 && /(rv)(?::| )([\w.]+)/.exec(f)) ||
                  (f.indexOf('compatible') < 0 && /(firefox)[ \/]([\w.]+)/.exec(f)) ||
                  [],
                m =
                  /(ipad)/.exec(f) ||
                  /(ipod)/.exec(f) ||
                  /(windows phone)/.exec(f) ||
                  /(iphone)/.exec(f) ||
                  /(kindle)/.exec(f) ||
                  /(android)/.exec(f) ||
                  /(windows)/.exec(f) ||
                  /(mac)/.exec(f) ||
                  /(linux)/.exec(f) ||
                  /(cros)/.exec(f) ||
                  [],
                p = {
                  browser: d[5] || d[3] || d[1] || '',
                  version: d[2] || d[4] || '0',
                  majorVersion: d[4] || d[2] || '0',
                  platform: m[0] || ''
                },
                v = {}
              if (p.browser) {
                v[p.browser] = !0
                var E = p.majorVersion.split('.')
                ;(v.version = { major: parseInt(p.majorVersion, 10), string: p.version }),
                  E.length > 1 && (v.version.minor = parseInt(E[1], 10)),
                  E.length > 2 && (v.version.build = parseInt(E[2], 10))
              }
              if (
                (p.platform && (v[p.platform] = !0),
                (v.chrome || v.opr || v.safari) && (v.webkit = !0),
                v.rv || v.iemobile)
              ) {
                v.rv && delete v.rv
                var x = 'msie'
                ;(p.browser = x), (v[x] = !0)
              }
              if (v.edge) {
                delete v.edge
                var T = 'msedge'
                ;(p.browser = T), (v[T] = !0)
              }
              if (v.opr) {
                var b = 'opera'
                ;(p.browser = b), (v[b] = !0)
              }
              if (v.safari && v.android) {
                var R = 'android'
                ;(p.browser = R), (v[R] = !0)
              }
              ;(v.name = p.browser), (v.platform = p.platform)
              for (var g in u) u.hasOwnProperty(g) && delete u[g]
              Object.assign(u, v)
            }
            c(), (o.default = u)
          },
          './src/utils/exception.js': function (a, o, l) {
            l.r(o),
              l.d(o, {
                RuntimeException: function () {
                  return c
                },
                IllegalStateException: function () {
                  return f
                },
                InvalidArgumentException: function () {
                  return d
                },
                NotImplementedException: function () {
                  return m
                }
              })
            var u = (function () {
                var p = function (v, E) {
                  return (
                    (p =
                      Object.setPrototypeOf ||
                      ({ __proto__: [] } instanceof Array &&
                        function (x, T) {
                          x.__proto__ = T
                        }) ||
                      function (x, T) {
                        for (var b in T) Object.prototype.hasOwnProperty.call(T, b) && (x[b] = T[b])
                      }),
                    p(v, E)
                  )
                }
                return function (v, E) {
                  if (typeof E != 'function' && E !== null)
                    throw new TypeError(
                      'Class extends value ' + String(E) + ' is not a constructor or null'
                    )
                  p(v, E)
                  function x() {
                    this.constructor = v
                  }
                  v.prototype =
                    E === null ? Object.create(E) : ((x.prototype = E.prototype), new x())
                }
              })(),
              c = (function () {
                function p(v) {
                  this._message = v
                }
                return (
                  Object.defineProperty(p.prototype, 'name', {
                    get: function () {
                      return 'RuntimeException'
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(p.prototype, 'message', {
                    get: function () {
                      return this._message
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  (p.prototype.toString = function () {
                    return this.name + ': ' + this.message
                  }),
                  p
                )
              })(),
              f = (function (p) {
                u(v, p)
                function v(E) {
                  return p.call(this, E) || this
                }
                return (
                  Object.defineProperty(v.prototype, 'name', {
                    get: function () {
                      return 'IllegalStateException'
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  v
                )
              })(c),
              d = (function (p) {
                u(v, p)
                function v(E) {
                  return p.call(this, E) || this
                }
                return (
                  Object.defineProperty(v.prototype, 'name', {
                    get: function () {
                      return 'InvalidArgumentException'
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  v
                )
              })(c),
              m = (function (p) {
                u(v, p)
                function v(E) {
                  return p.call(this, E) || this
                }
                return (
                  Object.defineProperty(v.prototype, 'name', {
                    get: function () {
                      return 'NotImplementedException'
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  v
                )
              })(c)
          },
          './src/utils/logger.js': function (a, o, l) {
            l.r(o)
            var u = l('./node_modules/events/events.js'),
              c = l.n(u),
              f = (function () {
                function d() {}
                return (
                  (d.e = function (m, p) {
                    ;(!m || d.FORCE_GLOBAL_TAG) && (m = d.GLOBAL_TAG)
                    var v = '[' + m + '] > ' + p
                    d.ENABLE_CALLBACK && d.emitter.emit('log', 'error', v),
                      d.ENABLE_ERROR &&
                        (console.error
                          ? console.error(v)
                          : console.warn
                          ? console.warn(v)
                          : console.log(v))
                  }),
                  (d.i = function (m, p) {
                    ;(!m || d.FORCE_GLOBAL_TAG) && (m = d.GLOBAL_TAG)
                    var v = '[' + m + '] > ' + p
                    d.ENABLE_CALLBACK && d.emitter.emit('log', 'info', v),
                      d.ENABLE_INFO && (console.info ? console.info(v) : console.log(v))
                  }),
                  (d.w = function (m, p) {
                    ;(!m || d.FORCE_GLOBAL_TAG) && (m = d.GLOBAL_TAG)
                    var v = '[' + m + '] > ' + p
                    d.ENABLE_CALLBACK && d.emitter.emit('log', 'warn', v),
                      d.ENABLE_WARN && (console.warn ? console.warn(v) : console.log(v))
                  }),
                  (d.d = function (m, p) {
                    ;(!m || d.FORCE_GLOBAL_TAG) && (m = d.GLOBAL_TAG)
                    var v = '[' + m + '] > ' + p
                    d.ENABLE_CALLBACK && d.emitter.emit('log', 'debug', v),
                      d.ENABLE_DEBUG && (console.debug ? console.debug(v) : console.log(v))
                  }),
                  (d.v = function (m, p) {
                    ;(!m || d.FORCE_GLOBAL_TAG) && (m = d.GLOBAL_TAG)
                    var v = '[' + m + '] > ' + p
                    d.ENABLE_CALLBACK && d.emitter.emit('log', 'verbose', v),
                      d.ENABLE_VERBOSE && console.log(v)
                  }),
                  d
                )
              })()
            ;(f.GLOBAL_TAG = 'flv.js'),
              (f.FORCE_GLOBAL_TAG = !1),
              (f.ENABLE_ERROR = !0),
              (f.ENABLE_INFO = !0),
              (f.ENABLE_WARN = !0),
              (f.ENABLE_DEBUG = !0),
              (f.ENABLE_VERBOSE = !0),
              (f.ENABLE_CALLBACK = !1),
              (f.emitter = new (c())()),
              (o.default = f)
          },
          './src/utils/logging-control.js': function (a, o, l) {
            l.r(o)
            var u = l('./node_modules/events/events.js'),
              c = l.n(u),
              f = l('./src/utils/logger.js'),
              d = (function () {
                function m() {}
                return (
                  Object.defineProperty(m, 'forceGlobalTag', {
                    get: function () {
                      return f.default.FORCE_GLOBAL_TAG
                    },
                    set: function (p) {
                      ;(f.default.FORCE_GLOBAL_TAG = p), m._notifyChange()
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m, 'globalTag', {
                    get: function () {
                      return f.default.GLOBAL_TAG
                    },
                    set: function (p) {
                      ;(f.default.GLOBAL_TAG = p), m._notifyChange()
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m, 'enableAll', {
                    get: function () {
                      return (
                        f.default.ENABLE_VERBOSE &&
                        f.default.ENABLE_DEBUG &&
                        f.default.ENABLE_INFO &&
                        f.default.ENABLE_WARN &&
                        f.default.ENABLE_ERROR
                      )
                    },
                    set: function (p) {
                      ;(f.default.ENABLE_VERBOSE = p),
                        (f.default.ENABLE_DEBUG = p),
                        (f.default.ENABLE_INFO = p),
                        (f.default.ENABLE_WARN = p),
                        (f.default.ENABLE_ERROR = p),
                        m._notifyChange()
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m, 'enableDebug', {
                    get: function () {
                      return f.default.ENABLE_DEBUG
                    },
                    set: function (p) {
                      ;(f.default.ENABLE_DEBUG = p), m._notifyChange()
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m, 'enableVerbose', {
                    get: function () {
                      return f.default.ENABLE_VERBOSE
                    },
                    set: function (p) {
                      ;(f.default.ENABLE_VERBOSE = p), m._notifyChange()
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m, 'enableInfo', {
                    get: function () {
                      return f.default.ENABLE_INFO
                    },
                    set: function (p) {
                      ;(f.default.ENABLE_INFO = p), m._notifyChange()
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m, 'enableWarn', {
                    get: function () {
                      return f.default.ENABLE_WARN
                    },
                    set: function (p) {
                      ;(f.default.ENABLE_WARN = p), m._notifyChange()
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  Object.defineProperty(m, 'enableError', {
                    get: function () {
                      return f.default.ENABLE_ERROR
                    },
                    set: function (p) {
                      ;(f.default.ENABLE_ERROR = p), m._notifyChange()
                    },
                    enumerable: !1,
                    configurable: !0
                  }),
                  (m.getConfig = function () {
                    return {
                      globalTag: f.default.GLOBAL_TAG,
                      forceGlobalTag: f.default.FORCE_GLOBAL_TAG,
                      enableVerbose: f.default.ENABLE_VERBOSE,
                      enableDebug: f.default.ENABLE_DEBUG,
                      enableInfo: f.default.ENABLE_INFO,
                      enableWarn: f.default.ENABLE_WARN,
                      enableError: f.default.ENABLE_ERROR,
                      enableCallback: f.default.ENABLE_CALLBACK
                    }
                  }),
                  (m.applyConfig = function (p) {
                    ;(f.default.GLOBAL_TAG = p.globalTag),
                      (f.default.FORCE_GLOBAL_TAG = p.forceGlobalTag),
                      (f.default.ENABLE_VERBOSE = p.enableVerbose),
                      (f.default.ENABLE_DEBUG = p.enableDebug),
                      (f.default.ENABLE_INFO = p.enableInfo),
                      (f.default.ENABLE_WARN = p.enableWarn),
                      (f.default.ENABLE_ERROR = p.enableError),
                      (f.default.ENABLE_CALLBACK = p.enableCallback)
                  }),
                  (m._notifyChange = function () {
                    var p = m.emitter
                    if (p.listenerCount('change') > 0) {
                      var v = m.getConfig()
                      p.emit('change', v)
                    }
                  }),
                  (m.registerListener = function (p) {
                    m.emitter.addListener('change', p)
                  }),
                  (m.removeListener = function (p) {
                    m.emitter.removeListener('change', p)
                  }),
                  (m.addLogListener = function (p) {
                    f.default.emitter.addListener('log', p),
                      f.default.emitter.listenerCount('log') > 0 &&
                        ((f.default.ENABLE_CALLBACK = !0), m._notifyChange())
                  }),
                  (m.removeLogListener = function (p) {
                    f.default.emitter.removeListener('log', p),
                      f.default.emitter.listenerCount('log') === 0 &&
                        ((f.default.ENABLE_CALLBACK = !1), m._notifyChange())
                  }),
                  m
                )
              })()
            ;(d.emitter = new (c())()), (o.default = d)
          },
          './src/utils/polyfill.js': function (a, o, l) {
            l.r(o)
            var u = (function () {
              function c() {}
              return (
                (c.install = function () {
                  ;(Object.setPrototypeOf =
                    Object.setPrototypeOf ||
                    function (f, d) {
                      return (f.__proto__ = d), f
                    }),
                    (Object.assign =
                      Object.assign ||
                      function (f) {
                        if (f == null)
                          throw new TypeError('Cannot convert undefined or null to object')
                        for (var d = Object(f), m = 1; m < arguments.length; m++) {
                          var p = arguments[m]
                          if (p != null) for (var v in p) p.hasOwnProperty(v) && (d[v] = p[v])
                        }
                        return d
                      }),
                    typeof self.Promise != 'function' &&
                      l('./node_modules/es6-promise/dist/es6-promise.js').polyfill()
                }),
                c
              )
            })()
            u.install(), (o.default = u)
          },
          './src/utils/utf8-conv.js': function (a, o, l) {
            l.r(o)
            function u(f, d, m) {
              var p = f
              if (d + m < p.length) {
                for (; m--; ) if ((p[++d] & 192) !== 128) return !1
                return !0
              } else return !1
            }
            function c(f) {
              for (var d = [], m = f, p = 0, v = f.length; p < v; ) {
                if (m[p] < 128) {
                  d.push(String.fromCharCode(m[p])), ++p
                  continue
                } else if (!(m[p] < 192)) {
                  if (m[p] < 224) {
                    if (u(m, p, 1)) {
                      var E = ((m[p] & 31) << 6) | (m[p + 1] & 63)
                      if (E >= 128) {
                        d.push(String.fromCharCode(E & 65535)), (p += 2)
                        continue
                      }
                    }
                  } else if (m[p] < 240) {
                    if (u(m, p, 2)) {
                      var E = ((m[p] & 15) << 12) | ((m[p + 1] & 63) << 6) | (m[p + 2] & 63)
                      if (E >= 2048 && (E & 63488) !== 55296) {
                        d.push(String.fromCharCode(E & 65535)), (p += 3)
                        continue
                      }
                    }
                  } else if (m[p] < 248 && u(m, p, 3)) {
                    var E =
                      ((m[p] & 7) << 18) |
                      ((m[p + 1] & 63) << 12) |
                      ((m[p + 2] & 63) << 6) |
                      (m[p + 3] & 63)
                    if (E > 65536 && E < 1114112) {
                      ;(E -= 65536),
                        d.push(String.fromCharCode((E >>> 10) | 55296)),
                        d.push(String.fromCharCode((E & 1023) | 56320)),
                        (p += 4)
                      continue
                    }
                  }
                }
                d.push(String.fromCharCode(65533)), ++p
              }
              return d.join('')
            }
            o.default = c
          }
        },
        r = {}
      function n(a) {
        var o = r[a]
        if (o !== void 0) return o.exports
        var l = (r[a] = { exports: {} })
        return t[a].call(l.exports, l, l.exports, n), l.exports
      }
      ;(n.m = t),
        (function () {
          n.n = function (a) {
            var o =
              a && a.__esModule
                ? function () {
                    return a.default
                  }
                : function () {
                    return a
                  }
            return n.d(o, { a: o }), o
          }
        })(),
        (function () {
          n.d = function (a, o) {
            for (var l in o)
              n.o(o, l) && !n.o(a, l) && Object.defineProperty(a, l, { enumerable: !0, get: o[l] })
          }
        })(),
        (function () {
          n.g = (function () {
            if (typeof globalThis == 'object') return globalThis
            try {
              return this || new Function('return this')()
            } catch {
              if (typeof window == 'object') return window
            }
          })()
        })(),
        (function () {
          n.o = function (a, o) {
            return Object.prototype.hasOwnProperty.call(a, o)
          }
        })(),
        (function () {
          n.r = function (a) {
            typeof Symbol < 'u' &&
              Symbol.toStringTag &&
              Object.defineProperty(a, Symbol.toStringTag, { value: 'Module' }),
              Object.defineProperty(a, '__esModule', { value: !0 })
          }
        })()
      var i = n('./src/index.js')
      return i
    })()
  })
})(ou)
function lu(s = {}) {
  return io({ url: '/live/list', method: 'post', data: s })
}
function uu(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, 'default') ? s.default : s
}
var Ks = { exports: {} }
;(function (s, e) {
  ;(function (t) {
    var r =
        /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/,
      n = /^(?=([^\/?#]*))\1([^]*)$/,
      i = /(?:\/|^)\.(?=\/)/g,
      a = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g,
      o = {
        buildAbsoluteURL: function (l, u, c) {
          if (((c = c || {}), (l = l.trim()), (u = u.trim()), !u)) {
            if (!c.alwaysNormalize) return l
            var f = o.parseURL(l)
            if (!f) throw new Error('Error trying to parse base URL.')
            return (f.path = o.normalizePath(f.path)), o.buildURLFromParts(f)
          }
          var d = o.parseURL(u)
          if (!d) throw new Error('Error trying to parse relative URL.')
          if (d.scheme)
            return c.alwaysNormalize
              ? ((d.path = o.normalizePath(d.path)), o.buildURLFromParts(d))
              : u
          var m = o.parseURL(l)
          if (!m) throw new Error('Error trying to parse base URL.')
          if (!m.netLoc && m.path && m.path[0] !== '/') {
            var p = n.exec(m.path)
            ;(m.netLoc = p[1]), (m.path = p[2])
          }
          m.netLoc && !m.path && (m.path = '/')
          var v = {
            scheme: m.scheme,
            netLoc: d.netLoc,
            path: null,
            params: d.params,
            query: d.query,
            fragment: d.fragment
          }
          if (!d.netLoc && ((v.netLoc = m.netLoc), d.path[0] !== '/'))
            if (!d.path)
              (v.path = m.path), d.params || ((v.params = m.params), d.query || (v.query = m.query))
            else {
              var E = m.path,
                x = E.substring(0, E.lastIndexOf('/') + 1) + d.path
              v.path = o.normalizePath(x)
            }
          return (
            v.path === null && (v.path = c.alwaysNormalize ? o.normalizePath(d.path) : d.path),
            o.buildURLFromParts(v)
          )
        },
        parseURL: function (l) {
          var u = r.exec(l)
          return u
            ? {
                scheme: u[1] || '',
                netLoc: u[2] || '',
                path: u[3] || '',
                params: u[4] || '',
                query: u[5] || '',
                fragment: u[6] || ''
              }
            : null
        },
        normalizePath: function (l) {
          for (
            l = l.split('').reverse().join('').replace(i, '');
            l.length !== (l = l.replace(a, '')).length;

          );
          return l.split('').reverse().join('')
        },
        buildURLFromParts: function (l) {
          return l.scheme + l.netLoc + l.path + l.params + l.query + l.fragment
        }
      }
    s.exports = o
  })()
})(Ks)
var wn = Ks.exports
function Si(s, e) {
  var t = Object.keys(s)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(s)
    e &&
      (r = r.filter(function (n) {
        return Object.getOwnPropertyDescriptor(s, n).enumerable
      })),
      t.push.apply(t, r)
  }
  return t
}
function Ve(s) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? Si(Object(t), !0).forEach(function (r) {
          cu(s, r, t[r])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(t))
      : Si(Object(t)).forEach(function (r) {
          Object.defineProperty(s, r, Object.getOwnPropertyDescriptor(t, r))
        })
  }
  return s
}
function cu(s, e, t) {
  return (
    (e = du(e)),
    e in s
      ? Object.defineProperty(s, e, { value: t, enumerable: !0, configurable: !0, writable: !0 })
      : (s[e] = t),
    s
  )
}
function Te() {
  return (
    (Te = Object.assign
      ? Object.assign.bind()
      : function (s) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e]
            for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (s[r] = t[r])
          }
          return s
        }),
    Te.apply(this, arguments)
  )
}
function fu(s, e) {
  if (typeof s != 'object' || s === null) return s
  var t = s[Symbol.toPrimitive]
  if (t !== void 0) {
    var r = t.call(s, e || 'default')
    if (typeof r != 'object') return r
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (e === 'string' ? String : Number)(s)
}
function du(s) {
  var e = fu(s, 'string')
  return typeof e == 'symbol' ? e : String(e)
}
const J =
  Number.isFinite ||
  function (s) {
    return typeof s == 'number' && isFinite(s)
  }
let O = (function (s) {
    return (
      (s.MEDIA_ATTACHING = 'hlsMediaAttaching'),
      (s.MEDIA_ATTACHED = 'hlsMediaAttached'),
      (s.MEDIA_DETACHING = 'hlsMediaDetaching'),
      (s.MEDIA_DETACHED = 'hlsMediaDetached'),
      (s.BUFFER_RESET = 'hlsBufferReset'),
      (s.BUFFER_CODECS = 'hlsBufferCodecs'),
      (s.BUFFER_CREATED = 'hlsBufferCreated'),
      (s.BUFFER_APPENDING = 'hlsBufferAppending'),
      (s.BUFFER_APPENDED = 'hlsBufferAppended'),
      (s.BUFFER_EOS = 'hlsBufferEos'),
      (s.BUFFER_FLUSHING = 'hlsBufferFlushing'),
      (s.BUFFER_FLUSHED = 'hlsBufferFlushed'),
      (s.MANIFEST_LOADING = 'hlsManifestLoading'),
      (s.MANIFEST_LOADED = 'hlsManifestLoaded'),
      (s.MANIFEST_PARSED = 'hlsManifestParsed'),
      (s.LEVEL_SWITCHING = 'hlsLevelSwitching'),
      (s.LEVEL_SWITCHED = 'hlsLevelSwitched'),
      (s.LEVEL_LOADING = 'hlsLevelLoading'),
      (s.LEVEL_LOADED = 'hlsLevelLoaded'),
      (s.LEVEL_UPDATED = 'hlsLevelUpdated'),
      (s.LEVEL_PTS_UPDATED = 'hlsLevelPtsUpdated'),
      (s.LEVELS_UPDATED = 'hlsLevelsUpdated'),
      (s.AUDIO_TRACKS_UPDATED = 'hlsAudioTracksUpdated'),
      (s.AUDIO_TRACK_SWITCHING = 'hlsAudioTrackSwitching'),
      (s.AUDIO_TRACK_SWITCHED = 'hlsAudioTrackSwitched'),
      (s.AUDIO_TRACK_LOADING = 'hlsAudioTrackLoading'),
      (s.AUDIO_TRACK_LOADED = 'hlsAudioTrackLoaded'),
      (s.SUBTITLE_TRACKS_UPDATED = 'hlsSubtitleTracksUpdated'),
      (s.SUBTITLE_TRACKS_CLEARED = 'hlsSubtitleTracksCleared'),
      (s.SUBTITLE_TRACK_SWITCH = 'hlsSubtitleTrackSwitch'),
      (s.SUBTITLE_TRACK_LOADING = 'hlsSubtitleTrackLoading'),
      (s.SUBTITLE_TRACK_LOADED = 'hlsSubtitleTrackLoaded'),
      (s.SUBTITLE_FRAG_PROCESSED = 'hlsSubtitleFragProcessed'),
      (s.CUES_PARSED = 'hlsCuesParsed'),
      (s.NON_NATIVE_TEXT_TRACKS_FOUND = 'hlsNonNativeTextTracksFound'),
      (s.INIT_PTS_FOUND = 'hlsInitPtsFound'),
      (s.FRAG_LOADING = 'hlsFragLoading'),
      (s.FRAG_LOAD_EMERGENCY_ABORTED = 'hlsFragLoadEmergencyAborted'),
      (s.FRAG_LOADED = 'hlsFragLoaded'),
      (s.FRAG_DECRYPTED = 'hlsFragDecrypted'),
      (s.FRAG_PARSING_INIT_SEGMENT = 'hlsFragParsingInitSegment'),
      (s.FRAG_PARSING_USERDATA = 'hlsFragParsingUserdata'),
      (s.FRAG_PARSING_METADATA = 'hlsFragParsingMetadata'),
      (s.FRAG_PARSED = 'hlsFragParsed'),
      (s.FRAG_BUFFERED = 'hlsFragBuffered'),
      (s.FRAG_CHANGED = 'hlsFragChanged'),
      (s.FPS_DROP = 'hlsFpsDrop'),
      (s.FPS_DROP_LEVEL_CAPPING = 'hlsFpsDropLevelCapping'),
      (s.ERROR = 'hlsError'),
      (s.DESTROYING = 'hlsDestroying'),
      (s.KEY_LOADING = 'hlsKeyLoading'),
      (s.KEY_LOADED = 'hlsKeyLoaded'),
      (s.LIVE_BACK_BUFFER_REACHED = 'hlsLiveBackBufferReached'),
      (s.BACK_BUFFER_REACHED = 'hlsBackBufferReached'),
      s
    )
  })({}),
  ne = (function (s) {
    return (
      (s.NETWORK_ERROR = 'networkError'),
      (s.MEDIA_ERROR = 'mediaError'),
      (s.KEY_SYSTEM_ERROR = 'keySystemError'),
      (s.MUX_ERROR = 'muxError'),
      (s.OTHER_ERROR = 'otherError'),
      s
    )
  })({}),
  K = (function (s) {
    return (
      (s.KEY_SYSTEM_NO_KEYS = 'keySystemNoKeys'),
      (s.KEY_SYSTEM_NO_ACCESS = 'keySystemNoAccess'),
      (s.KEY_SYSTEM_NO_SESSION = 'keySystemNoSession'),
      (s.KEY_SYSTEM_NO_CONFIGURED_LICENSE = 'keySystemNoConfiguredLicense'),
      (s.KEY_SYSTEM_LICENSE_REQUEST_FAILED = 'keySystemLicenseRequestFailed'),
      (s.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = 'keySystemServerCertificateRequestFailed'),
      (s.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = 'keySystemServerCertificateUpdateFailed'),
      (s.KEY_SYSTEM_SESSION_UPDATE_FAILED = 'keySystemSessionUpdateFailed'),
      (s.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = 'keySystemStatusOutputRestricted'),
      (s.KEY_SYSTEM_STATUS_INTERNAL_ERROR = 'keySystemStatusInternalError'),
      (s.MANIFEST_LOAD_ERROR = 'manifestLoadError'),
      (s.MANIFEST_LOAD_TIMEOUT = 'manifestLoadTimeOut'),
      (s.MANIFEST_PARSING_ERROR = 'manifestParsingError'),
      (s.MANIFEST_INCOMPATIBLE_CODECS_ERROR = 'manifestIncompatibleCodecsError'),
      (s.LEVEL_EMPTY_ERROR = 'levelEmptyError'),
      (s.LEVEL_LOAD_ERROR = 'levelLoadError'),
      (s.LEVEL_LOAD_TIMEOUT = 'levelLoadTimeOut'),
      (s.LEVEL_PARSING_ERROR = 'levelParsingError'),
      (s.LEVEL_SWITCH_ERROR = 'levelSwitchError'),
      (s.AUDIO_TRACK_LOAD_ERROR = 'audioTrackLoadError'),
      (s.AUDIO_TRACK_LOAD_TIMEOUT = 'audioTrackLoadTimeOut'),
      (s.SUBTITLE_LOAD_ERROR = 'subtitleTrackLoadError'),
      (s.SUBTITLE_TRACK_LOAD_TIMEOUT = 'subtitleTrackLoadTimeOut'),
      (s.FRAG_LOAD_ERROR = 'fragLoadError'),
      (s.FRAG_LOAD_TIMEOUT = 'fragLoadTimeOut'),
      (s.FRAG_DECRYPT_ERROR = 'fragDecryptError'),
      (s.FRAG_PARSING_ERROR = 'fragParsingError'),
      (s.FRAG_GAP = 'fragGap'),
      (s.REMUX_ALLOC_ERROR = 'remuxAllocError'),
      (s.KEY_LOAD_ERROR = 'keyLoadError'),
      (s.KEY_LOAD_TIMEOUT = 'keyLoadTimeOut'),
      (s.BUFFER_ADD_CODEC_ERROR = 'bufferAddCodecError'),
      (s.BUFFER_INCOMPATIBLE_CODECS_ERROR = 'bufferIncompatibleCodecsError'),
      (s.BUFFER_APPEND_ERROR = 'bufferAppendError'),
      (s.BUFFER_APPENDING_ERROR = 'bufferAppendingError'),
      (s.BUFFER_STALLED_ERROR = 'bufferStalledError'),
      (s.BUFFER_FULL_ERROR = 'bufferFullError'),
      (s.BUFFER_SEEK_OVER_HOLE = 'bufferSeekOverHole'),
      (s.BUFFER_NUDGE_ON_STALL = 'bufferNudgeOnStall'),
      (s.INTERNAL_EXCEPTION = 'internalException'),
      (s.INTERNAL_ABORTED = 'aborted'),
      (s.UNKNOWN = 'unknown'),
      s
    )
  })({})
const ht = function () {},
  vn = { trace: ht, debug: ht, log: ht, warn: ht, info: ht, error: ht }
let Gt = vn
function hu(s) {
  const e = self.console[s]
  return e ? e.bind(self.console, `[${s}] >`) : ht
}
function pu(s, ...e) {
  e.forEach(function (t) {
    Gt[t] = s[t] ? s[t].bind(s) : hu(t)
  })
}
function mu(s, e) {
  if ((self.console && s === !0) || typeof s == 'object') {
    pu(s, 'debug', 'log', 'info', 'warn', 'error')
    try {
      Gt.log(`Debug logs enabled for "${e}" in hls.js version 1.4.12`)
    } catch {
      Gt = vn
    }
  } else Gt = vn
}
const G = Gt,
  gu = /^(\d+)x(\d+)$/,
  Ti = /(.+?)=(".*?"|.*?)(?:,|$)/g
class ye {
  constructor(e) {
    typeof e == 'string' && (e = ye.parseAttrList(e))
    for (const t in e)
      e.hasOwnProperty(t) &&
        (t.substring(0, 2) === 'X-' &&
          ((this.clientAttrs = this.clientAttrs || []), this.clientAttrs.push(t)),
        (this[t] = e[t]))
  }
  decimalInteger(e) {
    const t = parseInt(this[e], 10)
    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
  }
  hexadecimalInteger(e) {
    if (this[e]) {
      let t = (this[e] || '0x').slice(2)
      t = (t.length & 1 ? '0' : '') + t
      const r = new Uint8Array(t.length / 2)
      for (let n = 0; n < t.length / 2; n++) r[n] = parseInt(t.slice(n * 2, n * 2 + 2), 16)
      return r
    } else return null
  }
  hexadecimalIntegerAsNumber(e) {
    const t = parseInt(this[e], 16)
    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
  }
  decimalFloatingPoint(e) {
    return parseFloat(this[e])
  }
  optionalFloat(e, t) {
    const r = this[e]
    return r ? parseFloat(r) : t
  }
  enumeratedString(e) {
    return this[e]
  }
  bool(e) {
    return this[e] === 'YES'
  }
  decimalResolution(e) {
    const t = gu.exec(this[e])
    if (t !== null) return { width: parseInt(t[1], 10), height: parseInt(t[2], 10) }
  }
  static parseAttrList(e) {
    let t
    const r = {},
      n = '"'
    for (Ti.lastIndex = 0; (t = Ti.exec(e)) !== null; ) {
      let i = t[2]
      i.indexOf(n) === 0 && i.lastIndexOf(n) === i.length - 1 && (i = i.slice(1, -1))
      const a = t[1].trim()
      r[a] = i
    }
    return r
  }
}
function yu(s) {
  return (
    s !== 'ID' &&
    s !== 'CLASS' &&
    s !== 'START-DATE' &&
    s !== 'DURATION' &&
    s !== 'END-DATE' &&
    s !== 'END-ON-NEXT'
  )
}
function vu(s) {
  return s === 'SCTE35-OUT' || s === 'SCTE35-IN'
}
class js {
  constructor(e, t) {
    if (
      ((this.attr = void 0),
      (this._startDate = void 0),
      (this._endDate = void 0),
      (this._badValueForSameId = void 0),
      t)
    ) {
      const r = t.attr
      for (const n in r)
        if (Object.prototype.hasOwnProperty.call(e, n) && e[n] !== r[n]) {
          G.warn(`DATERANGE tag attribute: "${n}" does not match for tags with ID: "${e.ID}"`),
            (this._badValueForSameId = n)
          break
        }
      e = Te(new ye({}), r, e)
    }
    if (((this.attr = e), (this._startDate = new Date(e['START-DATE'])), 'END-DATE' in this.attr)) {
      const r = new Date(this.attr['END-DATE'])
      J(r.getTime()) && (this._endDate = r)
    }
  }
  get id() {
    return this.attr.ID
  }
  get class() {
    return this.attr.CLASS
  }
  get startDate() {
    return this._startDate
  }
  get endDate() {
    if (this._endDate) return this._endDate
    const e = this.duration
    return e !== null ? new Date(this._startDate.getTime() + e * 1e3) : null
  }
  get duration() {
    if ('DURATION' in this.attr) {
      const e = this.attr.decimalFloatingPoint('DURATION')
      if (J(e)) return e
    } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3
    return null
  }
  get plannedDuration() {
    return 'PLANNED-DURATION' in this.attr
      ? this.attr.decimalFloatingPoint('PLANNED-DURATION')
      : null
  }
  get endOnNext() {
    return this.attr.bool('END-ON-NEXT')
  }
  get isValid() {
    return (
      !!this.id &&
      !this._badValueForSameId &&
      J(this.startDate.getTime()) &&
      (this.duration === null || this.duration >= 0) &&
      (!this.endOnNext || !!this.class)
    )
  }
}
class _r {
  constructor() {
    ;(this.aborted = !1),
      (this.loaded = 0),
      (this.retry = 0),
      (this.total = 0),
      (this.chunkCount = 0),
      (this.bwEstimate = 0),
      (this.loading = { start: 0, first: 0, end: 0 }),
      (this.parsing = { start: 0, end: 0 }),
      (this.buffering = { start: 0, first: 0, end: 0 })
  }
}
var pe = { AUDIO: 'audio', VIDEO: 'video', AUDIOVIDEO: 'audiovideo' }
class Vs {
  constructor(e) {
    ;(this._byteRange = null),
      (this._url = null),
      (this.baseurl = void 0),
      (this.relurl = void 0),
      (this.elementaryStreams = { [pe.AUDIO]: null, [pe.VIDEO]: null, [pe.AUDIOVIDEO]: null }),
      (this.baseurl = e)
  }
  setByteRange(e, t) {
    const r = e.split('@', 2),
      n = []
    r.length === 1 ? (n[0] = t ? t.byteRangeEndOffset : 0) : (n[0] = parseInt(r[1])),
      (n[1] = parseInt(r[0]) + n[0]),
      (this._byteRange = n)
  }
  get byteRange() {
    return this._byteRange ? this._byteRange : []
  }
  get byteRangeStartOffset() {
    return this.byteRange[0]
  }
  get byteRangeEndOffset() {
    return this.byteRange[1]
  }
  get url() {
    return (
      !this._url &&
        this.baseurl &&
        this.relurl &&
        (this._url = wn.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: !0 })),
      this._url || ''
    )
  }
  set url(e) {
    this._url = e
  }
}
class jr extends Vs {
  constructor(e, t) {
    super(t),
      (this._decryptdata = null),
      (this.rawProgramDateTime = null),
      (this.programDateTime = null),
      (this.tagList = []),
      (this.duration = 0),
      (this.sn = 0),
      (this.levelkeys = void 0),
      (this.type = void 0),
      (this.loader = null),
      (this.keyLoader = null),
      (this.level = -1),
      (this.cc = 0),
      (this.startPTS = void 0),
      (this.endPTS = void 0),
      (this.startDTS = void 0),
      (this.endDTS = void 0),
      (this.start = 0),
      (this.deltaPTS = void 0),
      (this.maxStartPTS = void 0),
      (this.minEndPTS = void 0),
      (this.stats = new _r()),
      (this.urlId = 0),
      (this.data = void 0),
      (this.bitrateTest = !1),
      (this.title = null),
      (this.initSegment = null),
      (this.endList = void 0),
      (this.gap = void 0),
      (this.type = e)
  }
  get decryptdata() {
    const { levelkeys: e } = this
    if (!e && !this._decryptdata) return null
    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
      const t = this.levelkeys.identity
      if (t) this._decryptdata = t.getDecryptData(this.sn)
      else {
        const r = Object.keys(this.levelkeys)
        if (r.length === 1)
          return (this._decryptdata = this.levelkeys[r[0]].getDecryptData(this.sn))
      }
    }
    return this._decryptdata
  }
  get end() {
    return this.start + this.duration
  }
  get endProgramDateTime() {
    if (this.programDateTime === null || !J(this.programDateTime)) return null
    const e = J(this.duration) ? this.duration : 0
    return this.programDateTime + e * 1e3
  }
  get encrypted() {
    var e
    if ((e = this._decryptdata) != null && e.encrypted) return !0
    if (this.levelkeys) {
      const t = Object.keys(this.levelkeys),
        r = t.length
      if (r > 1 || (r === 1 && this.levelkeys[t[0]].encrypted)) return !0
    }
    return !1
  }
  setKeyFormat(e) {
    if (this.levelkeys) {
      const t = this.levelkeys[e]
      t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn))
    }
  }
  abortRequests() {
    var e, t
    ;(e = this.loader) == null || e.abort(), (t = this.keyLoader) == null || t.abort()
  }
  setElementaryStreamInfo(e, t, r, n, i, a = !1) {
    const { elementaryStreams: o } = this,
      l = o[e]
    if (!l) {
      o[e] = { startPTS: t, endPTS: r, startDTS: n, endDTS: i, partial: a }
      return
    }
    ;(l.startPTS = Math.min(l.startPTS, t)),
      (l.endPTS = Math.max(l.endPTS, r)),
      (l.startDTS = Math.min(l.startDTS, n)),
      (l.endDTS = Math.max(l.endDTS, i))
  }
  clearElementaryStreamInfo() {
    const { elementaryStreams: e } = this
    ;(e[pe.AUDIO] = null), (e[pe.VIDEO] = null), (e[pe.AUDIOVIDEO] = null)
  }
}
class _u extends Vs {
  constructor(e, t, r, n, i) {
    super(r),
      (this.fragOffset = 0),
      (this.duration = 0),
      (this.gap = !1),
      (this.independent = !1),
      (this.relurl = void 0),
      (this.fragment = void 0),
      (this.index = void 0),
      (this.stats = new _r()),
      (this.duration = e.decimalFloatingPoint('DURATION')),
      (this.gap = e.bool('GAP')),
      (this.independent = e.bool('INDEPENDENT')),
      (this.relurl = e.enumeratedString('URI')),
      (this.fragment = t),
      (this.index = n)
    const a = e.enumeratedString('BYTERANGE')
    a && this.setByteRange(a, i), i && (this.fragOffset = i.fragOffset + i.duration)
  }
  get start() {
    return this.fragment.start + this.fragOffset
  }
  get end() {
    return this.start + this.duration
  }
  get loaded() {
    const { elementaryStreams: e } = this
    return !!(e.audio || e.video || e.audiovideo)
  }
}
const Eu = 10
class xu {
  constructor(e) {
    ;(this.PTSKnown = !1),
      (this.alignedSliding = !1),
      (this.averagetargetduration = void 0),
      (this.endCC = 0),
      (this.endSN = 0),
      (this.fragments = void 0),
      (this.fragmentHint = void 0),
      (this.partList = null),
      (this.dateRanges = void 0),
      (this.live = !0),
      (this.ageHeader = 0),
      (this.advancedDateTime = void 0),
      (this.updated = !0),
      (this.advanced = !0),
      (this.availabilityDelay = void 0),
      (this.misses = 0),
      (this.startCC = 0),
      (this.startSN = 0),
      (this.startTimeOffset = null),
      (this.targetduration = 0),
      (this.totalduration = 0),
      (this.type = null),
      (this.url = void 0),
      (this.m3u8 = ''),
      (this.version = null),
      (this.canBlockReload = !1),
      (this.canSkipUntil = 0),
      (this.canSkipDateRanges = !1),
      (this.skippedSegments = 0),
      (this.recentlyRemovedDateranges = void 0),
      (this.partHoldBack = 0),
      (this.holdBack = 0),
      (this.partTarget = 0),
      (this.preloadHint = void 0),
      (this.renditionReports = void 0),
      (this.tuneInGoal = 0),
      (this.deltaUpdateFailed = void 0),
      (this.driftStartTime = 0),
      (this.driftEndTime = 0),
      (this.driftStart = 0),
      (this.driftEnd = 0),
      (this.encryptedFragments = void 0),
      (this.playlistParsingError = null),
      (this.variableList = null),
      (this.hasVariableRefs = !1),
      (this.fragments = []),
      (this.encryptedFragments = []),
      (this.dateRanges = {}),
      (this.url = e)
  }
  reloaded(e) {
    if (!e) {
      ;(this.advanced = !0), (this.updated = !0)
      return
    }
    const t = this.lastPartSn - e.lastPartSn,
      r = this.lastPartIndex - e.lastPartIndex
    ;(this.updated = this.endSN !== e.endSN || !!r || !!t || !this.live),
      (this.advanced = this.endSN > e.endSN || t > 0 || (t === 0 && r > 0)),
      this.updated || this.advanced
        ? (this.misses = Math.floor(e.misses * 0.6))
        : (this.misses = e.misses + 1),
      (this.availabilityDelay = e.availabilityDelay)
  }
  get hasProgramDateTime() {
    return this.fragments.length ? J(this.fragments[this.fragments.length - 1].programDateTime) : !1
  }
  get levelTargetDuration() {
    return this.averagetargetduration || this.targetduration || Eu
  }
  get drift() {
    const e = this.driftEndTime - this.driftStartTime
    return e > 0 ? ((this.driftEnd - this.driftStart) * 1e3) / e : 1
  }
  get edge() {
    return this.partEnd || this.fragmentEnd
  }
  get partEnd() {
    var e
    return (e = this.partList) != null && e.length
      ? this.partList[this.partList.length - 1].end
      : this.fragmentEnd
  }
  get fragmentEnd() {
    var e
    return (e = this.fragments) != null && e.length
      ? this.fragments[this.fragments.length - 1].end
      : 0
  }
  get age() {
    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
  }
  get lastPartIndex() {
    var e
    return (e = this.partList) != null && e.length
      ? this.partList[this.partList.length - 1].index
      : -1
  }
  get lastPartSn() {
    var e
    return (e = this.partList) != null && e.length
      ? this.partList[this.partList.length - 1].fragment.sn
      : this.endSN
  }
}
function Cn(s) {
  return Uint8Array.from(atob(s), (e) => e.charCodeAt(0))
}
function Su(s) {
  const e = Hs(s).subarray(0, 16),
    t = new Uint8Array(16)
  return t.set(e, 16 - e.length), t
}
function Tu(s) {
  const e = function (r, n, i) {
    const a = r[n]
    ;(r[n] = r[i]), (r[i] = a)
  }
  e(s, 0, 3), e(s, 1, 2), e(s, 4, 5), e(s, 6, 7)
}
function bu(s) {
  const e = s.split(':')
  let t = null
  if (e[0] === 'data' && e.length === 2) {
    const r = e[1].split(';'),
      n = r[r.length - 1].split(',')
    if (n.length === 2) {
      const i = n[0] === 'base64',
        a = n[1]
      i ? (r.splice(-1, 1), (t = Cn(a))) : (t = Su(a))
    }
  }
  return t
}
function Hs(s) {
  return Uint8Array.from(unescape(encodeURIComponent(s)), (e) => e.charCodeAt(0))
}
var ve = {
    CLEARKEY: 'org.w3.clearkey',
    FAIRPLAY: 'com.apple.fps',
    PLAYREADY: 'com.microsoft.playready',
    WIDEVINE: 'com.widevine.alpha'
  },
  je = {
    CLEARKEY: 'org.w3.clearkey',
    FAIRPLAY: 'com.apple.streamingkeydelivery',
    PLAYREADY: 'com.microsoft.playready',
    WIDEVINE: 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'
  }
function bi(s) {
  switch (s) {
    case je.FAIRPLAY:
      return ve.FAIRPLAY
    case je.PLAYREADY:
      return ve.PLAYREADY
    case je.WIDEVINE:
      return ve.WIDEVINE
    case je.CLEARKEY:
      return ve.CLEARKEY
  }
}
var Ws = { WIDEVINE: 'edef8ba979d64acea3c827dcd51d21ed' }
function Lu(s) {
  if (s === Ws.WIDEVINE) return ve.WIDEVINE
}
function Li(s) {
  switch (s) {
    case ve.FAIRPLAY:
      return je.FAIRPLAY
    case ve.PLAYREADY:
      return je.PLAYREADY
    case ve.WIDEVINE:
      return je.WIDEVINE
    case ve.CLEARKEY:
      return je.CLEARKEY
  }
}
function Vr(s) {
  const { drmSystems: e, widevineLicenseUrl: t } = s,
    r = e ? [ve.FAIRPLAY, ve.WIDEVINE, ve.PLAYREADY, ve.CLEARKEY].filter((n) => !!e[n]) : []
  return !r[ve.WIDEVINE] && t && r.push(ve.WIDEVINE), r
}
const Ys = (function () {
  return typeof self < 'u' && self.navigator && self.navigator.requestMediaKeySystemAccess
    ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator)
    : null
})()
function Au(s, e, t, r) {
  let n
  switch (s) {
    case ve.FAIRPLAY:
      n = ['cenc', 'sinf']
      break
    case ve.WIDEVINE:
    case ve.PLAYREADY:
      n = ['cenc']
      break
    case ve.CLEARKEY:
      n = ['cenc', 'keyids']
      break
    default:
      throw new Error(`Unknown key-system: ${s}`)
  }
  return Ru(n, e, t, r)
}
function Ru(s, e, t, r) {
  return [
    {
      initDataTypes: s,
      persistentState: r.persistentState || 'not-allowed',
      distinctiveIdentifier: r.distinctiveIdentifier || 'not-allowed',
      sessionTypes: r.sessionTypes || [r.sessionType || 'temporary'],
      audioCapabilities: e.map((i) => ({
        contentType: `audio/mp4; codecs="${i}"`,
        robustness: r.audioRobustness || '',
        encryptionScheme: r.audioEncryptionScheme || null
      })),
      videoCapabilities: t.map((i) => ({
        contentType: `video/mp4; codecs="${i}"`,
        robustness: r.videoRobustness || '',
        encryptionScheme: r.videoEncryptionScheme || null
      }))
    }
  ]
}
function gt(s, e, t) {
  return Uint8Array.prototype.slice
    ? s.slice(e, t)
    : new Uint8Array(Array.prototype.slice.call(s, e, t))
}
const kn = (s, e) =>
    e + 10 <= s.length &&
    s[e] === 73 &&
    s[e + 1] === 68 &&
    s[e + 2] === 51 &&
    s[e + 3] < 255 &&
    s[e + 4] < 255 &&
    s[e + 6] < 128 &&
    s[e + 7] < 128 &&
    s[e + 8] < 128 &&
    s[e + 9] < 128,
  zs = (s, e) =>
    e + 10 <= s.length &&
    s[e] === 51 &&
    s[e + 1] === 68 &&
    s[e + 2] === 73 &&
    s[e + 3] < 255 &&
    s[e + 4] < 255 &&
    s[e + 6] < 128 &&
    s[e + 7] < 128 &&
    s[e + 8] < 128 &&
    s[e + 9] < 128,
  fr = (s, e) => {
    const t = e
    let r = 0
    for (; kn(s, e); ) {
      r += 10
      const n = Er(s, e + 6)
      ;(r += n), zs(s, e + 10) && (r += 10), (e += r)
    }
    if (r > 0) return s.subarray(t, t + r)
  },
  Er = (s, e) => {
    let t = 0
    return (
      (t = (s[e] & 127) << 21),
      (t |= (s[e + 1] & 127) << 14),
      (t |= (s[e + 2] & 127) << 7),
      (t |= s[e + 3] & 127),
      t
    )
  },
  Iu = (s, e) => kn(s, e) && Er(s, e + 6) + 10 <= s.length - e,
  Pu = (s) => {
    const e = Xs(s)
    for (let t = 0; t < e.length; t++) {
      const r = e[t]
      if (qs(r)) return Mu(r)
    }
  },
  qs = (s) => s && s.key === 'PRIV' && s.info === 'com.apple.streaming.transportStreamTimestamp',
  Du = (s) => {
    const e = String.fromCharCode(s[0], s[1], s[2], s[3]),
      t = Er(s, 4),
      r = 10
    return { type: e, size: t, data: s.subarray(r, r + t) }
  },
  Xs = (s) => {
    let e = 0
    const t = []
    for (; kn(s, e); ) {
      const r = Er(s, e + 6)
      e += 10
      const n = e + r
      for (; e + 8 < n; ) {
        const i = Du(s.subarray(e)),
          a = Ou(i)
        a && t.push(a), (e += i.size + 10)
      }
      zs(s, e) && (e += 10)
    }
    return t
  },
  Ou = (s) => (s.type === 'PRIV' ? wu(s) : s.type[0] === 'W' ? ku(s) : Cu(s)),
  wu = (s) => {
    if (s.size < 2) return
    const e = tt(s.data, !0),
      t = new Uint8Array(s.data.subarray(e.length + 1))
    return { key: s.type, info: e, data: t.buffer }
  },
  Cu = (s) => {
    if (s.size < 2) return
    if (s.type === 'TXXX') {
      let t = 1
      const r = tt(s.data.subarray(t), !0)
      t += r.length + 1
      const n = tt(s.data.subarray(t))
      return { key: s.type, info: r, data: n }
    }
    const e = tt(s.data.subarray(1))
    return { key: s.type, data: e }
  },
  ku = (s) => {
    if (s.type === 'WXXX') {
      if (s.size < 2) return
      let t = 1
      const r = tt(s.data.subarray(t), !0)
      t += r.length + 1
      const n = tt(s.data.subarray(t))
      return { key: s.type, info: r, data: n }
    }
    const e = tt(s.data)
    return { key: s.type, data: e }
  },
  Mu = (s) => {
    if (s.data.byteLength === 8) {
      const e = new Uint8Array(s.data),
        t = e[3] & 1
      let r = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7]
      return (r /= 45), t && (r += 4772185884e-2), Math.round(r)
    }
  },
  tt = (s, e = !1) => {
    const t = Fu()
    if (t) {
      const u = t.decode(s)
      if (e) {
        const c = u.indexOf('\0')
        return c !== -1 ? u.substring(0, c) : u
      }
      return u.replace(/\0/g, '')
    }
    const r = s.length
    let n,
      i,
      a,
      o = '',
      l = 0
    for (; l < r; ) {
      if (((n = s[l++]), n === 0 && e)) return o
      if (n === 0 || n === 3) continue
      switch (n >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          o += String.fromCharCode(n)
          break
        case 12:
        case 13:
          ;(i = s[l++]), (o += String.fromCharCode(((n & 31) << 6) | (i & 63)))
          break
        case 14:
          ;(i = s[l++]),
            (a = s[l++]),
            (o += String.fromCharCode(((n & 15) << 12) | ((i & 63) << 6) | ((a & 63) << 0)))
          break
      }
    }
    return o
  }
let Hr
function Fu() {
  return !Hr && typeof self.TextDecoder < 'u' && (Hr = new self.TextDecoder('utf-8')), Hr
}
const Je = {
    hexDump: function (s) {
      let e = ''
      for (let t = 0; t < s.length; t++) {
        let r = s[t].toString(16)
        r.length < 2 && (r = '0' + r), (e += r)
      }
      return e
    }
  },
  dr = Math.pow(2, 32) - 1,
  Nu = [].push,
  Qs = { video: 1, audio: 2, id3: 3, text: 4 }
function Pe(s) {
  return String.fromCharCode.apply(null, s)
}
function Zs(s, e) {
  const t = (s[e] << 8) | s[e + 1]
  return t < 0 ? 65536 + t : t
}
function se(s, e) {
  const t = Js(s, e)
  return t < 0 ? 4294967296 + t : t
}
function Js(s, e) {
  return (s[e] << 24) | (s[e + 1] << 16) | (s[e + 2] << 8) | s[e + 3]
}
function Wr(s, e, t) {
  ;(s[e] = t >> 24), (s[e + 1] = (t >> 16) & 255), (s[e + 2] = (t >> 8) & 255), (s[e + 3] = t & 255)
}
function ce(s, e) {
  const t = []
  if (!e.length) return t
  const r = s.byteLength
  for (let n = 0; n < r; ) {
    const i = se(s, n),
      a = Pe(s.subarray(n + 4, n + 8)),
      o = i > 1 ? n + i : r
    if (a === e[0])
      if (e.length === 1) t.push(s.subarray(n + 8, o))
      else {
        const l = ce(s.subarray(n + 8, o), e.slice(1))
        l.length && Nu.apply(t, l)
      }
    n = o
  }
  return t
}
function Uu(s) {
  const e = [],
    t = s[0]
  let r = 8
  const n = se(s, r)
  r += 4
  const i = 0,
    a = 0
  t === 0 ? (r += 8) : (r += 16), (r += 2)
  let o = s.length + a
  const l = Zs(s, r)
  r += 2
  for (let u = 0; u < l; u++) {
    let c = r
    const f = se(s, c)
    c += 4
    const d = f & 2147483647
    if ((f & 2147483648) >>> 31 === 1)
      return G.warn('SIDX has hierarchical references (not supported)'), null
    const p = se(s, c)
    ;(c += 4),
      e.push({
        referenceSize: d,
        subsegmentDuration: p,
        info: { duration: p / n, start: o, end: o + d - 1 }
      }),
      (o += d),
      (c += 4),
      (r = c)
  }
  return {
    earliestPresentationTime: i,
    timescale: n,
    version: t,
    referencesCount: l,
    references: e
  }
}
function ea(s) {
  const e = [],
    t = ce(s, ['moov', 'trak'])
  for (let n = 0; n < t.length; n++) {
    const i = t[n],
      a = ce(i, ['tkhd'])[0]
    if (a) {
      let o = a[0],
        l = o === 0 ? 12 : 20
      const u = se(a, l),
        c = ce(i, ['mdia', 'mdhd'])[0]
      if (c) {
        ;(o = c[0]), (l = o === 0 ? 12 : 20)
        const f = se(c, l),
          d = ce(i, ['mdia', 'hdlr'])[0]
        if (d) {
          const m = Pe(d.subarray(8, 12)),
            p = { soun: pe.AUDIO, vide: pe.VIDEO }[m]
          if (p) {
            const v = ce(i, ['mdia', 'minf', 'stbl', 'stsd'])[0]
            let E
            v && (E = Pe(v.subarray(12, 16))),
              (e[u] = { timescale: f, type: p }),
              (e[p] = { timescale: f, id: u, codec: E })
          }
        }
      }
    }
  }
  return (
    ce(s, ['moov', 'mvex', 'trex']).forEach((n) => {
      const i = se(n, 4),
        a = e[i]
      a && (a.default = { duration: se(n, 12), flags: se(n, 20) })
    }),
    e
  )
}
function Bu(s, e) {
  if (!s || !e) return s
  const t = e.keyId
  return (
    t &&
      e.isCommonEncryption &&
      ce(s, ['moov', 'trak']).forEach((n) => {
        const a = ce(n, ['mdia', 'minf', 'stbl', 'stsd'])[0].subarray(8)
        let o = ce(a, ['enca'])
        const l = o.length > 0
        l || (o = ce(a, ['encv'])),
          o.forEach((u) => {
            const c = l ? u.subarray(28) : u.subarray(78)
            ce(c, ['sinf']).forEach((d) => {
              const m = ta(d)
              if (m) {
                const p = m.subarray(8, 24)
                p.some((v) => v !== 0) ||
                  (G.log(
                    `[eme] Patching keyId in 'enc${l ? 'a' : 'v'}>sinf>>tenc' box: ${Je.hexDump(
                      p
                    )} -> ${Je.hexDump(t)}`
                  ),
                  m.set(t, 8))
              }
            })
          })
      }),
    s
  )
}
function ta(s) {
  const e = ce(s, ['schm'])[0]
  if (e) {
    const t = Pe(e.subarray(4, 8))
    if (t === 'cbcs' || t === 'cenc') return ce(s, ['schi', 'tenc'])[0]
  }
  return G.error("[eme] missing 'schm' box"), null
}
function Gu(s, e) {
  return ce(e, ['moof', 'traf']).reduce((t, r) => {
    const n = ce(r, ['tfdt'])[0],
      i = n[0],
      a = ce(r, ['tfhd']).reduce((o, l) => {
        const u = se(l, 4),
          c = s[u]
        if (c) {
          let f = se(n, 4)
          if (i === 1) {
            if (f === dr)
              return (
                G.warn(
                  '[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time'
                ),
                o
              )
            ;(f *= dr + 1), (f += se(n, 8))
          }
          const d = c.timescale || 9e4,
            m = f / d
          if (isFinite(m) && (o === null || m < o)) return m
        }
        return o
      }, null)
    return a !== null && isFinite(a) && (t === null || a < t) ? a : t
  }, null)
}
function $u(s, e) {
  let t = 0,
    r = 0,
    n = 0
  const i = ce(s, ['moof', 'traf'])
  for (let a = 0; a < i.length; a++) {
    const o = i[a],
      l = ce(o, ['tfhd'])[0],
      u = se(l, 4),
      c = e[u]
    if (!c) continue
    const f = c.default,
      d = se(l, 0) | (f == null ? void 0 : f.flags)
    let m = f == null ? void 0 : f.duration
    d & 8 && (d & 2 ? (m = se(l, 12)) : (m = se(l, 8)))
    const p = c.timescale || 9e4,
      v = ce(o, ['trun'])
    for (let E = 0; E < v.length; E++) {
      if (((t = Ku(v[E])), !t && m)) {
        const x = se(v[E], 4)
        t = m * x
      }
      c.type === pe.VIDEO ? (r += t / p) : c.type === pe.AUDIO && (n += t / p)
    }
  }
  if (r === 0 && n === 0) {
    let a = 0
    const o = ce(s, ['sidx'])
    for (let l = 0; l < o.length; l++) {
      const u = Uu(o[l])
      u != null && u.references && (a += u.references.reduce((c, f) => c + f.info.duration || 0, 0))
    }
    return a
  }
  return r || n
}
function Ku(s) {
  const e = se(s, 0)
  let t = 8
  e & 1 && (t += 4), e & 4 && (t += 4)
  let r = 0
  const n = se(s, 4)
  for (let i = 0; i < n; i++) {
    if (e & 256) {
      const a = se(s, t)
      ;(r += a), (t += 4)
    }
    e & 512 && (t += 4), e & 1024 && (t += 4), e & 2048 && (t += 4)
  }
  return r
}
function ju(s, e, t) {
  ce(e, ['moof', 'traf']).forEach((r) => {
    ce(r, ['tfhd']).forEach((n) => {
      const i = se(n, 4),
        a = s[i]
      if (!a) return
      const o = a.timescale || 9e4
      ce(r, ['tfdt']).forEach((l) => {
        const u = l[0]
        let c = se(l, 4)
        if (u === 0) (c -= t * o), (c = Math.max(c, 0)), Wr(l, 4, c)
        else {
          ;(c *= Math.pow(2, 32)), (c += se(l, 8)), (c -= t * o), (c = Math.max(c, 0))
          const f = Math.floor(c / (dr + 1)),
            d = Math.floor(c % (dr + 1))
          Wr(l, 4, f), Wr(l, 8, d)
        }
      })
    })
  })
}
function Vu(s) {
  const e = { valid: null, remainder: null },
    t = ce(s, ['moof'])
  if (t) {
    if (t.length < 2) return (e.remainder = s), e
  } else return e
  const r = t[t.length - 1]
  return (e.valid = gt(s, 0, r.byteOffset - 8)), (e.remainder = gt(s, r.byteOffset - 8)), e
}
function vt(s, e) {
  const t = new Uint8Array(s.length + e.length)
  return t.set(s), t.set(e, s.length), t
}
function Ai(s, e) {
  const t = [],
    r = e.samples,
    n = e.timescale,
    i = e.id
  let a = !1
  return (
    ce(r, ['moof']).map((l) => {
      const u = l.byteOffset - 8
      ce(l, ['traf']).map((f) => {
        const d = ce(f, ['tfdt']).map((m) => {
          const p = m[0]
          let v = se(m, 4)
          return p === 1 && ((v *= Math.pow(2, 32)), (v += se(m, 8))), v / n
        })[0]
        return (
          d !== void 0 && (s = d),
          ce(f, ['tfhd']).map((m) => {
            const p = se(m, 4),
              v = se(m, 0) & 16777215,
              E = (v & 1) !== 0,
              x = (v & 2) !== 0,
              T = (v & 8) !== 0
            let b = 0
            const R = (v & 16) !== 0
            let g = 0
            const A = (v & 32) !== 0
            let S = 8
            p === i &&
              (E && (S += 8),
              x && (S += 4),
              T && ((b = se(m, S)), (S += 4)),
              R && ((g = se(m, S)), (S += 4)),
              A && (S += 4),
              e.type === 'video' && (a = Hu(e.codec)),
              ce(f, ['trun']).map((h) => {
                const _ = h[0],
                  y = se(h, 0) & 16777215,
                  L = (y & 1) !== 0
                let I = 0
                const P = (y & 4) !== 0,
                  D = (y & 256) !== 0
                let C = 0
                const N = (y & 512) !== 0
                let M = 0
                const w = (y & 1024) !== 0,
                  U = (y & 2048) !== 0
                let F = 0
                const k = se(h, 4)
                let B = 8
                L && ((I = se(h, B)), (B += 4)), P && (B += 4)
                let V = I + u
                for (let H = 0; H < k; H++) {
                  if (
                    (D ? ((C = se(h, B)), (B += 4)) : (C = b),
                    N ? ((M = se(h, B)), (B += 4)) : (M = g),
                    w && (B += 4),
                    U && (_ === 0 ? (F = se(h, B)) : (F = Js(h, B)), (B += 4)),
                    e.type === pe.VIDEO)
                  ) {
                    let q = 0
                    for (; q < M; ) {
                      const X = se(r, V)
                      if (((V += 4), Wu(a, r[V]))) {
                        const Q = r.subarray(V, V + X)
                        ra(Q, a ? 2 : 1, s + F / n, t)
                      }
                      ;(V += X), (q += X + 4)
                    }
                  }
                  s += C / n
                }
              }))
          })
        )
      })
    }),
    t
  )
}
function Hu(s) {
  if (!s) return !1
  const e = s.indexOf('.'),
    t = e < 0 ? s : s.substring(0, e)
  return t === 'hvc1' || t === 'hev1' || t === 'dvh1' || t === 'dvhe'
}
function Wu(s, e) {
  if (s) {
    const t = (e >> 1) & 63
    return t === 39 || t === 40
  } else return (e & 31) === 6
}
function ra(s, e, t, r) {
  const n = na(s)
  let i = 0
  i += e
  let a = 0,
    o = 0,
    l = !1,
    u = 0
  for (; i < n.length; ) {
    a = 0
    do {
      if (i >= n.length) break
      ;(u = n[i++]), (a += u)
    } while (u === 255)
    o = 0
    do {
      if (i >= n.length) break
      ;(u = n[i++]), (o += u)
    } while (u === 255)
    const c = n.length - i
    if (!l && a === 4 && i < n.length) {
      if (((l = !0), n[i++] === 181)) {
        const d = Zs(n, i)
        if (((i += 2), d === 49)) {
          const m = se(n, i)
          if (((i += 4), m === 1195456820)) {
            const p = n[i++]
            if (p === 3) {
              const v = n[i++],
                E = 31 & v,
                x = 64 & v,
                T = x ? 2 + E * 3 : 0,
                b = new Uint8Array(T)
              if (x) {
                b[0] = v
                for (let R = 1; R < T; R++) b[R] = n[i++]
              }
              r.push({ type: p, payloadType: a, pts: t, bytes: b })
            }
          }
        }
      }
    } else if (a === 5 && o < c) {
      if (((l = !0), o > 16)) {
        const f = []
        for (let p = 0; p < 16; p++) {
          const v = n[i++].toString(16)
          f.push(v.length == 1 ? '0' + v : v),
            (p === 3 || p === 5 || p === 7 || p === 9) && f.push('-')
        }
        const d = o - 16,
          m = new Uint8Array(d)
        for (let p = 0; p < d; p++) m[p] = n[i++]
        r.push({ payloadType: a, pts: t, uuid: f.join(''), userData: tt(m), userDataBytes: m })
      }
    } else if (o < c) i += o
    else if (o > c) break
  }
}
function na(s) {
  const e = s.byteLength,
    t = []
  let r = 1
  for (; r < e - 2; )
    s[r] === 0 && s[r + 1] === 0 && s[r + 2] === 3 ? (t.push(r + 2), (r += 2)) : r++
  if (t.length === 0) return s
  const n = e - t.length,
    i = new Uint8Array(n)
  let a = 0
  for (r = 0; r < n; a++, r++) a === t[0] && (a++, t.shift()), (i[r] = s[a])
  return i
}
function Yu(s) {
  const e = s[0]
  let t = '',
    r = '',
    n = 0,
    i = 0,
    a = 0,
    o = 0,
    l = 0,
    u = 0
  if (e === 0) {
    for (; Pe(s.subarray(u, u + 1)) !== '\0'; ) (t += Pe(s.subarray(u, u + 1))), (u += 1)
    for (t += Pe(s.subarray(u, u + 1)), u += 1; Pe(s.subarray(u, u + 1)) !== '\0'; )
      (r += Pe(s.subarray(u, u + 1))), (u += 1)
    ;(r += Pe(s.subarray(u, u + 1))),
      (u += 1),
      (n = se(s, 12)),
      (i = se(s, 16)),
      (o = se(s, 20)),
      (l = se(s, 24)),
      (u = 28)
  } else if (e === 1) {
    ;(u += 4), (n = se(s, u)), (u += 4)
    const f = se(s, u)
    u += 4
    const d = se(s, u)
    for (
      u += 4,
        a = 2 ** 32 * f + d,
        Number.isSafeInteger(a) ||
          ((a = Number.MAX_SAFE_INTEGER),
          G.warn(
            'Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box'
          )),
        o = se(s, u),
        u += 4,
        l = se(s, u),
        u += 4;
      Pe(s.subarray(u, u + 1)) !== '\0';

    )
      (t += Pe(s.subarray(u, u + 1))), (u += 1)
    for (t += Pe(s.subarray(u, u + 1)), u += 1; Pe(s.subarray(u, u + 1)) !== '\0'; )
      (r += Pe(s.subarray(u, u + 1))), (u += 1)
    ;(r += Pe(s.subarray(u, u + 1))), (u += 1)
  }
  const c = s.subarray(u, s.byteLength)
  return {
    schemeIdUri: t,
    value: r,
    timeScale: n,
    presentationTime: a,
    presentationTimeDelta: i,
    eventDuration: o,
    id: l,
    payload: c
  }
}
function zu(s, ...e) {
  const t = e.length
  let r = 8,
    n = t
  for (; n--; ) r += e[n].byteLength
  const i = new Uint8Array(r)
  for (
    i[0] = (r >> 24) & 255,
      i[1] = (r >> 16) & 255,
      i[2] = (r >> 8) & 255,
      i[3] = r & 255,
      i.set(s, 4),
      n = 0,
      r = 8;
    n < t;
    n++
  )
    i.set(e[n], r), (r += e[n].byteLength)
  return i
}
function qu(s, e, t) {
  if (s.byteLength !== 16) throw new RangeError('Invalid system id')
  let r, n
  if (e) {
    ;(r = 1), (n = new Uint8Array(e.length * 16))
    for (let o = 0; o < e.length; o++) {
      const l = e[o]
      if (l.byteLength !== 16) throw new RangeError('Invalid key')
      n.set(l, o * 16)
    }
  } else (r = 0), (n = new Uint8Array())
  let i
  r > 0
    ? ((i = new Uint8Array(4)), e.length > 0 && new DataView(i.buffer).setUint32(0, e.length, !1))
    : (i = new Uint8Array())
  const a = new Uint8Array(4)
  return (
    t && t.byteLength > 0 && new DataView(a.buffer).setUint32(0, t.byteLength, !1),
    zu([112, 115, 115, 104], new Uint8Array([r, 0, 0, 0]), s, i, n, a, t || new Uint8Array())
  )
}
function Xu(s) {
  if (!(s instanceof ArrayBuffer) || s.byteLength < 32) return null
  const e = { version: 0, systemId: '', kids: null, data: null },
    t = new DataView(s),
    r = t.getUint32(0)
  if (
    (s.byteLength !== r && r > 44) ||
    t.getUint32(4) !== 1886614376 ||
    ((e.version = t.getUint32(8) >>> 24), e.version > 1)
  )
    return null
  e.systemId = Je.hexDump(new Uint8Array(s, 12, 16))
  const i = t.getUint32(28)
  if (e.version === 0) {
    if (r - 32 < i) return null
    e.data = new Uint8Array(s, 32, i)
  } else if (e.version === 1) {
    e.kids = []
    for (let a = 0; a < i; a++) e.kids.push(new Uint8Array(s, 32 + a * 16, 16))
  }
  return e
}
let qt = {}
class Vt {
  static clearKeyUriToKeyIdMap() {
    qt = {}
  }
  constructor(e, t, r, n = [1], i = null) {
    ;(this.uri = void 0),
      (this.method = void 0),
      (this.keyFormat = void 0),
      (this.keyFormatVersions = void 0),
      (this.encrypted = void 0),
      (this.isCommonEncryption = void 0),
      (this.iv = null),
      (this.key = null),
      (this.keyId = null),
      (this.pssh = null),
      (this.method = e),
      (this.uri = t),
      (this.keyFormat = r),
      (this.keyFormatVersions = n),
      (this.iv = i),
      (this.encrypted = e ? e !== 'NONE' : !1),
      (this.isCommonEncryption = this.encrypted && e !== 'AES-128')
  }
  isSupported() {
    if (this.method) {
      if (this.method === 'AES-128' || this.method === 'NONE') return !0
      if (this.keyFormat === 'identity') return this.method === 'SAMPLE-AES'
      switch (this.keyFormat) {
        case je.FAIRPLAY:
        case je.WIDEVINE:
        case je.PLAYREADY:
        case je.CLEARKEY:
          return (
            ['ISO-23001-7', 'SAMPLE-AES', 'SAMPLE-AES-CENC', 'SAMPLE-AES-CTR'].indexOf(
              this.method
            ) !== -1
          )
      }
    }
    return !1
  }
  getDecryptData(e) {
    if (!this.encrypted || !this.uri) return null
    if (this.method === 'AES-128' && this.uri && !this.iv) {
      typeof e != 'number' &&
        (this.method === 'AES-128' &&
          !this.iv &&
          G.warn(
            `missing IV for initialization segment with method="${this.method}" - compliance issue`
          ),
        (e = 0))
      const r = Qu(e)
      return new Vt(this.method, this.uri, 'identity', this.keyFormatVersions, r)
    }
    const t = bu(this.uri)
    if (t)
      switch (this.keyFormat) {
        case je.WIDEVINE:
          ;(this.pssh = t), t.length >= 22 && (this.keyId = t.subarray(t.length - 22, t.length - 6))
          break
        case je.PLAYREADY: {
          const r = new Uint8Array([
            154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149
          ])
          this.pssh = qu(r, null, t)
          const n = new Uint16Array(t.buffer, t.byteOffset, t.byteLength / 2),
            i = String.fromCharCode.apply(null, Array.from(n)),
            a = i.substring(i.indexOf('<'), i.length),
            u = new DOMParser().parseFromString(a, 'text/xml').getElementsByTagName('KID')[0]
          if (u) {
            const c = u.childNodes[0] ? u.childNodes[0].nodeValue : u.getAttribute('VALUE')
            if (c) {
              const f = Cn(c).subarray(0, 16)
              Tu(f), (this.keyId = f)
            }
          }
          break
        }
        default: {
          let r = t.subarray(0, 16)
          if (r.length !== 16) {
            const n = new Uint8Array(16)
            n.set(r, 16 - r.length), (r = n)
          }
          this.keyId = r
          break
        }
      }
    if (!this.keyId || this.keyId.byteLength !== 16) {
      let r = qt[this.uri]
      if (!r) {
        const n = Object.keys(qt).length % Number.MAX_SAFE_INTEGER
        ;(r = new Uint8Array(16)), new DataView(r.buffer, 12, 4).setUint32(0, n), (qt[this.uri] = r)
      }
      this.keyId = r
    }
    return this
  }
}
function Qu(s) {
  const e = new Uint8Array(16)
  for (let t = 12; t < 16; t++) e[t] = (s >> (8 * (15 - t))) & 255
  return e
}
const ia = /\{\$([a-zA-Z0-9-_]+)\}/g
function Ri(s) {
  return ia.test(s)
}
function Ke(s, e, t) {
  if (s.variableList !== null || s.hasVariableRefs)
    for (let r = t.length; r--; ) {
      const n = t[r],
        i = e[n]
      i && (e[n] = _n(s, i))
    }
}
function _n(s, e) {
  if (s.variableList !== null || s.hasVariableRefs) {
    const t = s.variableList
    return e.replace(ia, (r) => {
      const n = r.substring(2, r.length - 1),
        i = t == null ? void 0 : t[n]
      return i === void 0
        ? (s.playlistParsingError ||
            (s.playlistParsingError = new Error(
              `Missing preceding EXT-X-DEFINE tag for Variable Reference: "${n}"`
            )),
          r)
        : i
    })
  }
  return e
}
function Ii(s, e, t) {
  let r = s.variableList
  r || (s.variableList = r = {})
  let n, i
  if ('QUERYPARAM' in e) {
    n = e.QUERYPARAM
    try {
      const a = new self.URL(t).searchParams
      if (a.has(n)) i = a.get(n)
      else throw new Error(`"${n}" does not match any query parameter in URI: "${t}"`)
    } catch (a) {
      s.playlistParsingError ||
        (s.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${a.message}`))
    }
  } else (n = e.NAME), (i = e.VALUE)
  n in r
    ? s.playlistParsingError ||
      (s.playlistParsingError = new Error(
        `EXT-X-DEFINE duplicate Variable Name declarations: "${n}"`
      ))
    : (r[n] = i || '')
}
function Zu(s, e, t) {
  const r = e.IMPORT
  if (t && r in t) {
    let n = s.variableList
    n || (s.variableList = n = {}), (n[r] = t[r])
  } else
    s.playlistParsingError ||
      (s.playlistParsingError = new Error(
        `EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${r}"`
      ))
}
function xr() {
  if (!(typeof self > 'u')) return self.MediaSource || self.WebKitMediaSource
}
const Ju = {
    audio: {
      a3ds: !0,
      'ac-3': !0,
      'ac-4': !0,
      alac: !0,
      alaw: !0,
      dra1: !0,
      'dts+': !0,
      'dts-': !0,
      dtsc: !0,
      dtse: !0,
      dtsh: !0,
      'ec-3': !0,
      enca: !0,
      g719: !0,
      g726: !0,
      m4ae: !0,
      mha1: !0,
      mha2: !0,
      mhm1: !0,
      mhm2: !0,
      mlpa: !0,
      mp4a: !0,
      'raw ': !0,
      Opus: !0,
      opus: !0,
      samr: !0,
      sawb: !0,
      sawp: !0,
      sevc: !0,
      sqcp: !0,
      ssmv: !0,
      twos: !0,
      ulaw: !0
    },
    video: {
      avc1: !0,
      avc2: !0,
      avc3: !0,
      avc4: !0,
      avcp: !0,
      av01: !0,
      drac: !0,
      dva1: !0,
      dvav: !0,
      dvh1: !0,
      dvhe: !0,
      encv: !0,
      hev1: !0,
      hvc1: !0,
      mjp2: !0,
      mp4v: !0,
      mvc1: !0,
      mvc2: !0,
      mvc3: !0,
      mvc4: !0,
      resv: !0,
      rv60: !0,
      s263: !0,
      svc1: !0,
      svc2: !0,
      'vc-1': !0,
      vp08: !0,
      vp09: !0
    },
    text: { stpp: !0, wvtt: !0 }
  },
  Pi = xr()
function ec(s, e) {
  const t = Ju[e]
  return !!t && t[s.slice(0, 4)] === !0
}
function Yr(s, e) {
  var t
  return (t = Pi == null ? void 0 : Pi.isTypeSupported(`${e || 'video'}/mp4;codecs="${s}"`)) != null
    ? t
    : !1
}
const Di =
    /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g,
  Oi = /#EXT-X-MEDIA:(.*)/g,
  tc = /^#EXT(?:INF|-X-TARGETDURATION):/m,
  wi = new RegExp(
    [
      /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
      /(?!#) *(\S[\S ]*)/.source,
      /#EXT-X-BYTERANGE:*(.+)/.source,
      /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
      /#.*/.source
    ].join('|'),
    'g'
  ),
  rc = new RegExp(
    [
      /#(EXTM3U)/.source,
      /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/
        .source,
      /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/
        .source,
      /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source,
      /(#)([^:]*):(.*)/.source,
      /(#)(.*)(?:.*)\r?\n?/.source
    ].join('|')
  )
class Ze {
  static findGroup(e, t) {
    for (let r = 0; r < e.length; r++) {
      const n = e[r]
      if (n.id === t) return n
    }
  }
  static convertAVC1ToAVCOTI(e) {
    const t = e.split('.')
    if (t.length > 2) {
      let r = t.shift() + '.'
      return (
        (r += parseInt(t.shift()).toString(16)),
        (r += ('000' + parseInt(t.shift()).toString(16)).slice(-4)),
        r
      )
    }
    return e
  }
  static resolve(e, t) {
    return wn.buildAbsoluteURL(t, e, { alwaysNormalize: !0 })
  }
  static isMediaPlaylist(e) {
    return tc.test(e)
  }
  static parseMasterPlaylist(e, t) {
    const r = Ri(e),
      n = {
        contentSteering: null,
        levels: [],
        playlistParsingError: null,
        sessionData: null,
        sessionKeys: null,
        startTimeOffset: null,
        variableList: null,
        hasVariableRefs: r
      },
      i = []
    Di.lastIndex = 0
    let a
    for (; (a = Di.exec(e)) != null; )
      if (a[1]) {
        var o
        const u = new ye(a[1])
        Ke(n, u, [
          'CODECS',
          'SUPPLEMENTAL-CODECS',
          'ALLOWED-CPC',
          'PATHWAY-ID',
          'STABLE-VARIANT-ID',
          'AUDIO',
          'VIDEO',
          'SUBTITLES',
          'CLOSED-CAPTIONS',
          'NAME'
        ])
        const c = _n(n, a[2]),
          f = {
            attrs: u,
            bitrate: u.decimalInteger('AVERAGE-BANDWIDTH') || u.decimalInteger('BANDWIDTH'),
            name: u.NAME,
            url: Ze.resolve(c, t)
          },
          d = u.decimalResolution('RESOLUTION')
        d && ((f.width = d.width), (f.height = d.height)),
          nc(
            (u.CODECS || '').split(/[ ,]+/).filter((m) => m),
            f
          ),
          f.videoCodec &&
            f.videoCodec.indexOf('avc1') !== -1 &&
            (f.videoCodec = Ze.convertAVC1ToAVCOTI(f.videoCodec)),
          ((o = f.unknownCodecs) != null && o.length) || i.push(f),
          n.levels.push(f)
      } else if (a[3]) {
        const u = a[3],
          c = a[4]
        switch (u) {
          case 'SESSION-DATA': {
            const f = new ye(c)
            Ke(n, f, ['DATA-ID', 'LANGUAGE', 'VALUE', 'URI'])
            const d = f['DATA-ID']
            d && (n.sessionData === null && (n.sessionData = {}), (n.sessionData[d] = f))
            break
          }
          case 'SESSION-KEY': {
            const f = Ci(c, t, n)
            f.encrypted && f.isSupported()
              ? (n.sessionKeys === null && (n.sessionKeys = []), n.sessionKeys.push(f))
              : G.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${c}"`)
            break
          }
          case 'DEFINE': {
            {
              const f = new ye(c)
              Ke(n, f, ['NAME', 'VALUE', 'QUERYPARAM']), Ii(n, f, t)
            }
            break
          }
          case 'CONTENT-STEERING': {
            const f = new ye(c)
            Ke(n, f, ['SERVER-URI', 'PATHWAY-ID']),
              (n.contentSteering = {
                uri: Ze.resolve(f['SERVER-URI'], t),
                pathwayId: f['PATHWAY-ID'] || '.'
              })
            break
          }
          case 'START': {
            n.startTimeOffset = ki(c)
            break
          }
        }
      }
    const l = i.length > 0 && i.length < n.levels.length
    return (
      (n.levels = l ? i : n.levels),
      n.levels.length === 0 && (n.playlistParsingError = new Error('no levels found in manifest')),
      n
    )
  }
  static parseMasterPlaylistMedia(e, t, r) {
    let n
    const i = {},
      a = r.levels,
      o = {
        AUDIO: a.map((u) => ({ id: u.attrs.AUDIO, audioCodec: u.audioCodec })),
        SUBTITLES: a.map((u) => ({ id: u.attrs.SUBTITLES, textCodec: u.textCodec })),
        'CLOSED-CAPTIONS': []
      }
    let l = 0
    for (Oi.lastIndex = 0; (n = Oi.exec(e)) !== null; ) {
      const u = new ye(n[1]),
        c = u.TYPE
      if (c) {
        const f = o[c],
          d = i[c] || []
        ;(i[c] = d),
          Ke(r, u, [
            'URI',
            'GROUP-ID',
            'LANGUAGE',
            'ASSOC-LANGUAGE',
            'STABLE-RENDITION-ID',
            'NAME',
            'INSTREAM-ID',
            'CHARACTERISTICS',
            'CHANNELS'
          ])
        const m = {
          attrs: u,
          bitrate: 0,
          id: l++,
          groupId: u['GROUP-ID'] || '',
          instreamId: u['INSTREAM-ID'],
          name: u.NAME || u.LANGUAGE || '',
          type: c,
          default: u.bool('DEFAULT'),
          autoselect: u.bool('AUTOSELECT'),
          forced: u.bool('FORCED'),
          lang: u.LANGUAGE,
          url: u.URI ? Ze.resolve(u.URI, t) : ''
        }
        if (f != null && f.length) {
          const p = Ze.findGroup(f, m.groupId) || f[0]
          Mi(m, p, 'audioCodec'), Mi(m, p, 'textCodec')
        }
        d.push(m)
      }
    }
    return i
  }
  static parseLevelPlaylist(e, t, r, n, i, a) {
    const o = new xu(t),
      l = o.fragments
    let u = null,
      c = 0,
      f = 0,
      d = 0,
      m = 0,
      p = null,
      v = new jr(n, t),
      E,
      x,
      T,
      b = -1,
      R = !1
    for (wi.lastIndex = 0, o.m3u8 = e, o.hasVariableRefs = Ri(e); (E = wi.exec(e)) !== null; ) {
      R &&
        ((R = !1),
        (v = new jr(n, t)),
        (v.start = d),
        (v.sn = c),
        (v.cc = m),
        (v.level = r),
        u &&
          ((v.initSegment = u),
          (v.rawProgramDateTime = u.rawProgramDateTime),
          (u.rawProgramDateTime = null)))
      const h = E[1]
      if (h) {
        v.duration = parseFloat(h)
        const _ = (' ' + E[2]).slice(1)
        ;(v.title = _ || null), v.tagList.push(_ ? ['INF', h, _] : ['INF', h])
      } else if (E[3]) {
        if (J(v.duration)) {
          ;(v.start = d),
            T && Ui(v, T, o),
            (v.sn = c),
            (v.level = r),
            (v.cc = m),
            (v.urlId = i),
            l.push(v)
          const _ = (' ' + E[3]).slice(1)
          ;(v.relurl = _n(o, _)), Fi(v, p), (p = v), (d += v.duration), c++, (f = 0), (R = !0)
        }
      } else if (E[4]) {
        const _ = (' ' + E[4]).slice(1)
        p ? v.setByteRange(_, p) : v.setByteRange(_)
      } else if (E[5])
        (v.rawProgramDateTime = (' ' + E[5]).slice(1)),
          v.tagList.push(['PROGRAM-DATE-TIME', v.rawProgramDateTime]),
          b === -1 && (b = l.length)
      else {
        if (((E = E[0].match(rc)), !E)) {
          G.warn('No matches on slow regex match for level playlist!')
          continue
        }
        for (x = 1; x < E.length && !(typeof E[x] < 'u'); x++);
        const _ = (' ' + E[x]).slice(1),
          y = (' ' + E[x + 1]).slice(1),
          L = E[x + 2] ? (' ' + E[x + 2]).slice(1) : ''
        switch (_) {
          case 'PLAYLIST-TYPE':
            o.type = y.toUpperCase()
            break
          case 'MEDIA-SEQUENCE':
            c = o.startSN = parseInt(y)
            break
          case 'SKIP': {
            const I = new ye(y)
            Ke(o, I, ['RECENTLY-REMOVED-DATERANGES'])
            const P = I.decimalInteger('SKIPPED-SEGMENTS')
            if (J(P)) {
              o.skippedSegments = P
              for (let C = P; C--; ) l.unshift(null)
              c += P
            }
            const D = I.enumeratedString('RECENTLY-REMOVED-DATERANGES')
            D && (o.recentlyRemovedDateranges = D.split('	'))
            break
          }
          case 'TARGETDURATION':
            o.targetduration = Math.max(parseInt(y), 1)
            break
          case 'VERSION':
            o.version = parseInt(y)
            break
          case 'EXTM3U':
            break
          case 'ENDLIST':
            o.live = !1
            break
          case '#':
            ;(y || L) && v.tagList.push(L ? [y, L] : [y])
            break
          case 'DISCONTINUITY':
            m++, v.tagList.push(['DIS'])
            break
          case 'GAP':
            ;(v.gap = !0), v.tagList.push([_])
            break
          case 'BITRATE':
            v.tagList.push([_, y])
            break
          case 'DATERANGE': {
            const I = new ye(y)
            Ke(o, I, [
              'ID',
              'CLASS',
              'START-DATE',
              'END-DATE',
              'SCTE35-CMD',
              'SCTE35-OUT',
              'SCTE35-IN'
            ]),
              Ke(o, I, I.clientAttrs)
            const P = new js(I, o.dateRanges[I.ID])
            P.isValid || o.skippedSegments
              ? (o.dateRanges[P.id] = P)
              : G.warn(`Ignoring invalid DATERANGE tag: "${y}"`),
              v.tagList.push(['EXT-X-DATERANGE', y])
            break
          }
          case 'DEFINE': {
            {
              const I = new ye(y)
              Ke(o, I, ['NAME', 'VALUE', 'IMPORT', 'QUERYPARAM']),
                'IMPORT' in I ? Zu(o, I, a) : Ii(o, I, t)
            }
            break
          }
          case 'DISCONTINUITY-SEQUENCE':
            m = parseInt(y)
            break
          case 'KEY': {
            const I = Ci(y, t, o)
            if (I.isSupported()) {
              if (I.method === 'NONE') {
                T = void 0
                break
              }
              T || (T = {}), T[I.keyFormat] && (T = Te({}, T)), (T[I.keyFormat] = I)
            } else G.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${y}"`)
            break
          }
          case 'START':
            o.startTimeOffset = ki(y)
            break
          case 'MAP': {
            const I = new ye(y)
            if ((Ke(o, I, ['BYTERANGE', 'URI']), v.duration)) {
              const P = new jr(n, t)
              Ni(P, I, r, T),
                (u = P),
                (v.initSegment = u),
                u.rawProgramDateTime &&
                  !v.rawProgramDateTime &&
                  (v.rawProgramDateTime = u.rawProgramDateTime)
            } else Ni(v, I, r, T), (u = v), (R = !0)
            break
          }
          case 'SERVER-CONTROL': {
            const I = new ye(y)
            ;(o.canBlockReload = I.bool('CAN-BLOCK-RELOAD')),
              (o.canSkipUntil = I.optionalFloat('CAN-SKIP-UNTIL', 0)),
              (o.canSkipDateRanges = o.canSkipUntil > 0 && I.bool('CAN-SKIP-DATERANGES')),
              (o.partHoldBack = I.optionalFloat('PART-HOLD-BACK', 0)),
              (o.holdBack = I.optionalFloat('HOLD-BACK', 0))
            break
          }
          case 'PART-INF': {
            const I = new ye(y)
            o.partTarget = I.decimalFloatingPoint('PART-TARGET')
            break
          }
          case 'PART': {
            let I = o.partList
            I || (I = o.partList = [])
            const P = f > 0 ? I[I.length - 1] : void 0,
              D = f++,
              C = new ye(y)
            Ke(o, C, ['BYTERANGE', 'URI'])
            const N = new _u(C, v, t, D, P)
            I.push(N), (v.duration += N.duration)
            break
          }
          case 'PRELOAD-HINT': {
            const I = new ye(y)
            Ke(o, I, ['URI']), (o.preloadHint = I)
            break
          }
          case 'RENDITION-REPORT': {
            const I = new ye(y)
            Ke(o, I, ['URI']),
              (o.renditionReports = o.renditionReports || []),
              o.renditionReports.push(I)
            break
          }
          default:
            G.warn(`line parsed but not handled: ${E}`)
            break
        }
      }
    }
    p && !p.relurl
      ? (l.pop(), (d -= p.duration), o.partList && (o.fragmentHint = p))
      : o.partList && (Fi(v, p), (v.cc = m), (o.fragmentHint = v), T && Ui(v, T, o))
    const g = l.length,
      A = l[0],
      S = l[g - 1]
    if (((d += o.skippedSegments * o.targetduration), d > 0 && g && S)) {
      o.averagetargetduration = d / g
      const h = S.sn
      ;(o.endSN = h !== 'initSegment' ? h : 0), o.live || (S.endList = !0), A && (o.startCC = A.cc)
    } else (o.endSN = 0), (o.startCC = 0)
    return (
      o.fragmentHint && (d += o.fragmentHint.duration),
      (o.totalduration = d),
      (o.endCC = m),
      b > 0 && ic(l, b),
      o
    )
  }
}
function Ci(s, e, t) {
  var r, n
  const i = new ye(s)
  Ke(t, i, ['KEYFORMAT', 'KEYFORMATVERSIONS', 'URI', 'IV', 'URI'])
  const a = (r = i.METHOD) != null ? r : '',
    o = i.URI,
    l = i.hexadecimalInteger('IV'),
    u = i.KEYFORMATVERSIONS,
    c = (n = i.KEYFORMAT) != null ? n : 'identity'
  o && i.IV && !l && G.error(`Invalid IV: ${i.IV}`)
  const f = o ? Ze.resolve(o, e) : '',
    d = (u || '1').split('/').map(Number).filter(Number.isFinite)
  return new Vt(a, f, c, d, l)
}
function ki(s) {
  const t = new ye(s).decimalFloatingPoint('TIME-OFFSET')
  return J(t) ? t : null
}
function nc(s, e) {
  ;['video', 'audio', 'text'].forEach((t) => {
    const r = s.filter((n) => ec(n, t))
    if (r.length) {
      const n = r.filter((i) => i.lastIndexOf('avc1', 0) === 0 || i.lastIndexOf('mp4a', 0) === 0)
      ;(e[`${t}Codec`] = n.length > 0 ? n[0] : r[0]), (s = s.filter((i) => r.indexOf(i) === -1))
    }
  }),
    (e.unknownCodecs = s)
}
function Mi(s, e, t) {
  const r = e[t]
  r && (s[t] = r)
}
function ic(s, e) {
  let t = s[e]
  for (let r = e; r--; ) {
    const n = s[r]
    if (!n) return
    ;(n.programDateTime = t.programDateTime - n.duration * 1e3), (t = n)
  }
}
function Fi(s, e) {
  s.rawProgramDateTime
    ? (s.programDateTime = Date.parse(s.rawProgramDateTime))
    : e != null && e.programDateTime && (s.programDateTime = e.endProgramDateTime),
    J(s.programDateTime) || ((s.programDateTime = null), (s.rawProgramDateTime = null))
}
function Ni(s, e, t, r) {
  ;(s.relurl = e.URI),
    e.BYTERANGE && s.setByteRange(e.BYTERANGE),
    (s.level = t),
    (s.sn = 'initSegment'),
    r && (s.levelkeys = r),
    (s.initSegment = null)
}
function Ui(s, e, t) {
  s.levelkeys = e
  const { encryptedFragments: r } = t
  ;(!r.length || r[r.length - 1].levelkeys !== e) &&
    Object.keys(e).some((n) => e[n].isCommonEncryption) &&
    r.push(s)
}
var fe = {
    MANIFEST: 'manifest',
    LEVEL: 'level',
    AUDIO_TRACK: 'audioTrack',
    SUBTITLE_TRACK: 'subtitleTrack'
  },
  ie = { MAIN: 'main', AUDIO: 'audio', SUBTITLE: 'subtitle' }
function Bi(s) {
  const { type: e } = s
  switch (e) {
    case fe.AUDIO_TRACK:
      return ie.AUDIO
    case fe.SUBTITLE_TRACK:
      return ie.SUBTITLE
    default:
      return ie.MAIN
  }
}
function zr(s, e) {
  let t = s.url
  return (t === void 0 || t.indexOf('data:') === 0) && (t = e.url), t
}
class sc {
  constructor(e) {
    ;(this.hls = void 0),
      (this.loaders = Object.create(null)),
      (this.variableList = null),
      (this.hls = e),
      this.registerListeners()
  }
  startLoad(e) {}
  stopLoad() {
    this.destroyInternalLoaders()
  }
  registerListeners() {
    const { hls: e } = this
    e.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(O.LEVEL_LOADING, this.onLevelLoading, this),
      e.on(O.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
      e.on(O.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
  }
  unregisterListeners() {
    const { hls: e } = this
    e.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(O.LEVEL_LOADING, this.onLevelLoading, this),
      e.off(O.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
      e.off(O.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
  }
  createInternalLoader(e) {
    const t = this.hls.config,
      r = t.pLoader,
      n = t.loader,
      i = r || n,
      a = new i(t)
    return (this.loaders[e.type] = a), a
  }
  getInternalLoader(e) {
    return this.loaders[e.type]
  }
  resetInternalLoader(e) {
    this.loaders[e] && delete this.loaders[e]
  }
  destroyInternalLoaders() {
    for (const e in this.loaders) {
      const t = this.loaders[e]
      t && t.destroy(), this.resetInternalLoader(e)
    }
  }
  destroy() {
    ;(this.variableList = null), this.unregisterListeners(), this.destroyInternalLoaders()
  }
  onManifestLoading(e, t) {
    const { url: r } = t
    ;(this.variableList = null),
      this.load({
        id: null,
        level: 0,
        responseType: 'text',
        type: fe.MANIFEST,
        url: r,
        deliveryDirectives: null
      })
  }
  onLevelLoading(e, t) {
    const { id: r, level: n, url: i, deliveryDirectives: a } = t
    this.load({
      id: r,
      level: n,
      responseType: 'text',
      type: fe.LEVEL,
      url: i,
      deliveryDirectives: a
    })
  }
  onAudioTrackLoading(e, t) {
    const { id: r, groupId: n, url: i, deliveryDirectives: a } = t
    this.load({
      id: r,
      groupId: n,
      level: null,
      responseType: 'text',
      type: fe.AUDIO_TRACK,
      url: i,
      deliveryDirectives: a
    })
  }
  onSubtitleTrackLoading(e, t) {
    const { id: r, groupId: n, url: i, deliveryDirectives: a } = t
    this.load({
      id: r,
      groupId: n,
      level: null,
      responseType: 'text',
      type: fe.SUBTITLE_TRACK,
      url: i,
      deliveryDirectives: a
    })
  }
  load(e) {
    var t
    const r = this.hls.config
    let n = this.getInternalLoader(e)
    if (n) {
      const u = n.context
      if (u && u.url === e.url) {
        G.trace('[playlist-loader]: playlist request ongoing')
        return
      }
      G.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), n.abort()
    }
    let i
    if (
      (e.type === fe.MANIFEST
        ? (i = r.manifestLoadPolicy.default)
        : (i = Te({}, r.playlistLoadPolicy.default, { timeoutRetry: null, errorRetry: null })),
      (n = this.createInternalLoader(e)),
      (t = e.deliveryDirectives) != null && t.part)
    ) {
      let u
      if (
        (e.type === fe.LEVEL && e.level !== null
          ? (u = this.hls.levels[e.level].details)
          : e.type === fe.AUDIO_TRACK && e.id !== null
          ? (u = this.hls.audioTracks[e.id].details)
          : e.type === fe.SUBTITLE_TRACK &&
            e.id !== null &&
            (u = this.hls.subtitleTracks[e.id].details),
        u)
      ) {
        const c = u.partTarget,
          f = u.targetduration
        if (c && f) {
          const d = Math.max(c * 3, f * 0.8) * 1e3
          i = Te({}, i, {
            maxTimeToFirstByteMs: Math.min(d, i.maxTimeToFirstByteMs),
            maxLoadTimeMs: Math.min(d, i.maxTimeToFirstByteMs)
          })
        }
      }
    }
    const a = i.errorRetry || i.timeoutRetry || {},
      o = {
        loadPolicy: i,
        timeout: i.maxLoadTimeMs,
        maxRetry: a.maxNumRetry || 0,
        retryDelay: a.retryDelayMs || 0,
        maxRetryDelay: a.maxRetryDelayMs || 0
      },
      l = {
        onSuccess: (u, c, f, d) => {
          const m = this.getInternalLoader(f)
          this.resetInternalLoader(f.type)
          const p = u.data
          if (p.indexOf('#EXTM3U') !== 0) {
            this.handleManifestParsingError(u, f, new Error('no EXTM3U delimiter'), d || null, c)
            return
          }
          ;(c.parsing.start = performance.now()),
            Ze.isMediaPlaylist(p)
              ? this.handleTrackOrLevelPlaylist(u, c, f, d || null, m)
              : this.handleMasterPlaylist(u, c, f, d)
        },
        onError: (u, c, f, d) => {
          this.handleNetworkError(c, f, !1, u, d)
        },
        onTimeout: (u, c, f) => {
          this.handleNetworkError(c, f, !0, void 0, u)
        }
      }
    n.load(e, o, l)
  }
  handleMasterPlaylist(e, t, r, n) {
    const i = this.hls,
      a = e.data,
      o = zr(e, r),
      l = Ze.parseMasterPlaylist(a, o)
    if (l.playlistParsingError) {
      this.handleManifestParsingError(e, r, l.playlistParsingError, n, t)
      return
    }
    const {
      contentSteering: u,
      levels: c,
      sessionData: f,
      sessionKeys: d,
      startTimeOffset: m,
      variableList: p
    } = l
    this.variableList = p
    const {
      AUDIO: v = [],
      SUBTITLES: E,
      'CLOSED-CAPTIONS': x
    } = Ze.parseMasterPlaylistMedia(a, o, l)
    v.length &&
      !v.some((b) => !b.url) &&
      c[0].audioCodec &&
      !c[0].attrs.AUDIO &&
      (G.log(
        '[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one'
      ),
      v.unshift({
        type: 'main',
        name: 'main',
        groupId: 'main',
        default: !1,
        autoselect: !1,
        forced: !1,
        id: -1,
        attrs: new ye({}),
        bitrate: 0,
        url: ''
      })),
      i.trigger(O.MANIFEST_LOADED, {
        levels: c,
        audioTracks: v,
        subtitles: E,
        captions: x,
        contentSteering: u,
        url: o,
        stats: t,
        networkDetails: n,
        sessionData: f,
        sessionKeys: d,
        startTimeOffset: m,
        variableList: p
      })
  }
  handleTrackOrLevelPlaylist(e, t, r, n, i) {
    const a = this.hls,
      { id: o, level: l, type: u } = r,
      c = zr(e, r),
      f = J(o) ? o : 0,
      d = J(l) ? l : f,
      m = Bi(r),
      p = Ze.parseLevelPlaylist(e.data, c, d, m, f, this.variableList)
    if (u === fe.MANIFEST) {
      const v = { attrs: new ye({}), bitrate: 0, details: p, name: '', url: c }
      a.trigger(O.MANIFEST_LOADED, {
        levels: [v],
        audioTracks: [],
        url: c,
        stats: t,
        networkDetails: n,
        sessionData: null,
        sessionKeys: null,
        contentSteering: null,
        startTimeOffset: null,
        variableList: null
      })
    }
    ;(t.parsing.end = performance.now()),
      (r.levelDetails = p),
      this.handlePlaylistLoaded(p, e, t, r, n, i)
  }
  handleManifestParsingError(e, t, r, n, i) {
    this.hls.trigger(O.ERROR, {
      type: ne.NETWORK_ERROR,
      details: K.MANIFEST_PARSING_ERROR,
      fatal: t.type === fe.MANIFEST,
      url: e.url,
      err: r,
      error: r,
      reason: r.message,
      response: e,
      context: t,
      networkDetails: n,
      stats: i
    })
  }
  handleNetworkError(e, t, r = !1, n, i) {
    let a = `A network ${
      r ? 'timeout' : 'error' + (n ? ' (status ' + n.code + ')' : '')
    } occurred while loading ${e.type}`
    e.type === fe.LEVEL
      ? (a += `: ${e.level} id: ${e.id}`)
      : (e.type === fe.AUDIO_TRACK || e.type === fe.SUBTITLE_TRACK) &&
        (a += ` id: ${e.id} group-id: "${e.groupId}"`)
    const o = new Error(a)
    G.warn(`[playlist-loader]: ${a}`)
    let l = K.UNKNOWN,
      u = !1
    const c = this.getInternalLoader(e)
    switch (e.type) {
      case fe.MANIFEST:
        ;(l = r ? K.MANIFEST_LOAD_TIMEOUT : K.MANIFEST_LOAD_ERROR), (u = !0)
        break
      case fe.LEVEL:
        ;(l = r ? K.LEVEL_LOAD_TIMEOUT : K.LEVEL_LOAD_ERROR), (u = !1)
        break
      case fe.AUDIO_TRACK:
        ;(l = r ? K.AUDIO_TRACK_LOAD_TIMEOUT : K.AUDIO_TRACK_LOAD_ERROR), (u = !1)
        break
      case fe.SUBTITLE_TRACK:
        ;(l = r ? K.SUBTITLE_TRACK_LOAD_TIMEOUT : K.SUBTITLE_LOAD_ERROR), (u = !1)
        break
    }
    c && this.resetInternalLoader(e.type)
    const f = {
      type: ne.NETWORK_ERROR,
      details: l,
      fatal: u,
      url: e.url,
      loader: c,
      context: e,
      error: o,
      networkDetails: t,
      stats: i
    }
    if (n) {
      const d = (t == null ? void 0 : t.url) || e.url
      f.response = Ve({ url: d, data: void 0 }, n)
    }
    this.hls.trigger(O.ERROR, f)
  }
  handlePlaylistLoaded(e, t, r, n, i, a) {
    const o = this.hls,
      { type: l, level: u, id: c, groupId: f, deliveryDirectives: d } = n,
      m = zr(t, n),
      p = Bi(n),
      v = typeof n.level == 'number' && p === ie.MAIN ? u : void 0
    if (!e.fragments.length) {
      const x = new Error('No Segments found in Playlist')
      o.trigger(O.ERROR, {
        type: ne.NETWORK_ERROR,
        details: K.LEVEL_EMPTY_ERROR,
        fatal: !1,
        url: m,
        error: x,
        reason: x.message,
        response: t,
        context: n,
        level: v,
        parent: p,
        networkDetails: i,
        stats: r
      })
      return
    }
    e.targetduration || (e.playlistParsingError = new Error('Missing Target Duration'))
    const E = e.playlistParsingError
    if (E) {
      o.trigger(O.ERROR, {
        type: ne.NETWORK_ERROR,
        details: K.LEVEL_PARSING_ERROR,
        fatal: !1,
        url: m,
        error: E,
        reason: E.message,
        response: t,
        context: n,
        level: v,
        parent: p,
        networkDetails: i,
        stats: r
      })
      return
    }
    switch (
      (e.live &&
        a &&
        (a.getCacheAge && (e.ageHeader = a.getCacheAge() || 0),
        (!a.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)),
      l)
    ) {
      case fe.MANIFEST:
      case fe.LEVEL:
        o.trigger(O.LEVEL_LOADED, {
          details: e,
          level: v || 0,
          id: c || 0,
          stats: r,
          networkDetails: i,
          deliveryDirectives: d
        })
        break
      case fe.AUDIO_TRACK:
        o.trigger(O.AUDIO_TRACK_LOADED, {
          details: e,
          id: c || 0,
          groupId: f || '',
          stats: r,
          networkDetails: i,
          deliveryDirectives: d
        })
        break
      case fe.SUBTITLE_TRACK:
        o.trigger(O.SUBTITLE_TRACK_LOADED, {
          details: e,
          id: c || 0,
          groupId: f || '',
          stats: r,
          networkDetails: i,
          deliveryDirectives: d
        })
        break
    }
  }
}
function sa(s, e) {
  let t
  try {
    t = new Event('addtrack')
  } catch {
    ;(t = document.createEvent('Event')), t.initEvent('addtrack', !1, !1)
  }
  ;(t.track = s), e.dispatchEvent(t)
}
function aa(s, e) {
  const t = s.mode
  if ((t === 'disabled' && (s.mode = 'hidden'), s.cues && !s.cues.getCueById(e.id)))
    try {
      if ((s.addCue(e), !s.cues.getCueById(e.id))) throw new Error(`addCue is failed for: ${e}`)
    } catch (r) {
      G.debug(`[texttrack-utils]: ${r}`)
      try {
        const n = new self.TextTrackCue(e.startTime, e.endTime, e.text)
        ;(n.id = e.id), s.addCue(n)
      } catch (n) {
        G.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${n}`)
      }
    }
  t === 'disabled' && (s.mode = t)
}
function Pt(s) {
  const e = s.mode
  if ((e === 'disabled' && (s.mode = 'hidden'), s.cues))
    for (let t = s.cues.length; t--; ) s.removeCue(s.cues[t])
  e === 'disabled' && (s.mode = e)
}
function En(s, e, t, r) {
  const n = s.mode
  if ((n === 'disabled' && (s.mode = 'hidden'), s.cues && s.cues.length > 0)) {
    const i = oc(s.cues, e, t)
    for (let a = 0; a < i.length; a++) (!r || r(i[a])) && s.removeCue(i[a])
  }
  n === 'disabled' && (s.mode = n)
}
function ac(s, e) {
  if (e < s[0].startTime) return 0
  const t = s.length - 1
  if (e > s[t].endTime) return -1
  let r = 0,
    n = t
  for (; r <= n; ) {
    const i = Math.floor((n + r) / 2)
    if (e < s[i].startTime) n = i - 1
    else if (e > s[i].startTime && r < t) r = i + 1
    else return i
  }
  return s[r].startTime - e < e - s[n].startTime ? r : n
}
function oc(s, e, t) {
  const r = [],
    n = ac(s, e)
  if (n > -1)
    for (let i = n, a = s.length; i < a; i++) {
      const o = s[i]
      if (o.startTime >= e && o.endTime <= t) r.push(o)
      else if (o.startTime > t) return r
    }
  return r
}
var Qe = {
  audioId3: 'org.id3',
  dateRange: 'com.apple.quicktime.HLS',
  emsg: 'https://aomedia.org/emsg/ID3'
}
const lc = 0.25
function xn() {
  if (!(typeof self > 'u')) return self.WebKitDataCue || self.VTTCue || self.TextTrackCue
}
const Xt = (() => {
  const s = xn()
  try {
    new s(0, Number.POSITIVE_INFINITY, '')
  } catch {
    return Number.MAX_VALUE
  }
  return Number.POSITIVE_INFINITY
})()
function qr(s, e) {
  return s.getTime() / 1e3 - e
}
function uc(s) {
  return Uint8Array.from(
    s
      .replace(/^0x/, '')
      .replace(/([\da-fA-F]{2}) ?/g, '0x$1 ')
      .replace(/ +$/, '')
      .split(' ')
  ).buffer
}
class cc {
  constructor(e) {
    ;(this.hls = void 0),
      (this.id3Track = null),
      (this.media = null),
      (this.dateRangeCuesAppended = {}),
      (this.hls = e),
      this._registerListeners()
  }
  destroy() {
    this._unregisterListeners(),
      (this.id3Track = null),
      (this.media = null),
      (this.dateRangeCuesAppended = {}),
      (this.hls = null)
  }
  _registerListeners() {
    const { hls: e } = this
    e.on(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(O.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
      e.on(O.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.on(O.LEVEL_UPDATED, this.onLevelUpdated, this)
  }
  _unregisterListeners() {
    const { hls: e } = this
    e.off(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(O.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
      e.off(O.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.off(O.LEVEL_UPDATED, this.onLevelUpdated, this)
  }
  onMediaAttached(e, t) {
    this.media = t.media
  }
  onMediaDetaching() {
    this.id3Track &&
      (Pt(this.id3Track),
      (this.id3Track = null),
      (this.media = null),
      (this.dateRangeCuesAppended = {}))
  }
  onManifestLoading() {
    this.dateRangeCuesAppended = {}
  }
  createTrack(e) {
    const t = this.getID3Track(e.textTracks)
    return (t.mode = 'hidden'), t
  }
  getID3Track(e) {
    if (this.media) {
      for (let t = 0; t < e.length; t++) {
        const r = e[t]
        if (r.kind === 'metadata' && r.label === 'id3') return sa(r, this.media), r
      }
      return this.media.addTextTrack('metadata', 'id3')
    }
  }
  onFragParsingMetadata(e, t) {
    if (!this.media) return
    const {
      hls: {
        config: { enableEmsgMetadataCues: r, enableID3MetadataCues: n }
      }
    } = this
    if (!r && !n) return
    const { samples: i } = t
    this.id3Track || (this.id3Track = this.createTrack(this.media))
    const a = xn()
    for (let o = 0; o < i.length; o++) {
      const l = i[o].type
      if ((l === Qe.emsg && !r) || !n) continue
      const u = Xs(i[o].data)
      if (u) {
        const c = i[o].pts
        let f = c + i[o].duration
        f > Xt && (f = Xt), f - c <= 0 && (f = c + lc)
        for (let m = 0; m < u.length; m++) {
          const p = u[m]
          if (!qs(p)) {
            this.updateId3CueEnds(c, l)
            const v = new a(c, f, '')
            ;(v.value = p), l && (v.type = l), this.id3Track.addCue(v)
          }
        }
      }
    }
  }
  updateId3CueEnds(e, t) {
    var r
    const n = (r = this.id3Track) == null ? void 0 : r.cues
    if (n)
      for (let i = n.length; i--; ) {
        const a = n[i]
        a.type === t && a.startTime < e && a.endTime === Xt && (a.endTime = e)
      }
  }
  onBufferFlushing(e, { startOffset: t, endOffset: r, type: n }) {
    const { id3Track: i, hls: a } = this
    if (!a) return
    const {
      config: { enableEmsgMetadataCues: o, enableID3MetadataCues: l }
    } = a
    if (i && (o || l)) {
      let u
      n === 'audio'
        ? (u = (c) => c.type === Qe.audioId3 && l)
        : n === 'video'
        ? (u = (c) => c.type === Qe.emsg && o)
        : (u = (c) => (c.type === Qe.audioId3 && l) || (c.type === Qe.emsg && o)),
        En(i, t, r, u)
    }
  }
  onLevelUpdated(e, { details: t }) {
    if (!this.media || !t.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) return
    const { dateRangeCuesAppended: r, id3Track: n } = this,
      { dateRanges: i } = t,
      a = Object.keys(i)
    if (n) {
      const c = Object.keys(r).filter((f) => !a.includes(f))
      for (let f = c.length; f--; ) {
        const d = c[f]
        Object.keys(r[d].cues).forEach((m) => {
          n.removeCue(r[d].cues[m])
        }),
          delete r[d]
      }
    }
    const o = t.fragments[t.fragments.length - 1]
    if (a.length === 0 || !J(o == null ? void 0 : o.programDateTime)) return
    this.id3Track || (this.id3Track = this.createTrack(this.media))
    const l = o.programDateTime / 1e3 - o.start,
      u = xn()
    for (let c = 0; c < a.length; c++) {
      const f = a[c],
        d = i[f],
        m = r[f],
        p = (m == null ? void 0 : m.cues) || {}
      let v = (m == null ? void 0 : m.durationKnown) || !1
      const E = qr(d.startDate, l)
      let x = Xt
      const T = d.endDate
      if (T) (x = qr(T, l)), (v = !0)
      else if (d.endOnNext && !v) {
        const R = a
          .reduce((g, A) => {
            const S = i[A]
            return S.class === d.class && S.id !== A && S.startDate > d.startDate && g.push(S), g
          }, [])
          .sort((g, A) => g.startDate.getTime() - A.startDate.getTime())[0]
        R && ((x = qr(R.startDate, l)), (v = !0))
      }
      const b = Object.keys(d.attr)
      for (let R = 0; R < b.length; R++) {
        const g = b[R]
        if (!yu(g)) continue
        let A = p[g]
        if (A) v && !m.durationKnown && (A.endTime = x)
        else {
          let S = d.attr[g]
          ;(A = new u(E, x, '')),
            vu(g) && (S = uc(S)),
            (A.value = { key: g, data: S }),
            (A.type = Qe.dateRange),
            (A.id = f),
            this.id3Track.addCue(A),
            (p[g] = A)
        }
      }
      r[f] = { cues: p, dateRange: d, durationKnown: v }
    }
  }
}
class fc {
  constructor(e) {
    ;(this.hls = void 0),
      (this.config = void 0),
      (this.media = null),
      (this.levelDetails = null),
      (this.currentTime = 0),
      (this.stallCount = 0),
      (this._latency = null),
      (this.timeupdateHandler = () => this.timeupdate()),
      (this.hls = e),
      (this.config = e.config),
      this.registerListeners()
  }
  get latency() {
    return this._latency || 0
  }
  get maxLatency() {
    const { config: e, levelDetails: t } = this
    return e.liveMaxLatencyDuration !== void 0
      ? e.liveMaxLatencyDuration
      : t
      ? e.liveMaxLatencyDurationCount * t.targetduration
      : 0
  }
  get targetLatency() {
    const { levelDetails: e } = this
    if (e === null) return null
    const { holdBack: t, partHoldBack: r, targetduration: n } = e,
      { liveSyncDuration: i, liveSyncDurationCount: a, lowLatencyMode: o } = this.config,
      l = this.hls.userConfig
    let u = (o && r) || t
    ;(l.liveSyncDuration || l.liveSyncDurationCount || u === 0) && (u = i !== void 0 ? i : a * n)
    const c = n,
      f = 1
    return u + Math.min(this.stallCount * f, c)
  }
  get liveSyncPosition() {
    const e = this.estimateLiveEdge(),
      t = this.targetLatency,
      r = this.levelDetails
    if (e === null || t === null || r === null) return null
    const n = r.edge,
      i = e - t - this.edgeStalled,
      a = n - r.totalduration,
      o = n - ((this.config.lowLatencyMode && r.partTarget) || r.targetduration)
    return Math.min(Math.max(a, i), o)
  }
  get drift() {
    const { levelDetails: e } = this
    return e === null ? 1 : e.drift
  }
  get edgeStalled() {
    const { levelDetails: e } = this
    if (e === null) return 0
    const t = ((this.config.lowLatencyMode && e.partTarget) || e.targetduration) * 3
    return Math.max(e.age - t, 0)
  }
  get forwardBufferLength() {
    const { media: e, levelDetails: t } = this
    if (!e || !t) return 0
    const r = e.buffered.length
    return (r ? e.buffered.end(r - 1) : t.edge) - this.currentTime
  }
  destroy() {
    this.unregisterListeners(),
      this.onMediaDetaching(),
      (this.levelDetails = null),
      (this.hls = this.timeupdateHandler = null)
  }
  registerListeners() {
    this.hls.on(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      this.hls.on(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      this.hls.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      this.hls.on(O.LEVEL_UPDATED, this.onLevelUpdated, this),
      this.hls.on(O.ERROR, this.onError, this)
  }
  unregisterListeners() {
    this.hls.off(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      this.hls.off(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      this.hls.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      this.hls.off(O.LEVEL_UPDATED, this.onLevelUpdated, this),
      this.hls.off(O.ERROR, this.onError, this)
  }
  onMediaAttached(e, t) {
    ;(this.media = t.media), this.media.addEventListener('timeupdate', this.timeupdateHandler)
  }
  onMediaDetaching() {
    this.media &&
      (this.media.removeEventListener('timeupdate', this.timeupdateHandler), (this.media = null))
  }
  onManifestLoading() {
    ;(this.levelDetails = null), (this._latency = null), (this.stallCount = 0)
  }
  onLevelUpdated(e, { details: t }) {
    ;(this.levelDetails = t),
      t.advanced && this.timeupdate(),
      !t.live && this.media && this.media.removeEventListener('timeupdate', this.timeupdateHandler)
  }
  onError(e, t) {
    var r
    t.details === K.BUFFER_STALLED_ERROR &&
      (this.stallCount++,
      (r = this.levelDetails) != null &&
        r.live &&
        G.warn('[playback-rate-controller]: Stall detected, adjusting target latency'))
  }
  timeupdate() {
    const { media: e, levelDetails: t } = this
    if (!e || !t) return
    this.currentTime = e.currentTime
    const r = this.computeLatency()
    if (r === null) return
    this._latency = r
    const { lowLatencyMode: n, maxLiveSyncPlaybackRate: i } = this.config
    if (!n || i === 1) return
    const a = this.targetLatency
    if (a === null) return
    const o = r - a,
      l = Math.min(this.maxLatency, a + t.targetduration),
      u = o < l
    if (t.live && u && o > 0.05 && this.forwardBufferLength > 1) {
      const c = Math.min(2, Math.max(1, i)),
        f = Math.round((2 / (1 + Math.exp(-0.75 * o - this.edgeStalled))) * 20) / 20
      e.playbackRate = Math.min(c, Math.max(1, f))
    } else e.playbackRate !== 1 && e.playbackRate !== 0 && (e.playbackRate = 1)
  }
  estimateLiveEdge() {
    const { levelDetails: e } = this
    return e === null ? null : e.edge + e.age
  }
  computeLatency() {
    const e = this.estimateLiveEdge()
    return e === null ? null : e - this.currentTime
  }
}
const Sn = ['NONE', 'TYPE-0', 'TYPE-1', null]
var $t = { No: '', Yes: 'YES', v2: 'v2' }
function dc(s, e) {
  const { canSkipUntil: t, canSkipDateRanges: r, endSN: n } = s,
    i = e !== void 0 ? e - n : 0
  return t && i < t ? (r ? $t.v2 : $t.Yes) : $t.No
}
class Gi {
  constructor(e, t, r) {
    ;(this.msn = void 0),
      (this.part = void 0),
      (this.skip = void 0),
      (this.msn = e),
      (this.part = t),
      (this.skip = r)
  }
  addDirectives(e) {
    const t = new self.URL(e)
    return (
      this.msn !== void 0 && t.searchParams.set('_HLS_msn', this.msn.toString()),
      this.part !== void 0 && t.searchParams.set('_HLS_part', this.part.toString()),
      this.skip && t.searchParams.set('_HLS_skip', this.skip),
      t.href
    )
  }
}
class Ht {
  constructor(e) {
    ;(this._attrs = void 0),
      (this.audioCodec = void 0),
      (this.bitrate = void 0),
      (this.codecSet = void 0),
      (this.height = void 0),
      (this.id = void 0),
      (this.name = void 0),
      (this.videoCodec = void 0),
      (this.width = void 0),
      (this.unknownCodecs = void 0),
      (this.audioGroupIds = void 0),
      (this.details = void 0),
      (this.fragmentError = 0),
      (this.loadError = 0),
      (this.loaded = void 0),
      (this.realBitrate = 0),
      (this.textGroupIds = void 0),
      (this.url = void 0),
      (this._urlId = 0),
      (this.url = [e.url]),
      (this._attrs = [e.attrs]),
      (this.bitrate = e.bitrate),
      e.details && (this.details = e.details),
      (this.id = e.id || 0),
      (this.name = e.name),
      (this.width = e.width || 0),
      (this.height = e.height || 0),
      (this.audioCodec = e.audioCodec),
      (this.videoCodec = e.videoCodec),
      (this.unknownCodecs = e.unknownCodecs),
      (this.codecSet = [e.videoCodec, e.audioCodec]
        .filter((t) => t)
        .join(',')
        .replace(/\.[^.,]+/g, ''))
  }
  get maxBitrate() {
    return Math.max(this.realBitrate, this.bitrate)
  }
  get attrs() {
    return this._attrs[this._urlId]
  }
  get pathwayId() {
    return this.attrs['PATHWAY-ID'] || '.'
  }
  get uri() {
    return this.url[this._urlId] || ''
  }
  get urlId() {
    return this._urlId
  }
  set urlId(e) {
    const t = e % this.url.length
    this._urlId !== t &&
      ((this.fragmentError = 0), (this.loadError = 0), (this.details = void 0), (this._urlId = t))
  }
  get audioGroupId() {
    var e
    return (e = this.audioGroupIds) == null ? void 0 : e[this.urlId]
  }
  get textGroupId() {
    var e
    return (e = this.textGroupIds) == null ? void 0 : e[this.urlId]
  }
  addFallback(e) {
    this.url.push(e.url), this._attrs.push(e.attrs)
  }
}
function Xr(s, e) {
  const t = e.startPTS
  if (J(t)) {
    let r = 0,
      n
    e.sn > s.sn ? ((r = t - s.start), (n = s)) : ((r = s.start - t), (n = e)),
      n.duration !== r && (n.duration = r)
  } else
    e.sn > s.sn
      ? s.cc === e.cc && s.minEndPTS
        ? (e.start = s.start + (s.minEndPTS - s.start))
        : (e.start = s.start + s.duration)
      : (e.start = Math.max(s.start - e.duration, 0))
}
function oa(s, e, t, r, n, i) {
  r - t <= 0 &&
    (G.warn('Fragment should have a positive duration', e),
    (r = t + e.duration),
    (i = n + e.duration))
  let o = t,
    l = r
  const u = e.startPTS,
    c = e.endPTS
  if (J(u)) {
    const E = Math.abs(u - t)
    J(e.deltaPTS) ? (e.deltaPTS = Math.max(E, e.deltaPTS)) : (e.deltaPTS = E),
      (o = Math.max(t, u)),
      (t = Math.min(t, u)),
      (n = Math.min(n, e.startDTS)),
      (l = Math.min(r, c)),
      (r = Math.max(r, c)),
      (i = Math.max(i, e.endDTS))
  }
  const f = t - e.start
  e.start !== 0 && (e.start = t),
    (e.duration = r - e.start),
    (e.startPTS = t),
    (e.maxStartPTS = o),
    (e.startDTS = n),
    (e.endPTS = r),
    (e.minEndPTS = l),
    (e.endDTS = i)
  const d = e.sn
  if (!s || d < s.startSN || d > s.endSN) return 0
  let m
  const p = d - s.startSN,
    v = s.fragments
  for (v[p] = e, m = p; m > 0; m--) Xr(v[m], v[m - 1])
  for (m = p; m < v.length - 1; m++) Xr(v[m], v[m + 1])
  return (
    s.fragmentHint && Xr(v[v.length - 1], s.fragmentHint), (s.PTSKnown = s.alignedSliding = !0), f
  )
}
function hc(s, e) {
  let t = null
  const r = s.fragments
  for (let l = r.length - 1; l >= 0; l--) {
    const u = r[l].initSegment
    if (u) {
      t = u
      break
    }
  }
  s.fragmentHint && delete s.fragmentHint.endPTS
  let n = 0,
    i
  if (
    (gc(s, e, (l, u) => {
      l.relurl && (n = l.cc - u.cc),
        J(l.startPTS) &&
          J(l.endPTS) &&
          ((u.start = u.startPTS = l.startPTS),
          (u.startDTS = l.startDTS),
          (u.maxStartPTS = l.maxStartPTS),
          (u.endPTS = l.endPTS),
          (u.endDTS = l.endDTS),
          (u.minEndPTS = l.minEndPTS),
          (u.duration = l.endPTS - l.startPTS),
          u.duration && (i = u),
          (e.PTSKnown = e.alignedSliding = !0)),
        (u.elementaryStreams = l.elementaryStreams),
        (u.loader = l.loader),
        (u.stats = l.stats),
        (u.urlId = l.urlId),
        l.initSegment && ((u.initSegment = l.initSegment), (t = l.initSegment))
    }),
    t &&
      (e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments).forEach((u) => {
        var c
        ;(!u.initSegment || u.initSegment.relurl === ((c = t) == null ? void 0 : c.relurl)) &&
          (u.initSegment = t)
      }),
    e.skippedSegments)
  )
    if (((e.deltaUpdateFailed = e.fragments.some((l) => !l)), e.deltaUpdateFailed)) {
      G.warn('[level-helper] Previous playlist missing segments skipped in delta playlist')
      for (let l = e.skippedSegments; l--; ) e.fragments.shift()
      ;(e.startSN = e.fragments[0].sn), (e.startCC = e.fragments[0].cc)
    } else
      e.canSkipDateRanges &&
        (e.dateRanges = pc(s.dateRanges, e.dateRanges, e.recentlyRemovedDateranges))
  const a = e.fragments
  if (n) {
    G.warn('discontinuity sliding from playlist, take drift into account')
    for (let l = 0; l < a.length; l++) a[l].cc += n
  }
  e.skippedSegments && (e.startCC = e.fragments[0].cc),
    mc(s.partList, e.partList, (l, u) => {
      ;(u.elementaryStreams = l.elementaryStreams), (u.stats = l.stats)
    }),
    i ? oa(e, i, i.startPTS, i.endPTS, i.startDTS, i.endDTS) : la(s, e),
    a.length && (e.totalduration = e.edge - a[0].start),
    (e.driftStartTime = s.driftStartTime),
    (e.driftStart = s.driftStart)
  const o = e.advancedDateTime
  if (e.advanced && o) {
    const l = e.edge
    e.driftStart || ((e.driftStartTime = o), (e.driftStart = l)),
      (e.driftEndTime = o),
      (e.driftEnd = l)
  } else
    (e.driftEndTime = s.driftEndTime),
      (e.driftEnd = s.driftEnd),
      (e.advancedDateTime = s.advancedDateTime)
}
function pc(s, e, t) {
  const r = Te({}, s)
  return (
    t &&
      t.forEach((n) => {
        delete r[n]
      }),
    Object.keys(e).forEach((n) => {
      const i = new js(e[n].attr, r[n])
      i.isValid
        ? (r[n] = i)
        : G.warn(
            `Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(e[n].attr)}"`
          )
    }),
    r
  )
}
function mc(s, e, t) {
  if (s && e) {
    let r = 0
    for (let n = 0, i = s.length; n <= i; n++) {
      const a = s[n],
        o = e[n + r]
      a && o && a.index === o.index && a.fragment.sn === o.fragment.sn ? t(a, o) : r--
    }
  }
}
function gc(s, e, t) {
  const r = e.skippedSegments,
    n = Math.max(s.startSN, e.startSN) - e.startSN,
    i = (s.fragmentHint ? 1 : 0) + (r ? e.endSN : Math.min(s.endSN, e.endSN)) - e.startSN,
    a = e.startSN - s.startSN,
    o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments,
    l = s.fragmentHint ? s.fragments.concat(s.fragmentHint) : s.fragments
  for (let u = n; u <= i; u++) {
    const c = l[a + u]
    let f = o[u]
    r && !f && u < r && (f = e.fragments[u] = c), c && f && t(c, f)
  }
}
function la(s, e) {
  const t = e.startSN + e.skippedSegments - s.startSN,
    r = s.fragments
  t < 0 || t >= r.length || Tn(e, r[t].start)
}
function Tn(s, e) {
  if (e) {
    const t = s.fragments
    for (let r = s.skippedSegments; r < t.length; r++) t[r].start += e
    s.fragmentHint && (s.fragmentHint.start += e)
  }
}
function yc(s, e = 1 / 0) {
  let t = 1e3 * s.targetduration
  if (s.updated) {
    const r = s.fragments,
      n = 4
    if (r.length && t * n > e) {
      const i = r[r.length - 1].duration * 1e3
      i < t && (t = i)
    }
  } else t /= 2
  return Math.round(t)
}
function vc(s, e, t) {
  if (!(s != null && s.details)) return null
  const r = s.details
  let n = r.fragments[e - r.startSN]
  return n || ((n = r.fragmentHint), n && n.sn === e)
    ? n
    : e < r.startSN && t && t.sn === e
    ? t
    : null
}
function $i(s, e, t) {
  var r
  return s != null && s.details ? ua((r = s.details) == null ? void 0 : r.partList, e, t) : null
}
function ua(s, e, t) {
  if (s)
    for (let r = s.length; r--; ) {
      const n = s[r]
      if (n.index === t && n.fragment.sn === e) return n
    }
  return null
}
function hr(s) {
  switch (s.details) {
    case K.FRAG_LOAD_TIMEOUT:
    case K.KEY_LOAD_TIMEOUT:
    case K.LEVEL_LOAD_TIMEOUT:
    case K.MANIFEST_LOAD_TIMEOUT:
      return !0
  }
  return !1
}
function Ki(s, e) {
  const t = hr(e)
  return s.default[`${t ? 'timeout' : 'error'}Retry`]
}
function Mn(s, e) {
  const t = s.backoff === 'linear' ? 1 : Math.pow(2, e)
  return Math.min(t * s.retryDelayMs, s.maxRetryDelayMs)
}
function ji(s) {
  return Ve(Ve({}, s), { errorRetry: null, timeoutRetry: null })
}
function pr(s, e, t, r) {
  return !!s && e < s.maxNumRetry && (_c(r) || !!t)
}
function _c(s) {
  return (s === 0 && navigator.onLine === !1) || (!!s && (s < 400 || s > 499))
}
const ca = {
  search: function (s, e) {
    let t = 0,
      r = s.length - 1,
      n = null,
      i = null
    for (; t <= r; ) {
      ;(n = ((t + r) / 2) | 0), (i = s[n])
      const a = e(i)
      if (a > 0) t = n + 1
      else if (a < 0) r = n - 1
      else return i
    }
    return null
  }
}
function Ec(s, e, t) {
  if (e === null || !Array.isArray(s) || !s.length || !J(e)) return null
  const r = s[0].programDateTime
  if (e < (r || 0)) return null
  const n = s[s.length - 1].endProgramDateTime
  if (e >= (n || 0)) return null
  t = t || 0
  for (let i = 0; i < s.length; ++i) {
    const a = s[i]
    if (xc(e, t, a)) return a
  }
  return null
}
function Wt(s, e, t = 0, r = 0) {
  let n = null
  if (
    (s ? (n = e[s.sn - e[0].sn + 1] || null) : t === 0 && e[0].start === 0 && (n = e[0]),
    n && bn(t, r, n) === 0)
  )
    return n
  const i = ca.search(e, bn.bind(null, t, r))
  return i && (i !== s || !n) ? i : n
}
function bn(s = 0, e = 0, t) {
  if (t.start <= s && t.start + t.duration > s) return 0
  const r = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0))
  return t.start + t.duration - r <= s ? 1 : t.start - r > s && t.start ? -1 : 0
}
function xc(s, e, t) {
  const r = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)) * 1e3
  return (t.endProgramDateTime || 0) - r > s
}
function Sc(s, e) {
  return ca.search(s, (t) => (t.cc < e ? 1 : t.cc > e ? -1 : 0))
}
const Tc = 3e5
var Ce = {
    DoNothing: 0,
    SendEndCallback: 1,
    SendAlternateToPenaltyBox: 2,
    RemoveAlternatePermanently: 3,
    InsertDiscontinuity: 4,
    RetryRequest: 5
  },
  ze = {
    None: 0,
    MoveAllAlternatesMatchingHost: 1,
    MoveAllAlternatesMatchingHDCP: 2,
    SwitchToSDR: 4
  }
class bc {
  constructor(e) {
    ;(this.hls = void 0),
      (this.playlistError = 0),
      (this.penalizedRenditions = {}),
      (this.log = void 0),
      (this.warn = void 0),
      (this.error = void 0),
      (this.hls = e),
      (this.log = G.log.bind(G, '[info]:')),
      (this.warn = G.warn.bind(G, '[warning]:')),
      (this.error = G.error.bind(G, '[error]:')),
      this.registerListeners()
  }
  registerListeners() {
    const e = this.hls
    e.on(O.ERROR, this.onError, this),
      e.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(O.LEVEL_UPDATED, this.onLevelUpdated, this)
  }
  unregisterListeners() {
    const e = this.hls
    e &&
      (e.off(O.ERROR, this.onError, this),
      e.off(O.ERROR, this.onErrorOut, this),
      e.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(O.LEVEL_UPDATED, this.onLevelUpdated, this))
  }
  destroy() {
    this.unregisterListeners(), (this.hls = null), (this.penalizedRenditions = {})
  }
  startLoad(e) {
    this.playlistError = 0
  }
  stopLoad() {}
  getVariantLevelIndex(e) {
    return (e == null ? void 0 : e.type) === ie.MAIN ? e.level : this.hls.loadLevel
  }
  onManifestLoading() {
    ;(this.playlistError = 0), (this.penalizedRenditions = {})
  }
  onLevelUpdated() {
    this.playlistError = 0
  }
  onError(e, t) {
    var r, n
    if (t.fatal) return
    const i = this.hls,
      a = t.context
    switch (t.details) {
      case K.FRAG_LOAD_ERROR:
      case K.FRAG_LOAD_TIMEOUT:
      case K.KEY_LOAD_ERROR:
      case K.KEY_LOAD_TIMEOUT:
        t.errorAction = this.getFragRetryOrSwitchAction(t)
        return
      case K.FRAG_PARSING_ERROR:
        if ((r = t.frag) != null && r.gap) {
          t.errorAction = { action: Ce.DoNothing, flags: ze.None }
          return
        }
      case K.FRAG_GAP:
      case K.FRAG_DECRYPT_ERROR: {
        ;(t.errorAction = this.getFragRetryOrSwitchAction(t)),
          (t.errorAction.action = Ce.SendAlternateToPenaltyBox)
        return
      }
      case K.LEVEL_EMPTY_ERROR:
      case K.LEVEL_PARSING_ERROR:
        {
          var o, l
          const u = t.parent === ie.MAIN ? t.level : i.loadLevel
          t.details === K.LEVEL_EMPTY_ERROR &&
          (o = t.context) != null &&
          (l = o.levelDetails) != null &&
          l.live
            ? (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, u))
            : ((t.levelRetry = !1), (t.errorAction = this.getLevelSwitchAction(t, u)))
        }
        return
      case K.LEVEL_LOAD_ERROR:
      case K.LEVEL_LOAD_TIMEOUT:
        typeof (a == null ? void 0 : a.level) == 'number' &&
          (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, a.level))
        return
      case K.AUDIO_TRACK_LOAD_ERROR:
      case K.AUDIO_TRACK_LOAD_TIMEOUT:
      case K.SUBTITLE_LOAD_ERROR:
      case K.SUBTITLE_TRACK_LOAD_TIMEOUT:
        if (a) {
          const u = i.levels[i.loadLevel]
          if (
            u &&
            ((a.type === fe.AUDIO_TRACK && a.groupId === u.audioGroupId) ||
              (a.type === fe.SUBTITLE_TRACK && a.groupId === u.textGroupId))
          ) {
            ;(t.errorAction = this.getPlaylistRetryOrSwitchAction(t, i.loadLevel)),
              (t.errorAction.action = Ce.SendAlternateToPenaltyBox),
              (t.errorAction.flags = ze.MoveAllAlternatesMatchingHost)
            return
          }
        }
        return
      case K.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
        {
          const u = i.levels[i.loadLevel],
            c = u == null ? void 0 : u.attrs['HDCP-LEVEL']
          c &&
            (t.errorAction = {
              action: Ce.SendAlternateToPenaltyBox,
              flags: ze.MoveAllAlternatesMatchingHDCP,
              hdcpLevel: c
            })
        }
        return
      case K.BUFFER_ADD_CODEC_ERROR:
      case K.REMUX_ALLOC_ERROR:
        t.errorAction = this.getLevelSwitchAction(t, (n = t.level) != null ? n : i.loadLevel)
        return
      case K.INTERNAL_EXCEPTION:
      case K.BUFFER_APPENDING_ERROR:
      case K.BUFFER_APPEND_ERROR:
      case K.BUFFER_FULL_ERROR:
      case K.LEVEL_SWITCH_ERROR:
      case K.BUFFER_STALLED_ERROR:
      case K.BUFFER_SEEK_OVER_HOLE:
      case K.BUFFER_NUDGE_ON_STALL:
        t.errorAction = { action: Ce.DoNothing, flags: ze.None }
        return
    }
    if (t.type === ne.KEY_SYSTEM_ERROR) {
      const u = this.getVariantLevelIndex(t.frag)
      ;(t.levelRetry = !1), (t.errorAction = this.getLevelSwitchAction(t, u))
      return
    }
  }
  getPlaylistRetryOrSwitchAction(e, t) {
    var r
    const n = this.hls,
      i = Ki(n.config.playlistLoadPolicy, e),
      a = this.playlistError++,
      o = (r = e.response) == null ? void 0 : r.code
    if (pr(i, a, hr(e), o))
      return { action: Ce.RetryRequest, flags: ze.None, retryConfig: i, retryCount: a }
    const u = this.getLevelSwitchAction(e, t)
    return i && ((u.retryConfig = i), (u.retryCount = a)), u
  }
  getFragRetryOrSwitchAction(e) {
    const t = this.hls,
      r = this.getVariantLevelIndex(e.frag),
      n = t.levels[r],
      { fragLoadPolicy: i, keyLoadPolicy: a } = t.config,
      o = Ki(e.details.startsWith('key') ? a : i, e),
      l = t.levels.reduce((f, d) => f + d.fragmentError, 0)
    if (n) {
      var u
      e.details !== K.FRAG_GAP && n.fragmentError++
      const f = (u = e.response) == null ? void 0 : u.code
      if (pr(o, l, hr(e), f))
        return { action: Ce.RetryRequest, flags: ze.None, retryConfig: o, retryCount: l }
    }
    const c = this.getLevelSwitchAction(e, r)
    return o && ((c.retryConfig = o), (c.retryCount = l)), c
  }
  getLevelSwitchAction(e, t) {
    const r = this.hls
    t == null && (t = r.loadLevel)
    const n = this.hls.levels[t]
    if (n && (n.loadError++, r.autoLevelEnabled)) {
      var i, a
      let o = -1
      const { levels: l, loadLevel: u, minAutoLevel: c, maxAutoLevel: f } = r,
        d = (i = e.frag) == null ? void 0 : i.type,
        { type: m, groupId: p } = (a = e.context) != null ? a : {}
      for (let v = l.length; v--; ) {
        const E = (v + u) % l.length
        if (E !== u && E >= c && E <= f && l[E].loadError === 0) {
          const x = l[E]
          if (e.details === K.FRAG_GAP && e.frag) {
            const T = l[E].details
            if (T) {
              const b = Wt(e.frag, T.fragments, e.frag.start)
              if (b != null && b.gap) continue
            }
          } else {
            if (
              (m === fe.AUDIO_TRACK && p === x.audioGroupId) ||
              (m === fe.SUBTITLE_TRACK && p === x.textGroupId)
            )
              continue
            if (
              (d === ie.AUDIO && n.audioGroupId === x.audioGroupId) ||
              (d === ie.SUBTITLE && n.textGroupId === x.textGroupId)
            )
              continue
          }
          o = E
          break
        }
      }
      if (o > -1 && r.loadLevel !== o)
        return (
          (e.levelRetry = !0),
          (this.playlistError = 0),
          { action: Ce.SendAlternateToPenaltyBox, flags: ze.None, nextAutoLevel: o }
        )
    }
    return { action: Ce.SendAlternateToPenaltyBox, flags: ze.MoveAllAlternatesMatchingHost }
  }
  onErrorOut(e, t) {
    var r
    switch ((r = t.errorAction) == null ? void 0 : r.action) {
      case Ce.DoNothing:
        break
      case Ce.SendAlternateToPenaltyBox:
        this.sendAlternateToPenaltyBox(t),
          !t.errorAction.resolved && t.details !== K.FRAG_GAP && (t.fatal = !0)
        break
    }
    if (t.fatal) {
      this.hls.stopLoad()
      return
    }
  }
  sendAlternateToPenaltyBox(e) {
    const t = this.hls,
      r = e.errorAction
    if (!r) return
    const { flags: n, hdcpLevel: i, nextAutoLevel: a } = r
    switch (n) {
      case ze.None:
        this.switchLevel(e, a)
        break
      case ze.MoveAllAlternatesMatchingHost:
        r.resolved || (r.resolved = this.redundantFailover(e))
        break
      case ze.MoveAllAlternatesMatchingHDCP:
        i && ((t.maxHdcpLevel = Sn[Sn.indexOf(i) - 1]), (r.resolved = !0)),
          this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`)
        break
    }
    r.resolved || this.switchLevel(e, a)
  }
  switchLevel(e, t) {
    t !== void 0 &&
      e.errorAction &&
      (this.warn(`switching to level ${t} after ${e.details}`),
      (this.hls.nextAutoLevel = t),
      (e.errorAction.resolved = !0),
      (this.hls.nextLoadLevel = this.hls.nextAutoLevel))
  }
  redundantFailover(e) {
    const { hls: t, penalizedRenditions: r } = this,
      n = e.parent === ie.MAIN ? e.level : t.loadLevel,
      i = t.levels[n],
      a = i.url.length,
      o = e.frag ? e.frag.urlId : i.urlId
    i.urlId === o && (!e.frag || i.details) && this.penalizeRendition(i, e)
    for (let l = 1; l < a; l++) {
      const u = (o + l) % a,
        c = r[u]
      if (!c || Lc(c, e, r[o]))
        return (
          this.warn(
            `Switching to Redundant Stream ${u + 1}/${a}: "${i.url[u]}" after ${e.details}`
          ),
          (this.playlistError = 0),
          t.levels.forEach((f) => {
            f.urlId = u
          }),
          (t.nextLoadLevel = n),
          !0
        )
    }
    return !1
  }
  penalizeRendition(e, t) {
    const { penalizedRenditions: r } = this,
      n = r[e.urlId] || { lastErrorPerfMs: 0, errors: [], details: void 0 }
    ;(n.lastErrorPerfMs = performance.now()),
      n.errors.push(t),
      (n.details = e.details),
      (r[e.urlId] = n)
  }
}
function Lc(s, e, t) {
  if (performance.now() - s.lastErrorPerfMs > Tc) return !0
  const r = s.details
  if (e.details === K.FRAG_GAP && r && e.frag) {
    const n = e.frag.start,
      i = Wt(null, r.fragments, n)
    if (i && !i.gap) return !0
  }
  if (t && s.errors.length < t.errors.length) {
    const n = s.errors[s.errors.length - 1]
    if (r && n.frag && e.frag && Math.abs(n.frag.start - e.frag.start) > r.targetduration * 3)
      return !0
  }
  return !1
}
class Fn {
  constructor(e, t) {
    ;(this.hls = void 0),
      (this.timer = -1),
      (this.requestScheduled = -1),
      (this.canLoad = !1),
      (this.log = void 0),
      (this.warn = void 0),
      (this.log = G.log.bind(G, `${t}:`)),
      (this.warn = G.warn.bind(G, `${t}:`)),
      (this.hls = e)
  }
  destroy() {
    this.clearTimer(), (this.hls = this.log = this.warn = null)
  }
  clearTimer() {
    clearTimeout(this.timer), (this.timer = -1)
  }
  startLoad() {
    ;(this.canLoad = !0), (this.requestScheduled = -1), this.loadPlaylist()
  }
  stopLoad() {
    ;(this.canLoad = !1), this.clearTimer()
  }
  switchParams(e, t) {
    const r = t == null ? void 0 : t.renditionReports
    if (r) {
      let n = -1
      for (let i = 0; i < r.length; i++) {
        const a = r[i]
        let o
        try {
          o = new self.URL(a.URI, t.url).href
        } catch (l) {
          G.warn(`Could not construct new URL for Rendition Report: ${l}`), (o = a.URI || '')
        }
        if (o === e) {
          n = i
          break
        } else o === e.substring(0, o.length) && (n = i)
      }
      if (n !== -1) {
        const i = r[n],
          a = parseInt(i['LAST-MSN']) || (t == null ? void 0 : t.lastPartSn)
        let o = parseInt(i['LAST-PART']) || (t == null ? void 0 : t.lastPartIndex)
        if (this.hls.config.lowLatencyMode) {
          const l = Math.min(t.age - t.partTarget, t.targetduration)
          o >= 0 && l > t.partTarget && (o += 1)
        }
        return new Gi(a, o >= 0 ? o : void 0, $t.No)
      }
    }
  }
  loadPlaylist(e) {
    this.requestScheduled === -1 && (this.requestScheduled = self.performance.now())
  }
  shouldLoadPlaylist(e) {
    return this.canLoad && !!e && !!e.url && (!e.details || e.details.live)
  }
  shouldReloadPlaylist(e) {
    return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(e)
  }
  playlistLoaded(e, t, r) {
    const { details: n, stats: i } = t,
      a = self.performance.now(),
      o = i.loading.first ? Math.max(0, a - i.loading.first) : 0
    if (((n.advancedDateTime = Date.now() - o), n.live || (r != null && r.live))) {
      if (
        (n.reloaded(r),
        r &&
          this.log(
            `live playlist ${e} ${
              n.advanced
                ? 'REFRESHED ' + n.lastPartSn + '-' + n.lastPartIndex
                : n.updated
                ? 'UPDATED'
                : 'MISSED'
            }`
          ),
        r && n.fragments.length > 0 && hc(r, n),
        !this.canLoad || !n.live)
      )
        return
      let l, u, c
      if (n.canBlockReload && n.endSN && n.advanced) {
        const E = this.hls.config.lowLatencyMode,
          x = n.lastPartSn,
          T = n.endSN,
          b = n.lastPartIndex,
          R = b !== -1,
          g = x === T,
          A = E ? 0 : b
        R ? ((u = g ? T + 1 : x), (c = g ? A : b + 1)) : (u = T + 1)
        const S = n.age,
          h = S + n.ageHeader
        let _ = Math.min(h - n.partTarget, n.targetduration * 1.5)
        if (_ > 0) {
          if (r && _ > r.tuneInGoal)
            this.warn(
              `CDN Tune-in goal increased from: ${r.tuneInGoal} to: ${_} with playlist age: ${n.age}`
            ),
              (_ = 0)
          else {
            const y = Math.floor(_ / n.targetduration)
            if (((u += y), c !== void 0)) {
              const L = Math.round((_ % n.targetduration) / n.partTarget)
              c += L
            }
            this.log(
              `CDN Tune-in age: ${n.ageHeader}s last advanced ${S.toFixed(
                2
              )}s goal: ${_} skip sn ${y} to part ${c}`
            )
          }
          n.tuneInGoal = _
        }
        if (((l = this.getDeliveryDirectives(n, t.deliveryDirectives, u, c)), E || !g)) {
          this.loadPlaylist(l)
          return
        }
      } else
        (n.canBlockReload || n.canSkipUntil) &&
          (l = this.getDeliveryDirectives(n, t.deliveryDirectives, u, c))
      const f = this.hls.mainForwardBufferInfo,
        d = f ? f.end - f.len : 0,
        m = (n.edge - d) * 1e3,
        p = yc(n, m)
      n.updated && a > this.requestScheduled + p && (this.requestScheduled = i.loading.start),
        u !== void 0 && n.canBlockReload
          ? (this.requestScheduled = i.loading.first + p - (n.partTarget * 1e3 || 1e3))
          : this.requestScheduled === -1 || this.requestScheduled + p < a
          ? (this.requestScheduled = a)
          : this.requestScheduled - a <= 0 && (this.requestScheduled += p)
      let v = this.requestScheduled - a
      ;(v = Math.max(0, v)),
        this.log(`reload live playlist ${e} in ${Math.round(v)} ms`),
        (this.timer = self.setTimeout(() => this.loadPlaylist(l), v))
    } else this.clearTimer()
  }
  getDeliveryDirectives(e, t, r, n) {
    let i = dc(e, r)
    return (
      t != null && t.skip && e.deltaUpdateFailed && ((r = t.msn), (n = t.part), (i = $t.No)),
      new Gi(r, n, i)
    )
  }
  checkRetry(e) {
    const t = e.details,
      r = hr(e),
      n = e.errorAction,
      { action: i, retryCount: a = 0, retryConfig: o } = n || {},
      l =
        !!n && !!o && (i === Ce.RetryRequest || (!n.resolved && i === Ce.SendAlternateToPenaltyBox))
    if (l) {
      var u
      if (((this.requestScheduled = -1), a >= o.maxNumRetry)) return !1
      if (r && (u = e.context) != null && u.deliveryDirectives)
        this.warn(
          `Retrying playlist loading ${a + 1}/${
            o.maxNumRetry
          } after "${t}" without delivery-directives`
        ),
          this.loadPlaylist()
      else {
        const c = Mn(o, a)
        ;(this.timer = self.setTimeout(() => this.loadPlaylist(), c)),
          this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${t}" in ${c}ms`)
      }
      ;(e.levelRetry = !0), (n.resolved = !0)
    }
    return l
  }
}
let Qr
class Ac extends Fn {
  constructor(e, t) {
    super(e, '[level-controller]'),
      (this._levels = []),
      (this._firstLevel = -1),
      (this._startLevel = void 0),
      (this.currentLevel = null),
      (this.currentLevelIndex = -1),
      (this.manualLevelIndex = -1),
      (this.steering = void 0),
      (this.onParsedComplete = void 0),
      (this.steering = t),
      this._registerListeners()
  }
  _registerListeners() {
    const { hls: e } = this
    e.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(O.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.on(O.LEVEL_LOADED, this.onLevelLoaded, this),
      e.on(O.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.on(O.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
      e.on(O.FRAG_LOADED, this.onFragLoaded, this),
      e.on(O.ERROR, this.onError, this)
  }
  _unregisterListeners() {
    const { hls: e } = this
    e.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(O.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.off(O.LEVEL_LOADED, this.onLevelLoaded, this),
      e.off(O.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.off(O.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
      e.off(O.FRAG_LOADED, this.onFragLoaded, this),
      e.off(O.ERROR, this.onError, this)
  }
  destroy() {
    this._unregisterListeners(), (this.steering = null), this.resetLevels(), super.destroy()
  }
  startLoad() {
    this._levels.forEach((t) => {
      ;(t.loadError = 0), (t.fragmentError = 0)
    }),
      super.startLoad()
  }
  resetLevels() {
    ;(this._startLevel = void 0),
      (this.manualLevelIndex = -1),
      (this.currentLevelIndex = -1),
      (this.currentLevel = null),
      (this._levels = [])
  }
  onManifestLoading(e, t) {
    this.resetLevels()
  }
  onManifestLoaded(e, t) {
    const r = [],
      n = {}
    let i
    t.levels.forEach((a) => {
      var o
      const l = a.attrs
      ;((o = a.audioCodec) == null ? void 0 : o.indexOf('mp4a.40.34')) !== -1 &&
        (Qr || (Qr = /chrome|firefox/i.test(navigator.userAgent)), Qr && (a.audioCodec = void 0))
      const {
          AUDIO: u,
          CODECS: c,
          'FRAME-RATE': f,
          'PATHWAY-ID': d,
          RESOLUTION: m,
          SUBTITLES: p
        } = l,
        E = `${`${d || '.'}-`}${a.bitrate}-${m}-${f}-${c}`
      ;(i = n[E]),
        i ? i.addFallback(a) : ((i = new Ht(a)), (n[E] = i), r.push(i)),
        mr(i, 'audio', u),
        mr(i, 'text', p)
    }),
      this.filterAndSortMediaOptions(r, t)
  }
  filterAndSortMediaOptions(e, t) {
    let r = [],
      n = [],
      i = !1,
      a = !1,
      o = !1,
      l = e.filter(
        ({ audioCodec: m, videoCodec: p, width: v, height: E, unknownCodecs: x }) => (
          i || (i = !!(v && E)),
          a || (a = !!p),
          o || (o = !!m),
          !(x != null && x.length) && (!m || Yr(m, 'audio')) && (!p || Yr(p, 'video'))
        )
      )
    if (
      ((i || a) &&
        o &&
        (l = l.filter(({ videoCodec: m, width: p, height: v }) => !!m || !!(p && v))),
      l.length === 0)
    ) {
      Promise.resolve().then(() => {
        if (this.hls) {
          const m = new Error('no level with compatible codecs found in manifest')
          this.hls.trigger(O.ERROR, {
            type: ne.MEDIA_ERROR,
            details: K.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
            fatal: !0,
            url: t.url,
            error: m,
            reason: m.message
          })
        }
      })
      return
    }
    t.audioTracks &&
      ((r = t.audioTracks.filter((m) => !m.audioCodec || Yr(m.audioCodec, 'audio'))), Vi(r)),
      t.subtitles && ((n = t.subtitles), Vi(n))
    const u = l.slice(0)
    l.sort((m, p) =>
      m.attrs['HDCP-LEVEL'] !== p.attrs['HDCP-LEVEL']
        ? (m.attrs['HDCP-LEVEL'] || '') > (p.attrs['HDCP-LEVEL'] || '')
          ? 1
          : -1
        : m.bitrate !== p.bitrate
        ? m.bitrate - p.bitrate
        : m.attrs['FRAME-RATE'] !== p.attrs['FRAME-RATE']
        ? m.attrs.decimalFloatingPoint('FRAME-RATE') - p.attrs.decimalFloatingPoint('FRAME-RATE')
        : m.attrs.SCORE !== p.attrs.SCORE
        ? m.attrs.decimalFloatingPoint('SCORE') - p.attrs.decimalFloatingPoint('SCORE')
        : i && m.height !== p.height
        ? m.height - p.height
        : 0
    )
    let c = u[0]
    if (this.steering && ((l = this.steering.filterParsedLevels(l)), l.length !== u.length)) {
      for (let m = 0; m < u.length; m++)
        if (u[m].pathwayId === l[0].pathwayId) {
          c = u[m]
          break
        }
    }
    this._levels = l
    for (let m = 0; m < l.length; m++)
      if (l[m] === c) {
        ;(this._firstLevel = m),
          this.log(`manifest loaded, ${l.length} level(s) found, first bitrate: ${c.bitrate}`)
        break
      }
    const f = o && !a,
      d = {
        levels: l,
        audioTracks: r,
        subtitleTracks: n,
        sessionData: t.sessionData,
        sessionKeys: t.sessionKeys,
        firstLevel: this._firstLevel,
        stats: t.stats,
        audio: o,
        video: a,
        altAudio: !f && r.some((m) => !!m.url)
      }
    this.hls.trigger(O.MANIFEST_PARSED, d),
      (this.hls.config.autoStartLoad || this.hls.forceStartLoad) &&
        this.hls.startLoad(this.hls.config.startPosition)
  }
  get levels() {
    return this._levels.length === 0 ? null : this._levels
  }
  get level() {
    return this.currentLevelIndex
  }
  set level(e) {
    const t = this._levels
    if (t.length === 0) return
    if (e < 0 || e >= t.length) {
      const c = new Error('invalid level idx'),
        f = e < 0
      if (
        (this.hls.trigger(O.ERROR, {
          type: ne.OTHER_ERROR,
          details: K.LEVEL_SWITCH_ERROR,
          level: e,
          fatal: f,
          error: c,
          reason: c.message
        }),
        f)
      )
        return
      e = Math.min(e, t.length - 1)
    }
    const r = this.currentLevelIndex,
      n = this.currentLevel,
      i = n ? n.attrs['PATHWAY-ID'] : void 0,
      a = t[e],
      o = a.attrs['PATHWAY-ID']
    if (
      ((this.currentLevelIndex = e), (this.currentLevel = a), r === e && a.details && n && i === o)
    )
      return
    this.log(
      `Switching to level ${e}${o ? ' with Pathway ' + o : ''} from level ${r}${
        i ? ' with Pathway ' + i : ''
      }`
    )
    const l = Te({}, a, {
      level: e,
      maxBitrate: a.maxBitrate,
      attrs: a.attrs,
      uri: a.uri,
      urlId: a.urlId
    })
    delete l._attrs, delete l._urlId, this.hls.trigger(O.LEVEL_SWITCHING, l)
    const u = a.details
    if (!u || u.live) {
      const c = this.switchParams(a.uri, n == null ? void 0 : n.details)
      this.loadPlaylist(c)
    }
  }
  get manualLevel() {
    return this.manualLevelIndex
  }
  set manualLevel(e) {
    ;(this.manualLevelIndex = e),
      this._startLevel === void 0 && (this._startLevel = e),
      e !== -1 && (this.level = e)
  }
  get firstLevel() {
    return this._firstLevel
  }
  set firstLevel(e) {
    this._firstLevel = e
  }
  get startLevel() {
    if (this._startLevel === void 0) {
      const e = this.hls.config.startLevel
      return e !== void 0 ? e : this._firstLevel
    } else return this._startLevel
  }
  set startLevel(e) {
    this._startLevel = e
  }
  onError(e, t) {
    t.fatal ||
      !t.context ||
      (t.context.type === fe.LEVEL && t.context.level === this.level && this.checkRetry(t))
  }
  onFragLoaded(e, { frag: t }) {
    if (t !== void 0 && t.type === ie.MAIN) {
      const r = this._levels[t.level]
      r !== void 0 && (r.loadError = 0)
    }
  }
  onLevelLoaded(e, t) {
    var r
    const { level: n, details: i } = t,
      a = this._levels[n]
    if (!a) {
      var o
      this.warn(`Invalid level index ${n}`),
        (o = t.deliveryDirectives) != null && o.skip && (i.deltaUpdateFailed = !0)
      return
    }
    n === this.currentLevelIndex
      ? (a.fragmentError === 0 && (a.loadError = 0), this.playlistLoaded(n, t, a.details))
      : (r = t.deliveryDirectives) != null && r.skip && (i.deltaUpdateFailed = !0)
  }
  onAudioTrackSwitched(e, t) {
    const r = this.currentLevel
    if (!r) return
    const n = this.hls.audioTracks[t.id].groupId
    if (r.audioGroupIds && r.audioGroupId !== n) {
      let i = -1
      for (let a = 0; a < r.audioGroupIds.length; a++)
        if (r.audioGroupIds[a] === n) {
          i = a
          break
        }
      i !== -1 && i !== r.urlId && ((r.urlId = i), this.canLoad && this.startLoad())
    }
  }
  loadPlaylist(e) {
    super.loadPlaylist()
    const t = this.currentLevelIndex,
      r = this.currentLevel
    if (r && this.shouldLoadPlaylist(r)) {
      const n = r.urlId
      let i = r.uri
      if (e)
        try {
          i = e.addDirectives(i)
        } catch (o) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${o}`)
        }
      const a = r.attrs['PATHWAY-ID']
      this.log(
        `Loading level index ${t}${
          (e == null ? void 0 : e.msn) !== void 0 ? ' at sn ' + e.msn + ' part ' + e.part : ''
        } with${a ? ' Pathway ' + a : ''} URI ${n + 1}/${r.url.length} ${i}`
      ),
        this.clearTimer(),
        this.hls.trigger(O.LEVEL_LOADING, {
          url: i,
          level: t,
          id: n,
          deliveryDirectives: e || null
        })
    }
  }
  get nextLoadLevel() {
    return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel
  }
  set nextLoadLevel(e) {
    ;(this.level = e), this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e)
  }
  removeLevel(e, t) {
    const r = (i, a) => a !== t,
      n = this._levels.filter((i, a) =>
        a !== e
          ? !0
          : i.url.length > 1 && t !== void 0
          ? ((i.url = i.url.filter(r)),
            i.audioGroupIds && (i.audioGroupIds = i.audioGroupIds.filter(r)),
            i.textGroupIds && (i.textGroupIds = i.textGroupIds.filter(r)),
            (i.urlId = 0),
            !0)
          : (this.steering && this.steering.removeLevel(i), !1)
      )
    this.hls.trigger(O.LEVELS_UPDATED, { levels: n })
  }
  onLevelsUpdated(e, { levels: t }) {
    t.forEach((r, n) => {
      const { details: i } = r
      i != null &&
        i.fragments &&
        i.fragments.forEach((a) => {
          a.level = n
        })
    }),
      (this._levels = t)
  }
}
function mr(s, e, t) {
  t &&
    (e === 'audio'
      ? (s.audioGroupIds || (s.audioGroupIds = []), (s.audioGroupIds[s.url.length - 1] = t))
      : e === 'text' &&
        (s.textGroupIds || (s.textGroupIds = []), (s.textGroupIds[s.url.length - 1] = t)))
}
function Vi(s) {
  const e = {}
  s.forEach((t) => {
    const r = t.groupId || ''
    ;(t.id = e[r] = e[r] || 0), e[r]++
  })
}
var Re = { NOT_LOADED: 'NOT_LOADED', APPENDING: 'APPENDING', PARTIAL: 'PARTIAL', OK: 'OK' }
class Rc {
  constructor(e) {
    ;(this.activePartLists = Object.create(null)),
      (this.endListFragments = Object.create(null)),
      (this.fragments = Object.create(null)),
      (this.timeRanges = Object.create(null)),
      (this.bufferPadding = 0.2),
      (this.hls = void 0),
      (this.hasGaps = !1),
      (this.hls = e),
      this._registerListeners()
  }
  _registerListeners() {
    const { hls: e } = this
    e.on(O.BUFFER_APPENDED, this.onBufferAppended, this),
      e.on(O.FRAG_BUFFERED, this.onFragBuffered, this),
      e.on(O.FRAG_LOADED, this.onFragLoaded, this)
  }
  _unregisterListeners() {
    const { hls: e } = this
    e.off(O.BUFFER_APPENDED, this.onBufferAppended, this),
      e.off(O.FRAG_BUFFERED, this.onFragBuffered, this),
      e.off(O.FRAG_LOADED, this.onFragLoaded, this)
  }
  destroy() {
    this._unregisterListeners(),
      (this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null)
  }
  getAppendedFrag(e, t) {
    const r = this.activePartLists[t]
    if (r)
      for (let n = r.length; n--; ) {
        const i = r[n]
        if (!i) break
        const a = i.end
        if (i.start <= e && a !== null && e <= a) return i
      }
    return this.getBufferedFrag(e, t)
  }
  getBufferedFrag(e, t) {
    const { fragments: r } = this,
      n = Object.keys(r)
    for (let i = n.length; i--; ) {
      const a = r[n[i]]
      if ((a == null ? void 0 : a.body.type) === t && a.buffered) {
        const o = a.body
        if (o.start <= e && e <= o.end) return o
      }
    }
    return null
  }
  detectEvictedFragments(e, t, r, n) {
    this.timeRanges && (this.timeRanges[e] = t)
    const i = (n == null ? void 0 : n.fragment.sn) || -1
    Object.keys(this.fragments).forEach((a) => {
      const o = this.fragments[a]
      if (!o || i >= o.body.sn) return
      if (!o.buffered && !o.loaded) {
        o.body.type === r && this.removeFragment(o.body)
        return
      }
      const l = o.range[e]
      l &&
        l.time.some((u) => {
          const c = !this.isTimeBuffered(u.startPTS, u.endPTS, t)
          return c && this.removeFragment(o.body), c
        })
    })
  }
  detectPartialFragments(e) {
    const t = this.timeRanges,
      { frag: r, part: n } = e
    if (!t || r.sn === 'initSegment') return
    const i = Lt(r),
      a = this.fragments[i]
    if (!a || (a.buffered && r.gap)) return
    const o = !r.relurl
    Object.keys(t).forEach((l) => {
      const u = r.elementaryStreams[l]
      if (!u) return
      const c = t[l],
        f = o || u.partial === !0
      a.range[l] = this.getBufferedTimes(r, n, f, c)
    }),
      (a.loaded = null),
      Object.keys(a.range).length
        ? ((a.buffered = !0),
          (a.body.endList = r.endList || a.body.endList) &&
            (this.endListFragments[a.body.type] = a),
          Qt(a) || this.removeParts(r.sn - 1, r.type))
        : this.removeFragment(a.body)
  }
  removeParts(e, t) {
    const r = this.activePartLists[t]
    r && (this.activePartLists[t] = r.filter((n) => n.fragment.sn >= e))
  }
  fragBuffered(e, t) {
    const r = Lt(e)
    let n = this.fragments[r]
    !n &&
      t &&
      ((n = this.fragments[r] =
        { body: e, appendedPTS: null, loaded: null, buffered: !1, range: Object.create(null) }),
      e.gap && (this.hasGaps = !0)),
      n && ((n.loaded = null), (n.buffered = !0))
  }
  getBufferedTimes(e, t, r, n) {
    const i = { time: [], partial: r },
      a = e.start,
      o = e.end,
      l = e.minEndPTS || o,
      u = e.maxStartPTS || a
    for (let c = 0; c < n.length; c++) {
      const f = n.start(c) - this.bufferPadding,
        d = n.end(c) + this.bufferPadding
      if (u >= f && l <= d) {
        i.time.push({ startPTS: Math.max(a, n.start(c)), endPTS: Math.min(o, n.end(c)) })
        break
      } else if (a < d && o > f)
        (i.partial = !0),
          i.time.push({ startPTS: Math.max(a, n.start(c)), endPTS: Math.min(o, n.end(c)) })
      else if (o <= f) break
    }
    return i
  }
  getPartialFragment(e) {
    let t = null,
      r,
      n,
      i,
      a = 0
    const { bufferPadding: o, fragments: l } = this
    return (
      Object.keys(l).forEach((u) => {
        const c = l[u]
        c &&
          Qt(c) &&
          ((n = c.body.start - o),
          (i = c.body.end + o),
          e >= n && e <= i && ((r = Math.min(e - n, i - e)), a <= r && ((t = c.body), (a = r))))
      }),
      t
    )
  }
  isEndListAppended(e) {
    const t = this.endListFragments[e]
    return t !== void 0 && (t.buffered || Qt(t))
  }
  getState(e) {
    const t = Lt(e),
      r = this.fragments[t]
    return r ? (r.buffered ? (Qt(r) ? Re.PARTIAL : Re.OK) : Re.APPENDING) : Re.NOT_LOADED
  }
  isTimeBuffered(e, t, r) {
    let n, i
    for (let a = 0; a < r.length; a++) {
      if (
        ((n = r.start(a) - this.bufferPadding),
        (i = r.end(a) + this.bufferPadding),
        e >= n && t <= i)
      )
        return !0
      if (t <= n) return !1
    }
    return !1
  }
  onFragLoaded(e, t) {
    const { frag: r, part: n } = t
    if (r.sn === 'initSegment' || r.bitrateTest) return
    const i = n ? null : t,
      a = Lt(r)
    this.fragments[a] = {
      body: r,
      appendedPTS: null,
      loaded: i,
      buffered: !1,
      range: Object.create(null)
    }
  }
  onBufferAppended(e, t) {
    const { frag: r, part: n, timeRanges: i } = t
    if (r.sn === 'initSegment') return
    const a = r.type
    if (n) {
      let o = this.activePartLists[a]
      o || (this.activePartLists[a] = o = []), o.push(n)
    }
    ;(this.timeRanges = i),
      Object.keys(i).forEach((o) => {
        const l = i[o]
        this.detectEvictedFragments(o, l, a, n)
      })
  }
  onFragBuffered(e, t) {
    this.detectPartialFragments(t)
  }
  hasFragment(e) {
    const t = Lt(e)
    return !!this.fragments[t]
  }
  hasParts(e) {
    var t
    return !!((t = this.activePartLists[e]) != null && t.length)
  }
  removeFragmentsInRange(e, t, r, n, i) {
    ;(n && !this.hasGaps) ||
      Object.keys(this.fragments).forEach((a) => {
        const o = this.fragments[a]
        if (!o) return
        const l = o.body
        l.type !== r ||
          (n && !l.gap) ||
          (l.start < t && l.end > e && (o.buffered || i) && this.removeFragment(l))
      })
  }
  removeFragment(e) {
    const t = Lt(e)
    ;(e.stats.loaded = 0), e.clearElementaryStreamInfo()
    const r = this.activePartLists[e.type]
    if (r) {
      const n = e.sn
      this.activePartLists[e.type] = r.filter((i) => i.fragment.sn !== n)
    }
    delete this.fragments[t], e.endList && delete this.endListFragments[e.type]
  }
  removeAllFragments() {
    ;(this.fragments = Object.create(null)),
      (this.endListFragments = Object.create(null)),
      (this.activePartLists = Object.create(null)),
      (this.hasGaps = !1)
  }
}
function Qt(s) {
  var e, t, r
  return (
    s.buffered &&
    (s.body.gap ||
      ((e = s.range.video) == null ? void 0 : e.partial) ||
      ((t = s.range.audio) == null ? void 0 : t.partial) ||
      ((r = s.range.audiovideo) == null ? void 0 : r.partial))
  )
}
function Lt(s) {
  return `${s.type}_${s.level}_${s.urlId}_${s.sn}`
}
const Hi = Math.pow(2, 17)
class Ic {
  constructor(e) {
    ;(this.config = void 0), (this.loader = null), (this.partLoadTimeout = -1), (this.config = e)
  }
  destroy() {
    this.loader && (this.loader.destroy(), (this.loader = null))
  }
  abort() {
    this.loader && this.loader.abort()
  }
  load(e, t) {
    const r = e.url
    if (!r)
      return Promise.reject(
        new nt({
          type: ne.NETWORK_ERROR,
          details: K.FRAG_LOAD_ERROR,
          fatal: !1,
          frag: e,
          error: new Error(`Fragment does not have a ${r ? 'part list' : 'url'}`),
          networkDetails: null
        })
      )
    this.abort()
    const n = this.config,
      i = n.fLoader,
      a = n.loader
    return new Promise((o, l) => {
      if ((this.loader && this.loader.destroy(), e.gap))
        if (e.tagList.some((m) => m[0] === 'GAP')) {
          l(Yi(e))
          return
        } else e.gap = !1
      const u = (this.loader = e.loader = i ? new i(n) : new a(n)),
        c = Wi(e),
        f = ji(n.fragLoadPolicy.default),
        d = {
          loadPolicy: f,
          timeout: f.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: e.sn === 'initSegment' ? 1 / 0 : Hi
        }
      ;(e.stats = u.stats),
        u.load(c, d, {
          onSuccess: (m, p, v, E) => {
            this.resetLoader(e, u)
            let x = m.data
            v.resetIV &&
              e.decryptdata &&
              ((e.decryptdata.iv = new Uint8Array(x.slice(0, 16))), (x = x.slice(16))),
              o({ frag: e, part: null, payload: x, networkDetails: E })
          },
          onError: (m, p, v, E) => {
            this.resetLoader(e, u),
              l(
                new nt({
                  type: ne.NETWORK_ERROR,
                  details: K.FRAG_LOAD_ERROR,
                  fatal: !1,
                  frag: e,
                  response: Ve({ url: r, data: void 0 }, m),
                  error: new Error(`HTTP Error ${m.code} ${m.text}`),
                  networkDetails: v,
                  stats: E
                })
              )
          },
          onAbort: (m, p, v) => {
            this.resetLoader(e, u),
              l(
                new nt({
                  type: ne.NETWORK_ERROR,
                  details: K.INTERNAL_ABORTED,
                  fatal: !1,
                  frag: e,
                  error: new Error('Aborted'),
                  networkDetails: v,
                  stats: m
                })
              )
          },
          onTimeout: (m, p, v) => {
            this.resetLoader(e, u),
              l(
                new nt({
                  type: ne.NETWORK_ERROR,
                  details: K.FRAG_LOAD_TIMEOUT,
                  fatal: !1,
                  frag: e,
                  error: new Error(`Timeout after ${d.timeout}ms`),
                  networkDetails: v,
                  stats: m
                })
              )
          },
          onProgress: (m, p, v, E) => {
            t && t({ frag: e, part: null, payload: v, networkDetails: E })
          }
        })
    })
  }
  loadPart(e, t, r) {
    this.abort()
    const n = this.config,
      i = n.fLoader,
      a = n.loader
    return new Promise((o, l) => {
      if ((this.loader && this.loader.destroy(), e.gap || t.gap)) {
        l(Yi(e, t))
        return
      }
      const u = (this.loader = e.loader = i ? new i(n) : new a(n)),
        c = Wi(e, t),
        f = ji(n.fragLoadPolicy.default),
        d = {
          loadPolicy: f,
          timeout: f.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: Hi
        }
      ;(t.stats = u.stats),
        u.load(c, d, {
          onSuccess: (m, p, v, E) => {
            this.resetLoader(e, u), this.updateStatsFromPart(e, t)
            const x = { frag: e, part: t, payload: m.data, networkDetails: E }
            r(x), o(x)
          },
          onError: (m, p, v, E) => {
            this.resetLoader(e, u),
              l(
                new nt({
                  type: ne.NETWORK_ERROR,
                  details: K.FRAG_LOAD_ERROR,
                  fatal: !1,
                  frag: e,
                  part: t,
                  response: Ve({ url: c.url, data: void 0 }, m),
                  error: new Error(`HTTP Error ${m.code} ${m.text}`),
                  networkDetails: v,
                  stats: E
                })
              )
          },
          onAbort: (m, p, v) => {
            ;(e.stats.aborted = t.stats.aborted),
              this.resetLoader(e, u),
              l(
                new nt({
                  type: ne.NETWORK_ERROR,
                  details: K.INTERNAL_ABORTED,
                  fatal: !1,
                  frag: e,
                  part: t,
                  error: new Error('Aborted'),
                  networkDetails: v,
                  stats: m
                })
              )
          },
          onTimeout: (m, p, v) => {
            this.resetLoader(e, u),
              l(
                new nt({
                  type: ne.NETWORK_ERROR,
                  details: K.FRAG_LOAD_TIMEOUT,
                  fatal: !1,
                  frag: e,
                  part: t,
                  error: new Error(`Timeout after ${d.timeout}ms`),
                  networkDetails: v,
                  stats: m
                })
              )
          }
        })
    })
  }
  updateStatsFromPart(e, t) {
    const r = e.stats,
      n = t.stats,
      i = n.total
    if (((r.loaded += n.loaded), i)) {
      const l = Math.round(e.duration / t.duration),
        u = Math.min(Math.round(r.loaded / i), l),
        f = (l - u) * Math.round(r.loaded / u)
      r.total = r.loaded + f
    } else r.total = Math.max(r.loaded, r.total)
    const a = r.loading,
      o = n.loading
    a.start ? (a.first += o.first - o.start) : ((a.start = o.start), (a.first = o.first)),
      (a.end = o.end)
  }
  resetLoader(e, t) {
    ;(e.loader = null),
      this.loader === t && (self.clearTimeout(this.partLoadTimeout), (this.loader = null)),
      t.destroy()
  }
}
function Wi(s, e = null) {
  const t = e || s,
    r = {
      frag: s,
      part: e,
      responseType: 'arraybuffer',
      url: t.url,
      headers: {},
      rangeStart: 0,
      rangeEnd: 0
    },
    n = t.byteRangeStartOffset,
    i = t.byteRangeEndOffset
  if (J(n) && J(i)) {
    var a
    let o = n,
      l = i
    if (s.sn === 'initSegment' && ((a = s.decryptdata) == null ? void 0 : a.method) === 'AES-128') {
      const u = i - n
      u % 16 && (l = i + (16 - (u % 16))), n !== 0 && ((r.resetIV = !0), (o = n - 16))
    }
    ;(r.rangeStart = o), (r.rangeEnd = l)
  }
  return r
}
function Yi(s, e) {
  const t = new Error(`GAP ${s.gap ? 'tag' : 'attribute'} found`),
    r = {
      type: ne.MEDIA_ERROR,
      details: K.FRAG_GAP,
      fatal: !1,
      frag: s,
      error: t,
      networkDetails: null
    }
  return e && (r.part = e), ((e || s).stats.aborted = !0), new nt(r)
}
class nt extends Error {
  constructor(e) {
    super(e.error.message), (this.data = void 0), (this.data = e)
  }
}
class Pc {
  constructor(e) {
    ;(this.config = void 0),
      (this.keyUriToKeyInfo = {}),
      (this.emeController = null),
      (this.config = e)
  }
  abort(e) {
    for (const t in this.keyUriToKeyInfo) {
      const r = this.keyUriToKeyInfo[t].loader
      if (r) {
        if (e && e !== r.context.frag.type) return
        r.abort()
      }
    }
  }
  detach() {
    for (const e in this.keyUriToKeyInfo) {
      const t = this.keyUriToKeyInfo[e]
      ;(t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) &&
        delete this.keyUriToKeyInfo[e]
    }
  }
  destroy() {
    this.detach()
    for (const e in this.keyUriToKeyInfo) {
      const t = this.keyUriToKeyInfo[e].loader
      t && t.destroy()
    }
    this.keyUriToKeyInfo = {}
  }
  createKeyLoadError(e, t = K.KEY_LOAD_ERROR, r, n, i) {
    return new nt({
      type: ne.NETWORK_ERROR,
      details: t,
      fatal: !1,
      frag: e,
      response: i,
      error: r,
      networkDetails: n
    })
  }
  loadClear(e, t) {
    if (this.emeController && this.config.emeEnabled) {
      const { sn: r, cc: n } = e
      for (let i = 0; i < t.length; i++) {
        const a = t[i]
        if (n <= a.cc && (r === 'initSegment' || a.sn === 'initSegment' || r < a.sn)) {
          this.emeController.selectKeySystemFormat(a).then((o) => {
            a.setKeyFormat(o)
          })
          break
        }
      }
    }
  }
  load(e) {
    return !e.decryptdata && e.encrypted && this.emeController
      ? this.emeController.selectKeySystemFormat(e).then((t) => this.loadInternal(e, t))
      : this.loadInternal(e)
  }
  loadInternal(e, t) {
    var r, n
    t && e.setKeyFormat(t)
    const i = e.decryptdata
    if (!i) {
      const u = new Error(
        t
          ? `Expected frag.decryptdata to be defined after setting format ${t}`
          : 'Missing decryption data on fragment in onKeyLoading'
      )
      return Promise.reject(this.createKeyLoadError(e, K.KEY_LOAD_ERROR, u))
    }
    const a = i.uri
    if (!a)
      return Promise.reject(
        this.createKeyLoadError(e, K.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${a}"`))
      )
    let o = this.keyUriToKeyInfo[a]
    if ((r = o) != null && r.decryptdata.key)
      return (i.key = o.decryptdata.key), Promise.resolve({ frag: e, keyInfo: o })
    if ((n = o) != null && n.keyLoadPromise) {
      var l
      switch ((l = o.mediaKeySessionContext) == null ? void 0 : l.keyStatus) {
        case void 0:
        case 'status-pending':
        case 'usable':
        case 'usable-in-future':
          return o.keyLoadPromise.then(
            (u) => ((i.key = u.keyInfo.decryptdata.key), { frag: e, keyInfo: o })
          )
      }
    }
    switch (
      ((o = this.keyUriToKeyInfo[a] =
        { decryptdata: i, keyLoadPromise: null, loader: null, mediaKeySessionContext: null }),
      i.method)
    ) {
      case 'ISO-23001-7':
      case 'SAMPLE-AES':
      case 'SAMPLE-AES-CENC':
      case 'SAMPLE-AES-CTR':
        return i.keyFormat === 'identity' ? this.loadKeyHTTP(o, e) : this.loadKeyEME(o, e)
      case 'AES-128':
        return this.loadKeyHTTP(o, e)
      default:
        return Promise.reject(
          this.createKeyLoadError(
            e,
            K.KEY_LOAD_ERROR,
            new Error(`Key supplied with unsupported METHOD: "${i.method}"`)
          )
        )
    }
  }
  loadKeyEME(e, t) {
    const r = { frag: t, keyInfo: e }
    if (this.emeController && this.config.emeEnabled) {
      const n = this.emeController.loadKey(r)
      if (n)
        return (e.keyLoadPromise = n.then((i) => ((e.mediaKeySessionContext = i), r))).catch(
          (i) => {
            throw ((e.keyLoadPromise = null), i)
          }
        )
    }
    return Promise.resolve(r)
  }
  loadKeyHTTP(e, t) {
    const r = this.config,
      n = r.loader,
      i = new n(r)
    return (
      (t.keyLoader = e.loader = i),
      (e.keyLoadPromise = new Promise((a, o) => {
        const l = { keyInfo: e, frag: t, responseType: 'arraybuffer', url: e.decryptdata.uri },
          u = r.keyLoadPolicy.default,
          c = {
            loadPolicy: u,
            timeout: u.maxLoadTimeMs,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: 0
          },
          f = {
            onSuccess: (d, m, p, v) => {
              const { frag: E, keyInfo: x, url: T } = p
              if (!E.decryptdata || x !== this.keyUriToKeyInfo[T])
                return o(
                  this.createKeyLoadError(
                    E,
                    K.KEY_LOAD_ERROR,
                    new Error('after key load, decryptdata unset or changed'),
                    v
                  )
                )
              ;(x.decryptdata.key = E.decryptdata.key = new Uint8Array(d.data)),
                (E.keyLoader = null),
                (x.loader = null),
                a({ frag: E, keyInfo: x })
            },
            onError: (d, m, p, v) => {
              this.resetLoader(m),
                o(
                  this.createKeyLoadError(
                    t,
                    K.KEY_LOAD_ERROR,
                    new Error(`HTTP Error ${d.code} loading key ${d.text}`),
                    p,
                    Ve({ url: l.url, data: void 0 }, d)
                  )
                )
            },
            onTimeout: (d, m, p) => {
              this.resetLoader(m),
                o(
                  this.createKeyLoadError(
                    t,
                    K.KEY_LOAD_TIMEOUT,
                    new Error('key loading timed out'),
                    p
                  )
                )
            },
            onAbort: (d, m, p) => {
              this.resetLoader(m),
                o(
                  this.createKeyLoadError(
                    t,
                    K.INTERNAL_ABORTED,
                    new Error('key loading aborted'),
                    p
                  )
                )
            }
          }
        i.load(l, c, f)
      }))
    )
  }
  resetLoader(e) {
    const { frag: t, keyInfo: r, url: n } = e,
      i = r.loader
    t.keyLoader === i && ((t.keyLoader = null), (r.loader = null)),
      delete this.keyUriToKeyInfo[n],
      i && i.destroy()
  }
}
class Dc {
  constructor() {
    ;(this._boundTick = void 0),
      (this._tickTimer = null),
      (this._tickInterval = null),
      (this._tickCallCount = 0),
      (this._boundTick = this.tick.bind(this))
  }
  destroy() {
    this.onHandlerDestroying(), this.onHandlerDestroyed()
  }
  onHandlerDestroying() {
    this.clearNextTick(), this.clearInterval()
  }
  onHandlerDestroyed() {}
  hasInterval() {
    return !!this._tickInterval
  }
  hasNextTick() {
    return !!this._tickTimer
  }
  setInterval(e) {
    return this._tickInterval
      ? !1
      : ((this._tickCallCount = 0), (this._tickInterval = self.setInterval(this._boundTick, e)), !0)
  }
  clearInterval() {
    return this._tickInterval
      ? (self.clearInterval(this._tickInterval), (this._tickInterval = null), !0)
      : !1
  }
  clearNextTick() {
    return this._tickTimer ? (self.clearTimeout(this._tickTimer), (this._tickTimer = null), !0) : !1
  }
  tick() {
    this._tickCallCount++,
      this._tickCallCount === 1 &&
        (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), (this._tickCallCount = 0))
  }
  tickImmediate() {
    this.clearNextTick(), (this._tickTimer = self.setTimeout(this._boundTick, 0))
  }
  doTick() {}
}
const Oc = { length: 0, start: () => 0, end: () => 0 }
class ge {
  static isBuffered(e, t) {
    try {
      if (e) {
        const r = ge.getBuffered(e)
        for (let n = 0; n < r.length; n++) if (t >= r.start(n) && t <= r.end(n)) return !0
      }
    } catch {}
    return !1
  }
  static bufferInfo(e, t, r) {
    try {
      if (e) {
        const n = ge.getBuffered(e),
          i = []
        let a
        for (a = 0; a < n.length; a++) i.push({ start: n.start(a), end: n.end(a) })
        return this.bufferedInfo(i, t, r)
      }
    } catch {}
    return { len: 0, start: t, end: t, nextStart: void 0 }
  }
  static bufferedInfo(e, t, r) {
    ;(t = Math.max(0, t)),
      e.sort(function (u, c) {
        const f = u.start - c.start
        return f || c.end - u.end
      })
    let n = []
    if (r)
      for (let u = 0; u < e.length; u++) {
        const c = n.length
        if (c) {
          const f = n[c - 1].end
          e[u].start - f < r ? e[u].end > f && (n[c - 1].end = e[u].end) : n.push(e[u])
        } else n.push(e[u])
      }
    else n = e
    let i = 0,
      a,
      o = t,
      l = t
    for (let u = 0; u < n.length; u++) {
      const c = n[u].start,
        f = n[u].end
      if (t + r >= c && t < f) (o = c), (l = f), (i = l - t)
      else if (t + r < c) {
        a = c
        break
      }
    }
    return { len: i, start: o || 0, end: l || 0, nextStart: a }
  }
  static getBuffered(e) {
    try {
      return e.buffered
    } catch (t) {
      return G.log('failed to get media.buffered', t), Oc
    }
  }
}
class Nn {
  constructor(e, t, r, n = 0, i = -1, a = !1) {
    ;(this.level = void 0),
      (this.sn = void 0),
      (this.part = void 0),
      (this.id = void 0),
      (this.size = void 0),
      (this.partial = void 0),
      (this.transmuxing = Zt()),
      (this.buffering = { audio: Zt(), video: Zt(), audiovideo: Zt() }),
      (this.level = e),
      (this.sn = t),
      (this.id = r),
      (this.size = n),
      (this.part = i),
      (this.partial = a)
  }
}
function Zt() {
  return { start: 0, executeStart: 0, executeEnd: 0, end: 0 }
}
function fa(s, e) {
  let t = null
  for (let r = 0, n = s.length; r < n; r++) {
    const i = s[r]
    if (i && i.cc === e) {
      t = i
      break
    }
  }
  return t
}
function wc(s, e, t) {
  return !!(e.details && (t.endCC > t.startCC || (s && s.cc < t.startCC)))
}
function Cc(s, e, t = 0) {
  const r = s.fragments,
    n = e.fragments
  if (!n.length || !r.length) {
    G.log('No fragments to align')
    return
  }
  const i = fa(r, n[0].cc)
  if (!i || (i && !i.startPTS)) {
    G.log('No frag in previous level to align on')
    return
  }
  return i
}
function zi(s, e) {
  if (s) {
    const t = s.start + e
    ;(s.start = s.startPTS = t), (s.endPTS = t + s.duration)
  }
}
function Un(s, e) {
  const t = e.fragments
  for (let r = 0, n = t.length; r < n; r++) zi(t[r], s)
  e.fragmentHint && zi(e.fragmentHint, s), (e.alignedSliding = !0)
}
function kc(s, e, t) {
  e &&
    (Mc(s, t, e),
    !t.alignedSliding && e.details && Fc(t, e.details),
    !t.alignedSliding && e.details && !t.skippedSegments && la(e.details, t))
}
function Mc(s, e, t) {
  if (wc(s, t, e)) {
    const r = Cc(t.details, e)
    r &&
      J(r.start) &&
      (G.log(`Adjusting PTS using last level due to CC increase within current level ${e.url}`),
      Un(r.start, e))
  }
}
function Fc(s, e) {
  if (!e.fragments.length || !s.hasProgramDateTime || !e.hasProgramDateTime) return
  const t = e.fragments[0].programDateTime,
    r = s.fragments[0].programDateTime,
    n = (r - t) / 1e3 + e.fragments[0].start
  n &&
    J(n) &&
    (G.log(
      `Adjusting PTS using programDateTime delta ${r - t}ms, sliding:${n.toFixed(3)} ${s.url} `
    ),
    Un(n, s))
}
function da(s, e) {
  if (!s.hasProgramDateTime || !e.hasProgramDateTime) return
  const t = s.fragments,
    r = e.fragments
  if (!t.length || !r.length) return
  const n = Math.round(r.length / 2) - 1,
    i = r[n],
    a = fa(t, i.cc) || t[Math.round(t.length / 2) - 1],
    o = i.programDateTime,
    l = a.programDateTime
  if (o === null || l === null) return
  const u = (l - o) / 1e3 - (a.start - i.start)
  Un(u, s)
}
class Nc {
  constructor(e, t) {
    ;(this.subtle = void 0), (this.aesIV = void 0), (this.subtle = e), (this.aesIV = t)
  }
  decrypt(e, t) {
    return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, t, e)
  }
}
class Uc {
  constructor(e, t) {
    ;(this.subtle = void 0), (this.key = void 0), (this.subtle = e), (this.key = t)
  }
  expandKey() {
    return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, !1, ['encrypt', 'decrypt'])
  }
}
function Bc(s) {
  const e = s.byteLength,
    t = e && new DataView(s.buffer).getUint8(e - 1)
  return t ? gt(s, 0, e - t) : s
}
class Gc {
  constructor() {
    ;(this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]),
      (this.subMix = [
        new Uint32Array(256),
        new Uint32Array(256),
        new Uint32Array(256),
        new Uint32Array(256)
      ]),
      (this.invSubMix = [
        new Uint32Array(256),
        new Uint32Array(256),
        new Uint32Array(256),
        new Uint32Array(256)
      ]),
      (this.sBox = new Uint32Array(256)),
      (this.invSBox = new Uint32Array(256)),
      (this.key = new Uint32Array(0)),
      (this.ksRows = 0),
      (this.keySize = 0),
      (this.keySchedule = void 0),
      (this.invKeySchedule = void 0),
      this.initTable()
  }
  uint8ArrayToUint32Array_(e) {
    const t = new DataView(e),
      r = new Uint32Array(4)
    for (let n = 0; n < 4; n++) r[n] = t.getUint32(n * 4)
    return r
  }
  initTable() {
    const e = this.sBox,
      t = this.invSBox,
      r = this.subMix,
      n = r[0],
      i = r[1],
      a = r[2],
      o = r[3],
      l = this.invSubMix,
      u = l[0],
      c = l[1],
      f = l[2],
      d = l[3],
      m = new Uint32Array(256)
    let p = 0,
      v = 0,
      E = 0
    for (E = 0; E < 256; E++) E < 128 ? (m[E] = E << 1) : (m[E] = (E << 1) ^ 283)
    for (E = 0; E < 256; E++) {
      let x = v ^ (v << 1) ^ (v << 2) ^ (v << 3) ^ (v << 4)
      ;(x = (x >>> 8) ^ (x & 255) ^ 99), (e[p] = x), (t[x] = p)
      const T = m[p],
        b = m[T],
        R = m[b]
      let g = (m[x] * 257) ^ (x * 16843008)
      ;(n[p] = (g << 24) | (g >>> 8)),
        (i[p] = (g << 16) | (g >>> 16)),
        (a[p] = (g << 8) | (g >>> 24)),
        (o[p] = g),
        (g = (R * 16843009) ^ (b * 65537) ^ (T * 257) ^ (p * 16843008)),
        (u[x] = (g << 24) | (g >>> 8)),
        (c[x] = (g << 16) | (g >>> 16)),
        (f[x] = (g << 8) | (g >>> 24)),
        (d[x] = g),
        p ? ((p = T ^ m[m[m[R ^ T]]]), (v ^= m[m[v]])) : (p = v = 1)
    }
  }
  expandKey(e) {
    const t = this.uint8ArrayToUint32Array_(e)
    let r = !0,
      n = 0
    for (; n < t.length && r; ) (r = t[n] === this.key[n]), n++
    if (r) return
    this.key = t
    const i = (this.keySize = t.length)
    if (i !== 4 && i !== 6 && i !== 8) throw new Error('Invalid aes key size=' + i)
    const a = (this.ksRows = (i + 6 + 1) * 4)
    let o, l
    const u = (this.keySchedule = new Uint32Array(a)),
      c = (this.invKeySchedule = new Uint32Array(a)),
      f = this.sBox,
      d = this.rcon,
      m = this.invSubMix,
      p = m[0],
      v = m[1],
      E = m[2],
      x = m[3]
    let T, b
    for (o = 0; o < a; o++) {
      if (o < i) {
        T = u[o] = t[o]
        continue
      }
      ;(b = T),
        o % i === 0
          ? ((b = (b << 8) | (b >>> 24)),
            (b =
              (f[b >>> 24] << 24) |
              (f[(b >>> 16) & 255] << 16) |
              (f[(b >>> 8) & 255] << 8) |
              f[b & 255]),
            (b ^= d[(o / i) | 0] << 24))
          : i > 6 &&
            o % i === 4 &&
            (b =
              (f[b >>> 24] << 24) |
              (f[(b >>> 16) & 255] << 16) |
              (f[(b >>> 8) & 255] << 8) |
              f[b & 255]),
        (u[o] = T = (u[o - i] ^ b) >>> 0)
    }
    for (l = 0; l < a; l++)
      (o = a - l),
        l & 3 ? (b = u[o]) : (b = u[o - 4]),
        l < 4 || o <= 4
          ? (c[l] = b)
          : (c[l] =
              p[f[b >>> 24]] ^ v[f[(b >>> 16) & 255]] ^ E[f[(b >>> 8) & 255]] ^ x[f[b & 255]]),
        (c[l] = c[l] >>> 0)
  }
  networkToHostOrderSwap(e) {
    return (e << 24) | ((e & 65280) << 8) | ((e & 16711680) >> 8) | (e >>> 24)
  }
  decrypt(e, t, r) {
    const n = this.keySize + 6,
      i = this.invKeySchedule,
      a = this.invSBox,
      o = this.invSubMix,
      l = o[0],
      u = o[1],
      c = o[2],
      f = o[3],
      d = this.uint8ArrayToUint32Array_(r)
    let m = d[0],
      p = d[1],
      v = d[2],
      E = d[3]
    const x = new Int32Array(e),
      T = new Int32Array(x.length)
    let b, R, g, A, S, h, _, y, L, I, P, D, C, N
    const M = this.networkToHostOrderSwap
    for (; t < x.length; ) {
      for (
        L = M(x[t]),
          I = M(x[t + 1]),
          P = M(x[t + 2]),
          D = M(x[t + 3]),
          S = L ^ i[0],
          h = D ^ i[1],
          _ = P ^ i[2],
          y = I ^ i[3],
          C = 4,
          N = 1;
        N < n;
        N++
      )
        (b = l[S >>> 24] ^ u[(h >> 16) & 255] ^ c[(_ >> 8) & 255] ^ f[y & 255] ^ i[C]),
          (R = l[h >>> 24] ^ u[(_ >> 16) & 255] ^ c[(y >> 8) & 255] ^ f[S & 255] ^ i[C + 1]),
          (g = l[_ >>> 24] ^ u[(y >> 16) & 255] ^ c[(S >> 8) & 255] ^ f[h & 255] ^ i[C + 2]),
          (A = l[y >>> 24] ^ u[(S >> 16) & 255] ^ c[(h >> 8) & 255] ^ f[_ & 255] ^ i[C + 3]),
          (S = b),
          (h = R),
          (_ = g),
          (y = A),
          (C = C + 4)
      ;(b =
        (a[S >>> 24] << 24) ^
        (a[(h >> 16) & 255] << 16) ^
        (a[(_ >> 8) & 255] << 8) ^
        a[y & 255] ^
        i[C]),
        (R =
          (a[h >>> 24] << 24) ^
          (a[(_ >> 16) & 255] << 16) ^
          (a[(y >> 8) & 255] << 8) ^
          a[S & 255] ^
          i[C + 1]),
        (g =
          (a[_ >>> 24] << 24) ^
          (a[(y >> 16) & 255] << 16) ^
          (a[(S >> 8) & 255] << 8) ^
          a[h & 255] ^
          i[C + 2]),
        (A =
          (a[y >>> 24] << 24) ^
          (a[(S >> 16) & 255] << 16) ^
          (a[(h >> 8) & 255] << 8) ^
          a[_ & 255] ^
          i[C + 3]),
        (T[t] = M(b ^ m)),
        (T[t + 1] = M(A ^ p)),
        (T[t + 2] = M(g ^ v)),
        (T[t + 3] = M(R ^ E)),
        (m = L),
        (p = I),
        (v = P),
        (E = D),
        (t = t + 4)
    }
    return T.buffer
  }
}
const $c = 16
class Bn {
  constructor(e, { removePKCS7Padding: t = !0 } = {}) {
    if (
      ((this.logEnabled = !0),
      (this.removePKCS7Padding = void 0),
      (this.subtle = null),
      (this.softwareDecrypter = null),
      (this.key = null),
      (this.fastAesKey = null),
      (this.remainderData = null),
      (this.currentIV = null),
      (this.currentResult = null),
      (this.useSoftware = void 0),
      (this.useSoftware = e.enableSoftwareAES),
      (this.removePKCS7Padding = t),
      t)
    )
      try {
        const r = self.crypto
        r && (this.subtle = r.subtle || r.webkitSubtle)
      } catch {}
    this.subtle === null && (this.useSoftware = !0)
  }
  destroy() {
    ;(this.subtle = null),
      (this.softwareDecrypter = null),
      (this.key = null),
      (this.fastAesKey = null),
      (this.remainderData = null),
      (this.currentIV = null),
      (this.currentResult = null)
  }
  isSync() {
    return this.useSoftware
  }
  flush() {
    const { currentResult: e, remainderData: t } = this
    if (!e || t) return this.reset(), null
    const r = new Uint8Array(e)
    return this.reset(), this.removePKCS7Padding ? Bc(r) : r
  }
  reset() {
    ;(this.currentResult = null),
      (this.currentIV = null),
      (this.remainderData = null),
      this.softwareDecrypter && (this.softwareDecrypter = null)
  }
  decrypt(e, t, r) {
    return this.useSoftware
      ? new Promise((n, i) => {
          this.softwareDecrypt(new Uint8Array(e), t, r)
          const a = this.flush()
          a ? n(a.buffer) : i(new Error('[softwareDecrypt] Failed to decrypt data'))
        })
      : this.webCryptoDecrypt(new Uint8Array(e), t, r)
  }
  softwareDecrypt(e, t, r) {
    const { currentIV: n, currentResult: i, remainderData: a } = this
    this.logOnce('JS AES decrypt'), a && ((e = vt(a, e)), (this.remainderData = null))
    const o = this.getValidChunk(e)
    if (!o.length) return null
    n && (r = n)
    let l = this.softwareDecrypter
    l || (l = this.softwareDecrypter = new Gc()), l.expandKey(t)
    const u = i
    return (
      (this.currentResult = l.decrypt(o.buffer, 0, r)),
      (this.currentIV = gt(o, -16).buffer),
      u || null
    )
  }
  webCryptoDecrypt(e, t, r) {
    const n = this.subtle
    return (
      (this.key !== t || !this.fastAesKey) && ((this.key = t), (this.fastAesKey = new Uc(n, t))),
      this.fastAesKey
        .expandKey()
        .then((i) =>
          n
            ? (this.logOnce('WebCrypto AES decrypt'),
              new Nc(n, new Uint8Array(r)).decrypt(e.buffer, i))
            : Promise.reject(new Error('web crypto not initialized'))
        )
        .catch(
          (i) => (
            G.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${i.name}: ${i.message}`),
            this.onWebCryptoError(e, t, r)
          )
        )
    )
  }
  onWebCryptoError(e, t, r) {
    ;(this.useSoftware = !0), (this.logEnabled = !0), this.softwareDecrypt(e, t, r)
    const n = this.flush()
    if (n) return n.buffer
    throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data')
  }
  getValidChunk(e) {
    let t = e
    const r = e.length - (e.length % $c)
    return r !== e.length && ((t = gt(e, 0, r)), (this.remainderData = gt(e, r))), t
  }
  logOnce(e) {
    this.logEnabled && (G.log(`[decrypter]: ${e}`), (this.logEnabled = !1))
  }
}
const Kc = {
    toString: function (s) {
      let e = ''
      const t = s.length
      for (let r = 0; r < t; r++) e += `[${s.start(r).toFixed(3)}-${s.end(r).toFixed(3)}]`
      return e
    }
  },
  W = {
    STOPPED: 'STOPPED',
    IDLE: 'IDLE',
    KEY_LOADING: 'KEY_LOADING',
    FRAG_LOADING: 'FRAG_LOADING',
    FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
    WAITING_TRACK: 'WAITING_TRACK',
    PARSING: 'PARSING',
    PARSED: 'PARSED',
    ENDED: 'ENDED',
    ERROR: 'ERROR',
    WAITING_INIT_PTS: 'WAITING_INIT_PTS',
    WAITING_LEVEL: 'WAITING_LEVEL'
  }
class Gn extends Dc {
  constructor(e, t, r, n, i) {
    super(),
      (this.hls = void 0),
      (this.fragPrevious = null),
      (this.fragCurrent = null),
      (this.fragmentTracker = void 0),
      (this.transmuxer = null),
      (this._state = W.STOPPED),
      (this.playlistType = void 0),
      (this.media = null),
      (this.mediaBuffer = null),
      (this.config = void 0),
      (this.bitrateTest = !1),
      (this.lastCurrentTime = 0),
      (this.nextLoadPosition = 0),
      (this.startPosition = 0),
      (this.startTimeOffset = null),
      (this.loadedmetadata = !1),
      (this.retryDate = 0),
      (this.levels = null),
      (this.fragmentLoader = void 0),
      (this.keyLoader = void 0),
      (this.levelLastLoaded = null),
      (this.startFragRequested = !1),
      (this.decrypter = void 0),
      (this.initPTS = []),
      (this.onvseeking = null),
      (this.onvended = null),
      (this.logPrefix = ''),
      (this.log = void 0),
      (this.warn = void 0),
      (this.playlistType = i),
      (this.logPrefix = n),
      (this.log = G.log.bind(G, `${n}:`)),
      (this.warn = G.warn.bind(G, `${n}:`)),
      (this.hls = e),
      (this.fragmentLoader = new Ic(e.config)),
      (this.keyLoader = r),
      (this.fragmentTracker = t),
      (this.config = e.config),
      (this.decrypter = new Bn(e.config)),
      e.on(O.MANIFEST_LOADED, this.onManifestLoaded, this)
  }
  doTick() {
    this.onTickEnd()
  }
  onTickEnd() {}
  startLoad(e) {}
  stopLoad() {
    this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType)
    const e = this.fragCurrent
    e != null && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)),
      this.resetTransmuxer(),
      (this.fragCurrent = null),
      (this.fragPrevious = null),
      this.clearInterval(),
      this.clearNextTick(),
      (this.state = W.STOPPED)
  }
  _streamEnded(e, t) {
    if (t.live || e.nextStart || !e.end || !this.media) return !1
    const r = t.partList
    if (r != null && r.length) {
      const i = r[r.length - 1]
      return ge.isBuffered(this.media, i.start + i.duration / 2)
    }
    const n = t.fragments[t.fragments.length - 1].type
    return this.fragmentTracker.isEndListAppended(n)
  }
  getLevelDetails() {
    if (this.levels && this.levelLastLoaded !== null) {
      var e
      return (e = this.levels[this.levelLastLoaded]) == null ? void 0 : e.details
    }
  }
  onMediaAttached(e, t) {
    const r = (this.media = this.mediaBuffer = t.media)
    ;(this.onvseeking = this.onMediaSeeking.bind(this)),
      (this.onvended = this.onMediaEnded.bind(this)),
      r.addEventListener('seeking', this.onvseeking),
      r.addEventListener('ended', this.onvended)
    const n = this.config
    this.levels && n.autoStartLoad && this.state === W.STOPPED && this.startLoad(n.startPosition)
  }
  onMediaDetaching() {
    const e = this.media
    e != null &&
      e.ended &&
      (this.log('MSE detaching and video ended, reset startPosition'),
      (this.startPosition = this.lastCurrentTime = 0)),
      e &&
        this.onvseeking &&
        this.onvended &&
        (e.removeEventListener('seeking', this.onvseeking),
        e.removeEventListener('ended', this.onvended),
        (this.onvseeking = this.onvended = null)),
      this.keyLoader && this.keyLoader.detach(),
      (this.media = this.mediaBuffer = null),
      (this.loadedmetadata = !1),
      this.fragmentTracker.removeAllFragments(),
      this.stopLoad()
  }
  onMediaSeeking() {
    const { config: e, fragCurrent: t, media: r, mediaBuffer: n, state: i } = this,
      a = r ? r.currentTime : 0,
      o = ge.bufferInfo(n || r, a, e.maxBufferHole)
    if (
      (this.log(`media seeking to ${J(a) ? a.toFixed(3) : a}, state: ${i}`), this.state === W.ENDED)
    )
      this.resetLoadingState()
    else if (t) {
      const l = e.maxFragLookUpTolerance,
        u = t.start - l,
        c = t.start + t.duration + l
      if (!o.len || c < o.start || u > o.end) {
        const f = a > c
        ;(a < u || f) &&
          (f &&
            t.loader &&
            (this.log(
              'seeking outside of buffer while fragment load in progress, cancel fragment load'
            ),
            t.abortRequests(),
            this.resetLoadingState()),
          (this.fragPrevious = null))
      }
    }
    r &&
      (this.fragmentTracker.removeFragmentsInRange(a, 1 / 0, this.playlistType, !0),
      (this.lastCurrentTime = a)),
      !this.loadedmetadata && !o.len && (this.nextLoadPosition = this.startPosition = a),
      this.tickImmediate()
  }
  onMediaEnded() {
    this.startPosition = this.lastCurrentTime = 0
  }
  onManifestLoaded(e, t) {
    ;(this.startTimeOffset = t.startTimeOffset), (this.initPTS = [])
  }
  onHandlerDestroying() {
    this.stopLoad(), super.onHandlerDestroying()
  }
  onHandlerDestroyed() {
    ;(this.state = W.STOPPED),
      this.fragmentLoader && this.fragmentLoader.destroy(),
      this.keyLoader && this.keyLoader.destroy(),
      this.decrypter && this.decrypter.destroy(),
      (this.hls =
        this.log =
        this.warn =
        this.decrypter =
        this.keyLoader =
        this.fragmentLoader =
        this.fragmentTracker =
          null),
      super.onHandlerDestroyed()
  }
  loadFragment(e, t, r) {
    this._loadFragForPlayback(e, t, r)
  }
  _loadFragForPlayback(e, t, r) {
    const n = (i) => {
      if (this.fragContextChanged(e)) {
        this.warn(
          `Fragment ${e.sn}${i.part ? ' p: ' + i.part.index : ''} of level ${
            e.level
          } was dropped during download.`
        ),
          this.fragmentTracker.removeFragment(e)
        return
      }
      e.stats.chunkCount++, this._handleFragmentLoadProgress(i)
    }
    this._doFragLoad(e, t, r, n)
      .then((i) => {
        if (!i) return
        const a = this.state
        if (this.fragContextChanged(e)) {
          ;(a === W.FRAG_LOADING || (!this.fragCurrent && a === W.PARSING)) &&
            (this.fragmentTracker.removeFragment(e), (this.state = W.IDLE))
          return
        }
        'payload' in i &&
          (this.log(`Loaded fragment ${e.sn} of level ${e.level}`),
          this.hls.trigger(O.FRAG_LOADED, i)),
          this._handleFragmentLoadComplete(i)
      })
      .catch((i) => {
        this.state === W.STOPPED ||
          this.state === W.ERROR ||
          (this.warn(i), this.resetFragmentLoading(e))
      })
  }
  clearTrackerIfNeeded(e) {
    var t
    const { fragmentTracker: r } = this
    if (r.getState(e) === Re.APPENDING) {
      const i = e.type,
        a = this.getFwdBufferInfo(this.mediaBuffer, i),
        o = Math.max(e.duration, a ? a.len : this.config.maxBufferLength)
      this.reduceMaxBufferLength(o) && r.removeFragment(e)
    } else
      ((t = this.mediaBuffer) == null ? void 0 : t.buffered.length) === 0
        ? r.removeAllFragments()
        : r.hasParts(e.type) &&
          (r.detectPartialFragments({ frag: e, part: null, stats: e.stats, id: e.type }),
          r.getState(e) === Re.PARTIAL && r.removeFragment(e))
  }
  checkLiveUpdate(e) {
    if (e.updated && !e.live) {
      const t = e.fragments[e.fragments.length - 1]
      this.fragmentTracker.detectPartialFragments({
        frag: t,
        part: null,
        stats: t.stats,
        id: t.type
      })
    }
    e.fragments[0] || (e.deltaUpdateFailed = !0)
  }
  flushMainBuffer(e, t, r = null) {
    if (!(e - t)) return
    const n = { startOffset: e, endOffset: t, type: r }
    this.hls.trigger(O.BUFFER_FLUSHING, n)
  }
  _loadInitSegment(e, t) {
    this._doFragLoad(e, t)
      .then((r) => {
        if (!r || this.fragContextChanged(e) || !this.levels) throw new Error('init load aborted')
        return r
      })
      .then((r) => {
        const { hls: n } = this,
          { payload: i } = r,
          a = e.decryptdata
        if (i && i.byteLength > 0 && a && a.key && a.iv && a.method === 'AES-128') {
          const o = self.performance.now()
          return this.decrypter
            .decrypt(new Uint8Array(i), a.key.buffer, a.iv.buffer)
            .catch((l) => {
              throw (
                (n.trigger(O.ERROR, {
                  type: ne.MEDIA_ERROR,
                  details: K.FRAG_DECRYPT_ERROR,
                  fatal: !1,
                  error: l,
                  reason: l.message,
                  frag: e
                }),
                l)
              )
            })
            .then((l) => {
              const u = self.performance.now()
              return (
                n.trigger(O.FRAG_DECRYPTED, {
                  frag: e,
                  payload: l,
                  stats: { tstart: o, tdecrypt: u }
                }),
                (r.payload = l),
                r
              )
            })
        }
        return r
      })
      .then((r) => {
        const { fragCurrent: n, hls: i, levels: a } = this
        if (!a) throw new Error('init load aborted, missing levels')
        const o = e.stats
        ;(this.state = W.IDLE),
          (t.fragmentError = 0),
          (e.data = new Uint8Array(r.payload)),
          (o.parsing.start = o.buffering.start = self.performance.now()),
          (o.parsing.end = o.buffering.end = self.performance.now()),
          r.frag === n && i.trigger(O.FRAG_BUFFERED, { stats: o, frag: n, part: null, id: e.type }),
          this.tick()
      })
      .catch((r) => {
        this.state === W.STOPPED ||
          this.state === W.ERROR ||
          (this.warn(r), this.resetFragmentLoading(e))
      })
  }
  fragContextChanged(e) {
    const { fragCurrent: t } = this
    return !e || !t || e.level !== t.level || e.sn !== t.sn || e.urlId !== t.urlId
  }
  fragBufferedComplete(e, t) {
    var r, n, i, a
    const o = this.mediaBuffer ? this.mediaBuffer : this.media
    this.log(
      `Buffered ${e.type} sn: ${e.sn}${t ? ' part: ' + t.index : ''} of ${
        this.playlistType === ie.MAIN ? 'level' : 'track'
      } ${e.level} (frag:[${((r = e.startPTS) != null ? r : NaN).toFixed(3)}-${((n = e.endPTS) !=
      null
        ? n
        : NaN
      ).toFixed(3)}] > buffer:${o ? Kc.toString(ge.getBuffered(o)) : '(detached)'})`
    ),
      (this.state = W.IDLE),
      o &&
        (!this.loadedmetadata &&
          e.type == ie.MAIN &&
          o.buffered.length &&
          ((i = this.fragCurrent) == null ? void 0 : i.sn) ===
            ((a = this.fragPrevious) == null ? void 0 : a.sn) &&
          ((this.loadedmetadata = !0), this.seekToStartPos()),
        this.tick())
  }
  seekToStartPos() {}
  _handleFragmentLoadComplete(e) {
    const { transmuxer: t } = this
    if (!t) return
    const { frag: r, part: n, partsLoaded: i } = e,
      a = !i || i.length === 0 || i.some((l) => !l),
      o = new Nn(r.level, r.sn, r.stats.chunkCount + 1, 0, n ? n.index : -1, !a)
    t.flush(o)
  }
  _handleFragmentLoadProgress(e) {}
  _doFragLoad(e, t, r = null, n) {
    var i
    const a = t == null ? void 0 : t.details
    if (!this.levels || !a)
      throw new Error(`frag load aborted, missing level${a ? '' : ' detail'}s`)
    let o = null
    if (
      (e.encrypted && !((i = e.decryptdata) != null && i.key)
        ? (this.log(
            `Loading key for ${e.sn} of [${a.startSN}-${a.endSN}], ${
              this.logPrefix === '[stream-controller]' ? 'level' : 'track'
            } ${e.level}`
          ),
          (this.state = W.KEY_LOADING),
          (this.fragCurrent = e),
          (o = this.keyLoader.load(e).then((c) => {
            if (!this.fragContextChanged(c.frag))
              return (
                this.hls.trigger(O.KEY_LOADED, c),
                this.state === W.KEY_LOADING && (this.state = W.IDLE),
                c
              )
          })),
          this.hls.trigger(O.KEY_LOADING, { frag: e }),
          this.fragCurrent === null &&
            (o = Promise.reject(new Error('frag load aborted, context changed in KEY_LOADING'))))
        : !e.encrypted &&
          a.encryptedFragments.length &&
          this.keyLoader.loadClear(e, a.encryptedFragments),
      (r = Math.max(e.start, r || 0)),
      this.config.lowLatencyMode && e.sn !== 'initSegment')
    ) {
      const c = a.partList
      if (c && n) {
        r > e.end && a.fragmentHint && (e = a.fragmentHint)
        const f = this.getNextPart(c, e, r)
        if (f > -1) {
          const d = c[f]
          this.log(
            `Loading part sn: ${e.sn} p: ${d.index} cc: ${e.cc} of playlist [${a.startSN}-${
              a.endSN
            }] parts [0-${f}-${c.length - 1}] ${
              this.logPrefix === '[stream-controller]' ? 'level' : 'track'
            }: ${e.level}, target: ${parseFloat(r.toFixed(3))}`
          ),
            (this.nextLoadPosition = d.start + d.duration),
            (this.state = W.FRAG_LOADING)
          let m
          return (
            o
              ? (m = o
                  .then((p) =>
                    !p || this.fragContextChanged(p.frag) ? null : this.doFragPartsLoad(e, d, t, n)
                  )
                  .catch((p) => this.handleFragLoadError(p)))
              : (m = this.doFragPartsLoad(e, d, t, n).catch((p) => this.handleFragLoadError(p))),
            this.hls.trigger(O.FRAG_LOADING, { frag: e, part: d, targetBufferTime: r }),
            this.fragCurrent === null
              ? Promise.reject(
                  new Error('frag load aborted, context changed in FRAG_LOADING parts')
                )
              : m
          )
        } else if (!e.url || this.loadedEndOfParts(c, r)) return Promise.resolve(null)
      }
    }
    this.log(
      `Loading fragment ${e.sn} cc: ${e.cc} ${a ? 'of [' + a.startSN + '-' + a.endSN + '] ' : ''}${
        this.logPrefix === '[stream-controller]' ? 'level' : 'track'
      }: ${e.level}, target: ${parseFloat(r.toFixed(3))}`
    ),
      J(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration),
      (this.state = W.FRAG_LOADING)
    const l = this.config.progressive
    let u
    return (
      l && o
        ? (u = o
            .then((c) =>
              !c || this.fragContextChanged(c == null ? void 0 : c.frag)
                ? null
                : this.fragmentLoader.load(e, n)
            )
            .catch((c) => this.handleFragLoadError(c)))
        : (u = Promise.all([this.fragmentLoader.load(e, l ? n : void 0), o])
            .then(([c]) => (!l && c && n && n(c), c))
            .catch((c) => this.handleFragLoadError(c))),
      this.hls.trigger(O.FRAG_LOADING, { frag: e, targetBufferTime: r }),
      this.fragCurrent === null
        ? Promise.reject(new Error('frag load aborted, context changed in FRAG_LOADING'))
        : u
    )
  }
  doFragPartsLoad(e, t, r, n) {
    return new Promise((i, a) => {
      var o
      const l = [],
        u = (o = r.details) == null ? void 0 : o.partList,
        c = (f) => {
          this.fragmentLoader
            .loadPart(e, f, n)
            .then((d) => {
              l[f.index] = d
              const m = d.part
              this.hls.trigger(O.FRAG_LOADED, d)
              const p = $i(r, e.sn, f.index + 1) || ua(u, e.sn, f.index + 1)
              if (p) c(p)
              else return i({ frag: e, part: m, partsLoaded: l })
            })
            .catch(a)
        }
      c(t)
    })
  }
  handleFragLoadError(e) {
    if ('data' in e) {
      const t = e.data
      e.data && t.details === K.INTERNAL_ABORTED
        ? this.handleFragLoadAborted(t.frag, t.part)
        : this.hls.trigger(O.ERROR, t)
    } else
      this.hls.trigger(O.ERROR, {
        type: ne.OTHER_ERROR,
        details: K.INTERNAL_EXCEPTION,
        err: e,
        error: e,
        fatal: !0
      })
    return null
  }
  _handleTransmuxerFlush(e) {
    const t = this.getCurrentContext(e)
    if (!t || this.state !== W.PARSING) {
      !this.fragCurrent &&
        this.state !== W.STOPPED &&
        this.state !== W.ERROR &&
        (this.state = W.IDLE)
      return
    }
    const { frag: r, part: n, level: i } = t,
      a = self.performance.now()
    ;(r.stats.parsing.end = a),
      n && (n.stats.parsing.end = a),
      this.updateLevelTiming(r, n, i, e.partial)
  }
  getCurrentContext(e) {
    const { levels: t, fragCurrent: r } = this,
      { level: n, sn: i, part: a } = e
    if (!(t != null && t[n]))
      return (
        this.warn(
          `Levels object was unset while buffering fragment ${i} of level ${n}. The current chunk will not be buffered.`
        ),
        null
      )
    const o = t[n],
      l = a > -1 ? $i(o, i, a) : null,
      u = l ? l.fragment : vc(o, i, r)
    return u ? (r && r !== u && (u.stats = r.stats), { frag: u, part: l, level: o }) : null
  }
  bufferFragmentData(e, t, r, n, i) {
    var a
    if (!e || this.state !== W.PARSING) return
    const { data1: o, data2: l } = e
    let u = o
    if ((o && l && (u = vt(o, l)), !((a = u) != null && a.length))) return
    const c = { type: e.type, frag: t, part: r, chunkMeta: n, parent: t.type, data: u }
    if ((this.hls.trigger(O.BUFFER_APPENDING, c), e.dropped && e.independent && !r)) {
      if (i) return
      this.flushBufferGap(t)
    }
  }
  flushBufferGap(e) {
    const t = this.media
    if (!t) return
    if (!ge.isBuffered(t, t.currentTime)) {
      this.flushMainBuffer(0, e.start)
      return
    }
    const r = t.currentTime,
      n = ge.bufferInfo(t, r, 0),
      i = e.duration,
      a = Math.min(this.config.maxFragLookUpTolerance * 2, i * 0.25),
      o = Math.max(Math.min(e.start - a, n.end - a), r + a)
    e.start - o > a && this.flushMainBuffer(o, e.start)
  }
  getFwdBufferInfo(e, t) {
    const r = this.getLoadPosition()
    return J(r) ? this.getFwdBufferInfoAtPos(e, r, t) : null
  }
  getFwdBufferInfoAtPos(e, t, r) {
    const {
        config: { maxBufferHole: n }
      } = this,
      i = ge.bufferInfo(e, t, n)
    if (i.len === 0 && i.nextStart !== void 0) {
      const a = this.fragmentTracker.getBufferedFrag(t, r)
      if (a && i.nextStart < a.end) return ge.bufferInfo(e, t, Math.max(i.nextStart, n))
    }
    return i
  }
  getMaxBufferLength(e) {
    const { config: t } = this
    let r
    return (
      e ? (r = Math.max((8 * t.maxBufferSize) / e, t.maxBufferLength)) : (r = t.maxBufferLength),
      Math.min(r, t.maxMaxBufferLength)
    )
  }
  reduceMaxBufferLength(e) {
    const t = this.config,
      r = e || t.maxBufferLength
    return t.maxMaxBufferLength >= r
      ? ((t.maxMaxBufferLength /= 2),
        this.warn(`Reduce max buffer length to ${t.maxMaxBufferLength}s`),
        !0)
      : !1
  }
  getAppendedFrag(e, t = ie.MAIN) {
    const r = this.fragmentTracker.getAppendedFrag(e, ie.MAIN)
    return r && 'fragment' in r ? r.fragment : r
  }
  getNextFragment(e, t) {
    const r = t.fragments,
      n = r.length
    if (!n) return null
    const { config: i } = this,
      a = r[0].start
    let o
    if (t.live) {
      const l = i.initialLiveManifestSize
      if (n < l)
        return this.warn(`Not enough fragments to start playback (have: ${n}, need: ${l})`), null
      !t.PTSKnown &&
        !this.startFragRequested &&
        this.startPosition === -1 &&
        ((o = this.getInitialLiveFragment(t, r)),
        (this.startPosition = o ? this.hls.liveSyncPosition || o.start : e))
    } else e <= a && (o = r[0])
    if (!o) {
      const l = i.lowLatencyMode ? t.partEnd : t.fragmentEnd
      o = this.getFragmentAtPosition(e, l, t)
    }
    return this.mapToInitFragWhenRequired(o)
  }
  isLoopLoading(e, t) {
    const r = this.fragmentTracker.getState(e)
    return (r === Re.OK || (r === Re.PARTIAL && !!e.gap)) && this.nextLoadPosition > t
  }
  getNextFragmentLoopLoading(e, t, r, n, i) {
    const a = e.gap,
      o = this.getNextFragment(this.nextLoadPosition, t)
    if (o === null) return o
    if (((e = o), a && e && !e.gap && r.nextStart)) {
      const l = this.getFwdBufferInfoAtPos(
        this.mediaBuffer ? this.mediaBuffer : this.media,
        r.nextStart,
        n
      )
      if (l !== null && r.len + l.len >= i)
        return this.log(`buffer full after gaps in "${n}" playlist starting at sn: ${e.sn}`), null
    }
    return e
  }
  mapToInitFragWhenRequired(e) {
    return e != null && e.initSegment && !(e != null && e.initSegment.data) && !this.bitrateTest
      ? e.initSegment
      : e
  }
  getNextPart(e, t, r) {
    let n = -1,
      i = !1,
      a = !0
    for (let o = 0, l = e.length; o < l; o++) {
      const u = e[o]
      if (((a = a && !u.independent), n > -1 && r < u.start)) break
      const c = u.loaded
      c ? (n = -1) : (i || u.independent || a) && u.fragment === t && (n = o), (i = c)
    }
    return n
  }
  loadedEndOfParts(e, t) {
    const r = e[e.length - 1]
    return r && t > r.start && r.loaded
  }
  getInitialLiveFragment(e, t) {
    const r = this.fragPrevious
    let n = null
    if (r) {
      if (
        (e.hasProgramDateTime &&
          (this.log(
            `Live playlist, switching playlist, load frag with same PDT: ${r.programDateTime}`
          ),
          (n = Ec(t, r.endProgramDateTime, this.config.maxFragLookUpTolerance))),
        !n)
      ) {
        const i = r.sn + 1
        if (i >= e.startSN && i <= e.endSN) {
          const a = t[i - e.startSN]
          r.cc === a.cc &&
            ((n = a),
            this.log(`Live playlist, switching playlist, load frag with next SN: ${n.sn}`))
        }
        n ||
          ((n = Sc(t, r.cc)),
          n && this.log(`Live playlist, switching playlist, load frag with same CC: ${n.sn}`))
      }
    } else {
      const i = this.hls.liveSyncPosition
      i !== null &&
        (n = this.getFragmentAtPosition(i, this.bitrateTest ? e.fragmentEnd : e.edge, e))
    }
    return n
  }
  getFragmentAtPosition(e, t, r) {
    const { config: n } = this
    let { fragPrevious: i } = this,
      { fragments: a, endSN: o } = r
    const { fragmentHint: l } = r,
      u = n.maxFragLookUpTolerance,
      c = r.partList,
      f = !!(n.lowLatencyMode && c != null && c.length && l)
    f && l && !this.bitrateTest && ((a = a.concat(l)), (o = l.sn))
    let d
    if (e < t) {
      const m = e > t - u ? 0 : u
      d = Wt(i, a, e, m)
    } else d = a[a.length - 1]
    if (d) {
      const m = d.sn - r.startSN,
        p = this.fragmentTracker.getState(d)
      if (
        ((p === Re.OK || (p === Re.PARTIAL && d.gap)) && (i = d),
        i && d.sn === i.sn && (!f || c[0].fragment.sn > d.sn) && i && d.level === i.level)
      ) {
        const E = a[m + 1]
        d.sn < o && this.fragmentTracker.getState(E) !== Re.OK ? (d = E) : (d = null)
      }
    }
    return d
  }
  synchronizeToLiveEdge(e) {
    const { config: t, media: r } = this
    if (!r) return
    const n = this.hls.liveSyncPosition,
      i = r.currentTime,
      a = e.fragments[0].start,
      o = e.edge,
      l = i >= a - t.maxFragLookUpTolerance && i <= o
    if (n !== null && r.duration > n && (i < n || !l)) {
      const u =
        t.liveMaxLatencyDuration !== void 0
          ? t.liveMaxLatencyDuration
          : t.liveMaxLatencyDurationCount * e.targetduration
      ;((!l && r.readyState < 4) || i < o - u) &&
        (this.loadedmetadata || (this.nextLoadPosition = n),
        r.readyState &&
          (this.warn(
            `Playback: ${i.toFixed(
              3
            )} is located too far from the end of live sliding playlist: ${o}, reset currentTime to : ${n.toFixed(
              3
            )}`
          ),
          (r.currentTime = n)))
    }
  }
  alignPlaylists(e, t) {
    const { levels: r, levelLastLoaded: n, fragPrevious: i } = this,
      a = n !== null ? r[n] : null,
      o = e.fragments.length
    if (!o) return this.warn('No fragments in live playlist'), 0
    const l = e.fragments[0].start,
      u = !t,
      c = e.alignedSliding && J(l)
    if (u || (!c && !l)) {
      kc(i, a, e)
      const f = e.fragments[0].start
      return (
        this.log(
          `Live playlist sliding: ${f.toFixed(2)} start-sn: ${t ? t.startSN : 'na'}->${
            e.startSN
          } prev-sn: ${i ? i.sn : 'na'} fragments: ${o}`
        ),
        f
      )
    }
    return l
  }
  waitForCdnTuneIn(e) {
    return (
      e.live &&
      e.canBlockReload &&
      e.partTarget &&
      e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3)
    )
  }
  setStartPosition(e, t) {
    let r = this.startPosition
    if ((r < t && (r = -1), r === -1 || this.lastCurrentTime === -1)) {
      const n = this.startTimeOffset !== null,
        i = n ? this.startTimeOffset : e.startTimeOffset
      i !== null && J(i)
        ? ((r = t + i),
          i < 0 && (r += e.totalduration),
          (r = Math.min(Math.max(t, r), t + e.totalduration)),
          this.log(
            `Start time offset ${i} found in ${
              n ? 'multivariant' : 'media'
            } playlist, adjust startPosition to ${r}`
          ),
          (this.startPosition = r))
        : e.live
        ? (r = this.hls.liveSyncPosition || t)
        : (this.startPosition = r = 0),
        (this.lastCurrentTime = r)
    }
    this.nextLoadPosition = r
  }
  getLoadPosition() {
    const { media: e } = this
    let t = 0
    return (
      this.loadedmetadata && e
        ? (t = e.currentTime)
        : this.nextLoadPosition && (t = this.nextLoadPosition),
      t
    )
  }
  handleFragLoadAborted(e, t) {
    this.transmuxer &&
      e.sn !== 'initSegment' &&
      e.stats.aborted &&
      (this.warn(`Fragment ${e.sn}${t ? ' part ' + t.index : ''} of level ${e.level} was aborted`),
      this.resetFragmentLoading(e))
  }
  resetFragmentLoading(e) {
    ;(!this.fragCurrent ||
      (!this.fragContextChanged(e) && this.state !== W.FRAG_LOADING_WAITING_RETRY)) &&
      (this.state = W.IDLE)
  }
  onFragmentOrKeyLoadError(e, t) {
    if (t.chunkMeta && !t.frag) {
      const f = this.getCurrentContext(t.chunkMeta)
      f && (t.frag = f.frag)
    }
    const r = t.frag
    if (!r || r.type !== e || !this.levels) return
    if (this.fragContextChanged(r)) {
      var n
      this.warn(
        `Frag load error must match current frag to retry ${r.url} > ${
          (n = this.fragCurrent) == null ? void 0 : n.url
        }`
      )
      return
    }
    const i = t.details === K.FRAG_GAP
    i && this.fragmentTracker.fragBuffered(r, !0)
    const a = t.errorAction,
      { action: o, retryCount: l = 0, retryConfig: u } = a || {}
    if (a && o === Ce.RetryRequest && u) {
      var c
      this.resetStartWhenNotLoaded((c = this.levelLastLoaded) != null ? c : r.level)
      const f = Mn(u, l)
      this.warn(
        `Fragment ${r.sn} of ${e} ${r.level} errored with ${t.details}, retrying loading ${l + 1}/${
          u.maxNumRetry
        } in ${f}ms`
      ),
        (a.resolved = !0),
        (this.retryDate = self.performance.now() + f),
        (this.state = W.FRAG_LOADING_WAITING_RETRY)
    } else
      u && a
        ? (this.resetFragmentErrors(e),
          l < u.maxNumRetry
            ? i || (a.resolved = !0)
            : G.warn(`${t.details} reached or exceeded max retry (${l})`))
        : (a == null ? void 0 : a.action) === Ce.SendAlternateToPenaltyBox
        ? (this.state = W.WAITING_LEVEL)
        : (this.state = W.ERROR)
    this.tickImmediate()
  }
  reduceLengthAndFlushBuffer(e) {
    if (this.state === W.PARSING || this.state === W.PARSED) {
      const t = e.parent,
        r = this.getFwdBufferInfo(this.mediaBuffer, t),
        n = r && r.len > 0.5
      n && this.reduceMaxBufferLength(r.len)
      const i = !n
      return (
        i &&
          this.warn(`Buffer full error while media.currentTime is not buffered, flush ${t} buffer`),
        e.frag &&
          (this.fragmentTracker.removeFragment(e.frag), (this.nextLoadPosition = e.frag.start)),
        this.resetLoadingState(),
        i
      )
    }
    return !1
  }
  resetFragmentErrors(e) {
    e === ie.AUDIO && (this.fragCurrent = null),
      this.loadedmetadata || (this.startFragRequested = !1),
      this.state !== W.STOPPED && (this.state = W.IDLE)
  }
  afterBufferFlushed(e, t, r) {
    if (!e) return
    const n = ge.getBuffered(e)
    this.fragmentTracker.detectEvictedFragments(t, n, r),
      this.state === W.ENDED && this.resetLoadingState()
  }
  resetLoadingState() {
    this.log('Reset loading state'),
      (this.fragCurrent = null),
      (this.fragPrevious = null),
      (this.state = W.IDLE)
  }
  resetStartWhenNotLoaded(e) {
    if (!this.loadedmetadata) {
      this.startFragRequested = !1
      const t = this.levels ? this.levels[e].details : null
      t != null && t.live
        ? ((this.startPosition = -1), this.setStartPosition(t, 0), this.resetLoadingState())
        : (this.nextLoadPosition = this.startPosition)
    }
  }
  resetWhenMissingContext(e) {
    var t
    this.warn(
      `The loading context changed while buffering fragment ${e.sn} of level ${e.level}. This chunk will not be buffered.`
    ),
      this.removeUnbufferedFrags(),
      this.resetStartWhenNotLoaded((t = this.levelLastLoaded) != null ? t : e.level),
      this.resetLoadingState()
  }
  removeUnbufferedFrags(e = 0) {
    this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0)
  }
  updateLevelTiming(e, t, r, n) {
    var i
    const a = r.details
    if (!a) {
      this.warn('level.details undefined')
      return
    }
    if (
      Object.keys(e.elementaryStreams).reduce((l, u) => {
        const c = e.elementaryStreams[u]
        if (c) {
          const f = c.endPTS - c.startPTS
          if (f <= 0)
            return (
              this.warn(`Could not parse fragment ${e.sn} ${u} duration reliably (${f})`), l || !1
            )
          const d = n ? 0 : oa(a, e, c.startPTS, c.endPTS, c.startDTS, c.endDTS)
          return (
            this.hls.trigger(O.LEVEL_PTS_UPDATED, {
              details: a,
              level: r,
              drift: d,
              type: u,
              frag: e,
              start: c.startPTS,
              end: c.endPTS
            }),
            !0
          )
        }
        return l
      }, !1)
    )
      r.fragmentError = 0
    else if (((i = this.transmuxer) == null ? void 0 : i.error) === null) {
      const l = new Error(
        `Found no media in fragment ${e.sn} of level ${e.level} resetting transmuxer to fallback to playlist timing`
      )
      if (
        (r.fragmentError === 0 &&
          (r.fragmentError++,
          (e.gap = !0),
          this.fragmentTracker.removeFragment(e),
          this.fragmentTracker.fragBuffered(e, !0)),
        this.warn(l.message),
        this.hls.trigger(O.ERROR, {
          type: ne.MEDIA_ERROR,
          details: K.FRAG_PARSING_ERROR,
          fatal: !1,
          error: l,
          frag: e,
          reason: `Found no media in msn ${e.sn} of level "${r.url}"`
        }),
        !this.hls)
      )
        return
      this.resetTransmuxer()
    }
    ;(this.state = W.PARSED), this.hls.trigger(O.FRAG_PARSED, { frag: e, part: t })
  }
  resetTransmuxer() {
    this.transmuxer && (this.transmuxer.destroy(), (this.transmuxer = null))
  }
  recoverWorkerError(e) {
    if (e.event === 'demuxerWorker') {
      var t, r, n
      this.fragmentTracker.removeAllFragments(),
        this.resetTransmuxer(),
        this.resetStartWhenNotLoaded(
          (t =
            (r = this.levelLastLoaded) != null
              ? r
              : (n = this.fragCurrent) == null
              ? void 0
              : n.level) != null
            ? t
            : 0
        ),
        this.resetLoadingState()
    }
  }
  set state(e) {
    const t = this._state
    t !== e && ((this._state = e), this.log(`${t}->${e}`))
  }
  get state() {
    return this._state
  }
}
function ha() {
  return self.SourceBuffer || self.WebKitSourceBuffer
}
function jc() {
  const s = xr()
  if (!s) return !1
  const e = ha(),
    t =
      s &&
      typeof s.isTypeSupported == 'function' &&
      s.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),
    r =
      !e ||
      (e.prototype &&
        typeof e.prototype.appendBuffer == 'function' &&
        typeof e.prototype.remove == 'function')
  return !!t && !!r
}
function Vc() {
  var s
  const e = ha()
  return typeof (e == null || (s = e.prototype) == null ? void 0 : s.changeType) == 'function'
}
function Hc() {
  return typeof __HLS_WORKER_BUNDLE__ == 'function'
}
function Wc() {
  const s = new self.Blob(
      [
        `var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`
      ],
      { type: 'text/javascript' }
    ),
    e = self.URL.createObjectURL(s)
  return { worker: new self.Worker(e), objectURL: e }
}
function Yc(s) {
  const e = new self.URL(s, self.location.href).href
  return { worker: new self.Worker(e), scriptURL: e }
}
function et(s = '', e = 9e4) {
  return {
    type: s,
    id: -1,
    pid: -1,
    inputTimeScale: e,
    sequenceNumber: -1,
    samples: [],
    dropped: 0
  }
}
class pa {
  constructor() {
    ;(this._audioTrack = void 0),
      (this._id3Track = void 0),
      (this.frameIndex = 0),
      (this.cachedData = null),
      (this.basePTS = null),
      (this.initPTS = null),
      (this.lastPTS = null)
  }
  resetInitSegment(e, t, r, n) {
    this._id3Track = {
      type: 'id3',
      id: 3,
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0
    }
  }
  resetTimeStamp(e) {
    ;(this.initPTS = e), this.resetContiguity()
  }
  resetContiguity() {
    ;(this.basePTS = null), (this.lastPTS = null), (this.frameIndex = 0)
  }
  canParse(e, t) {
    return !1
  }
  appendFrame(e, t, r) {}
  demux(e, t) {
    this.cachedData && ((e = vt(this.cachedData, e)), (this.cachedData = null))
    let r = fr(e, 0),
      n = r ? r.length : 0,
      i
    const a = this._audioTrack,
      o = this._id3Track,
      l = r ? Pu(r) : void 0,
      u = e.length
    for (
      (this.basePTS === null || (this.frameIndex === 0 && J(l))) &&
        ((this.basePTS = zc(l, t, this.initPTS)), (this.lastPTS = this.basePTS)),
        this.lastPTS === null && (this.lastPTS = this.basePTS),
        r &&
          r.length > 0 &&
          o.samples.push({
            pts: this.lastPTS,
            dts: this.lastPTS,
            data: r,
            type: Qe.audioId3,
            duration: Number.POSITIVE_INFINITY
          });
      n < u;

    ) {
      if (this.canParse(e, n)) {
        const c = this.appendFrame(a, e, n)
        c ? (this.frameIndex++, (this.lastPTS = c.sample.pts), (n += c.length), (i = n)) : (n = u)
      } else
        Iu(e, n)
          ? ((r = fr(e, n)),
            o.samples.push({
              pts: this.lastPTS,
              dts: this.lastPTS,
              data: r,
              type: Qe.audioId3,
              duration: Number.POSITIVE_INFINITY
            }),
            (n += r.length),
            (i = n))
          : n++
      if (n === u && i !== u) {
        const c = gt(e, i)
        this.cachedData ? (this.cachedData = vt(this.cachedData, c)) : (this.cachedData = c)
      }
    }
    return { audioTrack: a, videoTrack: et(), id3Track: o, textTrack: et() }
  }
  demuxSampleAes(e, t, r) {
    return Promise.reject(
      new Error(`[${this}] This demuxer does not support Sample-AES decryption`)
    )
  }
  flush(e) {
    const t = this.cachedData
    return (
      t && ((this.cachedData = null), this.demux(t, 0)),
      { audioTrack: this._audioTrack, videoTrack: et(), id3Track: this._id3Track, textTrack: et() }
    )
  }
  destroy() {}
}
const zc = (s, e, t) => {
  if (J(s)) return s * 90
  const r = t ? (t.baseTime * 9e4) / t.timescale : 0
  return e * 9e4 + r
}
function qc(s, e, t, r) {
  let n, i, a, o
  const l = navigator.userAgent.toLowerCase(),
    u = r,
    c = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350]
  n = ((e[t + 2] & 192) >>> 6) + 1
  const f = (e[t + 2] & 60) >>> 2
  if (f > c.length - 1) {
    s.trigger(O.ERROR, {
      type: ne.MEDIA_ERROR,
      details: K.FRAG_PARSING_ERROR,
      fatal: !0,
      reason: `invalid ADTS sampling index:${f}`
    })
    return
  }
  return (
    (a = (e[t + 2] & 1) << 2),
    (a |= (e[t + 3] & 192) >>> 6),
    G.log(`manifest codec:${r}, ADTS type:${n}, samplingIndex:${f}`),
    /firefox/i.test(l)
      ? f >= 6
        ? ((n = 5), (o = new Array(4)), (i = f - 3))
        : ((n = 2), (o = new Array(2)), (i = f))
      : l.indexOf('android') !== -1
      ? ((n = 2), (o = new Array(2)), (i = f))
      : ((n = 5),
        (o = new Array(4)),
        (r && (r.indexOf('mp4a.40.29') !== -1 || r.indexOf('mp4a.40.5') !== -1)) || (!r && f >= 6)
          ? (i = f - 3)
          : (((r && r.indexOf('mp4a.40.2') !== -1 && ((f >= 6 && a === 1) || /vivaldi/i.test(l))) ||
              (!r && a === 1)) &&
              ((n = 2), (o = new Array(2))),
            (i = f))),
    (o[0] = n << 3),
    (o[0] |= (f & 14) >> 1),
    (o[1] |= (f & 1) << 7),
    (o[1] |= a << 3),
    n === 5 && ((o[1] |= (i & 14) >> 1), (o[2] = (i & 1) << 7), (o[2] |= 8), (o[3] = 0)),
    { config: o, samplerate: c[f], channelCount: a, codec: 'mp4a.40.' + n, manifestCodec: u }
  )
}
function ma(s, e) {
  return s[e] === 255 && (s[e + 1] & 246) === 240
}
function ga(s, e) {
  return s[e + 1] & 1 ? 7 : 9
}
function $n(s, e) {
  return ((s[e + 3] & 3) << 11) | (s[e + 4] << 3) | ((s[e + 5] & 224) >>> 5)
}
function Xc(s, e) {
  return e + 5 < s.length
}
function gr(s, e) {
  return e + 1 < s.length && ma(s, e)
}
function Qc(s, e) {
  return Xc(s, e) && ma(s, e) && $n(s, e) <= s.length - e
}
function Zc(s, e) {
  if (gr(s, e)) {
    const t = ga(s, e)
    if (e + t >= s.length) return !1
    const r = $n(s, e)
    if (r <= t) return !1
    const n = e + r
    return n === s.length || gr(s, n)
  }
  return !1
}
function ya(s, e, t, r, n) {
  if (!s.samplerate) {
    const i = qc(e, t, r, n)
    if (!i) return
    ;(s.config = i.config),
      (s.samplerate = i.samplerate),
      (s.channelCount = i.channelCount),
      (s.codec = i.codec),
      (s.manifestCodec = i.manifestCodec),
      G.log(`parsed codec:${s.codec}, rate:${i.samplerate}, channels:${i.channelCount}`)
  }
}
function va(s) {
  return (1024 * 9e4) / s
}
function Jc(s, e) {
  const t = ga(s, e)
  if (e + t <= s.length) {
    const r = $n(s, e) - t
    if (r > 0) return { headerLength: t, frameLength: r }
  }
}
function _a(s, e, t, r, n) {
  const i = va(s.samplerate),
    a = r + n * i,
    o = Jc(e, t)
  let l
  if (o) {
    const { frameLength: f, headerLength: d } = o,
      m = d + f,
      p = Math.max(0, t + m - e.length)
    p
      ? ((l = new Uint8Array(m - d)), l.set(e.subarray(t + d, e.length), 0))
      : (l = e.subarray(t + d, t + m))
    const v = { unit: l, pts: a }
    return p || s.samples.push(v), { sample: v, length: m, missing: p }
  }
  const u = e.length - t
  return (
    (l = new Uint8Array(u)),
    l.set(e.subarray(t, e.length), 0),
    { sample: { unit: l, pts: a }, length: u, missing: -1 }
  )
}
class ef extends pa {
  constructor(e, t) {
    super(),
      (this.observer = void 0),
      (this.config = void 0),
      (this.observer = e),
      (this.config = t)
  }
  resetInitSegment(e, t, r, n) {
    super.resetInitSegment(e, t, r, n),
      (this._audioTrack = {
        container: 'audio/adts',
        type: 'audio',
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: 'aac',
        samples: [],
        manifestCodec: t,
        duration: n,
        inputTimeScale: 9e4,
        dropped: 0
      })
  }
  static probe(e) {
    if (!e) return !1
    let r = (fr(e, 0) || []).length
    for (let n = e.length; r < n; r++) if (Zc(e, r)) return G.log('ADTS sync word found !'), !0
    return !1
  }
  canParse(e, t) {
    return Qc(e, t)
  }
  appendFrame(e, t, r) {
    ya(e, this.observer, t, r, e.manifestCodec)
    const n = _a(e, t, r, this.basePTS, this.frameIndex)
    if (n && n.missing === 0) return n
  }
}
const tf = /\/emsg[-/]ID3/i
class rf {
  constructor(e, t) {
    ;(this.remainderData = null),
      (this.timeOffset = 0),
      (this.config = void 0),
      (this.videoTrack = void 0),
      (this.audioTrack = void 0),
      (this.id3Track = void 0),
      (this.txtTrack = void 0),
      (this.config = t)
  }
  resetTimeStamp() {}
  resetInitSegment(e, t, r, n) {
    const i = (this.videoTrack = et('video', 1)),
      a = (this.audioTrack = et('audio', 1)),
      o = (this.txtTrack = et('text', 1))
    if (((this.id3Track = et('id3', 1)), (this.timeOffset = 0), !(e != null && e.byteLength)))
      return
    const l = ea(e)
    if (l.video) {
      const { id: u, timescale: c, codec: f } = l.video
      ;(i.id = u), (i.timescale = o.timescale = c), (i.codec = f)
    }
    if (l.audio) {
      const { id: u, timescale: c, codec: f } = l.audio
      ;(a.id = u), (a.timescale = c), (a.codec = f)
    }
    ;(o.id = Qs.text), (i.sampleDuration = 0), (i.duration = a.duration = n)
  }
  resetContiguity() {
    this.remainderData = null
  }
  static probe(e) {
    return (e = e.length > 16384 ? e.subarray(0, 16384) : e), ce(e, ['moof']).length > 0
  }
  demux(e, t) {
    this.timeOffset = t
    let r = e
    const n = this.videoTrack,
      i = this.txtTrack
    if (this.config.progressive) {
      this.remainderData && (r = vt(this.remainderData, e))
      const o = Vu(r)
      ;(this.remainderData = o.remainder), (n.samples = o.valid || new Uint8Array())
    } else n.samples = r
    const a = this.extractID3Track(n, t)
    return (
      (i.samples = Ai(t, n)),
      { videoTrack: n, audioTrack: this.audioTrack, id3Track: a, textTrack: this.txtTrack }
    )
  }
  flush() {
    const e = this.timeOffset,
      t = this.videoTrack,
      r = this.txtTrack
    ;(t.samples = this.remainderData || new Uint8Array()), (this.remainderData = null)
    const n = this.extractID3Track(t, this.timeOffset)
    return (r.samples = Ai(e, t)), { videoTrack: t, audioTrack: et(), id3Track: n, textTrack: et() }
  }
  extractID3Track(e, t) {
    const r = this.id3Track
    if (e.samples.length) {
      const n = ce(e.samples, ['emsg'])
      n &&
        n.forEach((i) => {
          const a = Yu(i)
          if (tf.test(a.schemeIdUri)) {
            const o = J(a.presentationTime)
              ? a.presentationTime / a.timeScale
              : t + a.presentationTimeDelta / a.timeScale
            let l =
              a.eventDuration === 4294967295
                ? Number.POSITIVE_INFINITY
                : a.eventDuration / a.timeScale
            l <= 0.001 && (l = Number.POSITIVE_INFINITY)
            const u = a.payload
            r.samples.push({
              data: u,
              len: u.byteLength,
              dts: o,
              pts: o,
              type: Qe.emsg,
              duration: l
            })
          }
        })
    }
    return r
  }
  demuxSampleAes(e, t, r) {
    return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'))
  }
  destroy() {}
}
let Jt = null
const nf = [
    32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112,
    128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256,
    320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56,
    64, 80, 96, 112, 128, 144, 160
  ],
  sf = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
  af = [
    [0, 72, 144, 12],
    [0, 0, 0, 0],
    [0, 72, 144, 12],
    [0, 144, 144, 12]
  ],
  of = [0, 1, 1, 4]
function Ea(s, e, t, r, n) {
  if (t + 24 > e.length) return
  const i = xa(e, t)
  if (i && t + i.frameLength <= e.length) {
    const a = (i.samplesPerFrame * 9e4) / i.sampleRate,
      o = r + n * a,
      l = { unit: e.subarray(t, t + i.frameLength), pts: o, dts: o }
    return (
      (s.config = []),
      (s.channelCount = i.channelCount),
      (s.samplerate = i.sampleRate),
      s.samples.push(l),
      { sample: l, length: i.frameLength, missing: 0 }
    )
  }
}
function xa(s, e) {
  const t = (s[e + 1] >> 3) & 3,
    r = (s[e + 1] >> 1) & 3,
    n = (s[e + 2] >> 4) & 15,
    i = (s[e + 2] >> 2) & 3
  if (t !== 1 && n !== 0 && n !== 15 && i !== 3) {
    const a = (s[e + 2] >> 1) & 1,
      o = s[e + 3] >> 6,
      l = t === 3 ? 3 - r : r === 3 ? 3 : 4,
      u = nf[l * 14 + n - 1] * 1e3,
      f = sf[(t === 3 ? 0 : t === 2 ? 1 : 2) * 3 + i],
      d = o === 3 ? 1 : 2,
      m = af[t][r],
      p = of[r],
      v = m * 8 * p,
      E = Math.floor((m * u) / f + a) * p
    if (Jt === null) {
      const b = (navigator.userAgent || '').match(/Chrome\/(\d+)/i)
      Jt = b ? parseInt(b[1]) : 0
    }
    return (
      !!Jt && Jt <= 87 && r === 2 && u >= 224e3 && o === 0 && (s[e + 3] = s[e + 3] | 128),
      { sampleRate: f, channelCount: d, frameLength: E, samplesPerFrame: v }
    )
  }
}
function Kn(s, e) {
  return s[e] === 255 && (s[e + 1] & 224) === 224 && (s[e + 1] & 6) !== 0
}
function Sa(s, e) {
  return e + 1 < s.length && Kn(s, e)
}
function lf(s, e) {
  return Kn(s, e) && 4 <= s.length - e
}
function uf(s, e) {
  if (e + 1 < s.length && Kn(s, e)) {
    const r = xa(s, e)
    let n = 4
    r != null && r.frameLength && (n = r.frameLength)
    const i = e + n
    return i === s.length || Sa(s, i)
  }
  return !1
}
class qi {
  constructor(e) {
    ;(this.data = void 0),
      (this.bytesAvailable = void 0),
      (this.word = void 0),
      (this.bitsAvailable = void 0),
      (this.data = e),
      (this.bytesAvailable = e.byteLength),
      (this.word = 0),
      (this.bitsAvailable = 0)
  }
  loadWord() {
    const e = this.data,
      t = this.bytesAvailable,
      r = e.byteLength - t,
      n = new Uint8Array(4),
      i = Math.min(4, t)
    if (i === 0) throw new Error('no bytes available')
    n.set(e.subarray(r, r + i)),
      (this.word = new DataView(n.buffer).getUint32(0)),
      (this.bitsAvailable = i * 8),
      (this.bytesAvailable -= i)
  }
  skipBits(e) {
    let t
    ;(e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable)),
      this.bitsAvailable > e
        ? ((this.word <<= e), (this.bitsAvailable -= e))
        : ((e -= this.bitsAvailable),
          (t = e >> 3),
          (e -= t << 3),
          (this.bytesAvailable -= t),
          this.loadWord(),
          (this.word <<= e),
          (this.bitsAvailable -= e))
  }
  readBits(e) {
    let t = Math.min(this.bitsAvailable, e)
    const r = this.word >>> (32 - t)
    if (
      (e > 32 && G.error('Cannot read more than 32 bits at a time'),
      (this.bitsAvailable -= t),
      this.bitsAvailable > 0)
    )
      this.word <<= t
    else if (this.bytesAvailable > 0) this.loadWord()
    else throw new Error('no bits available')
    return (t = e - t), t > 0 && this.bitsAvailable ? (r << t) | this.readBits(t) : r
  }
  skipLZ() {
    let e
    for (e = 0; e < this.bitsAvailable; ++e)
      if (this.word & (2147483648 >>> e)) return (this.word <<= e), (this.bitsAvailable -= e), e
    return this.loadWord(), e + this.skipLZ()
  }
  skipUEG() {
    this.skipBits(1 + this.skipLZ())
  }
  skipEG() {
    this.skipBits(1 + this.skipLZ())
  }
  readUEG() {
    const e = this.skipLZ()
    return this.readBits(e + 1) - 1
  }
  readEG() {
    const e = this.readUEG()
    return 1 & e ? (1 + e) >>> 1 : -1 * (e >>> 1)
  }
  readBoolean() {
    return this.readBits(1) === 1
  }
  readUByte() {
    return this.readBits(8)
  }
  readUShort() {
    return this.readBits(16)
  }
  readUInt() {
    return this.readBits(32)
  }
  skipScalingList(e) {
    let t = 8,
      r = 8,
      n
    for (let i = 0; i < e; i++)
      r !== 0 && ((n = this.readEG()), (r = (t + n + 256) % 256)), (t = r === 0 ? t : r)
  }
  readSPS() {
    let e = 0,
      t = 0,
      r = 0,
      n = 0,
      i,
      a,
      o
    const l = this.readUByte.bind(this),
      u = this.readBits.bind(this),
      c = this.readUEG.bind(this),
      f = this.readBoolean.bind(this),
      d = this.skipBits.bind(this),
      m = this.skipEG.bind(this),
      p = this.skipUEG.bind(this),
      v = this.skipScalingList.bind(this)
    l()
    const E = l()
    if (
      (u(5),
      d(3),
      l(),
      p(),
      E === 100 ||
        E === 110 ||
        E === 122 ||
        E === 244 ||
        E === 44 ||
        E === 83 ||
        E === 86 ||
        E === 118 ||
        E === 128)
    ) {
      const A = c()
      if ((A === 3 && d(1), p(), p(), d(1), f()))
        for (a = A !== 3 ? 8 : 12, o = 0; o < a; o++) f() && (o < 6 ? v(16) : v(64))
    }
    p()
    const x = c()
    if (x === 0) c()
    else if (x === 1) for (d(1), m(), m(), i = c(), o = 0; o < i; o++) m()
    p(), d(1)
    const T = c(),
      b = c(),
      R = u(1)
    R === 0 && d(1), d(1), f() && ((e = c()), (t = c()), (r = c()), (n = c()))
    let g = [1, 1]
    if (f() && f())
      switch (l()) {
        case 1:
          g = [1, 1]
          break
        case 2:
          g = [12, 11]
          break
        case 3:
          g = [10, 11]
          break
        case 4:
          g = [16, 11]
          break
        case 5:
          g = [40, 33]
          break
        case 6:
          g = [24, 11]
          break
        case 7:
          g = [20, 11]
          break
        case 8:
          g = [32, 11]
          break
        case 9:
          g = [80, 33]
          break
        case 10:
          g = [18, 11]
          break
        case 11:
          g = [15, 11]
          break
        case 12:
          g = [64, 33]
          break
        case 13:
          g = [160, 99]
          break
        case 14:
          g = [4, 3]
          break
        case 15:
          g = [3, 2]
          break
        case 16:
          g = [2, 1]
          break
        case 255: {
          g = [(l() << 8) | l(), (l() << 8) | l()]
          break
        }
      }
    return {
      width: Math.ceil((T + 1) * 16 - e * 2 - t * 2),
      height: (2 - R) * (b + 1) * 16 - (R ? 2 : 4) * (r + n),
      pixelRatio: g
    }
  }
  readSliceType() {
    return this.readUByte(), this.readUEG(), this.readUEG()
  }
}
class cf {
  constructor(e, t, r) {
    ;(this.keyData = void 0),
      (this.decrypter = void 0),
      (this.keyData = r),
      (this.decrypter = new Bn(t, { removePKCS7Padding: !1 }))
  }
  decryptBuffer(e) {
    return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer)
  }
  decryptAacSample(e, t, r) {
    const n = e[t].unit
    if (n.length <= 16) return
    const i = n.subarray(16, n.length - (n.length % 16)),
      a = i.buffer.slice(i.byteOffset, i.byteOffset + i.length)
    this.decryptBuffer(a).then((o) => {
      const l = new Uint8Array(o)
      n.set(l, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, r)
    })
  }
  decryptAacSamples(e, t, r) {
    for (; ; t++) {
      if (t >= e.length) {
        r()
        return
      }
      if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, r), !this.decrypter.isSync()))
        return
    }
  }
  getAvcEncryptedData(e) {
    const t = Math.floor((e.length - 48) / 160) * 16 + 16,
      r = new Int8Array(t)
    let n = 0
    for (let i = 32; i < e.length - 16; i += 160, n += 16) r.set(e.subarray(i, i + 16), n)
    return r
  }
  getAvcDecryptedUnit(e, t) {
    const r = new Uint8Array(t)
    let n = 0
    for (let i = 32; i < e.length - 16; i += 160, n += 16) e.set(r.subarray(n, n + 16), i)
    return e
  }
  decryptAvcSample(e, t, r, n, i) {
    const a = na(i.data),
      o = this.getAvcEncryptedData(a)
    this.decryptBuffer(o.buffer).then((l) => {
      ;(i.data = this.getAvcDecryptedUnit(a, l)),
        this.decrypter.isSync() || this.decryptAvcSamples(e, t, r + 1, n)
    })
  }
  decryptAvcSamples(e, t, r, n) {
    if (e instanceof Uint8Array) throw new Error('Cannot decrypt samples of type Uint8Array')
    for (; ; t++, r = 0) {
      if (t >= e.length) {
        n()
        return
      }
      const i = e[t].units
      for (; !(r >= i.length); r++) {
        const a = i[r]
        if (
          !(a.data.length <= 48 || (a.type !== 1 && a.type !== 5)) &&
          (this.decryptAvcSample(e, t, r, n, a), !this.decrypter.isSync())
        )
          return
      }
    }
  }
}
const Oe = 188
class ut {
  constructor(e, t, r) {
    ;(this.observer = void 0),
      (this.config = void 0),
      (this.typeSupported = void 0),
      (this.sampleAes = null),
      (this.pmtParsed = !1),
      (this.audioCodec = void 0),
      (this.videoCodec = void 0),
      (this._duration = 0),
      (this._pmtId = -1),
      (this._avcTrack = void 0),
      (this._audioTrack = void 0),
      (this._id3Track = void 0),
      (this._txtTrack = void 0),
      (this.aacOverFlow = null),
      (this.avcSample = null),
      (this.remainderData = null),
      (this.observer = e),
      (this.config = t),
      (this.typeSupported = r)
  }
  static probe(e) {
    const t = ut.syncOffset(e)
    return t > 0 && G.warn(`MPEG2-TS detected but first sync word found @ offset ${t}`), t !== -1
  }
  static syncOffset(e) {
    const t = e.length
    let r = Math.min(Oe * 5, e.length - Oe) + 1,
      n = 0
    for (; n < r; ) {
      let i = !1,
        a = -1,
        o = 0
      for (let l = n; l < t; l += Oe)
        if (e[l] === 71) {
          if (
            (o++,
            a === -1 && ((a = l), a !== 0 && (r = Math.min(a + Oe * 99, e.length - Oe) + 1)),
            i || (i = Ln(e, l) === 0),
            i && o > 1 && ((a === 0 && o > 2) || l + Oe > r))
          )
            return a
        } else {
          if (o) return -1
          break
        }
      n++
    }
    return -1
  }
  static createTrack(e, t) {
    return {
      container: e === 'video' || e === 'audio' ? 'video/mp2t' : void 0,
      type: e,
      id: Qs[e],
      pid: -1,
      inputTimeScale: 9e4,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
      duration: e === 'audio' ? t : void 0
    }
  }
  resetInitSegment(e, t, r, n) {
    ;(this.pmtParsed = !1),
      (this._pmtId = -1),
      (this._avcTrack = ut.createTrack('video')),
      (this._audioTrack = ut.createTrack('audio', n)),
      (this._id3Track = ut.createTrack('id3')),
      (this._txtTrack = ut.createTrack('text')),
      (this._audioTrack.segmentCodec = 'aac'),
      (this.aacOverFlow = null),
      (this.avcSample = null),
      (this.remainderData = null),
      (this.audioCodec = t),
      (this.videoCodec = r),
      (this._duration = n)
  }
  resetTimeStamp() {}
  resetContiguity() {
    const { _audioTrack: e, _avcTrack: t, _id3Track: r } = this
    e && (e.pesData = null),
      t && (t.pesData = null),
      r && (r.pesData = null),
      (this.aacOverFlow = null),
      (this.avcSample = null),
      (this.remainderData = null)
  }
  demux(e, t, r = !1, n = !1) {
    r || (this.sampleAes = null)
    let i
    const a = this._avcTrack,
      o = this._audioTrack,
      l = this._id3Track,
      u = this._txtTrack
    let c = a.pid,
      f = a.pesData,
      d = o.pid,
      m = l.pid,
      p = o.pesData,
      v = l.pesData,
      E = null,
      x = this.pmtParsed,
      T = this._pmtId,
      b = e.length
    if (
      (this.remainderData &&
        ((e = vt(this.remainderData, e)), (b = e.length), (this.remainderData = null)),
      b < Oe && !n)
    )
      return (this.remainderData = e), { audioTrack: o, videoTrack: a, id3Track: l, textTrack: u }
    const R = Math.max(0, ut.syncOffset(e))
    ;(b -= (b - R) % Oe),
      b < e.byteLength &&
        !n &&
        (this.remainderData = new Uint8Array(e.buffer, b, e.buffer.byteLength - b))
    let g = 0
    for (let S = R; S < b; S += Oe)
      if (e[S] === 71) {
        const h = !!(e[S + 1] & 64),
          _ = Ln(e, S),
          y = (e[S + 3] & 48) >> 4
        let L
        if (y > 1) {
          if (((L = S + 5 + e[S + 4]), L === S + Oe)) continue
        } else L = S + 4
        switch (_) {
          case c:
            h && (f && (i = At(f)) && this.parseAVCPES(a, u, i, !1), (f = { data: [], size: 0 })),
              f && (f.data.push(e.subarray(L, S + Oe)), (f.size += S + Oe - L))
            break
          case d:
            if (h) {
              if (p && (i = At(p)))
                switch (o.segmentCodec) {
                  case 'aac':
                    this.parseAACPES(o, i)
                    break
                  case 'mp3':
                    this.parseMPEGPES(o, i)
                    break
                }
              p = { data: [], size: 0 }
            }
            p && (p.data.push(e.subarray(L, S + Oe)), (p.size += S + Oe - L))
            break
          case m:
            h && (v && (i = At(v)) && this.parseID3PES(l, i), (v = { data: [], size: 0 })),
              v && (v.data.push(e.subarray(L, S + Oe)), (v.size += S + Oe - L))
            break
          case 0:
            h && (L += e[L] + 1), (T = this._pmtId = ff(e, L))
            break
          case T: {
            h && (L += e[L] + 1)
            const I = df(e, L, this.typeSupported, r)
            ;(c = I.avc),
              c > 0 && (a.pid = c),
              (d = I.audio),
              d > 0 && ((o.pid = d), (o.segmentCodec = I.segmentCodec)),
              (m = I.id3),
              m > 0 && (l.pid = m),
              E !== null &&
                !x &&
                (G.warn(
                  `MPEG-TS PMT found at ${S} after unknown PID '${E}'. Backtracking to sync byte @${R} to parse all TS packets.`
                ),
                (E = null),
                (S = R - 188)),
              (x = this.pmtParsed = !0)
            break
          }
          case 17:
          case 8191:
            break
          default:
            E = _
            break
        }
      } else g++
    if (g > 0) {
      const S = new Error(`Found ${g} TS packet/s that do not start with 0x47`)
      this.observer.emit(O.ERROR, O.ERROR, {
        type: ne.MEDIA_ERROR,
        details: K.FRAG_PARSING_ERROR,
        fatal: !1,
        error: S,
        reason: S.message
      })
    }
    ;(a.pesData = f), (o.pesData = p), (l.pesData = v)
    const A = { audioTrack: o, videoTrack: a, id3Track: l, textTrack: u }
    return n && this.extractRemainingSamples(A), A
  }
  flush() {
    const { remainderData: e } = this
    this.remainderData = null
    let t
    return (
      e
        ? (t = this.demux(e, -1, !1, !0))
        : (t = {
            videoTrack: this._avcTrack,
            audioTrack: this._audioTrack,
            id3Track: this._id3Track,
            textTrack: this._txtTrack
          }),
      this.extractRemainingSamples(t),
      this.sampleAes ? this.decrypt(t, this.sampleAes) : t
    )
  }
  extractRemainingSamples(e) {
    const { audioTrack: t, videoTrack: r, id3Track: n, textTrack: i } = e,
      a = r.pesData,
      o = t.pesData,
      l = n.pesData
    let u
    if (
      (a && (u = At(a)) ? (this.parseAVCPES(r, i, u, !0), (r.pesData = null)) : (r.pesData = a),
      o && (u = At(o)))
    ) {
      switch (t.segmentCodec) {
        case 'aac':
          this.parseAACPES(t, u)
          break
        case 'mp3':
          this.parseMPEGPES(t, u)
          break
      }
      t.pesData = null
    } else
      o != null && o.size && G.log('last AAC PES packet truncated,might overlap between fragments'),
        (t.pesData = o)
    l && (u = At(l)) ? (this.parseID3PES(n, u), (n.pesData = null)) : (n.pesData = l)
  }
  demuxSampleAes(e, t, r) {
    const n = this.demux(e, r, !0, !this.config.progressive),
      i = (this.sampleAes = new cf(this.observer, this.config, t))
    return this.decrypt(n, i)
  }
  decrypt(e, t) {
    return new Promise((r) => {
      const { audioTrack: n, videoTrack: i } = e
      n.samples && n.segmentCodec === 'aac'
        ? t.decryptAacSamples(n.samples, 0, () => {
            i.samples
              ? t.decryptAvcSamples(i.samples, 0, 0, () => {
                  r(e)
                })
              : r(e)
          })
        : i.samples &&
          t.decryptAvcSamples(i.samples, 0, 0, () => {
            r(e)
          })
    })
  }
  destroy() {
    this._duration = 0
  }
  parseAVCPES(e, t, r, n) {
    const i = this.parseAVCNALu(e, r.data)
    let a = this.avcSample,
      o,
      l = !1
    ;(r.data = null),
      a && i.length && !e.audFound && (Mt(a, e), (a = this.avcSample = er(!1, r.pts, r.dts, ''))),
      i.forEach((u) => {
        var c
        switch (u.type) {
          case 1: {
            let d = !1
            o = !0
            const m = u.data
            if (l && m.length > 4) {
              const p = new qi(m).readSliceType()
              ;(p === 2 || p === 4 || p === 7 || p === 9) && (d = !0)
            }
            if (d) {
              var f
              ;(f = a) != null && f.frame && !a.key && (Mt(a, e), (a = this.avcSample = null))
            }
            a || (a = this.avcSample = er(!0, r.pts, r.dts, '')), (a.frame = !0), (a.key = d)
            break
          }
          case 5:
            ;(o = !0),
              (c = a) != null && c.frame && !a.key && (Mt(a, e), (a = this.avcSample = null)),
              a || (a = this.avcSample = er(!0, r.pts, r.dts, '')),
              (a.key = !0),
              (a.frame = !0)
            break
          case 6: {
            ;(o = !0), ra(u.data, 1, r.pts, t.samples)
            break
          }
          case 7:
            if (((o = !0), (l = !0), !e.sps)) {
              const d = u.data,
                p = new qi(d).readSPS()
              ;(e.width = p.width),
                (e.height = p.height),
                (e.pixelRatio = p.pixelRatio),
                (e.sps = [d]),
                (e.duration = this._duration)
              const v = d.subarray(1, 4)
              let E = 'avc1.'
              for (let x = 0; x < 3; x++) {
                let T = v[x].toString(16)
                T.length < 2 && (T = '0' + T), (E += T)
              }
              e.codec = E
            }
            break
          case 8:
            ;(o = !0), e.pps || (e.pps = [u.data])
            break
          case 9:
            ;(o = !1),
              (e.audFound = !0),
              a && Mt(a, e),
              (a = this.avcSample = er(!1, r.pts, r.dts, ''))
            break
          case 12:
            o = !0
            break
          default:
            ;(o = !1), a && (a.debug += 'unknown NAL ' + u.type + ' ')
            break
        }
        a && o && a.units.push(u)
      }),
      n && a && (Mt(a, e), (this.avcSample = null))
  }
  getLastNalUnit(e) {
    var t
    let r = this.avcSample,
      n
    if (((!r || r.units.length === 0) && (r = e[e.length - 1]), (t = r) != null && t.units)) {
      const i = r.units
      n = i[i.length - 1]
    }
    return n
  }
  parseAVCNALu(e, t) {
    const r = t.byteLength
    let n = e.naluState || 0
    const i = n,
      a = []
    let o = 0,
      l,
      u,
      c,
      f = -1,
      d = 0
    for (n === -1 && ((f = 0), (d = t[0] & 31), (n = 0), (o = 1)); o < r; ) {
      if (((l = t[o++]), !n)) {
        n = l ? 0 : 1
        continue
      }
      if (n === 1) {
        n = l ? 0 : 2
        continue
      }
      if (!l) n = 3
      else if (l === 1) {
        if (f >= 0) {
          const m = { data: t.subarray(f, o - n - 1), type: d }
          a.push(m)
        } else {
          const m = this.getLastNalUnit(e.samples)
          if (
            m &&
            (i && o <= 4 - i && m.state && (m.data = m.data.subarray(0, m.data.byteLength - i)),
            (u = o - n - 1),
            u > 0)
          ) {
            const p = new Uint8Array(m.data.byteLength + u)
            p.set(m.data, 0),
              p.set(t.subarray(0, u), m.data.byteLength),
              (m.data = p),
              (m.state = 0)
          }
        }
        o < r ? ((c = t[o] & 31), (f = o), (d = c), (n = 0)) : (n = -1)
      } else n = 0
    }
    if (f >= 0 && n >= 0) {
      const m = { data: t.subarray(f, r), type: d, state: n }
      a.push(m)
    }
    if (a.length === 0) {
      const m = this.getLastNalUnit(e.samples)
      if (m) {
        const p = new Uint8Array(m.data.byteLength + t.byteLength)
        p.set(m.data, 0), p.set(t, m.data.byteLength), (m.data = p)
      }
    }
    return (e.naluState = n), a
  }
  parseAACPES(e, t) {
    let r = 0
    const n = this.aacOverFlow
    let i = t.data
    if (n) {
      this.aacOverFlow = null
      const f = n.missing,
        d = n.sample.unit.byteLength
      if (f === -1) {
        const m = new Uint8Array(d + i.byteLength)
        m.set(n.sample.unit, 0), m.set(i, d), (i = m)
      } else {
        const m = d - f
        n.sample.unit.set(i.subarray(0, f), m), e.samples.push(n.sample), (r = n.missing)
      }
    }
    let a, o
    for (a = r, o = i.length; a < o - 1 && !gr(i, a); a++);
    if (a !== r) {
      let f
      const d = a < o - 1
      d
        ? (f = `AAC PES did not start with ADTS header,offset:${a}`)
        : (f = 'No ADTS header found in AAC PES')
      const m = new Error(f)
      if (
        (G.warn(`parsing error: ${f}`),
        this.observer.emit(O.ERROR, O.ERROR, {
          type: ne.MEDIA_ERROR,
          details: K.FRAG_PARSING_ERROR,
          fatal: !1,
          levelRetry: d,
          error: m,
          reason: f
        }),
        !d)
      )
        return
    }
    ya(e, this.observer, i, a, this.audioCodec)
    let l
    if (t.pts !== void 0) l = t.pts
    else if (n) {
      const f = va(e.samplerate)
      l = n.sample.pts + f
    } else {
      G.warn('[tsdemuxer]: AAC PES unknown PTS')
      return
    }
    let u = 0,
      c
    for (; a < o; )
      if (((c = _a(e, i, a, l, u)), (a += c.length), c.missing)) {
        this.aacOverFlow = c
        break
      } else for (u++; a < o - 1 && !gr(i, a); a++);
  }
  parseMPEGPES(e, t) {
    const r = t.data,
      n = r.length
    let i = 0,
      a = 0
    const o = t.pts
    if (o === void 0) {
      G.warn('[tsdemuxer]: MPEG PES unknown PTS')
      return
    }
    for (; a < n; )
      if (Sa(r, a)) {
        const l = Ea(e, r, a, o, i)
        if (l) (a += l.length), i++
        else break
      } else a++
  }
  parseID3PES(e, t) {
    if (t.pts === void 0) {
      G.warn('[tsdemuxer]: ID3 PES unknown PTS')
      return
    }
    const r = Te({}, t, {
      type: this._avcTrack ? Qe.emsg : Qe.audioId3,
      duration: Number.POSITIVE_INFINITY
    })
    e.samples.push(r)
  }
}
function er(s, e, t, r) {
  return { key: s, frame: !1, pts: e, dts: t, units: [], debug: r, length: 0 }
}
function Ln(s, e) {
  return ((s[e + 1] & 31) << 8) + s[e + 2]
}
function ff(s, e) {
  return ((s[e + 10] & 31) << 8) | s[e + 11]
}
function df(s, e, t, r) {
  const n = { audio: -1, avc: -1, id3: -1, segmentCodec: 'aac' },
    i = ((s[e + 1] & 15) << 8) | s[e + 2],
    a = e + 3 + i - 4,
    o = ((s[e + 10] & 15) << 8) | s[e + 11]
  for (e += 12 + o; e < a; ) {
    const l = Ln(s, e)
    switch (s[e]) {
      case 207:
        if (!r) {
          G.log('ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream')
          break
        }
      case 15:
        n.audio === -1 && (n.audio = l)
        break
      case 21:
        n.id3 === -1 && (n.id3 = l)
        break
      case 219:
        if (!r) {
          G.log('H.264 with AES-128-CBC slice encryption found in unencrypted stream')
          break
        }
      case 27:
        n.avc === -1 && (n.avc = l)
        break
      case 3:
      case 4:
        t.mpeg !== !0 && t.mp3 !== !0
          ? G.log('MPEG audio found, not supported in this browser')
          : n.audio === -1 && ((n.audio = l), (n.segmentCodec = 'mp3'))
        break
      case 36:
        G.warn('Unsupported HEVC stream type found')
        break
    }
    e += (((s[e + 3] & 15) << 8) | s[e + 4]) + 5
  }
  return n
}
function At(s) {
  let e = 0,
    t,
    r,
    n,
    i,
    a
  const o = s.data
  if (!s || s.size === 0) return null
  for (; o[0].length < 19 && o.length > 1; ) {
    const u = new Uint8Array(o[0].length + o[1].length)
    u.set(o[0]), u.set(o[1], o[0].length), (o[0] = u), o.splice(1, 1)
  }
  if (((t = o[0]), (t[0] << 16) + (t[1] << 8) + t[2] === 1)) {
    if (((r = (t[4] << 8) + t[5]), r && r > s.size - 6)) return null
    const u = t[7]
    u & 192 &&
      ((i =
        (t[9] & 14) * 536870912 +
        (t[10] & 255) * 4194304 +
        (t[11] & 254) * 16384 +
        (t[12] & 255) * 128 +
        (t[13] & 254) / 2),
      u & 64
        ? ((a =
            (t[14] & 14) * 536870912 +
            (t[15] & 255) * 4194304 +
            (t[16] & 254) * 16384 +
            (t[17] & 255) * 128 +
            (t[18] & 254) / 2),
          i - a > 60 * 9e4 &&
            (G.warn(`${Math.round((i - a) / 9e4)}s delta between PTS and DTS, align them`),
            (i = a)))
        : (a = i)),
      (n = t[8])
    let c = n + 9
    if (s.size <= c) return null
    s.size -= c
    const f = new Uint8Array(s.size)
    for (let d = 0, m = o.length; d < m; d++) {
      t = o[d]
      let p = t.byteLength
      if (c)
        if (c > p) {
          c -= p
          continue
        } else (t = t.subarray(c)), (p -= c), (c = 0)
      f.set(t, e), (e += p)
    }
    return r && (r -= n + 3), { data: f, pts: i, dts: a, len: r }
  }
  return null
}
function Mt(s, e) {
  if (s.units.length && s.frame) {
    if (s.pts === void 0) {
      const t = e.samples,
        r = t.length
      if (r) {
        const n = t[r - 1]
        ;(s.pts = n.pts), (s.dts = n.dts)
      } else {
        e.dropped++
        return
      }
    }
    e.samples.push(s)
  }
  s.debug.length && G.log(s.pts + '/' + s.dts + ':' + s.debug)
}
class hf extends pa {
  resetInitSegment(e, t, r, n) {
    super.resetInitSegment(e, t, r, n),
      (this._audioTrack = {
        container: 'audio/mpeg',
        type: 'audio',
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: 'mp3',
        samples: [],
        manifestCodec: t,
        duration: n,
        inputTimeScale: 9e4,
        dropped: 0
      })
  }
  static probe(e) {
    if (!e) return !1
    let r = (fr(e, 0) || []).length
    for (let n = e.length; r < n; r++)
      if (uf(e, r)) return G.log('MPEG Audio sync word found !'), !0
    return !1
  }
  canParse(e, t) {
    return lf(e, t)
  }
  appendFrame(e, t, r) {
    if (this.basePTS !== null) return Ea(e, t, r, this.basePTS, this.frameIndex)
  }
}
class Xi {
  static getSilentFrame(e, t) {
    switch (e) {
      case 'mp4a.40.2':
        if (t === 1) return new Uint8Array([0, 200, 0, 128, 35, 128])
        if (t === 2) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128])
        if (t === 3) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142])
        if (t === 4)
          return new Uint8Array([
            0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56
          ])
        if (t === 5)
          return new Uint8Array([
            0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56
          ])
        if (t === 6)
          return new Uint8Array([
            0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178,
            0, 32, 8, 224
          ])
        break
      default:
        if (t === 1)
          return new Uint8Array([
            1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90,
            90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
            90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94
          ])
        if (t === 2)
          return new Uint8Array([
            1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90,
            90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
            90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94
          ])
        if (t === 3)
          return new Uint8Array([
            1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90,
            90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
            90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94
          ])
        break
    }
  }
}
const lt = Math.pow(2, 32) - 1
class $ {
  static init() {
    $.types = {
      avc1: [],
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      '.mp3': [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    }
    let e
    for (e in $.types)
      $.types.hasOwnProperty(e) &&
        ($.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)])
    const t = new Uint8Array([
        0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105,
        100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0
      ]),
      r = new Uint8Array([
        0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111,
        117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0
      ])
    $.HDLR_TYPES = { video: t, audio: r }
    const n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
      i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0])
    ;($.STTS = $.STSC = $.STCO = i),
      ($.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])),
      ($.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0])),
      ($.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0])),
      ($.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]))
    const a = new Uint8Array([105, 115, 111, 109]),
      o = new Uint8Array([97, 118, 99, 49]),
      l = new Uint8Array([0, 0, 0, 1])
    ;($.FTYP = $.box($.types.ftyp, a, l, a, o)),
      ($.DINF = $.box($.types.dinf, $.box($.types.dref, n)))
  }
  static box(e, ...t) {
    let r = 8,
      n = t.length
    const i = n
    for (; n--; ) r += t[n].byteLength
    const a = new Uint8Array(r)
    for (
      a[0] = (r >> 24) & 255,
        a[1] = (r >> 16) & 255,
        a[2] = (r >> 8) & 255,
        a[3] = r & 255,
        a.set(e, 4),
        n = 0,
        r = 8;
      n < i;
      n++
    )
      a.set(t[n], r), (r += t[n].byteLength)
    return a
  }
  static hdlr(e) {
    return $.box($.types.hdlr, $.HDLR_TYPES[e])
  }
  static mdat(e) {
    return $.box($.types.mdat, e)
  }
  static mdhd(e, t) {
    t *= e
    const r = Math.floor(t / (lt + 1)),
      n = Math.floor(t % (lt + 1))
    return $.box(
      $.types.mdhd,
      new Uint8Array([
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        3,
        (e >> 24) & 255,
        (e >> 16) & 255,
        (e >> 8) & 255,
        e & 255,
        r >> 24,
        (r >> 16) & 255,
        (r >> 8) & 255,
        r & 255,
        n >> 24,
        (n >> 16) & 255,
        (n >> 8) & 255,
        n & 255,
        85,
        196,
        0,
        0
      ])
    )
  }
  static mdia(e) {
    return $.box($.types.mdia, $.mdhd(e.timescale, e.duration), $.hdlr(e.type), $.minf(e))
  }
  static mfhd(e) {
    return $.box(
      $.types.mfhd,
      new Uint8Array([0, 0, 0, 0, e >> 24, (e >> 16) & 255, (e >> 8) & 255, e & 255])
    )
  }
  static minf(e) {
    return e.type === 'audio'
      ? $.box($.types.minf, $.box($.types.smhd, $.SMHD), $.DINF, $.stbl(e))
      : $.box($.types.minf, $.box($.types.vmhd, $.VMHD), $.DINF, $.stbl(e))
  }
  static moof(e, t, r) {
    return $.box($.types.moof, $.mfhd(e), $.traf(r, t))
  }
  static moov(e) {
    let t = e.length
    const r = []
    for (; t--; ) r[t] = $.trak(e[t])
    return $.box.apply(
      null,
      [$.types.moov, $.mvhd(e[0].timescale, e[0].duration)].concat(r).concat($.mvex(e))
    )
  }
  static mvex(e) {
    let t = e.length
    const r = []
    for (; t--; ) r[t] = $.trex(e[t])
    return $.box.apply(null, [$.types.mvex, ...r])
  }
  static mvhd(e, t) {
    t *= e
    const r = Math.floor(t / (lt + 1)),
      n = Math.floor(t % (lt + 1)),
      i = new Uint8Array([
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        3,
        (e >> 24) & 255,
        (e >> 16) & 255,
        (e >> 8) & 255,
        e & 255,
        r >> 24,
        (r >> 16) & 255,
        (r >> 8) & 255,
        r & 255,
        n >> 24,
        (n >> 16) & 255,
        (n >> 8) & 255,
        n & 255,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        255,
        255,
        255,
        255
      ])
    return $.box($.types.mvhd, i)
  }
  static sdtp(e) {
    const t = e.samples || [],
      r = new Uint8Array(4 + t.length)
    let n, i
    for (n = 0; n < t.length; n++)
      (i = t[n].flags), (r[n + 4] = (i.dependsOn << 4) | (i.isDependedOn << 2) | i.hasRedundancy)
    return $.box($.types.sdtp, r)
  }
  static stbl(e) {
    return $.box(
      $.types.stbl,
      $.stsd(e),
      $.box($.types.stts, $.STTS),
      $.box($.types.stsc, $.STSC),
      $.box($.types.stsz, $.STSZ),
      $.box($.types.stco, $.STCO)
    )
  }
  static avc1(e) {
    let t = [],
      r = [],
      n,
      i,
      a
    for (n = 0; n < e.sps.length; n++)
      (i = e.sps[n]),
        (a = i.byteLength),
        t.push((a >>> 8) & 255),
        t.push(a & 255),
        (t = t.concat(Array.prototype.slice.call(i)))
    for (n = 0; n < e.pps.length; n++)
      (i = e.pps[n]),
        (a = i.byteLength),
        r.push((a >>> 8) & 255),
        r.push(a & 255),
        (r = r.concat(Array.prototype.slice.call(i)))
    const o = $.box(
        $.types.avcC,
        new Uint8Array(
          [1, t[3], t[4], t[5], 255, 224 | e.sps.length].concat(t).concat([e.pps.length]).concat(r)
        )
      ),
      l = e.width,
      u = e.height,
      c = e.pixelRatio[0],
      f = e.pixelRatio[1]
    return $.box(
      $.types.avc1,
      new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        (l >> 8) & 255,
        l & 255,
        (u >> 8) & 255,
        u & 255,
        0,
        72,
        0,
        0,
        0,
        72,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        18,
        100,
        97,
        105,
        108,
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        17,
        17
      ]),
      o,
      $.box($.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])),
      $.box(
        $.types.pasp,
        new Uint8Array([
          c >> 24,
          (c >> 16) & 255,
          (c >> 8) & 255,
          c & 255,
          f >> 24,
          (f >> 16) & 255,
          (f >> 8) & 255,
          f & 255
        ])
      )
    )
  }
  static esds(e) {
    const t = e.config.length
    return new Uint8Array(
      [0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5]
        .concat([t])
        .concat(e.config)
        .concat([6, 1, 2])
    )
  }
  static mp4a(e) {
    const t = e.samplerate
    return $.box(
      $.types.mp4a,
      new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        e.channelCount,
        0,
        16,
        0,
        0,
        0,
        0,
        (t >> 8) & 255,
        t & 255,
        0,
        0
      ]),
      $.box($.types.esds, $.esds(e))
    )
  }
  static mp3(e) {
    const t = e.samplerate
    return $.box(
      $.types['.mp3'],
      new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        e.channelCount,
        0,
        16,
        0,
        0,
        0,
        0,
        (t >> 8) & 255,
        t & 255,
        0,
        0
      ])
    )
  }
  static stsd(e) {
    return e.type === 'audio'
      ? e.segmentCodec === 'mp3' && e.codec === 'mp3'
        ? $.box($.types.stsd, $.STSD, $.mp3(e))
        : $.box($.types.stsd, $.STSD, $.mp4a(e))
      : $.box($.types.stsd, $.STSD, $.avc1(e))
  }
  static tkhd(e) {
    const t = e.id,
      r = e.duration * e.timescale,
      n = e.width,
      i = e.height,
      a = Math.floor(r / (lt + 1)),
      o = Math.floor(r % (lt + 1))
    return $.box(
      $.types.tkhd,
      new Uint8Array([
        1,
        0,
        0,
        7,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        3,
        (t >> 24) & 255,
        (t >> 16) & 255,
        (t >> 8) & 255,
        t & 255,
        0,
        0,
        0,
        0,
        a >> 24,
        (a >> 16) & 255,
        (a >> 8) & 255,
        a & 255,
        o >> 24,
        (o >> 16) & 255,
        (o >> 8) & 255,
        o & 255,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        (n >> 8) & 255,
        n & 255,
        0,
        0,
        (i >> 8) & 255,
        i & 255,
        0,
        0
      ])
    )
  }
  static traf(e, t) {
    const r = $.sdtp(e),
      n = e.id,
      i = Math.floor(t / (lt + 1)),
      a = Math.floor(t % (lt + 1))
    return $.box(
      $.types.traf,
      $.box(
        $.types.tfhd,
        new Uint8Array([0, 0, 0, 0, n >> 24, (n >> 16) & 255, (n >> 8) & 255, n & 255])
      ),
      $.box(
        $.types.tfdt,
        new Uint8Array([
          1,
          0,
          0,
          0,
          i >> 24,
          (i >> 16) & 255,
          (i >> 8) & 255,
          i & 255,
          a >> 24,
          (a >> 16) & 255,
          (a >> 8) & 255,
          a & 255
        ])
      ),
      $.trun(e, r.length + 16 + 20 + 8 + 16 + 8 + 8),
      r
    )
  }
  static trak(e) {
    return (e.duration = e.duration || 4294967295), $.box($.types.trak, $.tkhd(e), $.mdia(e))
  }
  static trex(e) {
    const t = e.id
    return $.box(
      $.types.trex,
      new Uint8Array([
        0,
        0,
        0,
        0,
        t >> 24,
        (t >> 16) & 255,
        (t >> 8) & 255,
        t & 255,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        1
      ])
    )
  }
  static trun(e, t) {
    const r = e.samples || [],
      n = r.length,
      i = 12 + 16 * n,
      a = new Uint8Array(i)
    let o, l, u, c, f, d
    for (
      t += 8 + i,
        a.set(
          [
            e.type === 'video' ? 1 : 0,
            0,
            15,
            1,
            (n >>> 24) & 255,
            (n >>> 16) & 255,
            (n >>> 8) & 255,
            n & 255,
            (t >>> 24) & 255,
            (t >>> 16) & 255,
            (t >>> 8) & 255,
            t & 255
          ],
          0
        ),
        o = 0;
      o < n;
      o++
    )
      (l = r[o]),
        (u = l.duration),
        (c = l.size),
        (f = l.flags),
        (d = l.cts),
        a.set(
          [
            (u >>> 24) & 255,
            (u >>> 16) & 255,
            (u >>> 8) & 255,
            u & 255,
            (c >>> 24) & 255,
            (c >>> 16) & 255,
            (c >>> 8) & 255,
            c & 255,
            (f.isLeading << 2) | f.dependsOn,
            (f.isDependedOn << 6) | (f.hasRedundancy << 4) | (f.paddingValue << 1) | f.isNonSync,
            f.degradPrio & 61440,
            f.degradPrio & 15,
            (d >>> 24) & 255,
            (d >>> 16) & 255,
            (d >>> 8) & 255,
            d & 255
          ],
          12 + 16 * o
        )
    return $.box($.types.trun, a)
  }
  static initSegment(e) {
    $.types || $.init()
    const t = $.moov(e),
      r = new Uint8Array($.FTYP.byteLength + t.byteLength)
    return r.set($.FTYP), r.set(t, $.FTYP.byteLength), r
  }
}
$.types = void 0
$.HDLR_TYPES = void 0
$.STTS = void 0
$.STSC = void 0
$.STCO = void 0
$.STSZ = void 0
$.VMHD = void 0
$.SMHD = void 0
$.STSD = void 0
$.FTYP = void 0
$.DINF = void 0
const Ta = 9e4
function jn(s, e, t = 1, r = !1) {
  const n = s * e * t
  return r ? Math.round(n) : n
}
function pf(s, e, t = 1, r = !1) {
  return jn(s, e, 1 / t, r)
}
function Ft(s, e = !1) {
  return jn(s, 1e3, 1 / Ta, e)
}
function mf(s, e = 1) {
  return jn(s, Ta, 1 / e)
}
const gf = 10 * 1e3,
  Qi = 1024,
  yf = 1152
let tr = null,
  Zr = null
class Jr {
  constructor(e, t, r, n = '') {
    if (
      ((this.observer = void 0),
      (this.config = void 0),
      (this.typeSupported = void 0),
      (this.ISGenerated = !1),
      (this._initPTS = null),
      (this._initDTS = null),
      (this.nextAvcDts = null),
      (this.nextAudioPts = null),
      (this.videoSampleDuration = null),
      (this.isAudioContiguous = !1),
      (this.isVideoContiguous = !1),
      (this.observer = e),
      (this.config = t),
      (this.typeSupported = r),
      (this.ISGenerated = !1),
      tr === null)
    ) {
      const a = (navigator.userAgent || '').match(/Chrome\/(\d+)/i)
      tr = a ? parseInt(a[1]) : 0
    }
    if (Zr === null) {
      const i = navigator.userAgent.match(/Safari\/(\d+)/i)
      Zr = i ? parseInt(i[1]) : 0
    }
  }
  destroy() {}
  resetTimeStamp(e) {
    G.log('[mp4-remuxer]: initPTS & initDTS reset'), (this._initPTS = this._initDTS = e)
  }
  resetNextTimestamp() {
    G.log('[mp4-remuxer]: reset next timestamp'),
      (this.isVideoContiguous = !1),
      (this.isAudioContiguous = !1)
  }
  resetInitSegment() {
    G.log('[mp4-remuxer]: ISGenerated flag reset'), (this.ISGenerated = !1)
  }
  getVideoStartPts(e) {
    let t = !1
    const r = e.reduce((n, i) => {
      const a = i.pts - n
      return a < -4294967296 ? ((t = !0), qe(n, i.pts)) : a > 0 ? n : i.pts
    }, e[0].pts)
    return t && G.debug('PTS rollover detected'), r
  }
  remux(e, t, r, n, i, a, o, l) {
    let u,
      c,
      f,
      d,
      m,
      p,
      v = i,
      E = i
    const x = e.pid > -1,
      T = t.pid > -1,
      b = t.samples.length,
      R = e.samples.length > 0,
      g = (o && b > 0) || b > 1
    if (((!x || R) && (!T || g)) || this.ISGenerated || o) {
      this.ISGenerated || (f = this.generateIS(e, t, i, a))
      const S = this.isVideoContiguous
      let h = -1,
        _
      if (g && ((h = vf(t.samples)), !S && this.config.forceKeyFrameOnDiscontinuity))
        if (((p = !0), h > 0)) {
          G.warn(`[mp4-remuxer]: Dropped ${h} out of ${b} video samples due to a missing keyframe`)
          const y = this.getVideoStartPts(t.samples)
          ;(t.samples = t.samples.slice(h)),
            (t.dropped += h),
            (E += (t.samples[0].pts - y) / t.inputTimeScale),
            (_ = E)
        } else
          h === -1 &&
            (G.warn(`[mp4-remuxer]: No keyframe found out of ${b} video samples`), (p = !1))
      if (this.ISGenerated) {
        if (R && g) {
          const y = this.getVideoStartPts(t.samples),
            I = (qe(e.samples[0].pts, y) - y) / t.inputTimeScale
          ;(v += Math.max(0, I)), (E += Math.max(0, -I))
        }
        if (R) {
          if (
            (e.samplerate ||
              (G.warn('[mp4-remuxer]: regenerate InitSegment as audio detected'),
              (f = this.generateIS(e, t, i, a))),
            (c = this.remuxAudio(
              e,
              v,
              this.isAudioContiguous,
              a,
              T || g || l === ie.AUDIO ? E : void 0
            )),
            g)
          ) {
            const y = c ? c.endPTS - c.startPTS : 0
            t.inputTimeScale ||
              (G.warn('[mp4-remuxer]: regenerate InitSegment as video detected'),
              (f = this.generateIS(e, t, i, a))),
              (u = this.remuxVideo(t, E, S, y))
          }
        } else g && (u = this.remuxVideo(t, E, S, 0))
        u && ((u.firstKeyFrame = h), (u.independent = h !== -1), (u.firstKeyFramePTS = _))
      }
    }
    return (
      this.ISGenerated &&
        this._initPTS &&
        this._initDTS &&
        (r.samples.length && (m = ba(r, i, this._initPTS, this._initDTS)),
        n.samples.length && (d = La(n, i, this._initPTS))),
      { audio: c, video: u, initSegment: f, independent: p, text: d, id3: m }
    )
  }
  generateIS(e, t, r, n) {
    const i = e.samples,
      a = t.samples,
      o = this.typeSupported,
      l = {},
      u = this._initPTS
    let c = !u || n,
      f = 'audio/mp4',
      d,
      m,
      p
    if ((c && (d = m = 1 / 0), e.config && i.length)) {
      switch (((e.timescale = e.samplerate), e.segmentCodec)) {
        case 'mp3':
          o.mpeg ? ((f = 'audio/mpeg'), (e.codec = '')) : o.mp3 && (e.codec = 'mp3')
          break
      }
      ;(l.audio = {
        id: 'audio',
        container: f,
        codec: e.codec,
        initSegment: e.segmentCodec === 'mp3' && o.mpeg ? new Uint8Array(0) : $.initSegment([e]),
        metadata: { channelCount: e.channelCount }
      }),
        c &&
          ((p = e.inputTimeScale),
          !u || p !== u.timescale ? (d = m = i[0].pts - Math.round(p * r)) : (c = !1))
    }
    if (
      t.sps &&
      t.pps &&
      a.length &&
      ((t.timescale = t.inputTimeScale),
      (l.video = {
        id: 'main',
        container: 'video/mp4',
        codec: t.codec,
        initSegment: $.initSegment([t]),
        metadata: { width: t.width, height: t.height }
      }),
      c)
    )
      if (((p = t.inputTimeScale), !u || p !== u.timescale)) {
        const v = this.getVideoStartPts(a),
          E = Math.round(p * r)
        ;(m = Math.min(m, qe(a[0].dts, v) - E)), (d = Math.min(d, v - E))
      } else c = !1
    if (Object.keys(l).length)
      return (
        (this.ISGenerated = !0),
        c
          ? ((this._initPTS = { baseTime: d, timescale: p }),
            (this._initDTS = { baseTime: m, timescale: p }))
          : (d = p = void 0),
        { tracks: l, initPTS: d, timescale: p }
      )
  }
  remuxVideo(e, t, r, n) {
    const i = e.inputTimeScale,
      a = e.samples,
      o = [],
      l = a.length,
      u = this._initPTS
    let c = this.nextAvcDts,
      f = 8,
      d = this.videoSampleDuration,
      m,
      p,
      v = Number.POSITIVE_INFINITY,
      E = Number.NEGATIVE_INFINITY,
      x = !1
    if (!r || c === null) {
      const w = t * i,
        U = a[0].pts - qe(a[0].dts, a[0].pts)
      c = w - U
    }
    const T = (u.baseTime * i) / u.timescale
    for (let w = 0; w < l; w++) {
      const U = a[w]
      ;(U.pts = qe(U.pts - T, c)),
        (U.dts = qe(U.dts - T, c)),
        U.dts < a[w > 0 ? w - 1 : w].dts && (x = !0)
    }
    x &&
      a.sort(function (w, U) {
        const F = w.dts - U.dts,
          k = w.pts - U.pts
        return F || k
      }),
      (m = a[0].dts),
      (p = a[a.length - 1].dts)
    const b = p - m,
      R = b ? Math.round(b / (l - 1)) : d || e.inputTimeScale / 30
    if (r) {
      const w = m - c,
        U = w > R,
        F = w < -1
      if (
        (U || F) &&
        (U
          ? G.warn(`AVC: ${Ft(w, !0)} ms (${w}dts) hole between fragments detected, filling it`)
          : G.warn(`AVC: ${Ft(-w, !0)} ms (${w}dts) overlapping between fragments detected`),
        !F || c >= a[0].pts)
      ) {
        m = c
        const k = a[0].pts - w
        ;(a[0].dts = m),
          (a[0].pts = k),
          G.log(`Video: First PTS/DTS adjusted: ${Ft(k, !0)}/${Ft(m, !0)}, delta: ${Ft(w, !0)} ms`)
      }
    }
    m = Math.max(0, m)
    let g = 0,
      A = 0
    for (let w = 0; w < l; w++) {
      const U = a[w],
        F = U.units,
        k = F.length
      let B = 0
      for (let V = 0; V < k; V++) B += F[V].data.length
      ;(A += B),
        (g += k),
        (U.length = B),
        (U.dts = Math.max(U.dts, m)),
        (v = Math.min(U.pts, v)),
        (E = Math.max(U.pts, E))
    }
    p = a[l - 1].dts
    const S = A + 4 * g + 8
    let h
    try {
      h = new Uint8Array(S)
    } catch (w) {
      this.observer.emit(O.ERROR, O.ERROR, {
        type: ne.MUX_ERROR,
        details: K.REMUX_ALLOC_ERROR,
        fatal: !1,
        error: w,
        bytes: S,
        reason: `fail allocating video mdat ${S}`
      })
      return
    }
    const _ = new DataView(h.buffer)
    _.setUint32(0, S), h.set($.types.mdat, 4)
    let y = !1,
      L = Number.POSITIVE_INFINITY,
      I = Number.POSITIVE_INFINITY,
      P = Number.NEGATIVE_INFINITY,
      D = Number.NEGATIVE_INFINITY
    for (let w = 0; w < l; w++) {
      const U = a[w],
        F = U.units
      let k = 0
      for (let H = 0, q = F.length; H < q; H++) {
        const X = F[H],
          Q = X.data,
          ae = X.data.byteLength
        _.setUint32(f, ae), (f += 4), h.set(Q, f), (f += ae), (k += 4 + ae)
      }
      let B
      if (w < l - 1) (d = a[w + 1].dts - U.dts), (B = a[w + 1].pts - U.pts)
      else {
        const H = this.config,
          q = w > 0 ? U.dts - a[w - 1].dts : R
        if (
          ((B = w > 0 ? U.pts - a[w - 1].pts : R),
          H.stretchShortVideoTrack && this.nextAudioPts !== null)
        ) {
          const X = Math.floor(H.maxBufferHole * i),
            Q = (n ? v + n * i : this.nextAudioPts) - U.pts
          Q > X
            ? ((d = Q - q),
              d < 0 ? (d = q) : (y = !0),
              G.log(
                `[mp4-remuxer]: It is approximately ${
                  Q / 90
                } ms to the next segment; using duration ${d / 90} ms for the last video frame.`
              ))
            : (d = q)
        } else d = q
      }
      const V = Math.round(U.pts - U.dts)
      ;(L = Math.min(L, d)),
        (P = Math.max(P, d)),
        (I = Math.min(I, B)),
        (D = Math.max(D, B)),
        o.push(new Zi(U.key, d, k, V))
    }
    if (o.length) {
      if (tr) {
        if (tr < 70) {
          const w = o[0].flags
          ;(w.dependsOn = 2), (w.isNonSync = 0)
        }
      } else if (Zr && D - I < P - L && R / P < 0.025 && o[0].cts === 0) {
        G.warn(
          'Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.'
        )
        let w = m
        for (let U = 0, F = o.length; U < F; U++) {
          const k = w + o[U].duration,
            B = w + o[U].cts
          if (U < F - 1) {
            const V = k + o[U + 1].cts
            o[U].duration = V - B
          } else o[U].duration = U ? o[U - 1].duration : R
          ;(o[U].cts = 0), (w = k)
        }
      }
    }
    ;(d = y || !d ? R : d),
      (this.nextAvcDts = c = p + d),
      (this.videoSampleDuration = d),
      (this.isVideoContiguous = !0)
    const C = $.moof(e.sequenceNumber++, m, Te({}, e, { samples: o })),
      N = 'video',
      M = {
        data1: C,
        data2: h,
        startPTS: v / i,
        endPTS: (E + d) / i,
        startDTS: m / i,
        endDTS: c / i,
        type: N,
        hasAudio: !1,
        hasVideo: !0,
        nb: o.length,
        dropped: e.dropped
      }
    return (e.samples = []), (e.dropped = 0), M
  }
  remuxAudio(e, t, r, n, i) {
    const a = e.inputTimeScale,
      o = e.samplerate ? e.samplerate : a,
      l = a / o,
      u = e.segmentCodec === 'aac' ? Qi : yf,
      c = u * l,
      f = this._initPTS,
      d = e.segmentCodec === 'mp3' && this.typeSupported.mpeg,
      m = [],
      p = i !== void 0
    let v = e.samples,
      E = d ? 0 : 8,
      x = this.nextAudioPts || -1
    const T = t * a,
      b = (f.baseTime * a) / f.timescale
    if (
      ((this.isAudioContiguous = r =
        r ||
        (v.length &&
          x > 0 &&
          ((n && Math.abs(T - x) < 9e3) || Math.abs(qe(v[0].pts - b, T) - x) < 20 * c))),
      v.forEach(function (N) {
        N.pts = qe(N.pts - b, T)
      }),
      !r || x < 0)
    ) {
      if (((v = v.filter((N) => N.pts >= 0)), !v.length)) return
      i === 0 ? (x = 0) : n && !p ? (x = Math.max(0, T)) : (x = v[0].pts)
    }
    if (e.segmentCodec === 'aac') {
      const N = this.config.maxAudioFramesDrift
      for (let M = 0, w = x; M < v.length; M++) {
        const U = v[M],
          F = U.pts,
          k = F - w,
          B = Math.abs((1e3 * k) / a)
        if (k <= -N * c && p)
          M === 0 &&
            (G.warn(
              `Audio frame @ ${(F / a).toFixed(3)}s overlaps nextAudioPts by ${Math.round(
                (1e3 * k) / a
              )} ms.`
            ),
            (this.nextAudioPts = x = w = F))
        else if (k >= N * c && B < gf && p) {
          let V = Math.round(k / c)
          ;(w = F - V * c),
            w < 0 && (V--, (w += c)),
            M === 0 && (this.nextAudioPts = x = w),
            G.warn(
              `[mp4-remuxer]: Injecting ${V} audio frame @ ${(w / a).toFixed(
                3
              )}s due to ${Math.round((1e3 * k) / a)} ms gap.`
            )
          for (let H = 0; H < V; H++) {
            const q = Math.max(w, 0)
            let X = Xi.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)
            X ||
              (G.log(
                '[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.'
              ),
              (X = U.unit.subarray())),
              v.splice(M, 0, { unit: X, pts: q }),
              (w += c),
              M++
          }
        }
        ;(U.pts = w), (w += c)
      }
    }
    let R = null,
      g = null,
      A,
      S = 0,
      h = v.length
    for (; h--; ) S += v[h].unit.byteLength
    for (let N = 0, M = v.length; N < M; N++) {
      const w = v[N],
        U = w.unit
      let F = w.pts
      if (g !== null) {
        const B = m[N - 1]
        B.duration = Math.round((F - g) / l)
      } else if ((r && e.segmentCodec === 'aac' && (F = x), (R = F), S > 0)) {
        S += E
        try {
          A = new Uint8Array(S)
        } catch (B) {
          this.observer.emit(O.ERROR, O.ERROR, {
            type: ne.MUX_ERROR,
            details: K.REMUX_ALLOC_ERROR,
            fatal: !1,
            error: B,
            bytes: S,
            reason: `fail allocating audio mdat ${S}`
          })
          return
        }
        d || (new DataView(A.buffer).setUint32(0, S), A.set($.types.mdat, 4))
      } else return
      A.set(U, E)
      const k = U.byteLength
      ;(E += k), m.push(new Zi(!0, u, k, 0)), (g = F)
    }
    const _ = m.length
    if (!_) return
    const y = m[m.length - 1]
    this.nextAudioPts = x = g + l * y.duration
    const L = d ? new Uint8Array(0) : $.moof(e.sequenceNumber++, R / l, Te({}, e, { samples: m }))
    e.samples = []
    const I = R / a,
      P = x / a,
      C = {
        data1: L,
        data2: A,
        startPTS: I,
        endPTS: P,
        startDTS: I,
        endDTS: P,
        type: 'audio',
        hasAudio: !0,
        hasVideo: !1,
        nb: _
      }
    return (this.isAudioContiguous = !0), C
  }
  remuxEmptyAudio(e, t, r, n) {
    const i = e.inputTimeScale,
      a = e.samplerate ? e.samplerate : i,
      o = i / a,
      l = this.nextAudioPts,
      u = this._initDTS,
      c = (u.baseTime * 9e4) / u.timescale,
      f = (l !== null ? l : n.startDTS * i) + c,
      d = n.endDTS * i + c,
      m = o * Qi,
      p = Math.ceil((d - f) / m),
      v = Xi.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)
    if ((G.warn('[mp4-remuxer]: remux empty Audio'), !v)) {
      G.trace(
        '[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec'
      )
      return
    }
    const E = []
    for (let x = 0; x < p; x++) {
      const T = f + x * m
      E.push({ unit: v, pts: T, dts: T })
    }
    return (e.samples = E), this.remuxAudio(e, t, r, !1)
  }
}
function qe(s, e) {
  let t
  if (e === null) return s
  for (e < s ? (t = -8589934592) : (t = 8589934592); Math.abs(s - e) > 4294967296; ) s += t
  return s
}
function vf(s) {
  for (let e = 0; e < s.length; e++) if (s[e].key) return e
  return -1
}
function ba(s, e, t, r) {
  const n = s.samples.length
  if (!n) return
  const i = s.inputTimeScale
  for (let o = 0; o < n; o++) {
    const l = s.samples[o]
    ;(l.pts = qe(l.pts - (t.baseTime * i) / t.timescale, e * i) / i),
      (l.dts = qe(l.dts - (r.baseTime * i) / r.timescale, e * i) / i)
  }
  const a = s.samples
  return (s.samples = []), { samples: a }
}
function La(s, e, t) {
  const r = s.samples.length
  if (!r) return
  const n = s.inputTimeScale
  for (let a = 0; a < r; a++) {
    const o = s.samples[a]
    o.pts = qe(o.pts - (t.baseTime * n) / t.timescale, e * n) / n
  }
  s.samples.sort((a, o) => a.pts - o.pts)
  const i = s.samples
  return (s.samples = []), { samples: i }
}
class Zi {
  constructor(e, t, r, n) {
    ;(this.size = void 0),
      (this.duration = void 0),
      (this.cts = void 0),
      (this.flags = void 0),
      (this.duration = t),
      (this.size = r),
      (this.cts = n),
      (this.flags = new _f(e))
  }
}
class _f {
  constructor(e) {
    ;(this.isLeading = 0),
      (this.isDependedOn = 0),
      (this.hasRedundancy = 0),
      (this.degradPrio = 0),
      (this.dependsOn = 1),
      (this.isNonSync = 1),
      (this.dependsOn = e ? 2 : 1),
      (this.isNonSync = e ? 0 : 1)
  }
}
class Ef {
  constructor() {
    ;(this.emitInitSegment = !1),
      (this.audioCodec = void 0),
      (this.videoCodec = void 0),
      (this.initData = void 0),
      (this.initPTS = null),
      (this.initTracks = void 0),
      (this.lastEndTime = null)
  }
  destroy() {}
  resetTimeStamp(e) {
    ;(this.initPTS = e), (this.lastEndTime = null)
  }
  resetNextTimestamp() {
    this.lastEndTime = null
  }
  resetInitSegment(e, t, r, n) {
    ;(this.audioCodec = t),
      (this.videoCodec = r),
      this.generateInitSegment(Bu(e, n)),
      (this.emitInitSegment = !0)
  }
  generateInitSegment(e) {
    let { audioCodec: t, videoCodec: r } = this
    if (!(e != null && e.byteLength)) {
      ;(this.initTracks = void 0), (this.initData = void 0)
      return
    }
    const n = (this.initData = ea(e))
    t || (t = Ji(n.audio, pe.AUDIO)), r || (r = Ji(n.video, pe.VIDEO))
    const i = {}
    n.audio && n.video
      ? (i.audiovideo = { container: 'video/mp4', codec: t + ',' + r, initSegment: e, id: 'main' })
      : n.audio
      ? (i.audio = { container: 'audio/mp4', codec: t, initSegment: e, id: 'audio' })
      : n.video
      ? (i.video = { container: 'video/mp4', codec: r, initSegment: e, id: 'main' })
      : G.warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.'),
      (this.initTracks = i)
  }
  remux(e, t, r, n, i, a) {
    var o, l
    let { initPTS: u, lastEndTime: c } = this
    const f = { audio: void 0, video: void 0, text: n, id3: r, initSegment: void 0 }
    J(c) || (c = this.lastEndTime = i || 0)
    const d = t.samples
    if (!(d != null && d.length)) return f
    const m = { initPTS: void 0, timescale: 1 }
    let p = this.initData
    if (
      (((o = p) != null && o.length) || (this.generateInitSegment(d), (p = this.initData)),
      !((l = p) != null && l.length))
    )
      return G.warn('[passthrough-remuxer.ts]: Failed to generate initSegment.'), f
    this.emitInitSegment && ((m.tracks = this.initTracks), (this.emitInitSegment = !1))
    const v = $u(d, p),
      E = Gu(p, d),
      x = E === null ? i : E
    ;(xf(u, x, i, v) || (m.timescale !== u.timescale && a)) &&
      ((m.initPTS = x - i),
      u && u.timescale === 1 && G.warn(`Adjusting initPTS by ${m.initPTS - u.baseTime}`),
      (this.initPTS = u = { baseTime: m.initPTS, timescale: 1 }))
    const T = e ? x - u.baseTime / u.timescale : c,
      b = T + v
    ju(p, d, u.baseTime / u.timescale),
      v > 0
        ? (this.lastEndTime = b)
        : (G.warn('Duration parsed from mp4 should be greater than zero'),
          this.resetNextTimestamp())
    const R = !!p.audio,
      g = !!p.video
    let A = ''
    R && (A += 'audio'), g && (A += 'video')
    const S = {
      data1: d,
      startPTS: T,
      startDTS: T,
      endPTS: b,
      endDTS: b,
      type: A,
      hasAudio: R,
      hasVideo: g,
      nb: 1,
      dropped: 0
    }
    return (
      (f.audio = S.type === 'audio' ? S : void 0),
      (f.video = S.type !== 'audio' ? S : void 0),
      (f.initSegment = m),
      (f.id3 = ba(r, i, u, u)),
      n.samples.length && (f.text = La(n, i, u)),
      f
    )
  }
}
function xf(s, e, t, r) {
  if (s === null) return !0
  const n = Math.max(r, 1),
    i = e - s.baseTime / s.timescale
  return Math.abs(i - t) > n
}
function Ji(s, e) {
  const t = s == null ? void 0 : s.codec
  return t && t.length > 4
    ? t
    : t === 'hvc1' || t === 'hev1'
    ? 'hvc1.1.6.L120.90'
    : t === 'av01'
    ? 'av01.0.04M.08'
    : t === 'avc1' || e === pe.VIDEO
    ? 'avc1.42e01e'
    : 'mp4a.40.5'
}
let it
try {
  it = self.performance.now.bind(self.performance)
} catch {
  G.debug('Unable to use Performance API on this environment'),
    (it = typeof self < 'u' && self.Date.now)
}
const en = [
  { demux: rf, remux: Ef },
  { demux: ut, remux: Jr },
  { demux: ef, remux: Jr },
  { demux: hf, remux: Jr }
]
class es {
  constructor(e, t, r, n, i) {
    ;(this.async = !1),
      (this.observer = void 0),
      (this.typeSupported = void 0),
      (this.config = void 0),
      (this.vendor = void 0),
      (this.id = void 0),
      (this.demuxer = void 0),
      (this.remuxer = void 0),
      (this.decrypter = void 0),
      (this.probe = void 0),
      (this.decryptionPromise = null),
      (this.transmuxConfig = void 0),
      (this.currentTransmuxState = void 0),
      (this.observer = e),
      (this.typeSupported = t),
      (this.config = r),
      (this.vendor = n),
      (this.id = i)
  }
  configure(e) {
    ;(this.transmuxConfig = e), this.decrypter && this.decrypter.reset()
  }
  push(e, t, r, n) {
    const i = r.transmuxing
    i.executeStart = it()
    let a = new Uint8Array(e)
    const { currentTransmuxState: o, transmuxConfig: l } = this
    n && (this.currentTransmuxState = n)
    const {
        contiguous: u,
        discontinuity: c,
        trackSwitch: f,
        accurateTimeOffset: d,
        timeOffset: m,
        initSegmentChange: p
      } = n || o,
      { audioCodec: v, videoCodec: E, defaultInitPts: x, duration: T, initSegmentData: b } = l,
      R = Sf(a, t)
    if (R && R.method === 'AES-128') {
      const h = this.getDecrypter()
      if (h.isSync()) {
        let _ = h.softwareDecrypt(a, R.key.buffer, R.iv.buffer)
        if ((r.part > -1 && (_ = h.flush()), !_)) return (i.executeEnd = it()), tn(r)
        a = new Uint8Array(_)
      } else
        return (
          (this.decryptionPromise = h.webCryptoDecrypt(a, R.key.buffer, R.iv.buffer).then((_) => {
            const y = this.push(_, null, r)
            return (this.decryptionPromise = null), y
          })),
          this.decryptionPromise
        )
    }
    const g = this.needsProbing(c, f)
    if (g) {
      const h = this.configureTransmuxer(a)
      if (h)
        return (
          G.warn(`[transmuxer] ${h.message}`),
          this.observer.emit(O.ERROR, O.ERROR, {
            type: ne.MEDIA_ERROR,
            details: K.FRAG_PARSING_ERROR,
            fatal: !1,
            error: h,
            reason: h.message
          }),
          (i.executeEnd = it()),
          tn(r)
        )
    }
    ;(c || f || p || g) && this.resetInitSegment(b, v, E, T, t),
      (c || p || g) && this.resetInitialTimestamp(x),
      u || this.resetContiguity()
    const A = this.transmux(a, R, m, d, r),
      S = this.currentTransmuxState
    return (
      (S.contiguous = !0), (S.discontinuity = !1), (S.trackSwitch = !1), (i.executeEnd = it()), A
    )
  }
  flush(e) {
    const t = e.transmuxing
    t.executeStart = it()
    const { decrypter: r, currentTransmuxState: n, decryptionPromise: i } = this
    if (i) return i.then(() => this.flush(e))
    const a = [],
      { timeOffset: o } = n
    if (r) {
      const f = r.flush()
      f && a.push(this.push(f, null, e))
    }
    const { demuxer: l, remuxer: u } = this
    if (!l || !u) return (t.executeEnd = it()), [tn(e)]
    const c = l.flush(o)
    return or(c) ? c.then((f) => (this.flushRemux(a, f, e), a)) : (this.flushRemux(a, c, e), a)
  }
  flushRemux(e, t, r) {
    const { audioTrack: n, videoTrack: i, id3Track: a, textTrack: o } = t,
      { accurateTimeOffset: l, timeOffset: u } = this.currentTransmuxState
    G.log(
      `[transmuxer.ts]: Flushed fragment ${r.sn}${r.part > -1 ? ' p: ' + r.part : ''} of level ${
        r.level
      }`
    )
    const c = this.remuxer.remux(n, i, a, o, u, l, !0, this.id)
    e.push({ remuxResult: c, chunkMeta: r }), (r.transmuxing.executeEnd = it())
  }
  resetInitialTimestamp(e) {
    const { demuxer: t, remuxer: r } = this
    !t || !r || (t.resetTimeStamp(e), r.resetTimeStamp(e))
  }
  resetContiguity() {
    const { demuxer: e, remuxer: t } = this
    !e || !t || (e.resetContiguity(), t.resetNextTimestamp())
  }
  resetInitSegment(e, t, r, n, i) {
    const { demuxer: a, remuxer: o } = this
    !a || !o || (a.resetInitSegment(e, t, r, n), o.resetInitSegment(e, t, r, i))
  }
  destroy() {
    this.demuxer && (this.demuxer.destroy(), (this.demuxer = void 0)),
      this.remuxer && (this.remuxer.destroy(), (this.remuxer = void 0))
  }
  transmux(e, t, r, n, i) {
    let a
    return (
      t && t.method === 'SAMPLE-AES'
        ? (a = this.transmuxSampleAes(e, t, r, n, i))
        : (a = this.transmuxUnencrypted(e, r, n, i)),
      a
    )
  }
  transmuxUnencrypted(e, t, r, n) {
    const {
      audioTrack: i,
      videoTrack: a,
      id3Track: o,
      textTrack: l
    } = this.demuxer.demux(e, t, !1, !this.config.progressive)
    return { remuxResult: this.remuxer.remux(i, a, o, l, t, r, !1, this.id), chunkMeta: n }
  }
  transmuxSampleAes(e, t, r, n, i) {
    return this.demuxer
      .demuxSampleAes(e, t, r)
      .then((a) => ({
        remuxResult: this.remuxer.remux(
          a.audioTrack,
          a.videoTrack,
          a.id3Track,
          a.textTrack,
          r,
          n,
          !1,
          this.id
        ),
        chunkMeta: i
      }))
  }
  configureTransmuxer(e) {
    const { config: t, observer: r, typeSupported: n, vendor: i } = this
    let a
    for (let f = 0, d = en.length; f < d; f++)
      if (en[f].demux.probe(e)) {
        a = en[f]
        break
      }
    if (!a) return new Error('Failed to find demuxer by probing fragment data')
    const o = this.demuxer,
      l = this.remuxer,
      u = a.remux,
      c = a.demux
    ;(!l || !(l instanceof u)) && (this.remuxer = new u(r, t, n, i)),
      (!o || !(o instanceof c)) && ((this.demuxer = new c(r, t, n)), (this.probe = c.probe))
  }
  needsProbing(e, t) {
    return !this.demuxer || !this.remuxer || e || t
  }
  getDecrypter() {
    let e = this.decrypter
    return e || (e = this.decrypter = new Bn(this.config)), e
  }
}
function Sf(s, e) {
  let t = null
  return (
    s.byteLength > 0 && e != null && e.key != null && e.iv !== null && e.method != null && (t = e),
    t
  )
}
const tn = (s) => ({ remuxResult: {}, chunkMeta: s })
function or(s) {
  return 'then' in s && s.then instanceof Function
}
class Tf {
  constructor(e, t, r, n, i) {
    ;(this.audioCodec = void 0),
      (this.videoCodec = void 0),
      (this.initSegmentData = void 0),
      (this.duration = void 0),
      (this.defaultInitPts = void 0),
      (this.audioCodec = e),
      (this.videoCodec = t),
      (this.initSegmentData = r),
      (this.duration = n),
      (this.defaultInitPts = i || null)
  }
}
class bf {
  constructor(e, t, r, n, i, a) {
    ;(this.discontinuity = void 0),
      (this.contiguous = void 0),
      (this.accurateTimeOffset = void 0),
      (this.trackSwitch = void 0),
      (this.timeOffset = void 0),
      (this.initSegmentChange = void 0),
      (this.discontinuity = e),
      (this.contiguous = t),
      (this.accurateTimeOffset = r),
      (this.trackSwitch = n),
      (this.timeOffset = i),
      (this.initSegmentChange = a)
  }
}
var Aa = { exports: {} }
;(function (s) {
  var e = Object.prototype.hasOwnProperty,
    t = '~'
  function r() {}
  Object.create && ((r.prototype = Object.create(null)), new r().__proto__ || (t = !1))
  function n(l, u, c) {
    ;(this.fn = l), (this.context = u), (this.once = c || !1)
  }
  function i(l, u, c, f, d) {
    if (typeof c != 'function') throw new TypeError('The listener must be a function')
    var m = new n(c, f || l, d),
      p = t ? t + u : u
    return (
      l._events[p]
        ? l._events[p].fn
          ? (l._events[p] = [l._events[p], m])
          : l._events[p].push(m)
        : ((l._events[p] = m), l._eventsCount++),
      l
    )
  }
  function a(l, u) {
    --l._eventsCount === 0 ? (l._events = new r()) : delete l._events[u]
  }
  function o() {
    ;(this._events = new r()), (this._eventsCount = 0)
  }
  ;(o.prototype.eventNames = function () {
    var u = [],
      c,
      f
    if (this._eventsCount === 0) return u
    for (f in (c = this._events)) e.call(c, f) && u.push(t ? f.slice(1) : f)
    return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(c)) : u
  }),
    (o.prototype.listeners = function (u) {
      var c = t ? t + u : u,
        f = this._events[c]
      if (!f) return []
      if (f.fn) return [f.fn]
      for (var d = 0, m = f.length, p = new Array(m); d < m; d++) p[d] = f[d].fn
      return p
    }),
    (o.prototype.listenerCount = function (u) {
      var c = t ? t + u : u,
        f = this._events[c]
      return f ? (f.fn ? 1 : f.length) : 0
    }),
    (o.prototype.emit = function (u, c, f, d, m, p) {
      var v = t ? t + u : u
      if (!this._events[v]) return !1
      var E = this._events[v],
        x = arguments.length,
        T,
        b
      if (E.fn) {
        switch ((E.once && this.removeListener(u, E.fn, void 0, !0), x)) {
          case 1:
            return E.fn.call(E.context), !0
          case 2:
            return E.fn.call(E.context, c), !0
          case 3:
            return E.fn.call(E.context, c, f), !0
          case 4:
            return E.fn.call(E.context, c, f, d), !0
          case 5:
            return E.fn.call(E.context, c, f, d, m), !0
          case 6:
            return E.fn.call(E.context, c, f, d, m, p), !0
        }
        for (b = 1, T = new Array(x - 1); b < x; b++) T[b - 1] = arguments[b]
        E.fn.apply(E.context, T)
      } else {
        var R = E.length,
          g
        for (b = 0; b < R; b++)
          switch ((E[b].once && this.removeListener(u, E[b].fn, void 0, !0), x)) {
            case 1:
              E[b].fn.call(E[b].context)
              break
            case 2:
              E[b].fn.call(E[b].context, c)
              break
            case 3:
              E[b].fn.call(E[b].context, c, f)
              break
            case 4:
              E[b].fn.call(E[b].context, c, f, d)
              break
            default:
              if (!T) for (g = 1, T = new Array(x - 1); g < x; g++) T[g - 1] = arguments[g]
              E[b].fn.apply(E[b].context, T)
          }
      }
      return !0
    }),
    (o.prototype.on = function (u, c, f) {
      return i(this, u, c, f, !1)
    }),
    (o.prototype.once = function (u, c, f) {
      return i(this, u, c, f, !0)
    }),
    (o.prototype.removeListener = function (u, c, f, d) {
      var m = t ? t + u : u
      if (!this._events[m]) return this
      if (!c) return a(this, m), this
      var p = this._events[m]
      if (p.fn) p.fn === c && (!d || p.once) && (!f || p.context === f) && a(this, m)
      else {
        for (var v = 0, E = [], x = p.length; v < x; v++)
          (p[v].fn !== c || (d && !p[v].once) || (f && p[v].context !== f)) && E.push(p[v])
        E.length ? (this._events[m] = E.length === 1 ? E[0] : E) : a(this, m)
      }
      return this
    }),
    (o.prototype.removeAllListeners = function (u) {
      var c
      return (
        u
          ? ((c = t ? t + u : u), this._events[c] && a(this, c))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      )
    }),
    (o.prototype.off = o.prototype.removeListener),
    (o.prototype.addListener = o.prototype.on),
    (o.prefixed = t),
    (o.EventEmitter = o),
    (s.exports = o)
})(Aa)
var Lf = Aa.exports,
  Vn = uu(Lf)
const rn = xr() || { isTypeSupported: () => !1 }
class Ra {
  constructor(e, t, r, n) {
    ;(this.error = null),
      (this.hls = void 0),
      (this.id = void 0),
      (this.observer = void 0),
      (this.frag = null),
      (this.part = null),
      (this.useWorker = void 0),
      (this.workerContext = null),
      (this.onwmsg = void 0),
      (this.transmuxer = null),
      (this.onTransmuxComplete = void 0),
      (this.onFlush = void 0)
    const i = e.config
    ;(this.hls = e),
      (this.id = t),
      (this.useWorker = !!i.enableWorker),
      (this.onTransmuxComplete = r),
      (this.onFlush = n)
    const a = (u, c) => {
      ;(c = c || {}),
        (c.frag = this.frag),
        (c.id = this.id),
        u === O.ERROR && (this.error = c.error),
        this.hls.trigger(u, c)
    }
    ;(this.observer = new Vn()), this.observer.on(O.FRAG_DECRYPTED, a), this.observer.on(O.ERROR, a)
    const o = {
        mp4: rn.isTypeSupported('video/mp4'),
        mpeg: rn.isTypeSupported('audio/mpeg'),
        mp3: rn.isTypeSupported('audio/mp4; codecs="mp3"')
      },
      l = navigator.vendor
    if (this.useWorker && typeof Worker < 'u' && (i.workerPath || Hc())) {
      try {
        i.workerPath
          ? (G.log(`loading Web Worker ${i.workerPath} for "${t}"`),
            (this.workerContext = Yc(i.workerPath)))
          : (G.log(`injecting Web Worker for "${t}"`), (this.workerContext = Wc())),
          (this.onwmsg = (f) => this.onWorkerMessage(f))
        const { worker: c } = this.workerContext
        c.addEventListener('message', this.onwmsg),
          (c.onerror = (f) => {
            const d = new Error(`${f.message}  (${f.filename}:${f.lineno})`)
            ;(i.enableWorker = !1),
              G.warn(`Error in "${t}" Web Worker, fallback to inline`),
              this.hls.trigger(O.ERROR, {
                type: ne.OTHER_ERROR,
                details: K.INTERNAL_EXCEPTION,
                fatal: !1,
                event: 'demuxerWorker',
                error: d
              })
          }),
          c.postMessage({
            cmd: 'init',
            typeSupported: o,
            vendor: l,
            id: t,
            config: JSON.stringify(i)
          })
      } catch (c) {
        G.warn(`Error setting up "${t}" Web Worker, fallback to inline`, c),
          this.resetWorker(),
          (this.error = null),
          (this.transmuxer = new es(this.observer, o, i, l, t))
      }
      return
    }
    this.transmuxer = new es(this.observer, o, i, l, t)
  }
  resetWorker() {
    if (this.workerContext) {
      const { worker: e, objectURL: t } = this.workerContext
      t && self.URL.revokeObjectURL(t),
        e.removeEventListener('message', this.onwmsg),
        (e.onerror = null),
        e.terminate(),
        (this.workerContext = null)
    }
  }
  destroy() {
    if (this.workerContext) this.resetWorker(), (this.onwmsg = void 0)
    else {
      const t = this.transmuxer
      t && (t.destroy(), (this.transmuxer = null))
    }
    const e = this.observer
    e && e.removeAllListeners(), (this.frag = null), (this.observer = null), (this.hls = null)
  }
  push(e, t, r, n, i, a, o, l, u, c) {
    var f, d
    u.transmuxing.start = self.performance.now()
    const { transmuxer: m } = this,
      p = a ? a.start : i.start,
      v = i.decryptdata,
      E = this.frag,
      x = !(E && i.cc === E.cc),
      T = !(E && u.level === E.level),
      b = E ? u.sn - E.sn : -1,
      R = this.part ? u.part - this.part.index : -1,
      g = b === 0 && u.id > 1 && u.id === (E == null ? void 0 : E.stats.chunkCount),
      A = !T && (b === 1 || (b === 0 && (R === 1 || (g && R <= 0)))),
      S = self.performance.now()
    ;(T || b || i.stats.parsing.start === 0) && (i.stats.parsing.start = S),
      a && (R || !A) && (a.stats.parsing.start = S)
    const h = !(
        E &&
        ((f = i.initSegment) == null ? void 0 : f.url) ===
          ((d = E.initSegment) == null ? void 0 : d.url)
      ),
      _ = new bf(x, A, l, T, p, h)
    if (!A || x || h) {
      G.log(`[transmuxer-interface, ${i.type}]: Starting new transmux session for sn: ${u.sn} p: ${u.part} level: ${u.level} id: ${u.id}
        discontinuity: ${x}
        trackSwitch: ${T}
        contiguous: ${A}
        accurateTimeOffset: ${l}
        timeOffset: ${p}
        initSegmentChange: ${h}`)
      const y = new Tf(r, n, t, o, c)
      this.configureTransmuxer(y)
    }
    if (((this.frag = i), (this.part = a), this.workerContext))
      this.workerContext.worker.postMessage(
        { cmd: 'demux', data: e, decryptdata: v, chunkMeta: u, state: _ },
        e instanceof ArrayBuffer ? [e] : []
      )
    else if (m) {
      const y = m.push(e, v, u, _)
      or(y)
        ? ((m.async = !0),
          y
            .then((L) => {
              this.handleTransmuxComplete(L)
            })
            .catch((L) => {
              this.transmuxerError(L, u, 'transmuxer-interface push error')
            }))
        : ((m.async = !1), this.handleTransmuxComplete(y))
    }
  }
  flush(e) {
    e.transmuxing.start = self.performance.now()
    const { transmuxer: t } = this
    if (this.workerContext) this.workerContext.worker.postMessage({ cmd: 'flush', chunkMeta: e })
    else if (t) {
      let r = t.flush(e)
      or(r) || t.async
        ? (or(r) || (r = Promise.resolve(r)),
          r
            .then((i) => {
              this.handleFlushResult(i, e)
            })
            .catch((i) => {
              this.transmuxerError(i, e, 'transmuxer-interface flush error')
            }))
        : this.handleFlushResult(r, e)
    }
  }
  transmuxerError(e, t, r) {
    this.hls &&
      ((this.error = e),
      this.hls.trigger(O.ERROR, {
        type: ne.MEDIA_ERROR,
        details: K.FRAG_PARSING_ERROR,
        chunkMeta: t,
        fatal: !1,
        error: e,
        err: e,
        reason: r
      }))
  }
  handleFlushResult(e, t) {
    e.forEach((r) => {
      this.handleTransmuxComplete(r)
    }),
      this.onFlush(t)
  }
  onWorkerMessage(e) {
    const t = e.data,
      r = this.hls
    switch (t.event) {
      case 'init': {
        var n
        const i = (n = this.workerContext) == null ? void 0 : n.objectURL
        i && self.URL.revokeObjectURL(i)
        break
      }
      case 'transmuxComplete': {
        this.handleTransmuxComplete(t.data)
        break
      }
      case 'flush': {
        this.onFlush(t.data)
        break
      }
      case 'workerLog':
        G[t.data.logType] && G[t.data.logType](t.data.message)
        break
      default: {
        ;(t.data = t.data || {}),
          (t.data.frag = this.frag),
          (t.data.id = this.id),
          r.trigger(t.event, t.data)
        break
      }
    }
  }
  configureTransmuxer(e) {
    const { transmuxer: t } = this
    this.workerContext
      ? this.workerContext.worker.postMessage({ cmd: 'configure', config: e })
      : t && t.configure(e)
  }
  handleTransmuxComplete(e) {
    ;(e.chunkMeta.transmuxing.end = self.performance.now()), this.onTransmuxComplete(e)
  }
}
const Af = 250,
  nn = 2,
  Rf = 0.1,
  If = 0.05
class Pf {
  constructor(e, t, r, n) {
    ;(this.config = void 0),
      (this.media = null),
      (this.fragmentTracker = void 0),
      (this.hls = void 0),
      (this.nudgeRetry = 0),
      (this.stallReported = !1),
      (this.stalled = null),
      (this.moved = !1),
      (this.seeking = !1),
      (this.config = e),
      (this.media = t),
      (this.fragmentTracker = r),
      (this.hls = n)
  }
  destroy() {
    ;(this.media = null), (this.hls = this.fragmentTracker = null)
  }
  poll(e, t) {
    const { config: r, media: n, stalled: i } = this
    if (n === null) return
    const { currentTime: a, seeking: o } = n,
      l = this.seeking && !o,
      u = !this.seeking && o
    if (((this.seeking = o), a !== e)) {
      if (((this.moved = !0), i !== null)) {
        if (this.stallReported) {
          const x = self.performance.now() - i
          G.warn(`playback not stuck anymore @${a}, after ${Math.round(x)}ms`),
            (this.stallReported = !1)
        }
        ;(this.stalled = null), (this.nudgeRetry = 0)
      }
      return
    }
    if (u || l) {
      this.stalled = null
      return
    }
    if ((n.paused && !o) || n.ended || n.playbackRate === 0 || !ge.getBuffered(n).length) return
    const c = ge.bufferInfo(n, a, 0),
      f = c.len > 0,
      d = c.nextStart || 0
    if (!f && !d) return
    if (o) {
      const x = c.len > nn,
        T = !d || (t && t.start <= a) || (d - a > nn && !this.fragmentTracker.getPartialFragment(a))
      if (x || T) return
      this.moved = !1
    }
    if (!this.moved && this.stalled !== null) {
      var m
      const x = Math.max(d, c.start || 0) - a,
        T = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,
        R = (T == null || (m = T.details) == null ? void 0 : m.live)
          ? T.details.targetduration * 2
          : nn,
        g = this.fragmentTracker.getPartialFragment(a)
      if (x > 0 && (x <= R || g)) {
        this._trySkipBufferHole(g)
        return
      }
    }
    const p = self.performance.now()
    if (i === null) {
      this.stalled = p
      return
    }
    const v = p - i
    if (!o && v >= Af && (this._reportStall(c), !this.media)) return
    const E = ge.bufferInfo(n, a, r.maxBufferHole)
    this._tryFixBufferStall(E, v)
  }
  _tryFixBufferStall(e, t) {
    const { config: r, fragmentTracker: n, media: i } = this
    if (i === null) return
    const a = i.currentTime,
      o = n.getPartialFragment(a)
    ;(o && (this._trySkipBufferHole(o) || !this.media)) ||
      ((e.len > r.maxBufferHole || (e.nextStart && e.nextStart - a < r.maxBufferHole)) &&
        t > r.highBufferWatchdogPeriod * 1e3 &&
        (G.warn('Trying to nudge playhead over buffer-hole'),
        (this.stalled = null),
        this._tryNudgeBuffer()))
  }
  _reportStall(e) {
    const { hls: t, media: r, stallReported: n } = this
    if (!n && r) {
      this.stallReported = !0
      const i = new Error(
        `Playback stalling at @${r.currentTime} due to low buffer (${JSON.stringify(e)})`
      )
      G.warn(i.message),
        t.trigger(O.ERROR, {
          type: ne.MEDIA_ERROR,
          details: K.BUFFER_STALLED_ERROR,
          fatal: !1,
          error: i,
          buffer: e.len
        })
    }
  }
  _trySkipBufferHole(e) {
    const { config: t, hls: r, media: n } = this
    if (n === null) return 0
    const i = n.currentTime,
      a = ge.bufferInfo(n, i, 0),
      o = i < a.start ? a.start : a.nextStart
    if (o) {
      const l = a.len <= t.maxBufferHole,
        u = a.len > 0 && a.len < 1 && n.readyState < 3,
        c = o - i
      if (c > 0 && (l || u)) {
        if (c > t.maxBufferHole) {
          const { fragmentTracker: d } = this
          let m = !1
          if (i === 0) {
            const p = d.getAppendedFrag(0, ie.MAIN)
            p && o < p.end && (m = !0)
          }
          if (!m) {
            const p = e || d.getAppendedFrag(i, ie.MAIN)
            if (p) {
              let v = !1,
                E = p.end
              for (; E < o; ) {
                const x = d.getPartialFragment(E)
                if (x) E += x.duration
                else {
                  v = !0
                  break
                }
              }
              if (v) return 0
            }
          }
        }
        const f = Math.max(o + If, i + Rf)
        if (
          (G.warn(`skipping hole, adjusting currentTime from ${i} to ${f}`),
          (this.moved = !0),
          (this.stalled = null),
          (n.currentTime = f),
          e && !e.gap)
        ) {
          const d = new Error(`fragment loaded with buffer holes, seeking from ${i} to ${f}`)
          r.trigger(O.ERROR, {
            type: ne.MEDIA_ERROR,
            details: K.BUFFER_SEEK_OVER_HOLE,
            fatal: !1,
            error: d,
            reason: d.message,
            frag: e
          })
        }
        return f
      }
    }
    return 0
  }
  _tryNudgeBuffer() {
    const { config: e, hls: t, media: r, nudgeRetry: n } = this
    if (r === null) return
    const i = r.currentTime
    if ((this.nudgeRetry++, n < e.nudgeMaxRetry)) {
      const a = i + (n + 1) * e.nudgeOffset,
        o = new Error(`Nudging 'currentTime' from ${i} to ${a}`)
      G.warn(o.message),
        (r.currentTime = a),
        t.trigger(O.ERROR, {
          type: ne.MEDIA_ERROR,
          details: K.BUFFER_NUDGE_ON_STALL,
          error: o,
          fatal: !1
        })
    } else {
      const a = new Error(
        `Playhead still not moving while enough data buffered @${i} after ${e.nudgeMaxRetry} nudges`
      )
      G.error(a.message),
        t.trigger(O.ERROR, {
          type: ne.MEDIA_ERROR,
          details: K.BUFFER_STALLED_ERROR,
          error: a,
          fatal: !0
        })
    }
  }
}
const Df = 100
class Of extends Gn {
  constructor(e, t, r) {
    super(e, t, r, '[stream-controller]', ie.MAIN),
      (this.audioCodecSwap = !1),
      (this.gapController = null),
      (this.level = -1),
      (this._forceStartLoad = !1),
      (this.altAudio = !1),
      (this.audioOnly = !1),
      (this.fragPlaying = null),
      (this.onvplaying = null),
      (this.onvseeked = null),
      (this.fragLastKbps = 0),
      (this.couldBacktrack = !1),
      (this.backtrackFragment = null),
      (this.audioCodecSwitch = !1),
      (this.videoBuffer = null),
      this._registerListeners()
  }
  _registerListeners() {
    const { hls: e } = this
    e.on(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(O.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on(O.LEVEL_LOADING, this.onLevelLoading, this),
      e.on(O.LEVEL_LOADED, this.onLevelLoaded, this),
      e.on(O.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this),
      e.on(O.ERROR, this.onError, this),
      e.on(O.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
      e.on(O.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
      e.on(O.BUFFER_CREATED, this.onBufferCreated, this),
      e.on(O.BUFFER_FLUSHED, this.onBufferFlushed, this),
      e.on(O.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.on(O.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  _unregisterListeners() {
    const { hls: e } = this
    e.off(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(O.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off(O.LEVEL_LOADED, this.onLevelLoaded, this),
      e.off(O.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this),
      e.off(O.ERROR, this.onError, this),
      e.off(O.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
      e.off(O.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
      e.off(O.BUFFER_CREATED, this.onBufferCreated, this),
      e.off(O.BUFFER_FLUSHED, this.onBufferFlushed, this),
      e.off(O.LEVELS_UPDATED, this.onLevelsUpdated, this),
      e.off(O.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  onHandlerDestroying() {
    this._unregisterListeners(), this.onMediaDetaching()
  }
  startLoad(e) {
    if (this.levels) {
      const { lastCurrentTime: t, hls: r } = this
      if ((this.stopLoad(), this.setInterval(Df), (this.level = -1), !this.startFragRequested)) {
        let n = r.startLevel
        n === -1 &&
          (r.config.testBandwidth && this.levels.length > 1
            ? ((n = 0), (this.bitrateTest = !0))
            : (n = r.nextAutoLevel)),
          (this.level = r.nextLoadLevel = n),
          (this.loadedmetadata = !1)
      }
      t > 0 &&
        e === -1 &&
        (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`), (e = t)),
        (this.state = W.IDLE),
        (this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e),
        this.tick()
    } else (this._forceStartLoad = !0), (this.state = W.STOPPED)
  }
  stopLoad() {
    ;(this._forceStartLoad = !1), super.stopLoad()
  }
  doTick() {
    switch (this.state) {
      case W.WAITING_LEVEL: {
        var e
        const { levels: r, level: n } = this,
          i = r == null || (e = r[n]) == null ? void 0 : e.details
        if (i && (!i.live || this.levelLastLoaded === this.level)) {
          if (this.waitForCdnTuneIn(i)) break
          this.state = W.IDLE
          break
        } else if (this.hls.nextLoadLevel !== this.level) {
          this.state = W.IDLE
          break
        }
        break
      }
      case W.FRAG_LOADING_WAITING_RETRY:
        {
          var t
          const r = self.performance.now(),
            n = this.retryDate
          ;(!n || r >= n || ((t = this.media) != null && t.seeking)) &&
            (this.resetStartWhenNotLoaded(this.level), (this.state = W.IDLE))
        }
        break
    }
    this.state === W.IDLE && this.doTickIdle(), this.onTickEnd()
  }
  onTickEnd() {
    super.onTickEnd(), this.checkBuffer(), this.checkFragmentChanged()
  }
  doTickIdle() {
    const { hls: e, levelLastLoaded: t, levels: r, media: n } = this,
      { config: i, nextLoadLevel: a } = e
    if (
      t === null ||
      (!n && (this.startFragRequested || !i.startFragPrefetch)) ||
      (this.altAudio && this.audioOnly) ||
      !(r != null && r[a])
    )
      return
    const o = r[a],
      l = this.getMainFwdBufferInfo()
    if (l === null) return
    const u = this.getLevelDetails()
    if (u && this._streamEnded(l, u)) {
      const E = {}
      this.altAudio && (E.type = 'video'), this.hls.trigger(O.BUFFER_EOS, E), (this.state = W.ENDED)
      return
    }
    e.loadLevel !== a &&
      e.manualLevel === -1 &&
      this.log(`Adapting to level ${a} from level ${this.level}`),
      (this.level = e.nextLoadLevel = a)
    const c = o.details
    if (!c || this.state === W.WAITING_LEVEL || (c.live && this.levelLastLoaded !== a)) {
      ;(this.level = a), (this.state = W.WAITING_LEVEL)
      return
    }
    const f = l.len,
      d = this.getMaxBufferLength(o.maxBitrate)
    if (f >= d) return
    this.backtrackFragment &&
      this.backtrackFragment.start > l.end &&
      (this.backtrackFragment = null)
    const m = this.backtrackFragment ? this.backtrackFragment.start : l.end
    let p = this.getNextFragment(m, c)
    if (
      this.couldBacktrack &&
      !this.fragPrevious &&
      p &&
      p.sn !== 'initSegment' &&
      this.fragmentTracker.getState(p) !== Re.OK
    ) {
      var v
      const x = ((v = this.backtrackFragment) != null ? v : p).sn - c.startSN,
        T = c.fragments[x - 1]
      T && p.cc === T.cc && ((p = T), this.fragmentTracker.removeFragment(T))
    } else this.backtrackFragment && l.len && (this.backtrackFragment = null)
    if (p && this.isLoopLoading(p, m)) {
      if (!p.gap) {
        const x = this.audioOnly && !this.altAudio ? pe.AUDIO : pe.VIDEO,
          T = (x === pe.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media
        T && this.afterBufferFlushed(T, x, ie.MAIN)
      }
      p = this.getNextFragmentLoopLoading(p, c, l, ie.MAIN, d)
    }
    p &&
      (p.initSegment && !p.initSegment.data && !this.bitrateTest && (p = p.initSegment),
      this.loadFragment(p, o, m))
  }
  loadFragment(e, t, r) {
    const n = this.fragmentTracker.getState(e)
    ;(this.fragCurrent = e),
      n === Re.NOT_LOADED || n === Re.PARTIAL
        ? e.sn === 'initSegment'
          ? this._loadInitSegment(e, t)
          : this.bitrateTest
          ? (this.log(
              `Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`
            ),
            this._loadBitrateTestFrag(e, t))
          : ((this.startFragRequested = !0), super.loadFragment(e, t, r))
        : this.clearTrackerIfNeeded(e)
  }
  getBufferedFrag(e) {
    return this.fragmentTracker.getBufferedFrag(e, ie.MAIN)
  }
  followingBufferedFrag(e) {
    return e ? this.getBufferedFrag(e.end + 0.5) : null
  }
  immediateLevelSwitch() {
    this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
  }
  nextLevelSwitch() {
    const { levels: e, media: t } = this
    if (t != null && t.readyState) {
      let r
      const n = this.getAppendedFrag(t.currentTime)
      n && n.start > 1 && this.flushMainBuffer(0, n.start - 1)
      const i = this.getLevelDetails()
      if (i != null && i.live) {
        const o = this.getMainFwdBufferInfo()
        if (!o || o.len < i.targetduration * 2) return
      }
      if (!t.paused && e) {
        const o = this.hls.nextLoadLevel,
          l = e[o],
          u = this.fragLastKbps
        u && this.fragCurrent
          ? (r = (this.fragCurrent.duration * l.maxBitrate) / (1e3 * u) + 1)
          : (r = 0)
      } else r = 0
      const a = this.getBufferedFrag(t.currentTime + r)
      if (a) {
        const o = this.followingBufferedFrag(a)
        if (o) {
          this.abortCurrentFrag()
          const l = o.maxStartPTS ? o.maxStartPTS : o.start,
            u = o.duration,
            c = Math.max(
              a.end,
              l + Math.min(Math.max(u - this.config.maxFragLookUpTolerance, u * 0.5), u * 0.75)
            )
          this.flushMainBuffer(c, Number.POSITIVE_INFINITY)
        }
      }
    }
  }
  abortCurrentFrag() {
    const e = this.fragCurrent
    switch (
      ((this.fragCurrent = null),
      (this.backtrackFragment = null),
      e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)),
      this.state)
    ) {
      case W.KEY_LOADING:
      case W.FRAG_LOADING:
      case W.FRAG_LOADING_WAITING_RETRY:
      case W.PARSING:
      case W.PARSED:
        this.state = W.IDLE
        break
    }
    this.nextLoadPosition = this.getLoadPosition()
  }
  flushMainBuffer(e, t) {
    super.flushMainBuffer(e, t, this.altAudio ? 'video' : null)
  }
  onMediaAttached(e, t) {
    super.onMediaAttached(e, t)
    const r = t.media
    ;(this.onvplaying = this.onMediaPlaying.bind(this)),
      (this.onvseeked = this.onMediaSeeked.bind(this)),
      r.addEventListener('playing', this.onvplaying),
      r.addEventListener('seeked', this.onvseeked),
      (this.gapController = new Pf(this.config, r, this.fragmentTracker, this.hls))
  }
  onMediaDetaching() {
    const { media: e } = this
    e &&
      this.onvplaying &&
      this.onvseeked &&
      (e.removeEventListener('playing', this.onvplaying),
      e.removeEventListener('seeked', this.onvseeked),
      (this.onvplaying = this.onvseeked = null),
      (this.videoBuffer = null)),
      (this.fragPlaying = null),
      this.gapController && (this.gapController.destroy(), (this.gapController = null)),
      super.onMediaDetaching()
  }
  onMediaPlaying() {
    this.tick()
  }
  onMediaSeeked() {
    const e = this.media,
      t = e ? e.currentTime : null
    J(t) && this.log(`Media seeked to ${t.toFixed(3)}`)
    const r = this.getMainFwdBufferInfo()
    if (r === null || r.len === 0) {
      this.warn(`Main forward buffer length on "seeked" event ${r ? r.len : 'empty'})`)
      return
    }
    this.tick()
  }
  onManifestLoading() {
    this.log('Trigger BUFFER_RESET'),
      this.hls.trigger(O.BUFFER_RESET, void 0),
      this.fragmentTracker.removeAllFragments(),
      (this.couldBacktrack = !1),
      (this.startPosition = this.lastCurrentTime = 0),
      (this.levels = this.fragPlaying = this.backtrackFragment = null),
      (this.altAudio = this.audioOnly = !1)
  }
  onManifestParsed(e, t) {
    let r = !1,
      n = !1,
      i
    t.levels.forEach((a) => {
      ;(i = a.audioCodec),
        i && (i.indexOf('mp4a.40.2') !== -1 && (r = !0), i.indexOf('mp4a.40.5') !== -1 && (n = !0))
    }),
      (this.audioCodecSwitch = r && n && !Vc()),
      this.audioCodecSwitch &&
        this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC'),
      (this.levels = t.levels),
      (this.startFragRequested = !1)
  }
  onLevelLoading(e, t) {
    const { levels: r } = this
    if (!r || this.state !== W.IDLE) return
    const n = r[t.level]
    ;(!n.details ||
      (n.details.live && this.levelLastLoaded !== t.level) ||
      this.waitForCdnTuneIn(n.details)) &&
      (this.state = W.WAITING_LEVEL)
  }
  onLevelLoaded(e, t) {
    var r
    const { levels: n } = this,
      i = t.level,
      a = t.details,
      o = a.totalduration
    if (!n) {
      this.warn(`Levels were reset while loading level ${i}`)
      return
    }
    this.log(
      `Level ${i} loaded [${a.startSN},${a.endSN}]${
        a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ''
      }, cc [${a.startCC}, ${a.endCC}] duration:${o}`
    )
    const l = n[i],
      u = this.fragCurrent
    u &&
      (this.state === W.FRAG_LOADING || this.state === W.FRAG_LOADING_WAITING_RETRY) &&
      (u.level !== t.level || u.urlId !== l.urlId) &&
      u.loader &&
      this.abortCurrentFrag()
    let c = 0
    if (a.live || ((r = l.details) != null && r.live)) {
      if ((this.checkLiveUpdate(a), a.deltaUpdateFailed)) return
      c = this.alignPlaylists(a, l.details)
    }
    if (
      ((l.details = a),
      (this.levelLastLoaded = i),
      this.hls.trigger(O.LEVEL_UPDATED, { details: a, level: i }),
      this.state === W.WAITING_LEVEL)
    ) {
      if (this.waitForCdnTuneIn(a)) return
      this.state = W.IDLE
    }
    this.startFragRequested ? a.live && this.synchronizeToLiveEdge(a) : this.setStartPosition(a, c),
      this.tick()
  }
  _handleFragmentLoadProgress(e) {
    var t
    const { frag: r, part: n, payload: i } = e,
      { levels: a } = this
    if (!a) {
      this.warn(
        `Levels were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`
      )
      return
    }
    const o = a[r.level],
      l = o.details
    if (!l) {
      this.warn(`Dropping fragment ${r.sn} of level ${r.level} after level details were reset`),
        this.fragmentTracker.removeFragment(r)
      return
    }
    const u = o.videoCodec,
      c = l.PTSKnown || !l.live,
      f = (t = r.initSegment) == null ? void 0 : t.data,
      d = this._getAudioCodec(o),
      m = (this.transmuxer =
        this.transmuxer ||
        new Ra(
          this.hls,
          ie.MAIN,
          this._handleTransmuxComplete.bind(this),
          this._handleTransmuxerFlush.bind(this)
        )),
      p = n ? n.index : -1,
      v = p !== -1,
      E = new Nn(r.level, r.sn, r.stats.chunkCount, i.byteLength, p, v),
      x = this.initPTS[r.cc]
    m.push(i, f, d, u, r, n, l.totalduration, c, E, x)
  }
  onAudioTrackSwitching(e, t) {
    const r = this.altAudio
    if (!!!t.url) {
      if (this.mediaBuffer !== this.media) {
        this.log('Switching on main audio, use media.buffered to schedule main fragment loading'),
          (this.mediaBuffer = this.media)
        const a = this.fragCurrent
        a &&
          (this.log('Switching to main audio track, cancel main fragment load'),
          a.abortRequests(),
          this.fragmentTracker.removeFragment(a)),
          this.resetTransmuxer(),
          this.resetLoadingState()
      } else this.audioOnly && this.resetTransmuxer()
      const i = this.hls
      r &&
        (i.trigger(O.BUFFER_FLUSHING, {
          startOffset: 0,
          endOffset: Number.POSITIVE_INFINITY,
          type: null
        }),
        this.fragmentTracker.removeAllFragments()),
        i.trigger(O.AUDIO_TRACK_SWITCHED, t)
    }
  }
  onAudioTrackSwitched(e, t) {
    const r = t.id,
      n = !!this.hls.audioTracks[r].url
    if (n) {
      const i = this.videoBuffer
      i &&
        this.mediaBuffer !== i &&
        (this.log(
          'Switching on alternate audio, use video.buffered to schedule main fragment loading'
        ),
        (this.mediaBuffer = i))
    }
    ;(this.altAudio = n), this.tick()
  }
  onBufferCreated(e, t) {
    const r = t.tracks
    let n,
      i,
      a = !1
    for (const o in r) {
      const l = r[o]
      if (l.id === 'main') {
        if (((i = o), (n = l), o === 'video')) {
          const u = r[o]
          u && (this.videoBuffer = u.buffer)
        }
      } else a = !0
    }
    a && n
      ? (this.log(`Alternate track found, use ${i}.buffered to schedule main fragment loading`),
        (this.mediaBuffer = n.buffer))
      : (this.mediaBuffer = this.media)
  }
  onFragBuffered(e, t) {
    const { frag: r, part: n } = t
    if (r && r.type !== ie.MAIN) return
    if (this.fragContextChanged(r)) {
      this.warn(
        `Fragment ${r.sn}${n ? ' p: ' + n.index : ''} of level ${
          r.level
        } finished buffering, but was aborted. state: ${this.state}`
      ),
        this.state === W.PARSED && (this.state = W.IDLE)
      return
    }
    const i = n ? n.stats : r.stats
    ;(this.fragLastKbps = Math.round((8 * i.total) / (i.buffering.end - i.loading.first))),
      r.sn !== 'initSegment' && (this.fragPrevious = r),
      this.fragBufferedComplete(r, n)
  }
  onError(e, t) {
    var r
    if (t.fatal) {
      this.state = W.ERROR
      return
    }
    switch (t.details) {
      case K.FRAG_GAP:
      case K.FRAG_PARSING_ERROR:
      case K.FRAG_DECRYPT_ERROR:
      case K.FRAG_LOAD_ERROR:
      case K.FRAG_LOAD_TIMEOUT:
      case K.KEY_LOAD_ERROR:
      case K.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(ie.MAIN, t)
        break
      case K.LEVEL_LOAD_ERROR:
      case K.LEVEL_LOAD_TIMEOUT:
      case K.LEVEL_PARSING_ERROR:
        !t.levelRetry &&
          this.state === W.WAITING_LEVEL &&
          ((r = t.context) == null ? void 0 : r.type) === fe.LEVEL &&
          (this.state = W.IDLE)
        break
      case K.BUFFER_FULL_ERROR:
        if (!t.parent || t.parent !== 'main') return
        this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
        break
      case K.INTERNAL_EXCEPTION:
        this.recoverWorkerError(t)
        break
    }
  }
  checkBuffer() {
    const { media: e, gapController: t } = this
    if (!(!e || !t || !e.readyState)) {
      if (this.loadedmetadata || !ge.getBuffered(e).length) {
        const r = this.state !== W.IDLE ? this.fragCurrent : null
        t.poll(this.lastCurrentTime, r)
      }
      this.lastCurrentTime = e.currentTime
    }
  }
  onFragLoadEmergencyAborted() {
    ;(this.state = W.IDLE),
      this.loadedmetadata ||
        ((this.startFragRequested = !1), (this.nextLoadPosition = this.startPosition)),
      this.tickImmediate()
  }
  onBufferFlushed(e, { type: t }) {
    if (t !== pe.AUDIO || (this.audioOnly && !this.altAudio)) {
      const r = (t === pe.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media
      this.afterBufferFlushed(r, t, ie.MAIN)
    }
  }
  onLevelsUpdated(e, t) {
    this.levels = t.levels
  }
  swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap
  }
  seekToStartPos() {
    const { media: e } = this
    if (!e) return
    const t = e.currentTime
    let r = this.startPosition
    if (r >= 0 && t < r) {
      if (e.seeking) {
        this.log(`could not seek to ${r}, already seeking at ${t}`)
        return
      }
      const n = ge.getBuffered(e),
        a = (n.length ? n.start(0) : 0) - r
      a > 0 &&
        (a < this.config.maxBufferHole || a < this.config.maxFragLookUpTolerance) &&
        (this.log(`adjusting start position by ${a} to match buffer start`),
        (r += a),
        (this.startPosition = r)),
        this.log(`seek to target start position ${r} from current time ${t}`),
        (e.currentTime = r)
    }
  }
  _getAudioCodec(e) {
    let t = this.config.defaultAudioCodec || e.audioCodec
    return (
      this.audioCodecSwap &&
        t &&
        (this.log('Swapping audio codec'),
        t.indexOf('mp4a.40.5') !== -1 ? (t = 'mp4a.40.2') : (t = 'mp4a.40.5')),
      t
    )
  }
  _loadBitrateTestFrag(e, t) {
    ;(e.bitrateTest = !0),
      this._doFragLoad(e, t).then((r) => {
        const { hls: n } = this
        if (!r || this.fragContextChanged(e)) return
        ;(t.fragmentError = 0),
          (this.state = W.IDLE),
          (this.startFragRequested = !1),
          (this.bitrateTest = !1)
        const i = e.stats
        ;(i.parsing.start =
          i.parsing.end =
          i.buffering.start =
          i.buffering.end =
            self.performance.now()),
          n.trigger(O.FRAG_LOADED, r),
          (e.bitrateTest = !1)
      })
  }
  _handleTransmuxComplete(e) {
    var t
    const r = 'main',
      { hls: n } = this,
      { remuxResult: i, chunkMeta: a } = e,
      o = this.getCurrentContext(a)
    if (!o) {
      this.resetWhenMissingContext(a)
      return
    }
    const { frag: l, part: u, level: c } = o,
      { video: f, text: d, id3: m, initSegment: p } = i,
      { details: v } = c,
      E = this.altAudio ? void 0 : i.audio
    if (this.fragContextChanged(l)) {
      this.fragmentTracker.removeFragment(l)
      return
    }
    if (((this.state = W.PARSING), p)) {
      if (p != null && p.tracks) {
        const b = l.initSegment || l
        this._bufferInitSegment(c, p.tracks, b, a),
          n.trigger(O.FRAG_PARSING_INIT_SEGMENT, { frag: b, id: r, tracks: p.tracks })
      }
      const x = p.initPTS,
        T = p.timescale
      J(x) &&
        ((this.initPTS[l.cc] = { baseTime: x, timescale: T }),
        n.trigger(O.INIT_PTS_FOUND, { frag: l, id: r, initPTS: x, timescale: T }))
    }
    if (f && v && l.sn !== 'initSegment') {
      const x = v.fragments[l.sn - 1 - v.startSN],
        T = l.sn === v.startSN,
        b = !x || l.cc > x.cc
      if (i.independent !== !1) {
        const { startPTS: R, endPTS: g, startDTS: A, endDTS: S } = f
        if (u) u.elementaryStreams[f.type] = { startPTS: R, endPTS: g, startDTS: A, endDTS: S }
        else if (
          (f.firstKeyFrame && f.independent && a.id === 1 && !b && (this.couldBacktrack = !0),
          f.dropped && f.independent)
        ) {
          const h = this.getMainFwdBufferInfo(),
            _ = (h ? h.end : this.getLoadPosition()) + this.config.maxBufferHole,
            y = f.firstKeyFramePTS ? f.firstKeyFramePTS : R
          if (!T && _ < y - this.config.maxBufferHole && !b) {
            this.backtrack(l)
            return
          } else b && (l.gap = !0)
          l.setElementaryStreamInfo(f.type, l.start, g, l.start, S, !0)
        }
        l.setElementaryStreamInfo(f.type, R, g, A, S),
          this.backtrackFragment && (this.backtrackFragment = l),
          this.bufferFragmentData(f, l, u, a, T || b)
      } else if (T || b) l.gap = !0
      else {
        this.backtrack(l)
        return
      }
    }
    if (E) {
      const { startPTS: x, endPTS: T, startDTS: b, endDTS: R } = E
      u && (u.elementaryStreams[pe.AUDIO] = { startPTS: x, endPTS: T, startDTS: b, endDTS: R }),
        l.setElementaryStreamInfo(pe.AUDIO, x, T, b, R),
        this.bufferFragmentData(E, l, u, a)
    }
    if (v && m != null && (t = m.samples) != null && t.length) {
      const x = { id: r, frag: l, details: v, samples: m.samples }
      n.trigger(O.FRAG_PARSING_METADATA, x)
    }
    if (v && d) {
      const x = { id: r, frag: l, details: v, samples: d.samples }
      n.trigger(O.FRAG_PARSING_USERDATA, x)
    }
  }
  _bufferInitSegment(e, t, r, n) {
    if (this.state !== W.PARSING) return
    ;(this.audioOnly = !!t.audio && !t.video), this.altAudio && !this.audioOnly && delete t.audio
    const { audio: i, video: a, audiovideo: o } = t
    if (i) {
      let l = e.audioCodec
      const u = navigator.userAgent.toLowerCase()
      this.audioCodecSwitch &&
        (l && (l.indexOf('mp4a.40.5') !== -1 ? (l = 'mp4a.40.2') : (l = 'mp4a.40.5')),
        i.metadata.channelCount !== 1 && u.indexOf('firefox') === -1 && (l = 'mp4a.40.5')),
        u.indexOf('android') !== -1 &&
          i.container !== 'audio/mpeg' &&
          ((l = 'mp4a.40.2'), this.log(`Android: force audio codec to ${l}`)),
        e.audioCodec &&
          e.audioCodec !== l &&
          this.log(`Swapping manifest audio codec "${e.audioCodec}" for "${l}"`),
        (i.levelCodec = l),
        (i.id = 'main'),
        this.log(
          `Init audio buffer, container:${i.container}, codecs[selected/level/parsed]=[${l || ''}/${
            e.audioCodec || ''
          }/${i.codec}]`
        )
    }
    a &&
      ((a.levelCodec = e.videoCodec),
      (a.id = 'main'),
      this.log(
        `Init video buffer, container:${a.container}, codecs[level/parsed]=[${e.videoCodec || ''}/${
          a.codec
        }]`
      )),
      o &&
        this.log(
          `Init audiovideo buffer, container:${o.container}, codecs[level/parsed]=[${
            e.attrs.CODECS || ''
          }/${o.codec}]`
        ),
      this.hls.trigger(O.BUFFER_CODECS, t),
      Object.keys(t).forEach((l) => {
        const c = t[l].initSegment
        c != null &&
          c.byteLength &&
          this.hls.trigger(O.BUFFER_APPENDING, {
            type: l,
            data: c,
            frag: r,
            part: null,
            chunkMeta: n,
            parent: r.type
          })
      }),
      this.tick()
  }
  getMainFwdBufferInfo() {
    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, ie.MAIN)
  }
  backtrack(e) {
    ;(this.couldBacktrack = !0),
      (this.backtrackFragment = e),
      this.resetTransmuxer(),
      this.flushBufferGap(e),
      this.fragmentTracker.removeFragment(e),
      (this.fragPrevious = null),
      (this.nextLoadPosition = e.start),
      (this.state = W.IDLE)
  }
  checkFragmentChanged() {
    const e = this.media
    let t = null
    if (e && e.readyState > 1 && e.seeking === !1) {
      const r = e.currentTime
      if (
        (ge.isBuffered(e, r)
          ? (t = this.getAppendedFrag(r))
          : ge.isBuffered(e, r + 0.1) && (t = this.getAppendedFrag(r + 0.1)),
        t)
      ) {
        this.backtrackFragment = null
        const n = this.fragPlaying,
          i = t.level
        ;(!n || t.sn !== n.sn || n.level !== i || t.urlId !== n.urlId) &&
          ((this.fragPlaying = t),
          this.hls.trigger(O.FRAG_CHANGED, { frag: t }),
          (!n || n.level !== i) && this.hls.trigger(O.LEVEL_SWITCHED, { level: i }))
      }
    }
  }
  get nextLevel() {
    const e = this.nextBufferedFrag
    return e ? e.level : -1
  }
  get currentFrag() {
    const e = this.media
    return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null
  }
  get currentProgramDateTime() {
    const e = this.media
    if (e) {
      const t = e.currentTime,
        r = this.currentFrag
      if (r && J(t) && J(r.programDateTime)) {
        const n = r.programDateTime + (t - r.start) * 1e3
        return new Date(n)
      }
    }
    return null
  }
  get currentLevel() {
    const e = this.currentFrag
    return e ? e.level : -1
  }
  get nextBufferedFrag() {
    const e = this.currentFrag
    return e ? this.followingBufferedFrag(e) : null
  }
  get forceStartLoad() {
    return this._forceStartLoad
  }
}
class Rt {
  constructor(e, t = 0, r = 0) {
    ;(this.halfLife = void 0),
      (this.alpha_ = void 0),
      (this.estimate_ = void 0),
      (this.totalWeight_ = void 0),
      (this.halfLife = e),
      (this.alpha_ = e ? Math.exp(Math.log(0.5) / e) : 0),
      (this.estimate_ = t),
      (this.totalWeight_ = r)
  }
  sample(e, t) {
    const r = Math.pow(this.alpha_, e)
    ;(this.estimate_ = t * (1 - r) + r * this.estimate_), (this.totalWeight_ += e)
  }
  getTotalWeight() {
    return this.totalWeight_
  }
  getEstimate() {
    if (this.alpha_) {
      const e = 1 - Math.pow(this.alpha_, this.totalWeight_)
      if (e) return this.estimate_ / e
    }
    return this.estimate_
  }
}
class wf {
  constructor(e, t, r, n = 100) {
    ;(this.defaultEstimate_ = void 0),
      (this.minWeight_ = void 0),
      (this.minDelayMs_ = void 0),
      (this.slow_ = void 0),
      (this.fast_ = void 0),
      (this.defaultTTFB_ = void 0),
      (this.ttfb_ = void 0),
      (this.defaultEstimate_ = r),
      (this.minWeight_ = 0.001),
      (this.minDelayMs_ = 50),
      (this.slow_ = new Rt(e)),
      (this.fast_ = new Rt(t)),
      (this.defaultTTFB_ = n),
      (this.ttfb_ = new Rt(e))
  }
  update(e, t) {
    const { slow_: r, fast_: n, ttfb_: i } = this
    r.halfLife !== e && (this.slow_ = new Rt(e, r.getEstimate(), r.getTotalWeight())),
      n.halfLife !== t && (this.fast_ = new Rt(t, n.getEstimate(), n.getTotalWeight())),
      i.halfLife !== e && (this.ttfb_ = new Rt(e, i.getEstimate(), i.getTotalWeight()))
  }
  sample(e, t) {
    e = Math.max(e, this.minDelayMs_)
    const r = 8 * t,
      n = e / 1e3,
      i = r / n
    this.fast_.sample(n, i), this.slow_.sample(n, i)
  }
  sampleTTFB(e) {
    const t = e / 1e3,
      r = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2)
    this.ttfb_.sample(r, Math.max(e, 5))
  }
  canEstimate() {
    return this.fast_.getTotalWeight() >= this.minWeight_
  }
  getEstimate() {
    return this.canEstimate()
      ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate())
      : this.defaultEstimate_
  }
  getEstimateTTFB() {
    return this.ttfb_.getTotalWeight() >= this.minWeight_
      ? this.ttfb_.getEstimate()
      : this.defaultTTFB_
  }
  destroy() {}
}
class Cf {
  constructor(e) {
    ;(this.hls = void 0),
      (this.lastLevelLoadSec = 0),
      (this.lastLoadedFragLevel = 0),
      (this._nextAutoLevel = -1),
      (this.timer = -1),
      (this.onCheck = this._abandonRulesCheck.bind(this)),
      (this.fragCurrent = null),
      (this.partCurrent = null),
      (this.bitrateTestDelay = 0),
      (this.bwEstimator = void 0),
      (this.hls = e)
    const t = e.config
    ;(this.bwEstimator = new wf(t.abrEwmaSlowVoD, t.abrEwmaFastVoD, t.abrEwmaDefaultEstimate)),
      this.registerListeners()
  }
  registerListeners() {
    const { hls: e } = this
    e.on(O.FRAG_LOADING, this.onFragLoading, this),
      e.on(O.FRAG_LOADED, this.onFragLoaded, this),
      e.on(O.FRAG_BUFFERED, this.onFragBuffered, this),
      e.on(O.LEVEL_SWITCHING, this.onLevelSwitching, this),
      e.on(O.LEVEL_LOADED, this.onLevelLoaded, this)
  }
  unregisterListeners() {
    const { hls: e } = this
    e.off(O.FRAG_LOADING, this.onFragLoading, this),
      e.off(O.FRAG_LOADED, this.onFragLoaded, this),
      e.off(O.FRAG_BUFFERED, this.onFragBuffered, this),
      e.off(O.LEVEL_SWITCHING, this.onLevelSwitching, this),
      e.off(O.LEVEL_LOADED, this.onLevelLoaded, this)
  }
  destroy() {
    this.unregisterListeners(),
      this.clearTimer(),
      (this.hls = this.onCheck = null),
      (this.fragCurrent = this.partCurrent = null)
  }
  onFragLoading(e, t) {
    var r
    const n = t.frag
    this.ignoreFragment(n) ||
      ((this.fragCurrent = n),
      (this.partCurrent = (r = t.part) != null ? r : null),
      this.clearTimer(),
      (this.timer = self.setInterval(this.onCheck, 100)))
  }
  onLevelSwitching(e, t) {
    this.clearTimer()
  }
  getTimeToLoadFrag(e, t, r, n) {
    const i = e + r / t,
      a = n ? this.lastLevelLoadSec : 0
    return i + a
  }
  onLevelLoaded(e, t) {
    const r = this.hls.config,
      { total: n, bwEstimate: i } = t.stats
    J(n) && J(i) && (this.lastLevelLoadSec = (8 * n) / i),
      t.details.live
        ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive)
        : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD)
  }
  _abandonRulesCheck() {
    const { fragCurrent: e, partCurrent: t, hls: r } = this,
      { autoLevelEnabled: n, media: i } = r
    if (!e || !i) return
    const a = performance.now(),
      o = t ? t.stats : e.stats,
      l = t ? t.duration : e.duration,
      u = a - o.loading.start
    if (o.aborted || (o.loaded && o.loaded === o.total) || e.level === 0) {
      this.clearTimer(), (this._nextAutoLevel = -1)
      return
    }
    if (!n || i.paused || !i.playbackRate || !i.readyState) return
    const c = r.mainForwardBufferInfo
    if (c === null) return
    const f = this.bwEstimator.getEstimateTTFB(),
      d = Math.abs(i.playbackRate)
    if (u <= Math.max(f, 1e3 * (l / (d * 2)))) return
    const m = c.len / d
    if (m >= (2 * l) / d) return
    const p = o.loading.first ? o.loading.first - o.loading.start : -1,
      v = o.loaded && p > -1,
      E = this.bwEstimator.getEstimate(),
      { levels: x, minAutoLevel: T } = r,
      b = x[e.level],
      R = o.total || Math.max(o.loaded, Math.round((l * b.maxBitrate) / 8))
    let g = u - p
    g < 1 && v && (g = Math.min(u, (o.loaded * 8) / E))
    const A = v ? (o.loaded * 1e3) / g : 0,
      S = A ? (R - o.loaded) / A : (R * 8) / E + f / 1e3
    if (S <= m) return
    const h = A ? A * 8 : E
    let _ = Number.POSITIVE_INFINITY,
      y
    for (y = e.level - 1; y > T; y--) {
      const L = x[y].maxBitrate
      if (((_ = this.getTimeToLoadFrag(f / 1e3, h, l * L, !x[y].details)), _ < m)) break
    }
    _ >= S ||
      _ > l * 10 ||
      ((r.nextLoadLevel = y),
      v ? this.bwEstimator.sample(u - Math.min(f, p), o.loaded) : this.bwEstimator.sampleTTFB(u),
      this.clearTimer(),
      G.warn(`[abr] Fragment ${e.sn}${t ? ' part ' + t.index : ''} of level ${
        e.level
      } is loading too slowly;
      Time to underbuffer: ${m.toFixed(3)} s
      Estimated load time for current fragment: ${S.toFixed(3)} s
      Estimated load time for down switch fragment: ${_.toFixed(3)} s
      TTFB estimate: ${p}
      Current BW estimate: ${J(E) ? (E / 1024).toFixed(3) : 'Unknown'} Kb/s
      New BW estimate: ${(this.bwEstimator.getEstimate() / 1024).toFixed(3)} Kb/s
      Aborting and switching to level ${y}`),
      e.loader && ((this.fragCurrent = this.partCurrent = null), e.abortRequests()),
      r.trigger(O.FRAG_LOAD_EMERGENCY_ABORTED, { frag: e, part: t, stats: o }))
  }
  onFragLoaded(e, { frag: t, part: r }) {
    const n = r ? r.stats : t.stats
    if (
      (t.type === ie.MAIN && this.bwEstimator.sampleTTFB(n.loading.first - n.loading.start),
      !this.ignoreFragment(t))
    ) {
      if (
        (this.clearTimer(),
        (this.lastLoadedFragLevel = t.level),
        (this._nextAutoLevel = -1),
        this.hls.config.abrMaxWithRealBitrate)
      ) {
        const i = r ? r.duration : t.duration,
          a = this.hls.levels[t.level],
          o = (a.loaded ? a.loaded.bytes : 0) + n.loaded,
          l = (a.loaded ? a.loaded.duration : 0) + i
        ;(a.loaded = { bytes: o, duration: l }), (a.realBitrate = Math.round((8 * o) / l))
      }
      if (t.bitrateTest) {
        const i = { stats: n, frag: t, part: r, id: t.type }
        this.onFragBuffered(O.FRAG_BUFFERED, i), (t.bitrateTest = !1)
      }
    }
  }
  onFragBuffered(e, t) {
    const { frag: r, part: n } = t,
      i = n != null && n.stats.loaded ? n.stats : r.stats
    if (i.aborted || this.ignoreFragment(r)) return
    const a =
      i.parsing.end -
      i.loading.start -
      Math.min(i.loading.first - i.loading.start, this.bwEstimator.getEstimateTTFB())
    this.bwEstimator.sample(a, i.loaded),
      (i.bwEstimate = this.bwEstimator.getEstimate()),
      r.bitrateTest ? (this.bitrateTestDelay = a / 1e3) : (this.bitrateTestDelay = 0)
  }
  ignoreFragment(e) {
    return e.type !== ie.MAIN || e.sn === 'initSegment'
  }
  clearTimer() {
    self.clearInterval(this.timer)
  }
  get nextAutoLevel() {
    const e = this._nextAutoLevel,
      t = this.bwEstimator
    if (e !== -1 && !t.canEstimate()) return e
    let r = this.getNextABRAutoLevel()
    if (e !== -1) {
      const n = this.hls.levels
      if (n.length > Math.max(e, r) && n[e].loadError <= n[r].loadError) return e
    }
    return e !== -1 && (r = Math.min(e, r)), r
  }
  getNextABRAutoLevel() {
    const { fragCurrent: e, partCurrent: t, hls: r } = this,
      { maxAutoLevel: n, config: i, minAutoLevel: a, media: o } = r,
      l = t ? t.duration : e ? e.duration : 0,
      u = o && o.playbackRate !== 0 ? Math.abs(o.playbackRate) : 1,
      c = this.bwEstimator ? this.bwEstimator.getEstimate() : i.abrEwmaDefaultEstimate,
      f = r.mainForwardBufferInfo,
      d = (f ? f.len : 0) / u
    let m = this.findBestLevel(c, a, n, d, i.abrBandWidthFactor, i.abrBandWidthUpFactor)
    if (m >= 0) return m
    G.trace(
      `[abr] ${d ? 'rebuffering expected' : 'buffer is empty'}, finding optimal quality level`
    )
    let p = l ? Math.min(l, i.maxStarvationDelay) : i.maxStarvationDelay,
      v = i.abrBandWidthFactor,
      E = i.abrBandWidthUpFactor
    if (!d) {
      const x = this.bitrateTestDelay
      x &&
        ((p = (l ? Math.min(l, i.maxLoadingDelay) : i.maxLoadingDelay) - x),
        G.trace(
          `[abr] bitrate test took ${Math.round(
            1e3 * x
          )}ms, set first fragment max fetchDuration to ${Math.round(1e3 * p)} ms`
        ),
        (v = E = 1))
    }
    return (m = this.findBestLevel(c, a, n, d + p, v, E)), Math.max(m, 0)
  }
  findBestLevel(e, t, r, n, i, a) {
    var o
    const { fragCurrent: l, partCurrent: u, lastLoadedFragLevel: c } = this,
      { levels: f } = this.hls,
      d = f[c],
      m = !!(d != null && (o = d.details) != null && o.live),
      p = d == null ? void 0 : d.codecSet,
      v = u ? u.duration : l ? l.duration : 0,
      E = this.bwEstimator.getEstimateTTFB() / 1e3
    let x = t,
      T = -1
    for (let b = r; b >= t; b--) {
      const R = f[b]
      if (!R || (p && R.codecSet !== p)) {
        R && ((x = Math.min(b, x)), (T = Math.max(b, T)))
        continue
      }
      T !== -1 &&
        G.trace(
          `[abr] Skipped level(s) ${x}-${T} with CODECS:"${f[T].attrs.CODECS}"; not compatible with "${d.attrs.CODECS}"`
        )
      const g = R.details,
        A =
          (u
            ? g == null
              ? void 0
              : g.partTarget
            : g == null
            ? void 0
            : g.averagetargetduration) || v
      let S
      b <= c ? (S = i * e) : (S = a * e)
      const h = f[b].maxBitrate,
        _ = this.getTimeToLoadFrag(E, S, h * A, g === void 0)
      if (
        (G.trace(
          `[abr] level:${b} adjustedbw-bitrate:${Math.round(S - h)} avgDuration:${A.toFixed(
            1
          )} maxFetchDuration:${n.toFixed(1)} fetchDuration:${_.toFixed(1)}`
        ),
        S > h && (_ === 0 || !J(_) || (m && !this.bitrateTestDelay) || _ < n))
      )
        return b
    }
    return -1
  }
  set nextAutoLevel(e) {
    this._nextAutoLevel = e
  }
}
class Ia {
  constructor() {
    ;(this.chunks = []), (this.dataLength = 0)
  }
  push(e) {
    this.chunks.push(e), (this.dataLength += e.length)
  }
  flush() {
    const { chunks: e, dataLength: t } = this
    let r
    if (e.length) e.length === 1 ? (r = e[0]) : (r = kf(e, t))
    else return new Uint8Array(0)
    return this.reset(), r
  }
  reset() {
    ;(this.chunks.length = 0), (this.dataLength = 0)
  }
}
function kf(s, e) {
  const t = new Uint8Array(e)
  let r = 0
  for (let n = 0; n < s.length; n++) {
    const i = s[n]
    t.set(i, r), (r += i.length)
  }
  return t
}
const ts = 100
class Mf extends Gn {
  constructor(e, t, r) {
    super(e, t, r, '[audio-stream-controller]', ie.AUDIO),
      (this.videoBuffer = null),
      (this.videoTrackCC = -1),
      (this.waitingVideoCC = -1),
      (this.bufferedTrack = null),
      (this.switchingTrack = null),
      (this.trackId = -1),
      (this.waitingData = null),
      (this.mainDetails = null),
      (this.bufferFlushed = !1),
      (this.cachedTrackLoadedData = null),
      this._registerListeners()
  }
  onHandlerDestroying() {
    this._unregisterListeners(),
      (this.mainDetails = null),
      (this.bufferedTrack = null),
      (this.switchingTrack = null)
  }
  _registerListeners() {
    const { hls: e } = this
    e.on(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(O.LEVEL_LOADED, this.onLevelLoaded, this),
      e.on(O.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
      e.on(O.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
      e.on(O.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
      e.on(O.ERROR, this.onError, this),
      e.on(O.BUFFER_RESET, this.onBufferReset, this),
      e.on(O.BUFFER_CREATED, this.onBufferCreated, this),
      e.on(O.BUFFER_FLUSHED, this.onBufferFlushed, this),
      e.on(O.INIT_PTS_FOUND, this.onInitPtsFound, this),
      e.on(O.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  _unregisterListeners() {
    const { hls: e } = this
    e.off(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(O.LEVEL_LOADED, this.onLevelLoaded, this),
      e.off(O.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
      e.off(O.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
      e.off(O.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
      e.off(O.ERROR, this.onError, this),
      e.off(O.BUFFER_RESET, this.onBufferReset, this),
      e.off(O.BUFFER_CREATED, this.onBufferCreated, this),
      e.off(O.BUFFER_FLUSHED, this.onBufferFlushed, this),
      e.off(O.INIT_PTS_FOUND, this.onInitPtsFound, this),
      e.off(O.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  onInitPtsFound(e, { frag: t, id: r, initPTS: n, timescale: i }) {
    if (r === 'main') {
      const a = t.cc
      ;(this.initPTS[t.cc] = { baseTime: n, timescale: i }),
        this.log(`InitPTS for cc: ${a} found from main: ${n}`),
        (this.videoTrackCC = a),
        this.state === W.WAITING_INIT_PTS && this.tick()
    }
  }
  startLoad(e) {
    if (!this.levels) {
      ;(this.startPosition = e), (this.state = W.STOPPED)
      return
    }
    const t = this.lastCurrentTime
    this.stopLoad(),
      this.setInterval(ts),
      t > 0 && e === -1
        ? (this.log(`Override startPosition with lastCurrentTime @${t.toFixed(3)}`),
          (e = t),
          (this.state = W.IDLE))
        : ((this.loadedmetadata = !1), (this.state = W.WAITING_TRACK)),
      (this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e),
      this.tick()
  }
  doTick() {
    switch (this.state) {
      case W.IDLE:
        this.doTickIdle()
        break
      case W.WAITING_TRACK: {
        var e
        const { levels: r, trackId: n } = this,
          i = r == null || (e = r[n]) == null ? void 0 : e.details
        if (i) {
          if (this.waitForCdnTuneIn(i)) break
          this.state = W.WAITING_INIT_PTS
        }
        break
      }
      case W.FRAG_LOADING_WAITING_RETRY: {
        var t
        const r = performance.now(),
          n = this.retryDate
        ;(!n || r >= n || ((t = this.media) != null && t.seeking)) &&
          (this.log('RetryDate reached, switch back to IDLE state'),
          this.resetStartWhenNotLoaded(this.trackId),
          (this.state = W.IDLE))
        break
      }
      case W.WAITING_INIT_PTS: {
        const r = this.waitingData
        if (r) {
          const { frag: n, part: i, cache: a, complete: o } = r
          if (this.initPTS[n.cc] !== void 0) {
            ;(this.waitingData = null), (this.waitingVideoCC = -1), (this.state = W.FRAG_LOADING)
            const l = a.flush(),
              u = { frag: n, part: i, payload: l, networkDetails: null }
            this._handleFragmentLoadProgress(u), o && super._handleFragmentLoadComplete(u)
          } else if (this.videoTrackCC !== this.waitingVideoCC)
            this.log(
              `Waiting fragment cc (${n.cc}) cancelled because video is at cc ${this.videoTrackCC}`
            ),
              this.clearWaitingFragment()
          else {
            const l = this.getLoadPosition(),
              u = ge.bufferInfo(this.mediaBuffer, l, this.config.maxBufferHole)
            bn(u.end, this.config.maxFragLookUpTolerance, n) < 0 &&
              (this.log(
                `Waiting fragment cc (${n.cc}) @ ${n.start} cancelled because another fragment at ${u.end} is needed`
              ),
              this.clearWaitingFragment())
          }
        } else this.state = W.IDLE
      }
    }
    this.onTickEnd()
  }
  clearWaitingFragment() {
    const e = this.waitingData
    e &&
      (this.fragmentTracker.removeFragment(e.frag),
      (this.waitingData = null),
      (this.waitingVideoCC = -1),
      (this.state = W.IDLE))
  }
  resetLoadingState() {
    this.clearWaitingFragment(), super.resetLoadingState()
  }
  onTickEnd() {
    const { media: e } = this
    e != null && e.readyState && (this.lastCurrentTime = e.currentTime)
  }
  doTickIdle() {
    const { hls: e, levels: t, media: r, trackId: n } = this,
      i = e.config
    if (!(t != null && t[n]) || (!r && (this.startFragRequested || !i.startFragPrefetch))) return
    const a = t[n],
      o = a.details
    if (!o || (o.live && this.levelLastLoaded !== n) || this.waitForCdnTuneIn(o)) {
      this.state = W.WAITING_TRACK
      return
    }
    const l = this.mediaBuffer ? this.mediaBuffer : this.media
    this.bufferFlushed &&
      l &&
      ((this.bufferFlushed = !1), this.afterBufferFlushed(l, pe.AUDIO, ie.AUDIO))
    const u = this.getFwdBufferInfo(l, ie.AUDIO)
    if (u === null) return
    const { bufferedTrack: c, switchingTrack: f } = this
    if (!f && this._streamEnded(u, o)) {
      e.trigger(O.BUFFER_EOS, { type: 'audio' }), (this.state = W.ENDED)
      return
    }
    const d = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, ie.MAIN),
      m = u.len,
      p = this.getMaxBufferLength(d == null ? void 0 : d.len)
    if (m >= p && !f) return
    const E = o.fragments[0].start
    let x = u.end
    if (f && r) {
      const g = this.getLoadPosition()
      c && f.attrs !== c.attrs && (x = g),
        o.PTSKnown &&
          g < E &&
          (u.end > E || u.nextStart) &&
          (this.log('Alt audio track ahead of main track, seek to start of alt audio track'),
          (r.currentTime = E + 0.05))
    }
    let T = this.getNextFragment(x, o),
      b = !1
    if (
      (T &&
        this.isLoopLoading(T, x) &&
        ((b = !!T.gap), (T = this.getNextFragmentLoopLoading(T, o, u, ie.MAIN, p))),
      !T)
    ) {
      this.bufferFlushed = !0
      return
    }
    const R = d && T.start > d.end + o.targetduration
    if (R || (!(d != null && d.len) && u.len)) {
      const g = this.getAppendedFrag(T.start, ie.MAIN)
      if (
        g === null ||
        (b || (b = !!g.gap || (!!R && d.len === 0)),
        (R && !b) || (b && u.nextStart && u.nextStart < g.end))
      )
        return
    }
    this.loadFragment(T, a, x)
  }
  getMaxBufferLength(e) {
    const t = super.getMaxBufferLength()
    return e ? Math.min(Math.max(t, e), this.config.maxMaxBufferLength) : t
  }
  onMediaDetaching() {
    ;(this.videoBuffer = null), super.onMediaDetaching()
  }
  onAudioTracksUpdated(e, { audioTracks: t }) {
    this.resetTransmuxer(), (this.levels = t.map((r) => new Ht(r)))
  }
  onAudioTrackSwitching(e, t) {
    const r = !!t.url
    this.trackId = t.id
    const { fragCurrent: n } = this
    n && (n.abortRequests(), this.removeUnbufferedFrags(n.start)),
      this.resetLoadingState(),
      r ? this.setInterval(ts) : this.resetTransmuxer(),
      r
        ? ((this.switchingTrack = t), (this.state = W.IDLE))
        : ((this.switchingTrack = null), (this.bufferedTrack = t), (this.state = W.STOPPED)),
      this.tick()
  }
  onManifestLoading() {
    this.fragmentTracker.removeAllFragments(),
      (this.startPosition = this.lastCurrentTime = 0),
      (this.bufferFlushed = !1),
      (this.levels =
        this.mainDetails =
        this.waitingData =
        this.bufferedTrack =
        this.cachedTrackLoadedData =
        this.switchingTrack =
          null),
      (this.startFragRequested = !1),
      (this.trackId = this.videoTrackCC = this.waitingVideoCC = -1)
  }
  onLevelLoaded(e, t) {
    ;(this.mainDetails = t.details),
      this.cachedTrackLoadedData !== null &&
        (this.hls.trigger(O.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData),
        (this.cachedTrackLoadedData = null))
  }
  onAudioTrackLoaded(e, t) {
    var r
    if (this.mainDetails == null) {
      this.cachedTrackLoadedData = t
      return
    }
    const { levels: n } = this,
      { details: i, id: a } = t
    if (!n) {
      this.warn(`Audio tracks were reset while loading level ${a}`)
      return
    }
    this.log(
      `Track ${a} loaded [${i.startSN},${i.endSN}]${
        i.lastPartSn ? `[part-${i.lastPartSn}-${i.lastPartIndex}]` : ''
      },duration:${i.totalduration}`
    )
    const o = n[a]
    let l = 0
    if (i.live || ((r = o.details) != null && r.live)) {
      this.checkLiveUpdate(i)
      const u = this.mainDetails
      if (i.deltaUpdateFailed || !u) return
      !o.details && i.hasProgramDateTime && u.hasProgramDateTime
        ? (da(i, u), (l = i.fragments[0].start))
        : (l = this.alignPlaylists(i, o.details))
    }
    ;(o.details = i),
      (this.levelLastLoaded = a),
      !this.startFragRequested &&
        (this.mainDetails || !i.live) &&
        this.setStartPosition(o.details, l),
      this.state === W.WAITING_TRACK && !this.waitForCdnTuneIn(i) && (this.state = W.IDLE),
      this.tick()
  }
  _handleFragmentLoadProgress(e) {
    var t
    const { frag: r, part: n, payload: i } = e,
      { config: a, trackId: o, levels: l } = this
    if (!l) {
      this.warn(
        `Audio tracks were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`
      )
      return
    }
    const u = l[o]
    if (!u) {
      this.warn('Audio track is undefined on fragment load progress')
      return
    }
    const c = u.details
    if (!c) {
      this.warn('Audio track details undefined on fragment load progress'),
        this.removeUnbufferedFrags(r.start)
      return
    }
    const f = a.defaultAudioCodec || u.audioCodec || 'mp4a.40.2'
    let d = this.transmuxer
    d ||
      (d = this.transmuxer =
        new Ra(
          this.hls,
          ie.AUDIO,
          this._handleTransmuxComplete.bind(this),
          this._handleTransmuxerFlush.bind(this)
        ))
    const m = this.initPTS[r.cc],
      p = (t = r.initSegment) == null ? void 0 : t.data
    if (m !== void 0) {
      const E = n ? n.index : -1,
        x = E !== -1,
        T = new Nn(r.level, r.sn, r.stats.chunkCount, i.byteLength, E, x)
      d.push(i, p, f, '', r, n, c.totalduration, !1, T, m)
    } else {
      this.log(
        `Unknown video PTS for cc ${r.cc}, waiting for video PTS before demuxing audio frag ${r.sn} of [${c.startSN} ,${c.endSN}],track ${o}`
      )
      const { cache: v } = (this.waitingData = this.waitingData || {
        frag: r,
        part: n,
        cache: new Ia(),
        complete: !1
      })
      v.push(new Uint8Array(i)),
        (this.waitingVideoCC = this.videoTrackCC),
        (this.state = W.WAITING_INIT_PTS)
    }
  }
  _handleFragmentLoadComplete(e) {
    if (this.waitingData) {
      this.waitingData.complete = !0
      return
    }
    super._handleFragmentLoadComplete(e)
  }
  onBufferReset() {
    ;(this.mediaBuffer = this.videoBuffer = null), (this.loadedmetadata = !1)
  }
  onBufferCreated(e, t) {
    const r = t.tracks.audio
    r && (this.mediaBuffer = r.buffer || null),
      t.tracks.video && (this.videoBuffer = t.tracks.video.buffer || null)
  }
  onFragBuffered(e, t) {
    const { frag: r, part: n } = t
    if (r.type !== ie.AUDIO) {
      if (!this.loadedmetadata && r.type === ie.MAIN) {
        const i = this.videoBuffer || this.media
        i && ge.getBuffered(i).length && (this.loadedmetadata = !0)
      }
      return
    }
    if (this.fragContextChanged(r)) {
      this.warn(
        `Fragment ${r.sn}${n ? ' p: ' + n.index : ''} of level ${
          r.level
        } finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${
          this.switchingTrack ? this.switchingTrack.name : 'false'
        }`
      )
      return
    }
    if (r.sn !== 'initSegment') {
      this.fragPrevious = r
      const i = this.switchingTrack
      i &&
        ((this.bufferedTrack = i),
        (this.switchingTrack = null),
        this.hls.trigger(O.AUDIO_TRACK_SWITCHED, Ve({}, i)))
    }
    this.fragBufferedComplete(r, n)
  }
  onError(e, t) {
    var r
    if (t.fatal) {
      this.state = W.ERROR
      return
    }
    switch (t.details) {
      case K.FRAG_GAP:
      case K.FRAG_PARSING_ERROR:
      case K.FRAG_DECRYPT_ERROR:
      case K.FRAG_LOAD_ERROR:
      case K.FRAG_LOAD_TIMEOUT:
      case K.KEY_LOAD_ERROR:
      case K.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(ie.AUDIO, t)
        break
      case K.AUDIO_TRACK_LOAD_ERROR:
      case K.AUDIO_TRACK_LOAD_TIMEOUT:
      case K.LEVEL_PARSING_ERROR:
        !t.levelRetry &&
          this.state === W.WAITING_TRACK &&
          ((r = t.context) == null ? void 0 : r.type) === fe.AUDIO_TRACK &&
          (this.state = W.IDLE)
        break
      case K.BUFFER_FULL_ERROR:
        if (!t.parent || t.parent !== 'audio') return
        this.reduceLengthAndFlushBuffer(t) &&
          ((this.bufferedTrack = null), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio'))
        break
      case K.INTERNAL_EXCEPTION:
        this.recoverWorkerError(t)
        break
    }
  }
  onBufferFlushed(e, { type: t }) {
    t === pe.AUDIO && ((this.bufferFlushed = !0), this.state === W.ENDED && (this.state = W.IDLE))
  }
  _handleTransmuxComplete(e) {
    var t
    const r = 'audio',
      { hls: n } = this,
      { remuxResult: i, chunkMeta: a } = e,
      o = this.getCurrentContext(a)
    if (!o) {
      this.resetWhenMissingContext(a)
      return
    }
    const { frag: l, part: u, level: c } = o,
      { details: f } = c,
      { audio: d, text: m, id3: p, initSegment: v } = i
    if (this.fragContextChanged(l) || !f) {
      this.fragmentTracker.removeFragment(l)
      return
    }
    if (
      ((this.state = W.PARSING),
      this.switchingTrack && d && this.completeAudioSwitch(this.switchingTrack),
      v != null && v.tracks)
    ) {
      const E = l.initSegment || l
      this._bufferInitSegment(v.tracks, E, a),
        n.trigger(O.FRAG_PARSING_INIT_SEGMENT, { frag: E, id: r, tracks: v.tracks })
    }
    if (d) {
      const { startPTS: E, endPTS: x, startDTS: T, endDTS: b } = d
      u && (u.elementaryStreams[pe.AUDIO] = { startPTS: E, endPTS: x, startDTS: T, endDTS: b }),
        l.setElementaryStreamInfo(pe.AUDIO, E, x, T, b),
        this.bufferFragmentData(d, l, u, a)
    }
    if (p != null && (t = p.samples) != null && t.length) {
      const E = Te({ id: r, frag: l, details: f }, p)
      n.trigger(O.FRAG_PARSING_METADATA, E)
    }
    if (m) {
      const E = Te({ id: r, frag: l, details: f }, m)
      n.trigger(O.FRAG_PARSING_USERDATA, E)
    }
  }
  _bufferInitSegment(e, t, r) {
    if (this.state !== W.PARSING) return
    e.video && delete e.video
    const n = e.audio
    if (!n) return
    ;(n.levelCodec = n.codec),
      (n.id = 'audio'),
      this.log(`Init audio buffer, container:${n.container}, codecs[parsed]=[${n.codec}]`),
      this.hls.trigger(O.BUFFER_CODECS, e)
    const i = n.initSegment
    if (i != null && i.byteLength) {
      const a = { type: 'audio', frag: t, part: null, chunkMeta: r, parent: t.type, data: i }
      this.hls.trigger(O.BUFFER_APPENDING, a)
    }
    this.tick()
  }
  loadFragment(e, t, r) {
    const n = this.fragmentTracker.getState(e)
    if (((this.fragCurrent = e), this.switchingTrack || n === Re.NOT_LOADED || n === Re.PARTIAL)) {
      var i
      e.sn === 'initSegment'
        ? this._loadInitSegment(e, t)
        : (i = t.details) != null && i.live && !this.initPTS[e.cc]
        ? (this.log(
            `Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`
          ),
          (this.state = W.WAITING_INIT_PTS))
        : ((this.startFragRequested = !0), super.loadFragment(e, t, r))
    } else this.clearTrackerIfNeeded(e)
  }
  completeAudioSwitch(e) {
    const { hls: t, media: r, bufferedTrack: n } = this,
      i = n == null ? void 0 : n.attrs,
      a = e.attrs
    r &&
      i &&
      (i.CHANNELS !== a.CHANNELS || i.NAME !== a.NAME || i.LANGUAGE !== a.LANGUAGE) &&
      (this.log('Switching audio track : flushing all audio'),
      super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio')),
      (this.bufferedTrack = e),
      (this.switchingTrack = null),
      t.trigger(O.AUDIO_TRACK_SWITCHED, Ve({}, e))
  }
}
class Ff extends Fn {
  constructor(e) {
    super(e, '[audio-track-controller]'),
      (this.tracks = []),
      (this.groupId = null),
      (this.tracksInGroup = []),
      (this.trackId = -1),
      (this.currentTrack = null),
      (this.selectDefaultTrack = !0),
      this.registerListeners()
  }
  registerListeners() {
    const { hls: e } = this
    e.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(O.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on(O.LEVEL_LOADING, this.onLevelLoading, this),
      e.on(O.LEVEL_SWITCHING, this.onLevelSwitching, this),
      e.on(O.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
      e.on(O.ERROR, this.onError, this)
  }
  unregisterListeners() {
    const { hls: e } = this
    e.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(O.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off(O.LEVEL_LOADING, this.onLevelLoading, this),
      e.off(O.LEVEL_SWITCHING, this.onLevelSwitching, this),
      e.off(O.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
      e.off(O.ERROR, this.onError, this)
  }
  destroy() {
    this.unregisterListeners(),
      (this.tracks.length = 0),
      (this.tracksInGroup.length = 0),
      (this.currentTrack = null),
      super.destroy()
  }
  onManifestLoading() {
    ;(this.tracks = []),
      (this.groupId = null),
      (this.tracksInGroup = []),
      (this.trackId = -1),
      (this.currentTrack = null),
      (this.selectDefaultTrack = !0)
  }
  onManifestParsed(e, t) {
    this.tracks = t.audioTracks || []
  }
  onAudioTrackLoaded(e, t) {
    const { id: r, groupId: n, details: i } = t,
      a = this.tracksInGroup[r]
    if (!a || a.groupId !== n) {
      this.warn(`Track with id:${r} and group:${n} not found in active group ${a.groupId}`)
      return
    }
    const o = a.details
    ;(a.details = t.details),
      this.log(
        `audio-track ${r} "${a.name}" lang:${a.lang} group:${n} loaded [${i.startSN}-${i.endSN}]`
      ),
      r === this.trackId && this.playlistLoaded(r, t, o)
  }
  onLevelLoading(e, t) {
    this.switchLevel(t.level)
  }
  onLevelSwitching(e, t) {
    this.switchLevel(t.level)
  }
  switchLevel(e) {
    const t = this.hls.levels[e]
    if (!(t != null && t.audioGroupIds)) return
    const r = t.audioGroupIds[t.urlId]
    if (this.groupId !== r) {
      this.groupId = r || null
      const n = this.tracks.filter((a) => !r || a.groupId === r)
      this.selectDefaultTrack && !n.some((a) => a.default) && (this.selectDefaultTrack = !1),
        (this.tracksInGroup = n)
      const i = { audioTracks: n }
      this.log(`Updating audio tracks, ${n.length} track(s) found in group:${r}`),
        this.hls.trigger(O.AUDIO_TRACKS_UPDATED, i),
        this.selectInitialTrack()
    } else this.shouldReloadPlaylist(this.currentTrack) && this.setAudioTrack(this.trackId)
  }
  onError(e, t) {
    t.fatal ||
      !t.context ||
      (t.context.type === fe.AUDIO_TRACK &&
        t.context.id === this.trackId &&
        t.context.groupId === this.groupId &&
        ((this.requestScheduled = -1), this.checkRetry(t)))
  }
  get audioTracks() {
    return this.tracksInGroup
  }
  get audioTrack() {
    return this.trackId
  }
  set audioTrack(e) {
    ;(this.selectDefaultTrack = !1), this.setAudioTrack(e)
  }
  setAudioTrack(e) {
    const t = this.tracksInGroup
    if (e < 0 || e >= t.length) {
      this.warn('Invalid id passed to audio-track controller')
      return
    }
    this.clearTimer()
    const r = this.currentTrack
    t[this.trackId]
    const n = t[e],
      { groupId: i, name: a } = n
    if (
      (this.log(`Switching to audio-track ${e} "${a}" lang:${n.lang} group:${i}`),
      (this.trackId = e),
      (this.currentTrack = n),
      (this.selectDefaultTrack = !1),
      this.hls.trigger(O.AUDIO_TRACK_SWITCHING, Ve({}, n)),
      n.details && !n.details.live)
    )
      return
    const o = this.switchParams(n.url, r == null ? void 0 : r.details)
    this.loadPlaylist(o)
  }
  selectInitialTrack() {
    const e = this.tracksInGroup,
      t = this.findTrackId(this.currentTrack) | this.findTrackId(null)
    if (t !== -1) this.setAudioTrack(t)
    else {
      const r = new Error(
        `No track found for running audio group-ID: ${this.groupId} track count: ${e.length}`
      )
      this.warn(r.message),
        this.hls.trigger(O.ERROR, {
          type: ne.MEDIA_ERROR,
          details: K.AUDIO_TRACK_LOAD_ERROR,
          fatal: !0,
          error: r
        })
    }
  }
  findTrackId(e) {
    const t = this.tracksInGroup
    for (let r = 0; r < t.length; r++) {
      const n = t[r]
      if (
        (!this.selectDefaultTrack || n.default) &&
        (!e ||
          (e.attrs['STABLE-RENDITION-ID'] !== void 0 &&
            e.attrs['STABLE-RENDITION-ID'] === n.attrs['STABLE-RENDITION-ID']) ||
          (e.name === n.name && e.lang === n.lang))
      )
        return n.id
    }
    return -1
  }
  loadPlaylist(e) {
    super.loadPlaylist()
    const t = this.tracksInGroup[this.trackId]
    if (this.shouldLoadPlaylist(t)) {
      const r = t.id,
        n = t.groupId
      let i = t.url
      if (e)
        try {
          i = e.addDirectives(i)
        } catch (a) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${a}`)
        }
      this.log(`loading audio-track playlist ${r} "${t.name}" lang:${t.lang} group:${n}`),
        this.clearTimer(),
        this.hls.trigger(O.AUDIO_TRACK_LOADING, {
          url: i,
          id: r,
          groupId: n,
          deliveryDirectives: e || null
        })
    }
  }
}
function Pa(s, e) {
  if (s.length !== e.length) return !1
  for (let t = 0; t < s.length; t++) if (!Nf(s[t].attrs, e[t].attrs)) return !1
  return !0
}
function Nf(s, e) {
  const t = s['STABLE-RENDITION-ID']
  return t
    ? t === e['STABLE-RENDITION-ID']
    : !['LANGUAGE', 'NAME', 'CHARACTERISTICS', 'AUTOSELECT', 'DEFAULT', 'FORCED'].some(
        (r) => s[r] !== e[r]
      )
}
const rs = 500
class Uf extends Gn {
  constructor(e, t, r) {
    super(e, t, r, '[subtitle-stream-controller]', ie.SUBTITLE),
      (this.levels = []),
      (this.currentTrackId = -1),
      (this.tracksBuffered = []),
      (this.mainDetails = null),
      this._registerListeners()
  }
  onHandlerDestroying() {
    this._unregisterListeners(), (this.mainDetails = null)
  }
  _registerListeners() {
    const { hls: e } = this
    e.on(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(O.LEVEL_LOADED, this.onLevelLoaded, this),
      e.on(O.ERROR, this.onError, this),
      e.on(O.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
      e.on(O.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
      e.on(O.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
      e.on(O.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this),
      e.on(O.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.on(O.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  _unregisterListeners() {
    const { hls: e } = this
    e.off(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(O.LEVEL_LOADED, this.onLevelLoaded, this),
      e.off(O.ERROR, this.onError, this),
      e.off(O.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
      e.off(O.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
      e.off(O.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
      e.off(O.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this),
      e.off(O.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.off(O.FRAG_BUFFERED, this.onFragBuffered, this)
  }
  startLoad(e) {
    this.stopLoad(),
      (this.state = W.IDLE),
      this.setInterval(rs),
      (this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e),
      this.tick()
  }
  onManifestLoading() {
    ;(this.mainDetails = null), this.fragmentTracker.removeAllFragments()
  }
  onMediaDetaching() {
    ;(this.tracksBuffered = []), super.onMediaDetaching()
  }
  onLevelLoaded(e, t) {
    this.mainDetails = t.details
  }
  onSubtitleFragProcessed(e, t) {
    const { frag: r, success: n } = t
    if (((this.fragPrevious = r), (this.state = W.IDLE), !n)) return
    const i = this.tracksBuffered[this.currentTrackId]
    if (!i) return
    let a
    const o = r.start
    for (let u = 0; u < i.length; u++)
      if (o >= i[u].start && o <= i[u].end) {
        a = i[u]
        break
      }
    const l = r.start + r.duration
    a ? (a.end = l) : ((a = { start: o, end: l }), i.push(a)), this.fragmentTracker.fragBuffered(r)
  }
  onBufferFlushing(e, t) {
    const { startOffset: r, endOffset: n } = t
    if (r === 0 && n !== Number.POSITIVE_INFINITY) {
      const i = n - 1
      if (i <= 0) return
      ;(t.endOffsetSubtitles = Math.max(0, i)),
        this.tracksBuffered.forEach((a) => {
          for (let o = 0; o < a.length; ) {
            if (a[o].end <= i) {
              a.shift()
              continue
            } else if (a[o].start < i) a[o].start = i
            else break
            o++
          }
        }),
        this.fragmentTracker.removeFragmentsInRange(r, i, ie.SUBTITLE)
    }
  }
  onFragBuffered(e, t) {
    if (!this.loadedmetadata && t.frag.type === ie.MAIN) {
      var r
      ;(r = this.media) != null && r.buffered.length && (this.loadedmetadata = !0)
    }
  }
  onError(e, t) {
    const r = t.frag
    ;(r == null ? void 0 : r.type) === ie.SUBTITLE &&
      (this.fragCurrent && this.fragCurrent.abortRequests(),
      this.state !== W.STOPPED && (this.state = W.IDLE))
  }
  onSubtitleTracksUpdated(e, { subtitleTracks: t }) {
    if (Pa(this.levels, t)) {
      this.levels = t.map((r) => new Ht(r))
      return
    }
    ;(this.tracksBuffered = []),
      (this.levels = t.map((r) => {
        const n = new Ht(r)
        return (this.tracksBuffered[n.id] = []), n
      })),
      this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, ie.SUBTITLE),
      (this.fragPrevious = null),
      (this.mediaBuffer = null)
  }
  onSubtitleTrackSwitch(e, t) {
    if (((this.currentTrackId = t.id), !this.levels.length || this.currentTrackId === -1)) {
      this.clearInterval()
      return
    }
    const r = this.levels[this.currentTrackId]
    r != null && r.details
      ? (this.mediaBuffer = this.mediaBufferTimeRanges)
      : (this.mediaBuffer = null),
      r && this.setInterval(rs)
  }
  onSubtitleTrackLoaded(e, t) {
    var r
    const { details: n, id: i } = t,
      { currentTrackId: a, levels: o } = this
    if (!o.length) return
    const l = o[a]
    if (i >= o.length || i !== a || !l) return
    this.mediaBuffer = this.mediaBufferTimeRanges
    let u = 0
    if (n.live || ((r = l.details) != null && r.live)) {
      const c = this.mainDetails
      if (n.deltaUpdateFailed || !c) return
      const f = c.fragments[0]
      l.details
        ? ((u = this.alignPlaylists(n, l.details)), u === 0 && f && ((u = f.start), Tn(n, u)))
        : n.hasProgramDateTime && c.hasProgramDateTime
        ? (da(n, c), (u = n.fragments[0].start))
        : f && ((u = f.start), Tn(n, u))
    }
    ;(l.details = n),
      (this.levelLastLoaded = i),
      !this.startFragRequested &&
        (this.mainDetails || !n.live) &&
        this.setStartPosition(l.details, u),
      this.tick(),
      n.live &&
        !this.fragCurrent &&
        this.media &&
        this.state === W.IDLE &&
        (Wt(null, n.fragments, this.media.currentTime, 0) ||
          (this.warn('Subtitle playlist not aligned with playback'), (l.details = void 0)))
  }
  _handleFragmentLoadComplete(e) {
    const { frag: t, payload: r } = e,
      n = t.decryptdata,
      i = this.hls
    if (
      !this.fragContextChanged(t) &&
      r &&
      r.byteLength > 0 &&
      n &&
      n.key &&
      n.iv &&
      n.method === 'AES-128'
    ) {
      const a = performance.now()
      this.decrypter
        .decrypt(new Uint8Array(r), n.key.buffer, n.iv.buffer)
        .catch((o) => {
          throw (
            (i.trigger(O.ERROR, {
              type: ne.MEDIA_ERROR,
              details: K.FRAG_DECRYPT_ERROR,
              fatal: !1,
              error: o,
              reason: o.message,
              frag: t
            }),
            o)
          )
        })
        .then((o) => {
          const l = performance.now()
          i.trigger(O.FRAG_DECRYPTED, { frag: t, payload: o, stats: { tstart: a, tdecrypt: l } })
        })
        .catch((o) => {
          this.warn(`${o.name}: ${o.message}`), (this.state = W.IDLE)
        })
    }
  }
  doTick() {
    if (!this.media) {
      this.state = W.IDLE
      return
    }
    if (this.state === W.IDLE) {
      const { currentTrackId: e, levels: t } = this,
        r = t[e]
      if (!t.length || !r || !r.details) return
      const { config: n } = this,
        i = this.getLoadPosition(),
        a = ge.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], i, n.maxBufferHole),
        { end: o, len: l } = a,
        u = this.getFwdBufferInfo(this.media, ie.MAIN),
        c = r.details,
        f = this.getMaxBufferLength(u == null ? void 0 : u.len) + c.levelTargetDuration
      if (l > f) return
      const d = c.fragments,
        m = d.length,
        p = c.edge
      let v = null
      const E = this.fragPrevious
      if (o < p) {
        const x = n.maxFragLookUpTolerance,
          T = o > p - x ? 0 : x
        ;(v = Wt(E, d, Math.max(d[0].start, o), T)), !v && E && E.start < d[0].start && (v = d[0])
      } else v = d[m - 1]
      if (!v) return
      if (((v = this.mapToInitFragWhenRequired(v)), v.sn !== 'initSegment')) {
        const x = v.sn - c.startSN,
          T = d[x - 1]
        T && T.cc === v.cc && this.fragmentTracker.getState(T) === Re.NOT_LOADED && (v = T)
      }
      this.fragmentTracker.getState(v) === Re.NOT_LOADED && this.loadFragment(v, r, o)
    }
  }
  getMaxBufferLength(e) {
    const t = super.getMaxBufferLength()
    return e ? Math.max(t, e) : t
  }
  loadFragment(e, t, r) {
    ;(this.fragCurrent = e),
      e.sn === 'initSegment'
        ? this._loadInitSegment(e, t)
        : ((this.startFragRequested = !0), super.loadFragment(e, t, r))
  }
  get mediaBufferTimeRanges() {
    return new Bf(this.tracksBuffered[this.currentTrackId] || [])
  }
}
class Bf {
  constructor(e) {
    this.buffered = void 0
    const t = (r, n, i) => {
      if (((n = n >>> 0), n > i - 1))
        throw new DOMException(
          `Failed to execute '${r}' on 'TimeRanges': The index provided (${n}) is greater than the maximum bound (${i})`
        )
      return e[n][r]
    }
    this.buffered = {
      get length() {
        return e.length
      },
      end(r) {
        return t('end', r, e.length)
      },
      start(r) {
        return t('start', r, e.length)
      }
    }
  }
}
class Gf extends Fn {
  constructor(e) {
    super(e, '[subtitle-track-controller]'),
      (this.media = null),
      (this.tracks = []),
      (this.groupId = null),
      (this.tracksInGroup = []),
      (this.trackId = -1),
      (this.selectDefaultTrack = !0),
      (this.queuedDefaultTrack = -1),
      (this.trackChangeListener = () => this.onTextTracksChanged()),
      (this.asyncPollTrackChange = () => this.pollTrackChange(0)),
      (this.useTextTrackPolling = !1),
      (this.subtitlePollingInterval = -1),
      (this._subtitleDisplay = !0),
      this.registerListeners()
  }
  destroy() {
    this.unregisterListeners(),
      (this.tracks.length = 0),
      (this.tracksInGroup.length = 0),
      (this.trackChangeListener = this.asyncPollTrackChange = null),
      super.destroy()
  }
  get subtitleDisplay() {
    return this._subtitleDisplay
  }
  set subtitleDisplay(e) {
    ;(this._subtitleDisplay = e), this.trackId > -1 && this.toggleTrackModes(this.trackId)
  }
  registerListeners() {
    const { hls: e } = this
    e.on(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(O.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on(O.LEVEL_LOADING, this.onLevelLoading, this),
      e.on(O.LEVEL_SWITCHING, this.onLevelSwitching, this),
      e.on(O.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
      e.on(O.ERROR, this.onError, this)
  }
  unregisterListeners() {
    const { hls: e } = this
    e.off(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(O.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off(O.LEVEL_LOADING, this.onLevelLoading, this),
      e.off(O.LEVEL_SWITCHING, this.onLevelSwitching, this),
      e.off(O.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
      e.off(O.ERROR, this.onError, this)
  }
  onMediaAttached(e, t) {
    ;(this.media = t.media),
      this.media &&
        (this.queuedDefaultTrack > -1 &&
          ((this.subtitleTrack = this.queuedDefaultTrack), (this.queuedDefaultTrack = -1)),
        (this.useTextTrackPolling = !(
          this.media.textTracks && 'onchange' in this.media.textTracks
        )),
        this.useTextTrackPolling
          ? this.pollTrackChange(500)
          : this.media.textTracks.addEventListener('change', this.asyncPollTrackChange))
  }
  pollTrackChange(e) {
    self.clearInterval(this.subtitlePollingInterval),
      (this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, e))
  }
  onMediaDetaching() {
    if (!this.media) return
    self.clearInterval(this.subtitlePollingInterval),
      this.useTextTrackPolling ||
        this.media.textTracks.removeEventListener('change', this.asyncPollTrackChange),
      this.trackId > -1 && (this.queuedDefaultTrack = this.trackId),
      sn(this.media.textTracks).forEach((t) => {
        Pt(t)
      }),
      (this.subtitleTrack = -1),
      (this.media = null)
  }
  onManifestLoading() {
    ;(this.tracks = []),
      (this.groupId = null),
      (this.tracksInGroup = []),
      (this.trackId = -1),
      (this.selectDefaultTrack = !0)
  }
  onManifestParsed(e, t) {
    this.tracks = t.subtitleTracks
  }
  onSubtitleTrackLoaded(e, t) {
    const { id: r, details: n } = t,
      { trackId: i } = this,
      a = this.tracksInGroup[i]
    if (!a) {
      this.warn(`Invalid subtitle track id ${r}`)
      return
    }
    const o = a.details
    ;(a.details = t.details),
      this.log(`subtitle track ${r} loaded [${n.startSN}-${n.endSN}]`),
      r === this.trackId && this.playlistLoaded(r, t, o)
  }
  onLevelLoading(e, t) {
    this.switchLevel(t.level)
  }
  onLevelSwitching(e, t) {
    this.switchLevel(t.level)
  }
  switchLevel(e) {
    const t = this.hls.levels[e]
    if (!(t != null && t.textGroupIds)) return
    const r = t.textGroupIds[t.urlId],
      n = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0
    if (this.groupId !== r) {
      const i = this.tracks.filter((l) => !r || l.groupId === r)
      this.tracksInGroup = i
      const a = this.findTrackId(n == null ? void 0 : n.name) || this.findTrackId()
      this.groupId = r || null
      const o = { subtitleTracks: i }
      this.log(`Updating subtitle tracks, ${i.length} track(s) found in "${r}" group-id`),
        this.hls.trigger(O.SUBTITLE_TRACKS_UPDATED, o),
        a !== -1 && this.setSubtitleTrack(a, n)
    } else this.shouldReloadPlaylist(n) && this.setSubtitleTrack(this.trackId, n)
  }
  findTrackId(e) {
    const t = this.tracksInGroup
    for (let r = 0; r < t.length; r++) {
      const n = t[r]
      if ((!this.selectDefaultTrack || n.default) && (!e || e === n.name)) return n.id
    }
    return -1
  }
  onError(e, t) {
    t.fatal ||
      !t.context ||
      (t.context.type === fe.SUBTITLE_TRACK &&
        t.context.id === this.trackId &&
        t.context.groupId === this.groupId &&
        this.checkRetry(t))
  }
  get subtitleTracks() {
    return this.tracksInGroup
  }
  get subtitleTrack() {
    return this.trackId
  }
  set subtitleTrack(e) {
    this.selectDefaultTrack = !1
    const t = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0
    this.setSubtitleTrack(e, t)
  }
  loadPlaylist(e) {
    super.loadPlaylist()
    const t = this.tracksInGroup[this.trackId]
    if (this.shouldLoadPlaylist(t)) {
      const r = t.id,
        n = t.groupId
      let i = t.url
      if (e)
        try {
          i = e.addDirectives(i)
        } catch (a) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${a}`)
        }
      this.log(`Loading subtitle playlist for id ${r}`),
        this.hls.trigger(O.SUBTITLE_TRACK_LOADING, {
          url: i,
          id: r,
          groupId: n,
          deliveryDirectives: e || null
        })
    }
  }
  toggleTrackModes(e) {
    const { media: t, trackId: r } = this
    if (!t) return
    const n = sn(t.textTracks),
      i = n.filter((o) => o.groupId === this.groupId)
    if (e === -1)
      [].slice.call(n).forEach((o) => {
        o.mode = 'disabled'
      })
    else {
      const o = i[r]
      o && (o.mode = 'disabled')
    }
    const a = i[e]
    a && (a.mode = this.subtitleDisplay ? 'showing' : 'hidden')
  }
  setSubtitleTrack(e, t) {
    var r
    const n = this.tracksInGroup
    if (!this.media) {
      this.queuedDefaultTrack = e
      return
    }
    if (
      (this.trackId !== e && this.toggleTrackModes(e),
      (this.trackId === e && (e === -1 || ((r = n[e]) != null && r.details))) ||
        e < -1 ||
        e >= n.length)
    )
      return
    this.clearTimer()
    const i = n[e]
    if (
      (this.log(
        `Switching to subtitle-track ${e}` +
          (i ? ` "${i.name}" lang:${i.lang} group:${i.groupId}` : '')
      ),
      (this.trackId = e),
      i)
    ) {
      const { id: a, groupId: o = '', name: l, type: u, url: c } = i
      this.hls.trigger(O.SUBTITLE_TRACK_SWITCH, { id: a, groupId: o, name: l, type: u, url: c })
      const f = this.switchParams(i.url, t == null ? void 0 : t.details)
      this.loadPlaylist(f)
    } else this.hls.trigger(O.SUBTITLE_TRACK_SWITCH, { id: e })
  }
  onTextTracksChanged() {
    if (
      (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval),
      !this.media || !this.hls.config.renderTextTracksNatively)
    )
      return
    let e = -1
    const t = sn(this.media.textTracks)
    for (let r = 0; r < t.length; r++)
      if (t[r].mode === 'hidden') e = r
      else if (t[r].mode === 'showing') {
        e = r
        break
      }
    this.subtitleTrack !== e && (this.subtitleTrack = e)
  }
}
function sn(s) {
  const e = []
  for (let t = 0; t < s.length; t++) {
    const r = s[t]
    ;(r.kind === 'subtitles' || r.kind === 'captions') && r.label && e.push(s[t])
  }
  return e
}
class $f {
  constructor(e) {
    ;(this.buffers = void 0),
      (this.queues = { video: [], audio: [], audiovideo: [] }),
      (this.buffers = e)
  }
  append(e, t) {
    const r = this.queues[t]
    r.push(e), r.length === 1 && this.buffers[t] && this.executeNext(t)
  }
  insertAbort(e, t) {
    this.queues[t].unshift(e), this.executeNext(t)
  }
  appendBlocker(e) {
    let t
    const r = new Promise((i) => {
        t = i
      }),
      n = { execute: t, onStart: () => {}, onComplete: () => {}, onError: () => {} }
    return this.append(n, e), r
  }
  executeNext(e) {
    const { buffers: t, queues: r } = this,
      n = t[e],
      i = r[e]
    if (i.length) {
      const a = i[0]
      try {
        a.execute()
      } catch (o) {
        G.warn('[buffer-operation-queue]: Unhandled exception executing the current operation'),
          a.onError(o),
          (n != null && n.updating) || (i.shift(), this.executeNext(e))
      }
    }
  }
  shiftAndExecuteNext(e) {
    this.queues[e].shift(), this.executeNext(e)
  }
  current(e) {
    return this.queues[e][0]
  }
}
const ns = xr(),
  is = /([ha]vc.)(?:\.[^.,]+)+/
class Kf {
  constructor(e) {
    ;(this.details = null),
      (this._objectUrl = null),
      (this.operationQueue = void 0),
      (this.listeners = void 0),
      (this.hls = void 0),
      (this.bufferCodecEventsExpected = 0),
      (this._bufferCodecEventsTotal = 0),
      (this.media = null),
      (this.mediaSource = null),
      (this.lastMpegAudioChunk = null),
      (this.appendError = 0),
      (this.tracks = {}),
      (this.pendingTracks = {}),
      (this.sourceBuffer = void 0),
      (this._onMediaSourceOpen = () => {
        const { media: t, mediaSource: r } = this
        G.log('[buffer-controller]: Media source opened'),
          t &&
            (t.removeEventListener('emptied', this._onMediaEmptied),
            this.updateMediaElementDuration(),
            this.hls.trigger(O.MEDIA_ATTACHED, { media: t })),
          r && r.removeEventListener('sourceopen', this._onMediaSourceOpen),
          this.checkPendingTracks()
      }),
      (this._onMediaSourceClose = () => {
        G.log('[buffer-controller]: Media source closed')
      }),
      (this._onMediaSourceEnded = () => {
        G.log('[buffer-controller]: Media source ended')
      }),
      (this._onMediaEmptied = () => {
        const { media: t, _objectUrl: r } = this
        t &&
          t.src !== r &&
          G.error(`Media element src was set while attaching MediaSource (${r} > ${t.src})`)
      }),
      (this.hls = e),
      this._initSourceBuffer(),
      this.registerListeners()
  }
  hasSourceTypes() {
    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0
  }
  destroy() {
    this.unregisterListeners(), (this.details = null), (this.lastMpegAudioChunk = null)
  }
  registerListeners() {
    const { hls: e } = this
    e.on(O.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(O.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on(O.BUFFER_RESET, this.onBufferReset, this),
      e.on(O.BUFFER_APPENDING, this.onBufferAppending, this),
      e.on(O.BUFFER_CODECS, this.onBufferCodecs, this),
      e.on(O.BUFFER_EOS, this.onBufferEos, this),
      e.on(O.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.on(O.LEVEL_UPDATED, this.onLevelUpdated, this),
      e.on(O.FRAG_PARSED, this.onFragParsed, this),
      e.on(O.FRAG_CHANGED, this.onFragChanged, this)
  }
  unregisterListeners() {
    const { hls: e } = this
    e.off(O.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(O.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off(O.BUFFER_RESET, this.onBufferReset, this),
      e.off(O.BUFFER_APPENDING, this.onBufferAppending, this),
      e.off(O.BUFFER_CODECS, this.onBufferCodecs, this),
      e.off(O.BUFFER_EOS, this.onBufferEos, this),
      e.off(O.BUFFER_FLUSHING, this.onBufferFlushing, this),
      e.off(O.LEVEL_UPDATED, this.onLevelUpdated, this),
      e.off(O.FRAG_PARSED, this.onFragParsed, this),
      e.off(O.FRAG_CHANGED, this.onFragChanged, this)
  }
  _initSourceBuffer() {
    ;(this.sourceBuffer = {}),
      (this.operationQueue = new $f(this.sourceBuffer)),
      (this.listeners = { audio: [], video: [], audiovideo: [] }),
      (this.lastMpegAudioChunk = null)
  }
  onManifestLoading() {
    ;(this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0), (this.details = null)
  }
  onManifestParsed(e, t) {
    let r = 2
    ;((t.audio && !t.video) || !t.altAudio) && (r = 1),
      (this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = r),
      G.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`)
  }
  onMediaAttaching(e, t) {
    const r = (this.media = t.media)
    if (r && ns) {
      const n = (this.mediaSource = new ns())
      n.addEventListener('sourceopen', this._onMediaSourceOpen),
        n.addEventListener('sourceended', this._onMediaSourceEnded),
        n.addEventListener('sourceclose', this._onMediaSourceClose),
        (r.src = self.URL.createObjectURL(n)),
        (this._objectUrl = r.src),
        r.addEventListener('emptied', this._onMediaEmptied)
    }
  }
  onMediaDetaching() {
    const { media: e, mediaSource: t, _objectUrl: r } = this
    if (t) {
      if ((G.log('[buffer-controller]: media source detaching'), t.readyState === 'open'))
        try {
          t.endOfStream()
        } catch (n) {
          G.warn(`[buffer-controller]: onMediaDetaching: ${n.message} while calling endOfStream`)
        }
      this.onBufferReset(),
        t.removeEventListener('sourceopen', this._onMediaSourceOpen),
        t.removeEventListener('sourceended', this._onMediaSourceEnded),
        t.removeEventListener('sourceclose', this._onMediaSourceClose),
        e &&
          (e.removeEventListener('emptied', this._onMediaEmptied),
          r && self.URL.revokeObjectURL(r),
          e.src === r
            ? (e.removeAttribute('src'), e.load())
            : G.warn('[buffer-controller]: media.src was changed by a third party - skip cleanup')),
        (this.mediaSource = null),
        (this.media = null),
        (this._objectUrl = null),
        (this.bufferCodecEventsExpected = this._bufferCodecEventsTotal),
        (this.pendingTracks = {}),
        (this.tracks = {})
    }
    this.hls.trigger(O.MEDIA_DETACHED, void 0)
  }
  onBufferReset() {
    this.getSourceBufferTypes().forEach((e) => {
      const t = this.sourceBuffer[e]
      try {
        t &&
          (this.removeBufferListeners(e),
          this.mediaSource && this.mediaSource.removeSourceBuffer(t),
          (this.sourceBuffer[e] = void 0))
      } catch (r) {
        G.warn(`[buffer-controller]: Failed to reset the ${e} buffer`, r)
      }
    }),
      this._initSourceBuffer()
  }
  onBufferCodecs(e, t) {
    const r = this.getSourceBufferTypes().length
    Object.keys(t).forEach((n) => {
      if (r) {
        const i = this.tracks[n]
        if (i && typeof i.buffer.changeType == 'function') {
          const { id: a, codec: o, levelCodec: l, container: u, metadata: c } = t[n],
            f = (i.levelCodec || i.codec).replace(is, '$1'),
            d = (l || o).replace(is, '$1')
          if (f !== d) {
            const m = `${u};codecs=${l || o}`
            this.appendChangeType(n, m),
              G.log(`[buffer-controller]: switching codec ${f} to ${d}`),
              (this.tracks[n] = {
                buffer: i.buffer,
                codec: o,
                container: u,
                levelCodec: l,
                metadata: c,
                id: a
              })
          }
        }
      } else this.pendingTracks[n] = t[n]
    }),
      !r &&
        ((this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0)),
        this.mediaSource && this.mediaSource.readyState === 'open' && this.checkPendingTracks())
  }
  appendChangeType(e, t) {
    const { operationQueue: r } = this,
      n = {
        execute: () => {
          const i = this.sourceBuffer[e]
          i &&
            (G.log(`[buffer-controller]: changing ${e} sourceBuffer type to ${t}`),
            i.changeType(t)),
            r.shiftAndExecuteNext(e)
        },
        onStart: () => {},
        onComplete: () => {},
        onError: (i) => {
          G.warn(`[buffer-controller]: Failed to change ${e} SourceBuffer type`, i)
        }
      }
    r.append(n, e)
  }
  onBufferAppending(e, t) {
    const { hls: r, operationQueue: n, tracks: i } = this,
      { data: a, type: o, frag: l, part: u, chunkMeta: c } = t,
      f = c.buffering[o],
      d = self.performance.now()
    f.start = d
    const m = l.stats.buffering,
      p = u ? u.stats.buffering : null
    m.start === 0 && (m.start = d), p && p.start === 0 && (p.start = d)
    const v = i.audio
    let E = !1
    o === 'audio' &&
      (v == null ? void 0 : v.container) === 'audio/mpeg' &&
      ((E = !this.lastMpegAudioChunk || c.id === 1 || this.lastMpegAudioChunk.sn !== c.sn),
      (this.lastMpegAudioChunk = c))
    const x = l.start,
      T = {
        execute: () => {
          if (((f.executeStart = self.performance.now()), E)) {
            const b = this.sourceBuffer[o]
            if (b) {
              const R = x - b.timestampOffset
              Math.abs(R) >= 0.1 &&
                (G.log(
                  `[buffer-controller]: Updating audio SourceBuffer timestampOffset to ${x} (delta: ${R}) sn: ${l.sn})`
                ),
                (b.timestampOffset = x))
            }
          }
          this.appendExecutor(a, o)
        },
        onStart: () => {},
        onComplete: () => {
          const b = self.performance.now()
          ;(f.executeEnd = f.end = b),
            m.first === 0 && (m.first = b),
            p && p.first === 0 && (p.first = b)
          const { sourceBuffer: R } = this,
            g = {}
          for (const A in R) g[A] = ge.getBuffered(R[A])
          ;(this.appendError = 0),
            this.hls.trigger(O.BUFFER_APPENDED, {
              type: o,
              frag: l,
              part: u,
              chunkMeta: c,
              parent: l.type,
              timeRanges: g
            })
        },
        onError: (b) => {
          G.error(
            `[buffer-controller]: Error encountered while trying to append to the ${o} SourceBuffer`,
            b
          )
          const R = {
            type: ne.MEDIA_ERROR,
            parent: l.type,
            details: K.BUFFER_APPEND_ERROR,
            frag: l,
            part: u,
            chunkMeta: c,
            error: b,
            err: b,
            fatal: !1
          }
          b.code === DOMException.QUOTA_EXCEEDED_ERR
            ? (R.details = K.BUFFER_FULL_ERROR)
            : (this.appendError++,
              (R.details = K.BUFFER_APPEND_ERROR),
              this.appendError > r.config.appendErrorMaxRetry &&
                (G.error(
                  `[buffer-controller]: Failed ${r.config.appendErrorMaxRetry} times to append segment in sourceBuffer`
                ),
                (R.fatal = !0))),
            r.trigger(O.ERROR, R)
        }
      }
    n.append(T, o)
  }
  onBufferFlushing(e, t) {
    const { operationQueue: r } = this,
      n = (i) => ({
        execute: this.removeExecutor.bind(this, i, t.startOffset, t.endOffset),
        onStart: () => {},
        onComplete: () => {
          this.hls.trigger(O.BUFFER_FLUSHED, { type: i })
        },
        onError: (a) => {
          G.warn(`[buffer-controller]: Failed to remove from ${i} SourceBuffer`, a)
        }
      })
    t.type
      ? r.append(n(t.type), t.type)
      : this.getSourceBufferTypes().forEach((i) => {
          r.append(n(i), i)
        })
  }
  onFragParsed(e, t) {
    const { frag: r, part: n } = t,
      i = [],
      a = n ? n.elementaryStreams : r.elementaryStreams
    a[pe.AUDIOVIDEO]
      ? i.push('audiovideo')
      : (a[pe.AUDIO] && i.push('audio'), a[pe.VIDEO] && i.push('video'))
    const o = () => {
      const l = self.performance.now()
      ;(r.stats.buffering.end = l), n && (n.stats.buffering.end = l)
      const u = n ? n.stats : r.stats
      this.hls.trigger(O.FRAG_BUFFERED, { frag: r, part: n, stats: u, id: r.type })
    }
    i.length === 0 &&
      G.warn(
        `Fragments must have at least one ElementaryStreamType set. type: ${r.type} level: ${r.level} sn: ${r.sn}`
      ),
      this.blockBuffers(o, i)
  }
  onFragChanged(e, t) {
    this.flushBackBuffer()
  }
  onBufferEos(e, t) {
    this.getSourceBufferTypes().reduce((n, i) => {
      const a = this.sourceBuffer[i]
      return (
        a &&
          (!t.type || t.type === i) &&
          ((a.ending = !0),
          a.ended || ((a.ended = !0), G.log(`[buffer-controller]: ${i} sourceBuffer now EOS`))),
        n && !!(!a || a.ended)
      )
    }, !0) &&
      (G.log('[buffer-controller]: Queueing mediaSource.endOfStream()'),
      this.blockBuffers(() => {
        this.getSourceBufferTypes().forEach((i) => {
          const a = this.sourceBuffer[i]
          a && (a.ending = !1)
        })
        const { mediaSource: n } = this
        if (!n || n.readyState !== 'open') {
          n &&
            G.info(
              `[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: ${n.readyState}`
            )
          return
        }
        G.log('[buffer-controller]: Calling mediaSource.endOfStream()'), n.endOfStream()
      }))
  }
  onLevelUpdated(e, { details: t }) {
    t.fragments.length &&
      ((this.details = t),
      this.getSourceBufferTypes().length
        ? this.blockBuffers(this.updateMediaElementDuration.bind(this))
        : this.updateMediaElementDuration())
  }
  flushBackBuffer() {
    const { hls: e, details: t, media: r, sourceBuffer: n } = this
    if (!r || t === null) return
    const i = this.getSourceBufferTypes()
    if (!i.length) return
    const a =
      t.live && e.config.liveBackBufferLength !== null
        ? e.config.liveBackBufferLength
        : e.config.backBufferLength
    if (!J(a) || a < 0) return
    const o = r.currentTime,
      l = t.levelTargetDuration,
      u = Math.max(a, l),
      c = Math.floor(o / l) * l - u
    i.forEach((f) => {
      const d = n[f]
      if (d) {
        const m = ge.getBuffered(d)
        if (m.length > 0 && c > m.start(0)) {
          if ((e.trigger(O.BACK_BUFFER_REACHED, { bufferEnd: c }), t.live))
            e.trigger(O.LIVE_BACK_BUFFER_REACHED, { bufferEnd: c })
          else if (d.ended && m.end(m.length - 1) - o < l * 2) {
            G.info(
              `[buffer-controller]: Cannot flush ${f} back buffer while SourceBuffer is in ended state`
            )
            return
          }
          e.trigger(O.BUFFER_FLUSHING, { startOffset: 0, endOffset: c, type: f })
        }
      }
    })
  }
  updateMediaElementDuration() {
    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open')
      return
    const { details: e, hls: t, media: r, mediaSource: n } = this,
      i = e.fragments[0].start + e.totalduration,
      a = r.duration,
      o = J(n.duration) ? n.duration : 0
    e.live && t.config.liveDurationInfinity
      ? (G.log('[buffer-controller]: Media Source duration is set to Infinity'),
        (n.duration = 1 / 0),
        this.updateSeekableRange(e))
      : ((i > o && i > a) || !J(a)) &&
        (G.log(`[buffer-controller]: Updating Media Source duration to ${i.toFixed(3)}`),
        (n.duration = i))
  }
  updateSeekableRange(e) {
    const t = this.mediaSource,
      r = e.fragments
    if (r.length && e.live && t != null && t.setLiveSeekableRange) {
      const i = Math.max(0, r[0].start),
        a = Math.max(i, i + e.totalduration)
      t.setLiveSeekableRange(i, a)
    }
  }
  checkPendingTracks() {
    const { bufferCodecEventsExpected: e, operationQueue: t, pendingTracks: r } = this,
      n = Object.keys(r).length
    if ((n && !e) || n === 2) {
      this.createSourceBuffers(r), (this.pendingTracks = {})
      const i = this.getSourceBufferTypes()
      if (i.length)
        this.hls.trigger(O.BUFFER_CREATED, { tracks: this.tracks }),
          i.forEach((a) => {
            t.executeNext(a)
          })
      else {
        const a = new Error('could not create source buffer for media codec(s)')
        this.hls.trigger(O.ERROR, {
          type: ne.MEDIA_ERROR,
          details: K.BUFFER_INCOMPATIBLE_CODECS_ERROR,
          fatal: !0,
          error: a,
          reason: a.message
        })
      }
    }
  }
  createSourceBuffers(e) {
    const { sourceBuffer: t, mediaSource: r } = this
    if (!r) throw Error('createSourceBuffers called when mediaSource was null')
    for (const n in e)
      if (!t[n]) {
        const i = e[n]
        if (!i) throw Error(`source buffer exists for track ${n}, however track does not`)
        const a = i.levelCodec || i.codec,
          o = `${i.container};codecs=${a}`
        G.log(`[buffer-controller]: creating sourceBuffer(${o})`)
        try {
          const l = (t[n] = r.addSourceBuffer(o)),
            u = n
          this.addBufferListener(u, 'updatestart', this._onSBUpdateStart),
            this.addBufferListener(u, 'updateend', this._onSBUpdateEnd),
            this.addBufferListener(u, 'error', this._onSBUpdateError),
            (this.tracks[n] = {
              buffer: l,
              codec: a,
              container: i.container,
              levelCodec: i.levelCodec,
              metadata: i.metadata,
              id: i.id
            })
        } catch (l) {
          G.error(`[buffer-controller]: error while trying to add sourceBuffer: ${l.message}`),
            this.hls.trigger(O.ERROR, {
              type: ne.MEDIA_ERROR,
              details: K.BUFFER_ADD_CODEC_ERROR,
              fatal: !1,
              error: l,
              mimeType: o
            })
        }
      }
  }
  _onSBUpdateStart(e) {
    const { operationQueue: t } = this
    t.current(e).onStart()
  }
  _onSBUpdateEnd(e) {
    const { operationQueue: t } = this
    t.current(e).onComplete(), t.shiftAndExecuteNext(e)
  }
  _onSBUpdateError(e, t) {
    const r = new Error(`${e} SourceBuffer error`)
    G.error(`[buffer-controller]: ${r}`, t),
      this.hls.trigger(O.ERROR, {
        type: ne.MEDIA_ERROR,
        details: K.BUFFER_APPENDING_ERROR,
        error: r,
        fatal: !1
      })
    const n = this.operationQueue.current(e)
    n && n.onError(t)
  }
  removeExecutor(e, t, r) {
    const { media: n, mediaSource: i, operationQueue: a, sourceBuffer: o } = this,
      l = o[e]
    if (!n || !i || !l) {
      G.warn(
        `[buffer-controller]: Attempting to remove from the ${e} SourceBuffer, but it does not exist`
      ),
        a.shiftAndExecuteNext(e)
      return
    }
    const u = J(n.duration) ? n.duration : 1 / 0,
      c = J(i.duration) ? i.duration : 1 / 0,
      f = Math.max(0, t),
      d = Math.min(r, u, c)
    d > f && !l.ending
      ? ((l.ended = !1),
        G.log(`[buffer-controller]: Removing [${f},${d}] from the ${e} SourceBuffer`),
        l.remove(f, d))
      : a.shiftAndExecuteNext(e)
  }
  appendExecutor(e, t) {
    const { operationQueue: r, sourceBuffer: n } = this,
      i = n[t]
    if (!i) {
      G.warn(
        `[buffer-controller]: Attempting to append to the ${t} SourceBuffer, but it does not exist`
      ),
        r.shiftAndExecuteNext(t)
      return
    }
    ;(i.ended = !1), i.appendBuffer(e)
  }
  blockBuffers(e, t = this.getSourceBufferTypes()) {
    if (!t.length) {
      G.log('[buffer-controller]: Blocking operation requested, but no SourceBuffers exist'),
        Promise.resolve().then(e)
      return
    }
    const { operationQueue: r } = this,
      n = t.map((i) => r.appendBlocker(i))
    Promise.all(n).then(() => {
      e(),
        t.forEach((i) => {
          const a = this.sourceBuffer[i]
          ;(a != null && a.updating) || r.shiftAndExecuteNext(i)
        })
    })
  }
  getSourceBufferTypes() {
    return Object.keys(this.sourceBuffer)
  }
  addBufferListener(e, t, r) {
    const n = this.sourceBuffer[e]
    if (!n) return
    const i = r.bind(this, e)
    this.listeners[e].push({ event: t, listener: i }), n.addEventListener(t, i)
  }
  removeBufferListeners(e) {
    const t = this.sourceBuffer[e]
    t &&
      this.listeners[e].forEach((r) => {
        t.removeEventListener(r.event, r.listener)
      })
  }
}
const ss = {
    42: 225,
    92: 233,
    94: 237,
    95: 243,
    96: 250,
    123: 231,
    124: 247,
    125: 209,
    126: 241,
    127: 9608,
    128: 174,
    129: 176,
    130: 189,
    131: 191,
    132: 8482,
    133: 162,
    134: 163,
    135: 9834,
    136: 224,
    137: 32,
    138: 232,
    139: 226,
    140: 234,
    141: 238,
    142: 244,
    143: 251,
    144: 193,
    145: 201,
    146: 211,
    147: 218,
    148: 220,
    149: 252,
    150: 8216,
    151: 161,
    152: 42,
    153: 8217,
    154: 9473,
    155: 169,
    156: 8480,
    157: 8226,
    158: 8220,
    159: 8221,
    160: 192,
    161: 194,
    162: 199,
    163: 200,
    164: 202,
    165: 203,
    166: 235,
    167: 206,
    168: 207,
    169: 239,
    170: 212,
    171: 217,
    172: 249,
    173: 219,
    174: 171,
    175: 187,
    176: 195,
    177: 227,
    178: 205,
    179: 204,
    180: 236,
    181: 210,
    182: 242,
    183: 213,
    184: 245,
    185: 123,
    186: 125,
    187: 92,
    188: 94,
    189: 95,
    190: 124,
    191: 8764,
    192: 196,
    193: 228,
    194: 214,
    195: 246,
    196: 223,
    197: 165,
    198: 164,
    199: 9475,
    200: 197,
    201: 229,
    202: 216,
    203: 248,
    204: 9487,
    205: 9491,
    206: 9495,
    207: 9499
  },
  Da = function (e) {
    let t = e
    return ss.hasOwnProperty(e) && (t = ss[e]), String.fromCharCode(t)
  },
  Xe = 15,
  rt = 100,
  jf = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 },
  Vf = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 },
  Hf = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 },
  Wf = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 },
  Yf = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent']
class zf {
  constructor() {
    ;(this.time = null), (this.verboseLevel = 0)
  }
  log(e, t) {
    if (this.verboseLevel >= e) {
      const r = typeof t == 'function' ? t() : t
      G.log(`${this.time} [${e}] ${r}`)
    }
  }
}
const dt = function (e) {
  const t = []
  for (let r = 0; r < e.length; r++) t.push(e[r].toString(16))
  return t
}
class Oa {
  constructor(e, t, r, n, i) {
    ;(this.foreground = void 0),
      (this.underline = void 0),
      (this.italics = void 0),
      (this.background = void 0),
      (this.flash = void 0),
      (this.foreground = e || 'white'),
      (this.underline = t || !1),
      (this.italics = r || !1),
      (this.background = n || 'black'),
      (this.flash = i || !1)
  }
  reset() {
    ;(this.foreground = 'white'),
      (this.underline = !1),
      (this.italics = !1),
      (this.background = 'black'),
      (this.flash = !1)
  }
  setStyles(e) {
    const t = ['foreground', 'underline', 'italics', 'background', 'flash']
    for (let r = 0; r < t.length; r++) {
      const n = t[r]
      e.hasOwnProperty(n) && (this[n] = e[n])
    }
  }
  isDefault() {
    return (
      this.foreground === 'white' &&
      !this.underline &&
      !this.italics &&
      this.background === 'black' &&
      !this.flash
    )
  }
  equals(e) {
    return (
      this.foreground === e.foreground &&
      this.underline === e.underline &&
      this.italics === e.italics &&
      this.background === e.background &&
      this.flash === e.flash
    )
  }
  copy(e) {
    ;(this.foreground = e.foreground),
      (this.underline = e.underline),
      (this.italics = e.italics),
      (this.background = e.background),
      (this.flash = e.flash)
  }
  toString() {
    return (
      'color=' +
      this.foreground +
      ', underline=' +
      this.underline +
      ', italics=' +
      this.italics +
      ', background=' +
      this.background +
      ', flash=' +
      this.flash
    )
  }
}
class qf {
  constructor(e, t, r, n, i, a) {
    ;(this.uchar = void 0),
      (this.penState = void 0),
      (this.uchar = e || ' '),
      (this.penState = new Oa(t, r, n, i, a))
  }
  reset() {
    ;(this.uchar = ' '), this.penState.reset()
  }
  setChar(e, t) {
    ;(this.uchar = e), this.penState.copy(t)
  }
  setPenState(e) {
    this.penState.copy(e)
  }
  equals(e) {
    return this.uchar === e.uchar && this.penState.equals(e.penState)
  }
  copy(e) {
    ;(this.uchar = e.uchar), this.penState.copy(e.penState)
  }
  isEmpty() {
    return this.uchar === ' ' && this.penState.isDefault()
  }
}
class Xf {
  constructor(e) {
    ;(this.chars = void 0),
      (this.pos = void 0),
      (this.currPenState = void 0),
      (this.cueStartTime = void 0),
      (this.logger = void 0),
      (this.chars = [])
    for (let t = 0; t < rt; t++) this.chars.push(new qf())
    ;(this.logger = e), (this.pos = 0), (this.currPenState = new Oa())
  }
  equals(e) {
    let t = !0
    for (let r = 0; r < rt; r++)
      if (!this.chars[r].equals(e.chars[r])) {
        t = !1
        break
      }
    return t
  }
  copy(e) {
    for (let t = 0; t < rt; t++) this.chars[t].copy(e.chars[t])
  }
  isEmpty() {
    let e = !0
    for (let t = 0; t < rt; t++)
      if (!this.chars[t].isEmpty()) {
        e = !1
        break
      }
    return e
  }
  setCursor(e) {
    this.pos !== e && (this.pos = e),
      this.pos < 0
        ? (this.logger.log(3, 'Negative cursor position ' + this.pos), (this.pos = 0))
        : this.pos > rt &&
          (this.logger.log(3, 'Too large cursor position ' + this.pos), (this.pos = rt))
  }
  moveCursor(e) {
    const t = this.pos + e
    if (e > 1)
      for (let r = this.pos + 1; r < t + 1; r++) this.chars[r].setPenState(this.currPenState)
    this.setCursor(t)
  }
  backSpace() {
    this.moveCursor(-1), this.chars[this.pos].setChar(' ', this.currPenState)
  }
  insertChar(e) {
    e >= 144 && this.backSpace()
    const t = Da(e)
    if (this.pos >= rt) {
      this.logger.log(
        0,
        () =>
          'Cannot insert ' +
          e.toString(16) +
          ' (' +
          t +
          ') at position ' +
          this.pos +
          '. Skipping it!'
      )
      return
    }
    this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1)
  }
  clearFromPos(e) {
    let t
    for (t = e; t < rt; t++) this.chars[t].reset()
  }
  clear() {
    this.clearFromPos(0), (this.pos = 0), this.currPenState.reset()
  }
  clearToEndOfRow() {
    this.clearFromPos(this.pos)
  }
  getTextString() {
    const e = []
    let t = !0
    for (let r = 0; r < rt; r++) {
      const n = this.chars[r].uchar
      n !== ' ' && (t = !1), e.push(n)
    }
    return t ? '' : e.join('')
  }
  setPenStyles(e) {
    this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState)
  }
}
class an {
  constructor(e) {
    ;(this.rows = void 0),
      (this.currRow = void 0),
      (this.nrRollUpRows = void 0),
      (this.lastOutputScreen = void 0),
      (this.logger = void 0),
      (this.rows = [])
    for (let t = 0; t < Xe; t++) this.rows.push(new Xf(e))
    ;(this.logger = e),
      (this.currRow = Xe - 1),
      (this.nrRollUpRows = null),
      (this.lastOutputScreen = null),
      this.reset()
  }
  reset() {
    for (let e = 0; e < Xe; e++) this.rows[e].clear()
    this.currRow = Xe - 1
  }
  equals(e) {
    let t = !0
    for (let r = 0; r < Xe; r++)
      if (!this.rows[r].equals(e.rows[r])) {
        t = !1
        break
      }
    return t
  }
  copy(e) {
    for (let t = 0; t < Xe; t++) this.rows[t].copy(e.rows[t])
  }
  isEmpty() {
    let e = !0
    for (let t = 0; t < Xe; t++)
      if (!this.rows[t].isEmpty()) {
        e = !1
        break
      }
    return e
  }
  backSpace() {
    this.rows[this.currRow].backSpace()
  }
  clearToEndOfRow() {
    this.rows[this.currRow].clearToEndOfRow()
  }
  insertChar(e) {
    this.rows[this.currRow].insertChar(e)
  }
  setPen(e) {
    this.rows[this.currRow].setPenStyles(e)
  }
  moveCursor(e) {
    this.rows[this.currRow].moveCursor(e)
  }
  setCursor(e) {
    this.logger.log(2, 'setCursor: ' + e), this.rows[this.currRow].setCursor(e)
  }
  setPAC(e) {
    this.logger.log(2, () => 'pacData = ' + JSON.stringify(e))
    let t = e.row - 1
    if (
      (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1),
      this.nrRollUpRows && this.currRow !== t)
    ) {
      for (let o = 0; o < Xe; o++) this.rows[o].clear()
      const i = this.currRow + 1 - this.nrRollUpRows,
        a = this.lastOutputScreen
      if (a) {
        const o = a.rows[i].cueStartTime,
          l = this.logger.time
        if (o && l !== null && o < l)
          for (let u = 0; u < this.nrRollUpRows; u++)
            this.rows[t - this.nrRollUpRows + u + 1].copy(a.rows[i + u])
      }
    }
    this.currRow = t
    const r = this.rows[this.currRow]
    if (e.indent !== null) {
      const i = e.indent,
        a = Math.max(i - 1, 0)
      r.setCursor(e.indent), (e.color = r.chars[a].penState.foreground)
    }
    const n = {
      foreground: e.color,
      underline: e.underline,
      italics: e.italics,
      background: 'black',
      flash: !1
    }
    this.setPen(n)
  }
  setBkgData(e) {
    this.logger.log(2, () => 'bkgData = ' + JSON.stringify(e)),
      this.backSpace(),
      this.setPen(e),
      this.insertChar(32)
  }
  setRollUpRows(e) {
    this.nrRollUpRows = e
  }
  rollUp() {
    if (this.nrRollUpRows === null) {
      this.logger.log(3, 'roll_up but nrRollUpRows not set yet')
      return
    }
    this.logger.log(1, () => this.getDisplayText())
    const e = this.currRow + 1 - this.nrRollUpRows,
      t = this.rows.splice(e, 1)[0]
    t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, 'Rolling up')
  }
  getDisplayText(e) {
    e = e || !1
    const t = []
    let r = '',
      n = -1
    for (let i = 0; i < Xe; i++) {
      const a = this.rows[i].getTextString()
      a && ((n = i + 1), e ? t.push('Row ' + n + ": '" + a + "'") : t.push(a.trim()))
    }
    return (
      t.length > 0 &&
        (e
          ? (r = '[' + t.join(' | ') + ']')
          : (r = t.join(`
`))),
      r
    )
  }
  getTextAndFormat() {
    return this.rows
  }
}
class as {
  constructor(e, t, r) {
    ;(this.chNr = void 0),
      (this.outputFilter = void 0),
      (this.mode = void 0),
      (this.verbose = void 0),
      (this.displayedMemory = void 0),
      (this.nonDisplayedMemory = void 0),
      (this.lastOutputScreen = void 0),
      (this.currRollUpRow = void 0),
      (this.writeScreen = void 0),
      (this.cueStartTime = void 0),
      (this.logger = void 0),
      (this.chNr = e),
      (this.outputFilter = t),
      (this.mode = null),
      (this.verbose = 0),
      (this.displayedMemory = new an(r)),
      (this.nonDisplayedMemory = new an(r)),
      (this.lastOutputScreen = new an(r)),
      (this.currRollUpRow = this.displayedMemory.rows[Xe - 1]),
      (this.writeScreen = this.displayedMemory),
      (this.mode = null),
      (this.cueStartTime = null),
      (this.logger = r)
  }
  reset() {
    ;(this.mode = null),
      this.displayedMemory.reset(),
      this.nonDisplayedMemory.reset(),
      this.lastOutputScreen.reset(),
      this.outputFilter.reset(),
      (this.currRollUpRow = this.displayedMemory.rows[Xe - 1]),
      (this.writeScreen = this.displayedMemory),
      (this.mode = null),
      (this.cueStartTime = null)
  }
  getHandler() {
    return this.outputFilter
  }
  setHandler(e) {
    this.outputFilter = e
  }
  setPAC(e) {
    this.writeScreen.setPAC(e)
  }
  setBkgData(e) {
    this.writeScreen.setBkgData(e)
  }
  setMode(e) {
    e !== this.mode &&
      ((this.mode = e),
      this.logger.log(2, () => 'MODE=' + e),
      this.mode === 'MODE_POP-ON'
        ? (this.writeScreen = this.nonDisplayedMemory)
        : ((this.writeScreen = this.displayedMemory), this.writeScreen.reset()),
      this.mode !== 'MODE_ROLL-UP' &&
        ((this.displayedMemory.nrRollUpRows = null), (this.nonDisplayedMemory.nrRollUpRows = null)),
      (this.mode = e))
  }
  insertChars(e) {
    for (let r = 0; r < e.length; r++) this.writeScreen.insertChar(e[r])
    const t = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP'
    this.logger.log(2, () => t + ': ' + this.writeScreen.getDisplayText(!0)),
      (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') &&
        (this.logger.log(1, () => 'DISPLAYED: ' + this.displayedMemory.getDisplayText(!0)),
        this.outputDataUpdate())
  }
  ccRCL() {
    this.logger.log(2, 'RCL - Resume Caption Loading'), this.setMode('MODE_POP-ON')
  }
  ccBS() {
    this.logger.log(2, 'BS - BackSpace'),
      this.mode !== 'MODE_TEXT' &&
        (this.writeScreen.backSpace(),
        this.writeScreen === this.displayedMemory && this.outputDataUpdate())
  }
  ccAOF() {}
  ccAON() {}
  ccDER() {
    this.logger.log(2, 'DER- Delete to End of Row'),
      this.writeScreen.clearToEndOfRow(),
      this.outputDataUpdate()
  }
  ccRU(e) {
    this.logger.log(2, 'RU(' + e + ') - Roll Up'),
      (this.writeScreen = this.displayedMemory),
      this.setMode('MODE_ROLL-UP'),
      this.writeScreen.setRollUpRows(e)
  }
  ccFON() {
    this.logger.log(2, 'FON - Flash On'), this.writeScreen.setPen({ flash: !0 })
  }
  ccRDC() {
    this.logger.log(2, 'RDC - Resume Direct Captioning'), this.setMode('MODE_PAINT-ON')
  }
  ccTR() {
    this.logger.log(2, 'TR'), this.setMode('MODE_TEXT')
  }
  ccRTD() {
    this.logger.log(2, 'RTD'), this.setMode('MODE_TEXT')
  }
  ccEDM() {
    this.logger.log(2, 'EDM - Erase Displayed Memory'),
      this.displayedMemory.reset(),
      this.outputDataUpdate(!0)
  }
  ccCR() {
    this.logger.log(2, 'CR - Carriage Return'), this.writeScreen.rollUp(), this.outputDataUpdate(!0)
  }
  ccENM() {
    this.logger.log(2, 'ENM - Erase Non-displayed Memory'), this.nonDisplayedMemory.reset()
  }
  ccEOC() {
    if ((this.logger.log(2, 'EOC - End Of Caption'), this.mode === 'MODE_POP-ON')) {
      const e = this.displayedMemory
      ;(this.displayedMemory = this.nonDisplayedMemory),
        (this.nonDisplayedMemory = e),
        (this.writeScreen = this.nonDisplayedMemory),
        this.logger.log(1, () => 'DISP: ' + this.displayedMemory.getDisplayText())
    }
    this.outputDataUpdate(!0)
  }
  ccTO(e) {
    this.logger.log(2, 'TO(' + e + ') - Tab Offset'), this.writeScreen.moveCursor(e)
  }
  ccMIDROW(e) {
    const t = { flash: !1 }
    if (((t.underline = e % 2 === 1), (t.italics = e >= 46), t.italics)) t.foreground = 'white'
    else {
      const r = Math.floor(e / 2) - 16,
        n = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta']
      t.foreground = n[r]
    }
    this.logger.log(2, 'MIDROW: ' + JSON.stringify(t)), this.writeScreen.setPen(t)
  }
  outputDataUpdate(e = !1) {
    const t = this.logger.time
    t !== null &&
      this.outputFilter &&
      (this.cueStartTime === null && !this.displayedMemory.isEmpty()
        ? (this.cueStartTime = t)
        : this.displayedMemory.equals(this.lastOutputScreen) ||
          (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen),
          e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(),
          (this.cueStartTime = this.displayedMemory.isEmpty() ? null : t)),
      this.lastOutputScreen.copy(this.displayedMemory))
  }
  cueSplitAtTime(e) {
    this.outputFilter &&
      (this.displayedMemory.isEmpty() ||
        (this.outputFilter.newCue &&
          this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory),
        (this.cueStartTime = e)))
  }
}
class os {
  constructor(e, t, r) {
    ;(this.channels = void 0),
      (this.currentChannel = 0),
      (this.cmdHistory = void 0),
      (this.logger = void 0)
    const n = new zf()
    ;(this.channels = [null, new as(e, t, n), new as(e + 1, r, n)]),
      (this.cmdHistory = us()),
      (this.logger = n)
  }
  getHandler(e) {
    return this.channels[e].getHandler()
  }
  setHandler(e, t) {
    this.channels[e].setHandler(t)
  }
  addData(e, t) {
    let r,
      n,
      i,
      a = !1
    this.logger.time = e
    for (let o = 0; o < t.length; o += 2)
      if (((n = t[o] & 127), (i = t[o + 1] & 127), !(n === 0 && i === 0))) {
        if (
          (this.logger.log(3, '[' + dt([t[o], t[o + 1]]) + '] -> (' + dt([n, i]) + ')'),
          (r = this.parseCmd(n, i)),
          r || (r = this.parseMidrow(n, i)),
          r || (r = this.parsePAC(n, i)),
          r || (r = this.parseBackgroundAttributes(n, i)),
          !r && ((a = this.parseChars(n, i)), a))
        ) {
          const l = this.currentChannel
          l && l > 0
            ? this.channels[l].insertChars(a)
            : this.logger.log(2, 'No channel found yet. TEXT-MODE?')
        }
        !r &&
          !a &&
          this.logger.log(
            2,
            "Couldn't parse cleaned data " + dt([n, i]) + ' orig: ' + dt([t[o], t[o + 1]])
          )
      }
  }
  parseCmd(e, t) {
    const { cmdHistory: r } = this,
      n = (e === 20 || e === 28 || e === 21 || e === 29) && t >= 32 && t <= 47,
      i = (e === 23 || e === 31) && t >= 33 && t <= 35
    if (!(n || i)) return !1
    if (ls(e, t, r))
      return (
        It(null, null, r),
        this.logger.log(3, 'Repeated command (' + dt([e, t]) + ') is dropped'),
        !0
      )
    const a = e === 20 || e === 21 || e === 23 ? 1 : 2,
      o = this.channels[a]
    return (
      e === 20 || e === 21 || e === 28 || e === 29
        ? t === 32
          ? o.ccRCL()
          : t === 33
          ? o.ccBS()
          : t === 34
          ? o.ccAOF()
          : t === 35
          ? o.ccAON()
          : t === 36
          ? o.ccDER()
          : t === 37
          ? o.ccRU(2)
          : t === 38
          ? o.ccRU(3)
          : t === 39
          ? o.ccRU(4)
          : t === 40
          ? o.ccFON()
          : t === 41
          ? o.ccRDC()
          : t === 42
          ? o.ccTR()
          : t === 43
          ? o.ccRTD()
          : t === 44
          ? o.ccEDM()
          : t === 45
          ? o.ccCR()
          : t === 46
          ? o.ccENM()
          : t === 47 && o.ccEOC()
        : o.ccTO(t - 32),
      It(e, t, r),
      (this.currentChannel = a),
      !0
    )
  }
  parseMidrow(e, t) {
    let r = 0
    if ((e === 17 || e === 25) && t >= 32 && t <= 47) {
      if ((e === 17 ? (r = 1) : (r = 2), r !== this.currentChannel))
        return this.logger.log(0, 'Mismatch channel in midrow parsing'), !1
      const n = this.channels[r]
      return n ? (n.ccMIDROW(t), this.logger.log(3, 'MIDROW (' + dt([e, t]) + ')'), !0) : !1
    }
    return !1
  }
  parsePAC(e, t) {
    let r
    const n = this.cmdHistory,
      i = ((e >= 17 && e <= 23) || (e >= 25 && e <= 31)) && t >= 64 && t <= 127,
      a = (e === 16 || e === 24) && t >= 64 && t <= 95
    if (!(i || a)) return !1
    if (ls(e, t, n)) return It(null, null, n), !0
    const o = e <= 23 ? 1 : 2
    t >= 64 && t <= 95 ? (r = o === 1 ? jf[e] : Hf[e]) : (r = o === 1 ? Vf[e] : Wf[e])
    const l = this.channels[o]
    return l ? (l.setPAC(this.interpretPAC(r, t)), It(e, t, n), (this.currentChannel = o), !0) : !1
  }
  interpretPAC(e, t) {
    let r
    const n = { color: null, italics: !1, indent: null, underline: !1, row: e }
    return (
      t > 95 ? (r = t - 96) : (r = t - 64),
      (n.underline = (r & 1) === 1),
      r <= 13
        ? (n.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][
            Math.floor(r / 2)
          ])
        : r <= 15
        ? ((n.italics = !0), (n.color = 'white'))
        : (n.indent = Math.floor((r - 16) / 2) * 4),
      n
    )
  }
  parseChars(e, t) {
    let r,
      n = null,
      i = null
    if ((e >= 25 ? ((r = 2), (i = e - 8)) : ((r = 1), (i = e)), i >= 17 && i <= 19)) {
      let a
      i === 17 ? (a = t + 80) : i === 18 ? (a = t + 112) : (a = t + 144),
        this.logger.log(2, "Special char '" + Da(a) + "' in channel " + r),
        (n = [a])
    } else e >= 32 && e <= 127 && (n = t === 0 ? [e] : [e, t])
    if (n) {
      const a = dt(n)
      this.logger.log(3, 'Char codes =  ' + a.join(',')), It(e, t, this.cmdHistory)
    }
    return n
  }
  parseBackgroundAttributes(e, t) {
    const r = (e === 16 || e === 24) && t >= 32 && t <= 47,
      n = (e === 23 || e === 31) && t >= 45 && t <= 47
    if (!(r || n)) return !1
    let i
    const a = {}
    e === 16 || e === 24
      ? ((i = Math.floor((t - 32) / 2)),
        (a.background = Yf[i]),
        t % 2 === 1 && (a.background = a.background + '_semi'))
      : t === 45
      ? (a.background = 'transparent')
      : ((a.foreground = 'black'), t === 47 && (a.underline = !0))
    const o = e <= 23 ? 1 : 2
    return this.channels[o].setBkgData(a), It(e, t, this.cmdHistory), !0
  }
  reset() {
    for (let e = 0; e < Object.keys(this.channels).length; e++) {
      const t = this.channels[e]
      t && t.reset()
    }
    this.cmdHistory = us()
  }
  cueSplitAtTime(e) {
    for (let t = 0; t < this.channels.length; t++) {
      const r = this.channels[t]
      r && r.cueSplitAtTime(e)
    }
  }
}
function It(s, e, t) {
  ;(t.a = s), (t.b = e)
}
function ls(s, e, t) {
  return t.a === s && t.b === e
}
function us() {
  return { a: null, b: null }
}
class rr {
  constructor(e, t) {
    ;(this.timelineController = void 0),
      (this.cueRanges = []),
      (this.trackName = void 0),
      (this.startTime = null),
      (this.endTime = null),
      (this.screen = null),
      (this.timelineController = e),
      (this.trackName = t)
  }
  dispatchCue() {
    this.startTime !== null &&
      (this.timelineController.addCues(
        this.trackName,
        this.startTime,
        this.endTime,
        this.screen,
        this.cueRanges
      ),
      (this.startTime = null))
  }
  newCue(e, t, r) {
    ;(this.startTime === null || this.startTime > e) && (this.startTime = e),
      (this.endTime = t),
      (this.screen = r),
      this.timelineController.createCaptionsTrack(this.trackName)
  }
  reset() {
    ;(this.cueRanges = []), (this.startTime = null)
  }
}
var Hn = (function () {
  if (typeof self < 'u' && self.VTTCue) return self.VTTCue
  const s = ['', 'lr', 'rl'],
    e = ['start', 'middle', 'end', 'left', 'right']
  function t(o, l) {
    if (typeof l != 'string' || !Array.isArray(o)) return !1
    const u = l.toLowerCase()
    return ~o.indexOf(u) ? u : !1
  }
  function r(o) {
    return t(s, o)
  }
  function n(o) {
    return t(e, o)
  }
  function i(o, ...l) {
    let u = 1
    for (; u < arguments.length; u++) {
      const c = arguments[u]
      for (const f in c) o[f] = c[f]
    }
    return o
  }
  function a(o, l, u) {
    const c = this,
      f = { enumerable: !0 }
    c.hasBeenReset = !1
    let d = '',
      m = !1,
      p = o,
      v = l,
      E = u,
      x = null,
      T = '',
      b = !0,
      R = 'auto',
      g = 'start',
      A = 50,
      S = 'middle',
      h = 50,
      _ = 'middle'
    Object.defineProperty(
      c,
      'id',
      i({}, f, {
        get: function () {
          return d
        },
        set: function (y) {
          d = '' + y
        }
      })
    ),
      Object.defineProperty(
        c,
        'pauseOnExit',
        i({}, f, {
          get: function () {
            return m
          },
          set: function (y) {
            m = !!y
          }
        })
      ),
      Object.defineProperty(
        c,
        'startTime',
        i({}, f, {
          get: function () {
            return p
          },
          set: function (y) {
            if (typeof y != 'number') throw new TypeError('Start time must be set to a number.')
            ;(p = y), (this.hasBeenReset = !0)
          }
        })
      ),
      Object.defineProperty(
        c,
        'endTime',
        i({}, f, {
          get: function () {
            return v
          },
          set: function (y) {
            if (typeof y != 'number') throw new TypeError('End time must be set to a number.')
            ;(v = y), (this.hasBeenReset = !0)
          }
        })
      ),
      Object.defineProperty(
        c,
        'text',
        i({}, f, {
          get: function () {
            return E
          },
          set: function (y) {
            ;(E = '' + y), (this.hasBeenReset = !0)
          }
        })
      ),
      Object.defineProperty(
        c,
        'region',
        i({}, f, {
          get: function () {
            return x
          },
          set: function (y) {
            ;(x = y), (this.hasBeenReset = !0)
          }
        })
      ),
      Object.defineProperty(
        c,
        'vertical',
        i({}, f, {
          get: function () {
            return T
          },
          set: function (y) {
            const L = r(y)
            if (L === !1) throw new SyntaxError('An invalid or illegal string was specified.')
            ;(T = L), (this.hasBeenReset = !0)
          }
        })
      ),
      Object.defineProperty(
        c,
        'snapToLines',
        i({}, f, {
          get: function () {
            return b
          },
          set: function (y) {
            ;(b = !!y), (this.hasBeenReset = !0)
          }
        })
      ),
      Object.defineProperty(
        c,
        'line',
        i({}, f, {
          get: function () {
            return R
          },
          set: function (y) {
            if (typeof y != 'number' && y !== 'auto')
              throw new SyntaxError('An invalid number or illegal string was specified.')
            ;(R = y), (this.hasBeenReset = !0)
          }
        })
      ),
      Object.defineProperty(
        c,
        'lineAlign',
        i({}, f, {
          get: function () {
            return g
          },
          set: function (y) {
            const L = n(y)
            if (!L) throw new SyntaxError('An invalid or illegal string was specified.')
            ;(g = L), (this.hasBeenReset = !0)
          }
        })
      ),
      Object.defineProperty(
        c,
        'position',
        i({}, f, {
          get: function () {
            return A
          },
          set: function (y) {
            if (y < 0 || y > 100) throw new Error('Position must be between 0 and 100.')
            ;(A = y), (this.hasBeenReset = !0)
          }
        })
      ),
      Object.defineProperty(
        c,
        'positionAlign',
        i({}, f, {
          get: function () {
            return S
          },
          set: function (y) {
            const L = n(y)
            if (!L) throw new SyntaxError('An invalid or illegal string was specified.')
            ;(S = L), (this.hasBeenReset = !0)
          }
        })
      ),
      Object.defineProperty(
        c,
        'size',
        i({}, f, {
          get: function () {
            return h
          },
          set: function (y) {
            if (y < 0 || y > 100) throw new Error('Size must be between 0 and 100.')
            ;(h = y), (this.hasBeenReset = !0)
          }
        })
      ),
      Object.defineProperty(
        c,
        'align',
        i({}, f, {
          get: function () {
            return _
          },
          set: function (y) {
            const L = n(y)
            if (!L) throw new SyntaxError('An invalid or illegal string was specified.')
            ;(_ = L), (this.hasBeenReset = !0)
          }
        })
      ),
      (c.displayState = void 0)
  }
  return (
    (a.prototype.getCueAsHTML = function () {
      return self.WebVTT.convertCueToDOMTree(self, this.text)
    }),
    a
  )
})()
class Qf {
  decode(e, t) {
    if (!e) return ''
    if (typeof e != 'string') throw new Error('Error - expected string data.')
    return decodeURIComponent(encodeURIComponent(e))
  }
}
function wa(s) {
  function e(r, n, i, a) {
    return (r | 0) * 3600 + (n | 0) * 60 + (i | 0) + parseFloat(a || 0)
  }
  const t = s.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/)
  return t ? (parseFloat(t[2]) > 59 ? e(t[2], t[3], 0, t[4]) : e(t[1], t[2], t[3], t[4])) : null
}
class Zf {
  constructor() {
    this.values = Object.create(null)
  }
  set(e, t) {
    !this.get(e) && t !== '' && (this.values[e] = t)
  }
  get(e, t, r) {
    return r ? (this.has(e) ? this.values[e] : t[r]) : this.has(e) ? this.values[e] : t
  }
  has(e) {
    return e in this.values
  }
  alt(e, t, r) {
    for (let n = 0; n < r.length; ++n)
      if (t === r[n]) {
        this.set(e, t)
        break
      }
  }
  integer(e, t) {
    ;/^-?\d+$/.test(t) && this.set(e, parseInt(t, 10))
  }
  percent(e, t) {
    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
      const r = parseFloat(t)
      if (r >= 0 && r <= 100) return this.set(e, r), !0
    }
    return !1
  }
}
function Ca(s, e, t, r) {
  const n = r ? s.split(r) : [s]
  for (const i in n) {
    if (typeof n[i] != 'string') continue
    const a = n[i].split(t)
    if (a.length !== 2) continue
    const o = a[0],
      l = a[1]
    e(o, l)
  }
}
const An = new Hn(0, 0, ''),
  nr = An.align === 'middle' ? 'middle' : 'center'
function Jf(s, e, t) {
  const r = s
  function n() {
    const o = wa(s)
    if (o === null) throw new Error('Malformed timestamp: ' + r)
    return (s = s.replace(/^[^\sa-zA-Z-]+/, '')), o
  }
  function i(o, l) {
    const u = new Zf()
    Ca(
      o,
      function (d, m) {
        let p
        switch (d) {
          case 'region':
            for (let v = t.length - 1; v >= 0; v--)
              if (t[v].id === m) {
                u.set(d, t[v].region)
                break
              }
            break
          case 'vertical':
            u.alt(d, m, ['rl', 'lr'])
            break
          case 'line':
            ;(p = m.split(',')),
              u.integer(d, p[0]),
              u.percent(d, p[0]) && u.set('snapToLines', !1),
              u.alt(d, p[0], ['auto']),
              p.length === 2 && u.alt('lineAlign', p[1], ['start', nr, 'end'])
            break
          case 'position':
            ;(p = m.split(',')),
              u.percent(d, p[0]),
              p.length === 2 &&
                u.alt('positionAlign', p[1], [
                  'start',
                  nr,
                  'end',
                  'line-left',
                  'line-right',
                  'auto'
                ])
            break
          case 'size':
            u.percent(d, m)
            break
          case 'align':
            u.alt(d, m, ['start', nr, 'end', 'left', 'right'])
            break
        }
      },
      /:/,
      /\s/
    ),
      (l.region = u.get('region', null)),
      (l.vertical = u.get('vertical', ''))
    let c = u.get('line', 'auto')
    c === 'auto' && An.line === -1 && (c = -1),
      (l.line = c),
      (l.lineAlign = u.get('lineAlign', 'start')),
      (l.snapToLines = u.get('snapToLines', !0)),
      (l.size = u.get('size', 100)),
      (l.align = u.get('align', nr))
    let f = u.get('position', 'auto')
    f === 'auto' &&
      An.position === 50 &&
      (f =
        l.align === 'start' || l.align === 'left'
          ? 0
          : l.align === 'end' || l.align === 'right'
          ? 100
          : 50),
      (l.position = f)
  }
  function a() {
    s = s.replace(/^\s+/, '')
  }
  if ((a(), (e.startTime = n()), a(), s.slice(0, 3) !== '-->'))
    throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + r)
  ;(s = s.slice(3)), a(), (e.endTime = n()), a(), i(s, e)
}
function ka(s) {
  return s.replace(
    /<br(?: \/)?>/gi,
    `
`
  )
}
class ed {
  constructor() {
    ;(this.state = 'INITIAL'),
      (this.buffer = ''),
      (this.decoder = new Qf()),
      (this.regionList = []),
      (this.cue = null),
      (this.oncue = void 0),
      (this.onparsingerror = void 0),
      (this.onflush = void 0)
  }
  parse(e) {
    const t = this
    e && (t.buffer += t.decoder.decode(e, { stream: !0 }))
    function r() {
      let i = t.buffer,
        a = 0
      for (
        i = ka(i);
        a < i.length &&
        i[a] !== '\r' &&
        i[a] !==
          `
`;

      )
        ++a
      const o = i.slice(0, a)
      return (
        i[a] === '\r' && ++a,
        i[a] ===
          `
` && ++a,
        (t.buffer = i.slice(a)),
        o
      )
    }
    function n(i) {
      Ca(i, function (a, o) {}, /:/)
    }
    try {
      let i = ''
      if (t.state === 'INITIAL') {
        if (!/\r\n|\n/.test(t.buffer)) return this
        i = r()
        const o = i.match(/^(ï»¿)?WEBVTT([ \t].*)?$/)
        if (!(o != null && o[0])) throw new Error('Malformed WebVTT signature.')
        t.state = 'HEADER'
      }
      let a = !1
      for (; t.buffer; ) {
        if (!/\r\n|\n/.test(t.buffer)) return this
        switch ((a ? (a = !1) : (i = r()), t.state)) {
          case 'HEADER':
            ;/:/.test(i) ? n(i) : i || (t.state = 'ID')
            continue
          case 'NOTE':
            i || (t.state = 'ID')
            continue
          case 'ID':
            if (/^NOTE($|[ \t])/.test(i)) {
              t.state = 'NOTE'
              break
            }
            if (!i) continue
            if (((t.cue = new Hn(0, 0, '')), (t.state = 'CUE'), i.indexOf('-->') === -1)) {
              t.cue.id = i
              continue
            }
          case 'CUE':
            if (!t.cue) {
              t.state = 'BADCUE'
              continue
            }
            try {
              Jf(i, t.cue, t.regionList)
            } catch {
              ;(t.cue = null), (t.state = 'BADCUE')
              continue
            }
            t.state = 'CUETEXT'
            continue
          case 'CUETEXT':
            {
              const o = i.indexOf('-->') !== -1
              if (!i || (o && (a = !0))) {
                t.oncue && t.cue && t.oncue(t.cue), (t.cue = null), (t.state = 'ID')
                continue
              }
              if (t.cue === null) continue
              t.cue.text &&
                (t.cue.text += `
`),
                (t.cue.text += i)
            }
            continue
          case 'BADCUE':
            i || (t.state = 'ID')
        }
      }
    } catch {
      t.state === 'CUETEXT' && t.cue && t.oncue && t.oncue(t.cue),
        (t.cue = null),
        (t.state = t.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE')
    }
    return this
  }
  flush() {
    const e = this
    try {
      if (
        ((e.cue || e.state === 'HEADER') &&
          ((e.buffer += `

`),
          e.parse()),
        e.state === 'INITIAL' || e.state === 'BADWEBVTT')
      )
        throw new Error('Malformed WebVTT signature.')
    } catch (t) {
      e.onparsingerror && e.onparsingerror(t)
    }
    return e.onflush && e.onflush(), this
  }
}
const td = /\r\n|\n\r|\n|\r/g,
  on = function (e, t, r = 0) {
    return e.slice(r, r + t.length) === t
  },
  rd = function (e) {
    let t = parseInt(e.slice(-3))
    const r = parseInt(e.slice(-6, -4)),
      n = parseInt(e.slice(-9, -7)),
      i = e.length > 9 ? parseInt(e.substring(0, e.indexOf(':'))) : 0
    if (!J(t) || !J(r) || !J(n) || !J(i)) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`)
    return (t += 1e3 * r), (t += 60 * 1e3 * n), (t += 60 * 60 * 1e3 * i), t
  },
  ln = function (e) {
    let t = 5381,
      r = e.length
    for (; r; ) t = (t * 33) ^ e.charCodeAt(--r)
    return (t >>> 0).toString()
  }
function Wn(s, e, t) {
  return ln(s.toString()) + ln(e.toString()) + ln(t)
}
const nd = function (e, t, r) {
  let n = e[t],
    i = e[n.prevCC]
  if (!i || (!i.new && n.new)) {
    ;(e.ccOffset = e.presentationOffset = n.start), (n.new = !1)
    return
  }
  for (; (a = i) != null && a.new; ) {
    var a
    ;(e.ccOffset += n.start - i.start), (n.new = !1), (n = i), (i = e[n.prevCC])
  }
  e.presentationOffset = r
}
function id(s, e, t, r, n, i, a) {
  const o = new ed(),
    l = tt(new Uint8Array(s))
      .trim()
      .replace(
        td,
        `
`
      ).split(`
`),
    u = [],
    c = e ? mf(e.baseTime, e.timescale) : 0
  let f = '00:00.000',
    d = 0,
    m = 0,
    p,
    v = !0
  ;(o.oncue = function (E) {
    const x = t[r]
    let T = t.ccOffset
    const b = (d - c) / 9e4
    if ((x != null && x.new && (m !== void 0 ? (T = t.ccOffset = x.start) : nd(t, r, b)), b)) {
      if (!e) {
        p = new Error('Missing initPTS for VTT MPEGTS')
        return
      }
      T = b - t.presentationOffset
    }
    const R = E.endTime - E.startTime,
      g = qe((E.startTime + T - m) * 9e4, n * 9e4) / 9e4
    ;(E.startTime = Math.max(g, 0)), (E.endTime = Math.max(g + R, 0))
    const A = E.text.trim()
    ;(E.text = decodeURIComponent(encodeURIComponent(A))),
      E.id || (E.id = Wn(E.startTime, E.endTime, A)),
      E.endTime > 0 && u.push(E)
  }),
    (o.onparsingerror = function (E) {
      p = E
    }),
    (o.onflush = function () {
      if (p) {
        a(p)
        return
      }
      i(u)
    }),
    l.forEach((E) => {
      if (v)
        if (on(E, 'X-TIMESTAMP-MAP=')) {
          ;(v = !1),
            E.slice(16)
              .split(',')
              .forEach((x) => {
                on(x, 'LOCAL:') ? (f = x.slice(6)) : on(x, 'MPEGTS:') && (d = parseInt(x.slice(7)))
              })
          try {
            m = rd(f) / 1e3
          } catch (x) {
            p = x
          }
          return
        } else E === '' && (v = !1)
      o.parse(
        E +
          `
`
      )
    }),
    o.flush()
}
const un = 'stpp.ttml.im1t',
  Ma = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
  Fa = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
  sd = { left: 'start', center: 'center', right: 'end', start: 'start', end: 'end' }
function cs(s, e, t, r) {
  const n = ce(new Uint8Array(s), ['mdat'])
  if (n.length === 0) {
    r(new Error('Could not parse IMSC1 mdat'))
    return
  }
  const i = n.map((o) => tt(o)),
    a = pf(e.baseTime, 1, e.timescale)
  try {
    i.forEach((o) => t(ad(o, a)))
  } catch (o) {
    r(o)
  }
}
function ad(s, e) {
  const n = new DOMParser().parseFromString(s, 'text/xml').getElementsByTagName('tt')[0]
  if (!n) throw new Error('Invalid ttml')
  const i = { frameRate: 30, subFrameRate: 1, frameRateMultiplier: 0, tickRate: 0 },
    a = Object.keys(i).reduce((f, d) => ((f[d] = n.getAttribute(`ttp:${d}`) || i[d]), f), {}),
    o = n.getAttribute('xml:space') !== 'preserve',
    l = fs(cn(n, 'styling', 'style')),
    u = fs(cn(n, 'layout', 'region')),
    c = cn(n, 'body', '[begin]')
  return [].map
    .call(c, (f) => {
      const d = Na(f, o)
      if (!d || !f.hasAttribute('begin')) return null
      const m = dn(f.getAttribute('begin'), a),
        p = dn(f.getAttribute('dur'), a)
      let v = dn(f.getAttribute('end'), a)
      if (m === null) throw ds(f)
      if (v === null) {
        if (p === null) throw ds(f)
        v = m + p
      }
      const E = new Hn(m - e, v - e, d)
      E.id = Wn(E.startTime, E.endTime, E.text)
      const x = u[f.getAttribute('region')],
        T = l[f.getAttribute('style')],
        b = od(x, T, l),
        { textAlign: R } = b
      if (R) {
        const g = sd[R]
        g && (E.lineAlign = g), (E.align = R)
      }
      return Te(E, b), E
    })
    .filter((f) => f !== null)
}
function cn(s, e, t) {
  const r = s.getElementsByTagName(e)[0]
  return r ? [].slice.call(r.querySelectorAll(t)) : []
}
function fs(s) {
  return s.reduce((e, t) => {
    const r = t.getAttribute('xml:id')
    return r && (e[r] = t), e
  }, {})
}
function Na(s, e) {
  return [].slice.call(s.childNodes).reduce((t, r, n) => {
    var i
    return r.nodeName === 'br' && n
      ? t +
          `
`
      : (i = r.childNodes) != null && i.length
      ? Na(r, e)
      : e
      ? t + r.textContent.trim().replace(/\s+/g, ' ')
      : t + r.textContent
  }, '')
}
function od(s, e, t) {
  const r = 'http://www.w3.org/ns/ttml#styling'
  let n = null
  const i = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily'],
    a = s != null && s.hasAttribute('style') ? s.getAttribute('style') : null
  return (
    a && t.hasOwnProperty(a) && (n = t[a]),
    i.reduce((o, l) => {
      const u = fn(e, r, l) || fn(s, r, l) || fn(n, r, l)
      return u && (o[l] = u), o
    }, {})
  )
}
function fn(s, e, t) {
  return s && s.hasAttributeNS(e, t) ? s.getAttributeNS(e, t) : null
}
function ds(s) {
  return new Error(`Could not parse ttml timestamp ${s}`)
}
function dn(s, e) {
  if (!s) return null
  let t = wa(s)
  return t === null && (Ma.test(s) ? (t = ld(s, e)) : Fa.test(s) && (t = ud(s, e))), t
}
function ld(s, e) {
  const t = Ma.exec(s),
    r = (t[4] | 0) + (t[5] | 0) / e.subFrameRate
  return (t[1] | 0) * 3600 + (t[2] | 0) * 60 + (t[3] | 0) + r / e.frameRate
}
function ud(s, e) {
  const t = Fa.exec(s),
    r = Number(t[1])
  switch (t[2]) {
    case 'h':
      return r * 3600
    case 'm':
      return r * 60
    case 'ms':
      return r * 1e3
    case 'f':
      return r / e.frameRate
    case 't':
      return r / e.tickRate
  }
  return r
}
class cd {
  constructor(e) {
    if (
      ((this.hls = void 0),
      (this.media = null),
      (this.config = void 0),
      (this.enabled = !0),
      (this.Cues = void 0),
      (this.textTracks = []),
      (this.tracks = []),
      (this.initPTS = []),
      (this.unparsedVttFrags = []),
      (this.captionsTracks = {}),
      (this.nonNativeCaptionsTracks = {}),
      (this.cea608Parser1 = void 0),
      (this.cea608Parser2 = void 0),
      (this.lastSn = -1),
      (this.lastPartIndex = -1),
      (this.prevCC = -1),
      (this.vttCCs = hs()),
      (this.captionsProperties = void 0),
      (this.hls = e),
      (this.config = e.config),
      (this.Cues = e.config.cueHandler),
      (this.captionsProperties = {
        textTrack1: {
          label: this.config.captionsTextTrack1Label,
          languageCode: this.config.captionsTextTrack1LanguageCode
        },
        textTrack2: {
          label: this.config.captionsTextTrack2Label,
          languageCode: this.config.captionsTextTrack2LanguageCode
        },
        textTrack3: {
          label: this.config.captionsTextTrack3Label,
          languageCode: this.config.captionsTextTrack3LanguageCode
        },
        textTrack4: {
          label: this.config.captionsTextTrack4Label,
          languageCode: this.config.captionsTextTrack4LanguageCode
        }
      }),
      this.config.enableCEA708Captions)
    ) {
      const t = new rr(this, 'textTrack1'),
        r = new rr(this, 'textTrack2'),
        n = new rr(this, 'textTrack3'),
        i = new rr(this, 'textTrack4')
      ;(this.cea608Parser1 = new os(1, t, r)), (this.cea608Parser2 = new os(3, n, i))
    }
    e.on(O.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(O.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.on(O.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
      e.on(O.FRAG_LOADING, this.onFragLoading, this),
      e.on(O.FRAG_LOADED, this.onFragLoaded, this),
      e.on(O.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this),
      e.on(O.FRAG_DECRYPTED, this.onFragDecrypted, this),
      e.on(O.INIT_PTS_FOUND, this.onInitPtsFound, this),
      e.on(O.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this),
      e.on(O.BUFFER_FLUSHING, this.onBufferFlushing, this)
  }
  destroy() {
    const { hls: e } = this
    e.off(O.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this),
      e.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(O.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.off(O.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
      e.off(O.FRAG_LOADING, this.onFragLoading, this),
      e.off(O.FRAG_LOADED, this.onFragLoaded, this),
      e.off(O.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this),
      e.off(O.FRAG_DECRYPTED, this.onFragDecrypted, this),
      e.off(O.INIT_PTS_FOUND, this.onInitPtsFound, this),
      e.off(O.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this),
      e.off(O.BUFFER_FLUSHING, this.onBufferFlushing, this),
      (this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null)
  }
  addCues(e, t, r, n, i) {
    let a = !1
    for (let o = i.length; o--; ) {
      const l = i[o],
        u = dd(l[0], l[1], t, r)
      if (
        u >= 0 &&
        ((l[0] = Math.min(l[0], t)), (l[1] = Math.max(l[1], r)), (a = !0), u / (r - t) > 0.5)
      )
        return
    }
    if ((a || i.push([t, r]), this.config.renderTextTracksNatively)) {
      const o = this.captionsTracks[e]
      this.Cues.newCue(o, t, r, n)
    } else {
      const o = this.Cues.newCue(null, t, r, n)
      this.hls.trigger(O.CUES_PARSED, { type: 'captions', cues: o, track: e })
    }
  }
  onInitPtsFound(e, { frag: t, id: r, initPTS: n, timescale: i }) {
    const { unparsedVttFrags: a } = this
    r === 'main' && (this.initPTS[t.cc] = { baseTime: n, timescale: i }),
      a.length &&
        ((this.unparsedVttFrags = []),
        a.forEach((o) => {
          this.onFragLoaded(O.FRAG_LOADED, o)
        }))
  }
  getExistingTrack(e) {
    const { media: t } = this
    if (t)
      for (let r = 0; r < t.textTracks.length; r++) {
        const n = t.textTracks[r]
        if (n[e]) return n
      }
    return null
  }
  createCaptionsTrack(e) {
    this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e)
  }
  createNativeTrack(e) {
    if (this.captionsTracks[e]) return
    const { captionsProperties: t, captionsTracks: r, media: n } = this,
      { label: i, languageCode: a } = t[e],
      o = this.getExistingTrack(e)
    if (o) (r[e] = o), Pt(r[e]), sa(r[e], n)
    else {
      const l = this.createTextTrack('captions', i, a)
      l && ((l[e] = !0), (r[e] = l))
    }
  }
  createNonNativeTrack(e) {
    if (this.nonNativeCaptionsTracks[e]) return
    const t = this.captionsProperties[e]
    if (!t) return
    const r = t.label,
      n = {
        _id: e,
        label: r,
        kind: 'captions',
        default: t.media ? !!t.media.default : !1,
        closedCaptions: t.media
      }
    ;(this.nonNativeCaptionsTracks[e] = n),
      this.hls.trigger(O.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: [n] })
  }
  createTextTrack(e, t, r) {
    const n = this.media
    if (n) return n.addTextTrack(e, t, r)
  }
  onMediaAttaching(e, t) {
    ;(this.media = t.media), this._cleanTracks()
  }
  onMediaDetaching() {
    const { captionsTracks: e } = this
    Object.keys(e).forEach((t) => {
      Pt(e[t]), delete e[t]
    }),
      (this.nonNativeCaptionsTracks = {})
  }
  onManifestLoading() {
    ;(this.lastSn = -1),
      (this.lastPartIndex = -1),
      (this.prevCC = -1),
      (this.vttCCs = hs()),
      this._cleanTracks(),
      (this.tracks = []),
      (this.captionsTracks = {}),
      (this.nonNativeCaptionsTracks = {}),
      (this.textTracks = []),
      (this.unparsedVttFrags = []),
      (this.initPTS = []),
      this.cea608Parser1 &&
        this.cea608Parser2 &&
        (this.cea608Parser1.reset(), this.cea608Parser2.reset())
  }
  _cleanTracks() {
    const { media: e } = this
    if (!e) return
    const t = e.textTracks
    if (t) for (let r = 0; r < t.length; r++) Pt(t[r])
  }
  onSubtitleTracksUpdated(e, t) {
    const r = t.subtitleTracks || [],
      n = r.some((i) => i.textCodec === un)
    if (this.config.enableWebVTT || (n && this.config.enableIMSC1)) {
      if (Pa(this.tracks, r)) {
        this.tracks = r
        return
      }
      if (((this.textTracks = []), (this.tracks = r), this.config.renderTextTracksNatively)) {
        const a = this.media ? this.media.textTracks : null
        this.tracks.forEach((o, l) => {
          let u
          if (a && l < a.length) {
            let c = null
            for (let f = 0; f < a.length; f++)
              if (fd(a[f], o)) {
                c = a[f]
                break
              }
            c && (u = c)
          }
          if (u) Pt(u)
          else {
            const c = this._captionsOrSubtitlesFromCharacteristics(o)
            ;(u = this.createTextTrack(c, o.name, o.lang)), u && (u.mode = 'disabled')
          }
          u && ((u.groupId = o.groupId), this.textTracks.push(u))
        })
      } else if (this.tracks.length) {
        const a = this.tracks.map((o) => ({
          label: o.name,
          kind: o.type.toLowerCase(),
          default: o.default,
          subtitleTrack: o
        }))
        this.hls.trigger(O.NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: a })
      }
    }
  }
  _captionsOrSubtitlesFromCharacteristics(e) {
    if (e.attrs.CHARACTERISTICS) {
      const t = /transcribes-spoken-dialog/gi.test(e.attrs.CHARACTERISTICS),
        r = /describes-music-and-sound/gi.test(e.attrs.CHARACTERISTICS)
      if (t && r) return 'captions'
    }
    return 'subtitles'
  }
  onManifestLoaded(e, t) {
    this.config.enableCEA708Captions &&
      t.captions &&
      t.captions.forEach((r) => {
        const n = /(?:CC|SERVICE)([1-4])/.exec(r.instreamId)
        if (!n) return
        const i = `textTrack${n[1]}`,
          a = this.captionsProperties[i]
        a && ((a.label = r.name), r.lang && (a.languageCode = r.lang), (a.media = r))
      })
  }
  closedCaptionsForLevel(e) {
    const t = this.hls.levels[e.level]
    return t == null ? void 0 : t.attrs['CLOSED-CAPTIONS']
  }
  onFragLoading(e, t) {
    const { cea608Parser1: r, cea608Parser2: n, lastSn: i, lastPartIndex: a } = this
    if (!(!this.enabled || !(r && n)) && t.frag.type === ie.MAIN) {
      var o, l
      const u = t.frag.sn,
        c = (o = t == null || (l = t.part) == null ? void 0 : l.index) != null ? o : -1
      u === i + 1 || (u === i && c === a + 1) || (r.reset(), n.reset()),
        (this.lastSn = u),
        (this.lastPartIndex = c)
    }
  }
  onFragLoaded(e, t) {
    const { frag: r, payload: n } = t
    if (r.type === ie.SUBTITLE)
      if (n.byteLength) {
        const i = r.decryptdata,
          a = 'stats' in t
        if (i == null || !i.encrypted || a) {
          const o = this.tracks[r.level],
            l = this.vttCCs
          l[r.cc] ||
            ((l[r.cc] = { start: r.start, prevCC: this.prevCC, new: !0 }), (this.prevCC = r.cc)),
            o && o.textCodec === un ? this._parseIMSC1(r, n) : this._parseVTTs(t)
        }
      } else
        this.hls.trigger(O.SUBTITLE_FRAG_PROCESSED, {
          success: !1,
          frag: r,
          error: new Error('Empty subtitle payload')
        })
  }
  _parseIMSC1(e, t) {
    const r = this.hls
    cs(
      t,
      this.initPTS[e.cc],
      (n) => {
        this._appendCues(n, e.level), r.trigger(O.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: e })
      },
      (n) => {
        G.log(`Failed to parse IMSC1: ${n}`),
          r.trigger(O.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: e, error: n })
      }
    )
  }
  _parseVTTs(e) {
    var t
    const { frag: r, payload: n } = e,
      { initPTS: i, unparsedVttFrags: a } = this,
      o = i.length - 1
    if (!i[r.cc] && o === -1) {
      a.push(e)
      return
    }
    const l = this.hls,
      u = (t = r.initSegment) != null && t.data ? vt(r.initSegment.data, new Uint8Array(n)) : n
    id(
      u,
      this.initPTS[r.cc],
      this.vttCCs,
      r.cc,
      r.start,
      (c) => {
        this._appendCues(c, r.level), l.trigger(O.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: r })
      },
      (c) => {
        const f = c.message === 'Missing initPTS for VTT MPEGTS'
        f ? a.push(e) : this._fallbackToIMSC1(r, n),
          G.log(`Failed to parse VTT cue: ${c}`),
          !(f && o > r.cc) &&
            l.trigger(O.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: r, error: c })
      }
    )
  }
  _fallbackToIMSC1(e, t) {
    const r = this.tracks[e.level]
    r.textCodec ||
      cs(
        t,
        this.initPTS[e.cc],
        () => {
          ;(r.textCodec = un), this._parseIMSC1(e, t)
        },
        () => {
          r.textCodec = 'wvtt'
        }
      )
  }
  _appendCues(e, t) {
    const r = this.hls
    if (this.config.renderTextTracksNatively) {
      const n = this.textTracks[t]
      if (!n || n.mode === 'disabled') return
      e.forEach((i) => aa(n, i))
    } else {
      const n = this.tracks[t]
      if (!n) return
      const i = n.default ? 'default' : 'subtitles' + t
      r.trigger(O.CUES_PARSED, { type: 'subtitles', cues: e, track: i })
    }
  }
  onFragDecrypted(e, t) {
    const { frag: r } = t
    r.type === ie.SUBTITLE && this.onFragLoaded(O.FRAG_LOADED, t)
  }
  onSubtitleTracksCleared() {
    ;(this.tracks = []), (this.captionsTracks = {})
  }
  onFragParsingUserdata(e, t) {
    const { cea608Parser1: r, cea608Parser2: n } = this
    if (!this.enabled || !(r && n)) return
    const { frag: i, samples: a } = t
    if (!(i.type === ie.MAIN && this.closedCaptionsForLevel(i) === 'NONE'))
      for (let o = 0; o < a.length; o++) {
        const l = a[o].bytes
        if (l) {
          const u = this.extractCea608Data(l)
          r.addData(a[o].pts, u[0]), n.addData(a[o].pts, u[1])
        }
      }
  }
  onBufferFlushing(e, { startOffset: t, endOffset: r, endOffsetSubtitles: n, type: i }) {
    const { media: a } = this
    if (!(!a || a.currentTime < r)) {
      if (!i || i === 'video') {
        const { captionsTracks: o } = this
        Object.keys(o).forEach((l) => En(o[l], t, r))
      }
      if (this.config.renderTextTracksNatively && t === 0 && n !== void 0) {
        const { textTracks: o } = this
        Object.keys(o).forEach((l) => En(o[l], t, n))
      }
    }
  }
  extractCea608Data(e) {
    const t = [[], []],
      r = e[0] & 31
    let n = 2
    for (let i = 0; i < r; i++) {
      const a = e[n++],
        o = 127 & e[n++],
        l = 127 & e[n++]
      if (o === 0 && l === 0) continue
      if ((4 & a) !== 0) {
        const c = 3 & a
        ;(c === 0 || c === 1) && (t[c].push(o), t[c].push(l))
      }
    }
    return t
  }
}
function fd(s, e) {
  return !!s && s.label === e.name && !(s.textTrack1 || s.textTrack2)
}
function dd(s, e, t, r) {
  return Math.min(e, r) - Math.max(s, t)
}
function hs() {
  return { ccOffset: 0, presentationOffset: 0, 0: { start: 0, prevCC: -1, new: !0 } }
}
class Yn {
  constructor(e) {
    ;(this.hls = void 0),
      (this.autoLevelCapping = void 0),
      (this.firstLevel = void 0),
      (this.media = void 0),
      (this.restrictedLevels = void 0),
      (this.timer = void 0),
      (this.clientRect = void 0),
      (this.streamController = void 0),
      (this.hls = e),
      (this.autoLevelCapping = Number.POSITIVE_INFINITY),
      (this.firstLevel = -1),
      (this.media = null),
      (this.restrictedLevels = []),
      (this.timer = void 0),
      (this.clientRect = null),
      this.registerListeners()
  }
  setStreamController(e) {
    this.streamController = e
  }
  destroy() {
    this.unregisterListener(),
      this.hls.config.capLevelToPlayerSize && this.stopCapping(),
      (this.media = null),
      (this.clientRect = null),
      (this.hls = this.streamController = null)
  }
  registerListeners() {
    const { hls: e } = this
    e.on(O.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
      e.on(O.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.on(O.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on(O.BUFFER_CODECS, this.onBufferCodecs, this),
      e.on(O.MEDIA_DETACHING, this.onMediaDetaching, this)
  }
  unregisterListener() {
    const { hls: e } = this
    e.off(O.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
      e.off(O.MEDIA_ATTACHING, this.onMediaAttaching, this),
      e.off(O.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off(O.BUFFER_CODECS, this.onBufferCodecs, this),
      e.off(O.MEDIA_DETACHING, this.onMediaDetaching, this)
  }
  onFpsDropLevelCapping(e, t) {
    const r = this.hls.levels[t.droppedLevel]
    this.isLevelAllowed(r) &&
      this.restrictedLevels.push({ bitrate: r.bitrate, height: r.height, width: r.width })
  }
  onMediaAttaching(e, t) {
    ;(this.media = t.media instanceof HTMLVideoElement ? t.media : null), (this.clientRect = null)
  }
  onManifestParsed(e, t) {
    const r = this.hls
    ;(this.restrictedLevels = []),
      (this.firstLevel = t.firstLevel),
      r.config.capLevelToPlayerSize && t.video && this.startCapping()
  }
  onBufferCodecs(e, t) {
    this.hls.config.capLevelToPlayerSize && t.video && this.startCapping()
  }
  onMediaDetaching() {
    this.stopCapping()
  }
  detectPlayerSize() {
    if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
      const e = this.hls.levels
      if (e.length) {
        const t = this.hls
        ;(t.autoLevelCapping = this.getMaxLevel(e.length - 1)),
          t.autoLevelCapping > this.autoLevelCapping &&
            this.streamController &&
            this.streamController.nextLevelSwitch(),
          (this.autoLevelCapping = t.autoLevelCapping)
      }
    }
  }
  getMaxLevel(e) {
    const t = this.hls.levels
    if (!t.length) return -1
    const r = t.filter((n, i) => this.isLevelAllowed(n) && i <= e)
    return (this.clientRect = null), Yn.getMaxLevelByMediaSize(r, this.mediaWidth, this.mediaHeight)
  }
  startCapping() {
    this.timer ||
      ((this.autoLevelCapping = Number.POSITIVE_INFINITY),
      (this.hls.firstLevel = this.getMaxLevel(this.firstLevel)),
      self.clearInterval(this.timer),
      (this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3)),
      this.detectPlayerSize())
  }
  stopCapping() {
    ;(this.restrictedLevels = []),
      (this.firstLevel = -1),
      (this.autoLevelCapping = Number.POSITIVE_INFINITY),
      this.timer && (self.clearInterval(this.timer), (this.timer = void 0))
  }
  getDimensions() {
    if (this.clientRect) return this.clientRect
    const e = this.media,
      t = { width: 0, height: 0 }
    if (e) {
      const r = e.getBoundingClientRect()
      ;(t.width = r.width),
        (t.height = r.height),
        !t.width &&
          !t.height &&
          ((t.width = r.right - r.left || e.width || 0),
          (t.height = r.bottom - r.top || e.height || 0))
    }
    return (this.clientRect = t), t
  }
  get mediaWidth() {
    return this.getDimensions().width * this.contentScaleFactor
  }
  get mediaHeight() {
    return this.getDimensions().height * this.contentScaleFactor
  }
  get contentScaleFactor() {
    let e = 1
    if (!this.hls.config.ignoreDevicePixelRatio)
      try {
        e = self.devicePixelRatio
      } catch {}
    return e
  }
  isLevelAllowed(e) {
    return !this.restrictedLevels.some(
      (r) => e.bitrate === r.bitrate && e.width === r.width && e.height === r.height
    )
  }
  static getMaxLevelByMediaSize(e, t, r) {
    if (!(e != null && e.length)) return -1
    const n = (a, o) => (o ? a.width !== o.width || a.height !== o.height : !0)
    let i = e.length - 1
    for (let a = 0; a < e.length; a += 1) {
      const o = e[a]
      if ((o.width >= t || o.height >= r) && n(o, e[a + 1])) {
        i = a
        break
      }
    }
    return i
  }
}
class hd {
  constructor(e) {
    ;(this.hls = void 0),
      (this.isVideoPlaybackQualityAvailable = !1),
      (this.timer = void 0),
      (this.media = null),
      (this.lastTime = void 0),
      (this.lastDroppedFrames = 0),
      (this.lastDecodedFrames = 0),
      (this.streamController = void 0),
      (this.hls = e),
      this.registerListeners()
  }
  setStreamController(e) {
    this.streamController = e
  }
  registerListeners() {
    this.hls.on(O.MEDIA_ATTACHING, this.onMediaAttaching, this)
  }
  unregisterListeners() {
    this.hls.off(O.MEDIA_ATTACHING, this.onMediaAttaching, this)
  }
  destroy() {
    this.timer && clearInterval(this.timer),
      this.unregisterListeners(),
      (this.isVideoPlaybackQualityAvailable = !1),
      (this.media = null)
  }
  onMediaAttaching(e, t) {
    const r = this.hls.config
    if (r.capLevelOnFPSDrop) {
      const n = t.media instanceof self.HTMLVideoElement ? t.media : null
      ;(this.media = n),
        n &&
          typeof n.getVideoPlaybackQuality == 'function' &&
          (this.isVideoPlaybackQualityAvailable = !0),
        self.clearInterval(this.timer),
        (this.timer = self.setInterval(
          this.checkFPSInterval.bind(this),
          r.fpsDroppedMonitoringPeriod
        ))
    }
  }
  checkFPS(e, t, r) {
    const n = performance.now()
    if (t) {
      if (this.lastTime) {
        const i = n - this.lastTime,
          a = r - this.lastDroppedFrames,
          o = t - this.lastDecodedFrames,
          l = (1e3 * a) / i,
          u = this.hls
        if (
          (u.trigger(O.FPS_DROP, { currentDropped: a, currentDecoded: o, totalDroppedFrames: r }),
          l > 0 && a > u.config.fpsDroppedMonitoringThreshold * o)
        ) {
          let c = u.currentLevel
          G.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + c),
            c > 0 &&
              (u.autoLevelCapping === -1 || u.autoLevelCapping >= c) &&
              ((c = c - 1),
              u.trigger(O.FPS_DROP_LEVEL_CAPPING, { level: c, droppedLevel: u.currentLevel }),
              (u.autoLevelCapping = c),
              this.streamController.nextLevelSwitch())
        }
      }
      ;(this.lastTime = n), (this.lastDroppedFrames = r), (this.lastDecodedFrames = t)
    }
  }
  checkFPSInterval() {
    const e = this.media
    if (e)
      if (this.isVideoPlaybackQualityAvailable) {
        const t = e.getVideoPlaybackQuality()
        this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames)
      } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount)
  }
}
const ir = '[eme]'
class Dt {
  constructor(e) {
    ;(this.hls = void 0),
      (this.config = void 0),
      (this.media = null),
      (this.keyFormatPromise = null),
      (this.keySystemAccessPromises = {}),
      (this._requestLicenseFailureCount = 0),
      (this.mediaKeySessions = []),
      (this.keyIdToKeySessionPromise = {}),
      (this.setMediaKeysQueue = Dt.CDMCleanupPromise ? [Dt.CDMCleanupPromise] : []),
      (this.onMediaEncrypted = this._onMediaEncrypted.bind(this)),
      (this.onWaitingForKey = this._onWaitingForKey.bind(this)),
      (this.debug = G.debug.bind(G, ir)),
      (this.log = G.log.bind(G, ir)),
      (this.warn = G.warn.bind(G, ir)),
      (this.error = G.error.bind(G, ir)),
      (this.hls = e),
      (this.config = e.config),
      this.registerListeners()
  }
  destroy() {
    this.unregisterListeners(), this.onMediaDetached()
    const e = this.config
    ;(e.requestMediaKeySystemAccessFunc = null),
      (e.licenseXhrSetup = e.licenseResponseCallback = void 0),
      (e.drmSystems = e.drmSystemOptions = {}),
      (this.hls =
        this.onMediaEncrypted =
        this.onWaitingForKey =
        this.keyIdToKeySessionPromise =
          null),
      (this.config = null)
  }
  registerListeners() {
    this.hls.on(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      this.hls.on(O.MEDIA_DETACHED, this.onMediaDetached, this),
      this.hls.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      this.hls.on(O.MANIFEST_LOADED, this.onManifestLoaded, this)
  }
  unregisterListeners() {
    this.hls.off(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      this.hls.off(O.MEDIA_DETACHED, this.onMediaDetached, this),
      this.hls.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      this.hls.off(O.MANIFEST_LOADED, this.onManifestLoaded, this)
  }
  getLicenseServerUrl(e) {
    const { drmSystems: t, widevineLicenseUrl: r } = this.config,
      n = t[e]
    if (n) return n.licenseUrl
    if (e === ve.WIDEVINE && r) return r
    throw new Error(`no license server URL configured for key-system "${e}"`)
  }
  getServerCertificateUrl(e) {
    const { drmSystems: t } = this.config,
      r = t[e]
    if (r) return r.serverCertificateUrl
    this.log(`No Server Certificate in config.drmSystems["${e}"]`)
  }
  attemptKeySystemAccess(e) {
    const t = this.hls.levels,
      r = (a, o, l) => !!a && l.indexOf(a) === o,
      n = t.map((a) => a.audioCodec).filter(r),
      i = t.map((a) => a.videoCodec).filter(r)
    return (
      n.length + i.length === 0 && i.push('avc1.42e01e'),
      new Promise((a, o) => {
        const l = (u) => {
          const c = u.shift()
          this.getMediaKeysPromise(c, n, i)
            .then((f) => a({ keySystem: c, mediaKeys: f }))
            .catch((f) => {
              u.length
                ? l(u)
                : f instanceof Ye
                ? o(f)
                : o(
                    new Ye(
                      {
                        type: ne.KEY_SYSTEM_ERROR,
                        details: K.KEY_SYSTEM_NO_ACCESS,
                        error: f,
                        fatal: !0
                      },
                      f.message
                    )
                  )
            })
        }
        l(e)
      })
    )
  }
  requestMediaKeySystemAccess(e, t) {
    const { requestMediaKeySystemAccessFunc: r } = this.config
    if (typeof r != 'function') {
      let n = `Configured requestMediaKeySystemAccess is not a function ${r}`
      return (
        Ys === null &&
          self.location.protocol === 'http:' &&
          (n = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`),
        Promise.reject(new Error(n))
      )
    }
    return r(e, t)
  }
  getMediaKeysPromise(e, t, r) {
    const n = Au(e, t, r, this.config.drmSystemOptions),
      i = this.keySystemAccessPromises[e]
    let a = i == null ? void 0 : i.keySystemAccess
    if (!a) {
      this.log(
        `Requesting encrypted media "${e}" key-system access with config: ${JSON.stringify(n)}`
      ),
        (a = this.requestMediaKeySystemAccess(e, n))
      const o = (this.keySystemAccessPromises[e] = { keySystemAccess: a })
      return (
        a.catch((l) => {
          this.log(`Failed to obtain access to key-system "${e}": ${l}`)
        }),
        a.then((l) => {
          this.log(`Access for key-system "${l.keySystem}" obtained`)
          const u = this.fetchServerCertificate(e)
          return (
            this.log(`Create media-keys for "${e}"`),
            (o.mediaKeys = l
              .createMediaKeys()
              .then(
                (c) => (
                  this.log(`Media-keys created for "${e}"`),
                  u.then((f) => (f ? this.setMediaKeysServerCertificate(c, e, f) : c))
                )
              )),
            o.mediaKeys.catch((c) => {
              this.error(`Failed to create media-keys for "${e}"}: ${c}`)
            }),
            o.mediaKeys
          )
        })
      )
    }
    return a.then(() => i.mediaKeys)
  }
  createMediaKeySessionContext({ decryptdata: e, keySystem: t, mediaKeys: r }) {
    this.log(`Creating key-system session "${t}" keyId: ${Je.hexDump(e.keyId || [])}`)
    const n = r.createSession(),
      i = {
        decryptdata: e,
        keySystem: t,
        mediaKeys: r,
        mediaKeysSession: n,
        keyStatus: 'status-pending'
      }
    return this.mediaKeySessions.push(i), i
  }
  renewKeySession(e) {
    const t = e.decryptdata
    if (t.pssh) {
      const r = this.createMediaKeySessionContext(e),
        n = this.getKeyIdString(t),
        i = 'cenc'
      this.keyIdToKeySessionPromise[n] = this.generateRequestWithPreferredKeySession(
        r,
        i,
        t.pssh,
        'expired'
      )
    } else this.warn('Could not renew expired session. Missing pssh initData.')
    this.removeSession(e)
  }
  getKeyIdString(e) {
    if (!e) throw new Error('Could not read keyId of undefined decryptdata')
    if (e.keyId === null) throw new Error('keyId is null')
    return Je.hexDump(e.keyId)
  }
  updateKeySession(e, t) {
    var r
    const n = e.mediaKeysSession
    return (
      this.log(`Updating key-session "${n.sessionId}" for keyID ${Je.hexDump(
        ((r = e.decryptdata) == null ? void 0 : r.keyId) || []
      )}
      } (data length: ${t && t.byteLength})`),
      n.update(t)
    )
  }
  selectKeySystemFormat(e) {
    const t = Object.keys(e.levelkeys || {})
    return (
      this.keyFormatPromise ||
        (this.log(
          `Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${
            e.level
          }) key formats ${t.join(', ')}`
        ),
        (this.keyFormatPromise = this.getKeyFormatPromise(t))),
      this.keyFormatPromise
    )
  }
  getKeyFormatPromise(e) {
    return new Promise((t, r) => {
      const n = Vr(this.config),
        i = e.map(bi).filter((a) => !!a && n.indexOf(a) !== -1)
      return this.getKeySystemSelectionPromise(i)
        .then(({ keySystem: a }) => {
          const o = Li(a)
          o ? t(o) : r(new Error(`Unable to find format for key-system "${a}"`))
        })
        .catch(r)
    })
  }
  loadKey(e) {
    const t = e.keyInfo.decryptdata,
      r = this.getKeyIdString(t),
      n = `(keyId: ${r} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`
    this.log(`Starting session for key ${n}`)
    let i = this.keyIdToKeySessionPromise[r]
    return (
      i ||
        ((i = this.keyIdToKeySessionPromise[r] =
          this.getKeySystemForKeyPromise(t).then(
            ({ keySystem: a, mediaKeys: o }) => (
              this.throwIfDestroyed(),
              this.log(
                `Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${n}`
              ),
              this.attemptSetMediaKeys(a, o).then(() => {
                this.throwIfDestroyed()
                const l = this.createMediaKeySessionContext({
                    keySystem: a,
                    mediaKeys: o,
                    decryptdata: t
                  }),
                  u = 'cenc'
                return this.generateRequestWithPreferredKeySession(l, u, t.pssh, 'playlist-key')
              })
            )
          )),
        i.catch((a) => this.handleError(a))),
      i
    )
  }
  throwIfDestroyed(e = 'Invalid state') {
    if (!this.hls) throw new Error('invalid state')
  }
  handleError(e) {
    this.hls &&
      (this.error(e.message),
      e instanceof Ye
        ? this.hls.trigger(O.ERROR, e.data)
        : this.hls.trigger(O.ERROR, {
            type: ne.KEY_SYSTEM_ERROR,
            details: K.KEY_SYSTEM_NO_KEYS,
            error: e,
            fatal: !0
          }))
  }
  getKeySystemForKeyPromise(e) {
    const t = this.getKeyIdString(e),
      r = this.keyIdToKeySessionPromise[t]
    if (!r) {
      const n = bi(e.keyFormat),
        i = n ? [n] : Vr(this.config)
      return this.attemptKeySystemAccess(i)
    }
    return r
  }
  getKeySystemSelectionPromise(e) {
    if ((e.length || (e = Vr(this.config)), e.length === 0))
      throw new Ye(
        { type: ne.KEY_SYSTEM_ERROR, details: K.KEY_SYSTEM_NO_CONFIGURED_LICENSE, fatal: !0 },
        `Missing key-system license configuration options ${JSON.stringify({
          drmSystems: this.config.drmSystems
        })}`
      )
    return this.attemptKeySystemAccess(e)
  }
  _onMediaEncrypted(e) {
    const { initDataType: t, initData: r } = e
    if ((this.debug(`"${e.type}" event: init data type: "${t}"`), r === null)) return
    let n, i
    if (t === 'sinf' && this.config.drmSystems[ve.FAIRPLAY]) {
      const c = Pe(new Uint8Array(r))
      try {
        const f = Cn(JSON.parse(c).sinf),
          d = ta(new Uint8Array(f))
        if (!d) return
        ;(n = d.subarray(8, 24)), (i = ve.FAIRPLAY)
      } catch {
        this.warn('Failed to parse sinf "encrypted" event message initData')
        return
      }
    } else {
      const c = Xu(r)
      if (c === null) return
      c.version === 0 && c.systemId === Ws.WIDEVINE && c.data && (n = c.data.subarray(8, 24)),
        (i = Lu(c.systemId))
    }
    if (!i || !n) return
    const a = Je.hexDump(n),
      { keyIdToKeySessionPromise: o, mediaKeySessions: l } = this
    let u = o[a]
    for (let c = 0; c < l.length; c++) {
      const f = l[c],
        d = f.decryptdata
      if (d.pssh || !d.keyId) continue
      const m = Je.hexDump(d.keyId)
      if (a === m || d.uri.replace(/-/g, '').indexOf(a) !== -1) {
        ;(u = o[m]),
          delete o[m],
          (d.pssh = new Uint8Array(r)),
          (d.keyId = n),
          (u = o[a] =
            u.then(() =>
              this.generateRequestWithPreferredKeySession(f, t, r, 'encrypted-event-key-match')
            ))
        break
      }
    }
    u ||
      (u = o[a] =
        this.getKeySystemSelectionPromise([i]).then(({ keySystem: c, mediaKeys: f }) => {
          var d
          this.throwIfDestroyed()
          const m = new Vt('ISO-23001-7', a, (d = Li(c)) != null ? d : '')
          return (
            (m.pssh = new Uint8Array(r)),
            (m.keyId = n),
            this.attemptSetMediaKeys(c, f).then(() => {
              this.throwIfDestroyed()
              const p = this.createMediaKeySessionContext({
                decryptdata: m,
                keySystem: c,
                mediaKeys: f
              })
              return this.generateRequestWithPreferredKeySession(
                p,
                t,
                r,
                'encrypted-event-no-match'
              )
            })
          )
        })),
      u.catch((c) => this.handleError(c))
  }
  _onWaitingForKey(e) {
    this.log(`"${e.type}" event`)
  }
  attemptSetMediaKeys(e, t) {
    const r = this.setMediaKeysQueue.slice()
    this.log(`Setting media-keys for "${e}"`)
    const n = Promise.all(r).then(() => {
      if (!this.media) throw new Error('Attempted to set mediaKeys without media element attached')
      return this.media.setMediaKeys(t)
    })
    return (
      this.setMediaKeysQueue.push(n),
      n.then(() => {
        this.log(`Media-keys set for "${e}"`),
          r.push(n),
          (this.setMediaKeysQueue = this.setMediaKeysQueue.filter((i) => r.indexOf(i) === -1))
      })
    )
  }
  generateRequestWithPreferredKeySession(e, t, r, n) {
    var i, a
    const o =
      (i = this.config.drmSystems) == null || (a = i[e.keySystem]) == null
        ? void 0
        : a.generateRequest
    if (o)
      try {
        const d = o.call(this.hls, t, r, e)
        if (!d) throw new Error('Invalid response from configured generateRequest filter')
        ;(t = d.initDataType),
          (r = e.decryptdata.pssh = d.initData ? new Uint8Array(d.initData) : null)
      } catch (d) {
        var l
        if ((this.warn(d.message), (l = this.hls) != null && l.config.debug)) throw d
      }
    if (r === null)
      return this.log(`Skipping key-session request for "${n}" (no initData)`), Promise.resolve(e)
    const u = this.getKeyIdString(e.decryptdata)
    this.log(
      `Generating key-session request for "${n}": ${u} (init data type: ${t} length: ${
        r ? r.byteLength : null
      })`
    )
    const c = new Vn()
    ;(e.mediaKeysSession.onmessage = (d) => {
      const m = e.mediaKeysSession
      if (!m) {
        c.emit('error', new Error('invalid state'))
        return
      }
      const { messageType: p, message: v } = d
      this.log(`"${p}" message event for session "${m.sessionId}" message size: ${v.byteLength}`),
        p === 'license-request' || p === 'license-renewal'
          ? this.renewLicense(e, v).catch((E) => {
              this.handleError(E), c.emit('error', E)
            })
          : p === 'license-release'
          ? e.keySystem === ve.FAIRPLAY &&
            (this.updateKeySession(e, Hs('acknowledged')), this.removeSession(e))
          : this.warn(`unhandled media key message type "${p}"`)
    }),
      (e.mediaKeysSession.onkeystatuseschange = (d) => {
        if (!e.mediaKeysSession) {
          c.emit('error', new Error('invalid state'))
          return
        }
        this.onKeyStatusChange(e)
        const p = e.keyStatus
        c.emit('keyStatus', p),
          p === 'expired' &&
            (this.warn(`${e.keySystem} expired for key ${u}`), this.renewKeySession(e))
      })
    const f = new Promise((d, m) => {
      c.on('error', m),
        c.on('keyStatus', (p) => {
          p.startsWith('usable')
            ? d()
            : p === 'output-restricted'
            ? m(
                new Ye(
                  {
                    type: ne.KEY_SYSTEM_ERROR,
                    details: K.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                    fatal: !1
                  },
                  'HDCP level output restricted'
                )
              )
            : p === 'internal-error'
            ? m(
                new Ye(
                  {
                    type: ne.KEY_SYSTEM_ERROR,
                    details: K.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                    fatal: !0
                  },
                  `key status changed to "${p}"`
                )
              )
            : p === 'expired'
            ? m(new Error('key expired while generating request'))
            : this.warn(`unhandled key status change "${p}"`)
        })
    })
    return e.mediaKeysSession
      .generateRequest(t, r)
      .then(() => {
        var d
        this.log(
          `Request generated for key-session "${
            (d = e.mediaKeysSession) == null ? void 0 : d.sessionId
          }" keyId: ${u}`
        )
      })
      .catch((d) => {
        throw new Ye(
          { type: ne.KEY_SYSTEM_ERROR, details: K.KEY_SYSTEM_NO_SESSION, error: d, fatal: !1 },
          `Error generating key-session request: ${d}`
        )
      })
      .then(() => f)
      .catch((d) => {
        throw (c.removeAllListeners(), this.removeSession(e), d)
      })
      .then(() => (c.removeAllListeners(), e))
  }
  onKeyStatusChange(e) {
    e.mediaKeysSession.keyStatuses.forEach((t, r) => {
      this.log(
        `key status change "${t}" for keyStatuses keyId: ${Je.hexDump(
          'buffer' in r ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : new Uint8Array(r)
        )} session keyId: ${Je.hexDump(new Uint8Array(e.decryptdata.keyId || []))} uri: ${
          e.decryptdata.uri
        }`
      ),
        (e.keyStatus = t)
    })
  }
  fetchServerCertificate(e) {
    const t = this.config,
      r = t.loader,
      n = new r(t),
      i = this.getServerCertificateUrl(e)
    return i
      ? (this.log(`Fetching serverCertificate for "${e}"`),
        new Promise((a, o) => {
          const l = { responseType: 'arraybuffer', url: i },
            u = t.certLoadPolicy.default,
            c = {
              loadPolicy: u,
              timeout: u.maxLoadTimeMs,
              maxRetry: 0,
              retryDelay: 0,
              maxRetryDelay: 0
            },
            f = {
              onSuccess: (d, m, p, v) => {
                a(d.data)
              },
              onError: (d, m, p, v) => {
                o(
                  new Ye(
                    {
                      type: ne.KEY_SYSTEM_ERROR,
                      details: K.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                      fatal: !0,
                      networkDetails: p,
                      response: Ve({ url: l.url, data: void 0 }, d)
                    },
                    `"${e}" certificate request failed (${i}). Status: ${d.code} (${d.text})`
                  )
                )
              },
              onTimeout: (d, m, p) => {
                o(
                  new Ye(
                    {
                      type: ne.KEY_SYSTEM_ERROR,
                      details: K.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                      fatal: !0,
                      networkDetails: p,
                      response: { url: l.url, data: void 0 }
                    },
                    `"${e}" certificate request timed out (${i})`
                  )
                )
              },
              onAbort: (d, m, p) => {
                o(new Error('aborted'))
              }
            }
          n.load(l, c, f)
        }))
      : Promise.resolve()
  }
  setMediaKeysServerCertificate(e, t, r) {
    return new Promise((n, i) => {
      e.setServerCertificate(r)
        .then((a) => {
          this.log(
            `setServerCertificate ${a ? 'success' : 'not supported by CDM'} (${
              r == null ? void 0 : r.byteLength
            }) on "${t}"`
          ),
            n(e)
        })
        .catch((a) => {
          i(
            new Ye(
              {
                type: ne.KEY_SYSTEM_ERROR,
                details: K.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                error: a,
                fatal: !0
              },
              a.message
            )
          )
        })
    })
  }
  renewLicense(e, t) {
    return this.requestLicense(e, new Uint8Array(t)).then((r) =>
      this.updateKeySession(e, new Uint8Array(r)).catch((n) => {
        throw new Ye(
          {
            type: ne.KEY_SYSTEM_ERROR,
            details: K.KEY_SYSTEM_SESSION_UPDATE_FAILED,
            error: n,
            fatal: !0
          },
          n.message
        )
      })
    )
  }
  setupLicenseXHR(e, t, r, n) {
    const i = this.config.licenseXhrSetup
    return i
      ? Promise.resolve()
          .then(() => {
            if (!r.decryptdata) throw new Error('Key removed')
            return i.call(this.hls, e, t, r, n)
          })
          .catch((a) => {
            if (!r.decryptdata) throw a
            return e.open('POST', t, !0), i.call(this.hls, e, t, r, n)
          })
          .then(
            (a) => (e.readyState || e.open('POST', t, !0), { xhr: e, licenseChallenge: a || n })
          )
      : (e.open('POST', t, !0), Promise.resolve({ xhr: e, licenseChallenge: n }))
  }
  requestLicense(e, t) {
    const r = this.config.keyLoadPolicy.default
    return new Promise((n, i) => {
      const a = this.getLicenseServerUrl(e.keySystem)
      this.log(`Sending license request to URL: ${a}`)
      const o = new XMLHttpRequest()
      ;(o.responseType = 'arraybuffer'),
        (o.onreadystatechange = () => {
          if (!this.hls || !e.mediaKeysSession) return i(new Error('invalid state'))
          if (o.readyState === 4)
            if (o.status === 200) {
              this._requestLicenseFailureCount = 0
              let l = o.response
              this.log(`License received ${l instanceof ArrayBuffer ? l.byteLength : l}`)
              const u = this.config.licenseResponseCallback
              if (u)
                try {
                  l = u.call(this.hls, o, a, e)
                } catch (c) {
                  this.error(c)
                }
              n(l)
            } else {
              const l = r.errorRetry,
                u = l ? l.maxNumRetry : 0
              if (
                (this._requestLicenseFailureCount++,
                this._requestLicenseFailureCount > u || (o.status >= 400 && o.status < 500))
              )
                i(
                  new Ye(
                    {
                      type: ne.KEY_SYSTEM_ERROR,
                      details: K.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                      fatal: !0,
                      networkDetails: o,
                      response: { url: a, data: void 0, code: o.status, text: o.statusText }
                    },
                    `License Request XHR failed (${a}). Status: ${o.status} (${o.statusText})`
                  )
                )
              else {
                const c = u - this._requestLicenseFailureCount + 1
                this.warn(`Retrying license request, ${c} attempts left`),
                  this.requestLicense(e, t).then(n, i)
              }
            }
        }),
        e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(),
        (e.licenseXhr = o),
        this.setupLicenseXHR(o, a, e, t).then(({ xhr: l, licenseChallenge: u }) => {
          l.send(u)
        })
    })
  }
  onMediaAttached(e, t) {
    if (!this.config.emeEnabled) return
    const r = t.media
    ;(this.media = r),
      r.addEventListener('encrypted', this.onMediaEncrypted),
      r.addEventListener('waitingforkey', this.onWaitingForKey)
  }
  onMediaDetached() {
    const e = this.media,
      t = this.mediaKeySessions
    e &&
      (e.removeEventListener('encrypted', this.onMediaEncrypted),
      e.removeEventListener('waitingforkey', this.onWaitingForKey),
      (this.media = null)),
      (this._requestLicenseFailureCount = 0),
      (this.setMediaKeysQueue = []),
      (this.mediaKeySessions = []),
      (this.keyIdToKeySessionPromise = {}),
      Vt.clearKeyUriToKeyIdMap()
    const r = t.length
    Dt.CDMCleanupPromise = Promise.all(
      t
        .map((n) => this.removeSession(n))
        .concat(
          e == null
            ? void 0
            : e.setMediaKeys(null).catch((n) => {
                this.log(
                  `Could not clear media keys: ${n}. media.src: ${e == null ? void 0 : e.src}`
                )
              })
        )
    )
      .then(() => {
        r && (this.log('finished closing key sessions and clearing media keys'), (t.length = 0))
      })
      .catch((n) => {
        this.log(
          `Could not close sessions and clear media keys: ${n}. media.src: ${
            e == null ? void 0 : e.src
          }`
        )
      })
  }
  onManifestLoading() {
    this.keyFormatPromise = null
  }
  onManifestLoaded(e, { sessionKeys: t }) {
    if (!(!t || !this.config.emeEnabled) && !this.keyFormatPromise) {
      const r = t.reduce((n, i) => (n.indexOf(i.keyFormat) === -1 && n.push(i.keyFormat), n), [])
      this.log(`Selecting key-system from session-keys ${r.join(', ')}`),
        (this.keyFormatPromise = this.getKeyFormatPromise(r))
    }
  }
  removeSession(e) {
    const { mediaKeysSession: t, licenseXhr: r } = e
    if (t) {
      this.log(`Remove licenses and keys and close session ${t.sessionId}`),
        (t.onmessage = null),
        (t.onkeystatuseschange = null),
        r && r.readyState !== XMLHttpRequest.DONE && r.abort(),
        (e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0)
      const n = this.mediaKeySessions.indexOf(e)
      return (
        n > -1 && this.mediaKeySessions.splice(n, 1),
        t
          .remove()
          .catch((i) => {
            this.log(`Could not remove session: ${i}`)
          })
          .then(() => t.close())
          .catch((i) => {
            this.log(`Could not close session: ${i}`)
          })
      )
    }
  }
}
Dt.CDMCleanupPromise = void 0
class Ye extends Error {
  constructor(e, t) {
    super(t),
      (this.data = void 0),
      e.error || (e.error = new Error(t)),
      (this.data = e),
      (e.err = e.error)
  }
}
const pd = 1
var $e = {
  MANIFEST: 'm',
  AUDIO: 'a',
  VIDEO: 'v',
  MUXED: 'av',
  INIT: 'i',
  CAPTION: 'c',
  TIMED_TEXT: 'tt',
  KEY: 'k',
  OTHER: 'o'
}
const md = 'h'
class ct {
  constructor(e) {
    ;(this.hls = void 0),
      (this.config = void 0),
      (this.media = void 0),
      (this.sid = void 0),
      (this.cid = void 0),
      (this.useHeaders = !1),
      (this.initialized = !1),
      (this.starved = !1),
      (this.buffering = !0),
      (this.audioBuffer = void 0),
      (this.videoBuffer = void 0),
      (this.onWaiting = () => {
        this.initialized && (this.starved = !0), (this.buffering = !0)
      }),
      (this.onPlaying = () => {
        this.initialized || (this.initialized = !0), (this.buffering = !1)
      }),
      (this.applyPlaylistData = (n) => {
        try {
          this.apply(n, { ot: $e.MANIFEST, su: !this.initialized })
        } catch (i) {
          G.warn('Could not generate manifest CMCD data.', i)
        }
      }),
      (this.applyFragmentData = (n) => {
        try {
          const i = n.frag,
            a = this.hls.levels[i.level],
            o = this.getObjectType(i),
            l = { d: i.duration * 1e3, ot: o }
          ;(o === $e.VIDEO || o === $e.AUDIO || o == $e.MUXED) &&
            ((l.br = a.bitrate / 1e3),
            (l.tb = this.getTopBandwidth(o) / 1e3),
            (l.bl = this.getBufferLength(o))),
            this.apply(n, l)
        } catch (i) {
          G.warn('Could not generate segment CMCD data.', i)
        }
      }),
      (this.hls = e)
    const t = (this.config = e.config),
      { cmcd: r } = t
    r != null &&
      ((t.pLoader = this.createPlaylistLoader()),
      (t.fLoader = this.createFragmentLoader()),
      (this.sid = r.sessionId || ct.uuid()),
      (this.cid = r.contentId),
      (this.useHeaders = r.useHeaders === !0),
      this.registerListeners())
  }
  registerListeners() {
    const e = this.hls
    e.on(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.on(O.MEDIA_DETACHED, this.onMediaDetached, this),
      e.on(O.BUFFER_CREATED, this.onBufferCreated, this)
  }
  unregisterListeners() {
    const e = this.hls
    e.off(O.MEDIA_ATTACHED, this.onMediaAttached, this),
      e.off(O.MEDIA_DETACHED, this.onMediaDetached, this),
      e.off(O.BUFFER_CREATED, this.onBufferCreated, this)
  }
  destroy() {
    this.unregisterListeners(),
      this.onMediaDetached(),
      (this.hls = this.config = this.audioBuffer = this.videoBuffer = null)
  }
  onMediaAttached(e, t) {
    ;(this.media = t.media),
      this.media.addEventListener('waiting', this.onWaiting),
      this.media.addEventListener('playing', this.onPlaying)
  }
  onMediaDetached() {
    this.media &&
      (this.media.removeEventListener('waiting', this.onWaiting),
      this.media.removeEventListener('playing', this.onPlaying),
      (this.media = null))
  }
  onBufferCreated(e, t) {
    var r, n
    ;(this.audioBuffer = (r = t.tracks.audio) == null ? void 0 : r.buffer),
      (this.videoBuffer = (n = t.tracks.video) == null ? void 0 : n.buffer)
  }
  createData() {
    var e
    return {
      v: pd,
      sf: md,
      sid: this.sid,
      cid: this.cid,
      pr: (e = this.media) == null ? void 0 : e.playbackRate,
      mtp: this.hls.bandwidthEstimate / 1e3
    }
  }
  apply(e, t = {}) {
    Te(t, this.createData())
    const r = t.ot === $e.INIT || t.ot === $e.VIDEO || t.ot === $e.MUXED
    if (
      (this.starved && r && ((t.bs = !0), (t.su = !0), (this.starved = !1)),
      t.su == null && (t.su = this.buffering),
      this.useHeaders)
    ) {
      const n = ct.toHeaders(t)
      if (!Object.keys(n).length) return
      e.headers || (e.headers = {}), Te(e.headers, n)
    } else {
      const n = ct.toQuery(t)
      if (!n) return
      e.url = ct.appendQueryToUri(e.url, n)
    }
  }
  getObjectType(e) {
    const { type: t } = e
    if (t === 'subtitle') return $e.TIMED_TEXT
    if (e.sn === 'initSegment') return $e.INIT
    if (t === 'audio') return $e.AUDIO
    if (t === 'main') return this.hls.audioTracks.length ? $e.VIDEO : $e.MUXED
  }
  getTopBandwidth(e) {
    let t = 0,
      r
    const n = this.hls
    if (e === $e.AUDIO) r = n.audioTracks
    else {
      const i = n.maxAutoLevel,
        a = i > -1 ? i + 1 : n.levels.length
      r = n.levels.slice(0, a)
    }
    for (const i of r) i.bitrate > t && (t = i.bitrate)
    return t > 0 ? t : NaN
  }
  getBufferLength(e) {
    const t = this.hls.media,
      r = e === $e.AUDIO ? this.audioBuffer : this.videoBuffer
    return !r || !t ? NaN : ge.bufferInfo(r, t.currentTime, this.config.maxBufferHole).len * 1e3
  }
  createPlaylistLoader() {
    const { pLoader: e } = this.config,
      t = this.applyPlaylistData,
      r = e || this.config.loader
    return class {
      constructor(i) {
        ;(this.loader = void 0), (this.loader = new r(i))
      }
      get stats() {
        return this.loader.stats
      }
      get context() {
        return this.loader.context
      }
      destroy() {
        this.loader.destroy()
      }
      abort() {
        this.loader.abort()
      }
      load(i, a, o) {
        t(i), this.loader.load(i, a, o)
      }
    }
  }
  createFragmentLoader() {
    const { fLoader: e } = this.config,
      t = this.applyFragmentData,
      r = e || this.config.loader
    return class {
      constructor(i) {
        ;(this.loader = void 0), (this.loader = new r(i))
      }
      get stats() {
        return this.loader.stats
      }
      get context() {
        return this.loader.context
      }
      destroy() {
        this.loader.destroy()
      }
      abort() {
        this.loader.abort()
      }
      load(i, a, o) {
        t(i), this.loader.load(i, a, o)
      }
    }
  }
  static uuid() {
    const e = URL.createObjectURL(new Blob()),
      t = e.toString()
    return URL.revokeObjectURL(e), t.slice(t.lastIndexOf('/') + 1)
  }
  static serialize(e) {
    const t = [],
      r = (u) => !Number.isNaN(u) && u != null && u !== '' && u !== !1,
      n = (u) => Math.round(u),
      i = (u) => n(u / 100) * 100,
      o = { br: n, d: n, bl: i, dl: i, mtp: i, nor: (u) => encodeURIComponent(u), rtp: i, tb: n },
      l = Object.keys(e || {}).sort()
    for (const u of l) {
      let c = e[u]
      if (!r(c) || (u === 'v' && c === 1) || (u == 'pr' && c === 1)) continue
      const f = o[u]
      f && (c = f(c))
      const d = typeof c
      let m
      u === 'ot' || u === 'sf' || u === 'st'
        ? (m = `${u}=${c}`)
        : d === 'boolean'
        ? (m = u)
        : d === 'number'
        ? (m = `${u}=${c}`)
        : (m = `${u}=${JSON.stringify(c)}`),
        t.push(m)
    }
    return t.join(',')
  }
  static toHeaders(e) {
    const t = Object.keys(e),
      r = {},
      n = ['Object', 'Request', 'Session', 'Status'],
      i = [{}, {}, {}, {}],
      a = {
        br: 0,
        d: 0,
        ot: 0,
        tb: 0,
        bl: 1,
        dl: 1,
        mtp: 1,
        nor: 1,
        nrr: 1,
        su: 1,
        cid: 2,
        pr: 2,
        sf: 2,
        sid: 2,
        st: 2,
        v: 2,
        bs: 3,
        rtp: 3
      }
    for (const o of t) {
      const l = a[o] != null ? a[o] : 1
      i[l][o] = e[o]
    }
    for (let o = 0; o < i.length; o++) {
      const l = ct.serialize(i[o])
      l && (r[`CMCD-${n[o]}`] = l)
    }
    return r
  }
  static toQuery(e) {
    return `CMCD=${encodeURIComponent(ct.serialize(e))}`
  }
  static appendQueryToUri(e, t) {
    if (!t) return e
    const r = e.includes('?') ? '&' : '?'
    return `${e}${r}${t}`
  }
}
const gd = 3e5
class yd {
  constructor(e) {
    ;(this.hls = void 0),
      (this.log = void 0),
      (this.loader = null),
      (this.uri = null),
      (this.pathwayId = '.'),
      (this.pathwayPriority = null),
      (this.timeToLoad = 300),
      (this.reloadTimer = -1),
      (this.updated = 0),
      (this.started = !1),
      (this.enabled = !0),
      (this.levels = null),
      (this.audioTracks = null),
      (this.subtitleTracks = null),
      (this.penalizedPathways = {}),
      (this.hls = e),
      (this.log = G.log.bind(G, '[content-steering]:')),
      this.registerListeners()
  }
  registerListeners() {
    const e = this.hls
    e.on(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.on(O.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.on(O.MANIFEST_PARSED, this.onManifestParsed, this),
      e.on(O.ERROR, this.onError, this)
  }
  unregisterListeners() {
    const e = this.hls
    e &&
      (e.off(O.MANIFEST_LOADING, this.onManifestLoading, this),
      e.off(O.MANIFEST_LOADED, this.onManifestLoaded, this),
      e.off(O.MANIFEST_PARSED, this.onManifestParsed, this),
      e.off(O.ERROR, this.onError, this))
  }
  startLoad() {
    if (((this.started = !0), self.clearTimeout(this.reloadTimer), this.enabled && this.uri))
      if (this.updated) {
        const e = Math.max(this.timeToLoad * 1e3 - (performance.now() - this.updated), 0)
        this.scheduleRefresh(this.uri, e)
      } else this.loadSteeringManifest(this.uri)
  }
  stopLoad() {
    ;(this.started = !1),
      this.loader && (this.loader.destroy(), (this.loader = null)),
      self.clearTimeout(this.reloadTimer)
  }
  destroy() {
    this.unregisterListeners(),
      this.stopLoad(),
      (this.hls = null),
      (this.levels = this.audioTracks = this.subtitleTracks = null)
  }
  removeLevel(e) {
    const t = this.levels
    t && (this.levels = t.filter((r) => r !== e))
  }
  onManifestLoading() {
    this.stopLoad(),
      (this.enabled = !0),
      (this.timeToLoad = 300),
      (this.updated = 0),
      (this.uri = null),
      (this.pathwayId = '.'),
      (this.levels = this.audioTracks = this.subtitleTracks = null)
  }
  onManifestLoaded(e, t) {
    const { contentSteering: r } = t
    r !== null &&
      ((this.pathwayId = r.pathwayId), (this.uri = r.uri), this.started && this.startLoad())
  }
  onManifestParsed(e, t) {
    ;(this.audioTracks = t.audioTracks), (this.subtitleTracks = t.subtitleTracks)
  }
  onError(e, t) {
    const { errorAction: r } = t
    if (
      (r == null ? void 0 : r.action) === Ce.SendAlternateToPenaltyBox &&
      r.flags === ze.MoveAllAlternatesMatchingHost
    ) {
      let n = this.pathwayPriority
      const i = this.pathwayId
      this.penalizedPathways[i] || (this.penalizedPathways[i] = performance.now()),
        !n &&
          this.levels &&
          (n = this.levels.reduce(
            (a, o) => (a.indexOf(o.pathwayId) === -1 && a.push(o.pathwayId), a),
            []
          )),
        n && n.length > 1 && (this.updatePathwayPriority(n), (r.resolved = this.pathwayId !== i))
    }
  }
  filterParsedLevels(e) {
    this.levels = e
    let t = this.getLevelsForPathway(this.pathwayId)
    if (t.length === 0) {
      const r = e[0].pathwayId
      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${r}"`),
        (t = this.getLevelsForPathway(r)),
        (this.pathwayId = r)
    }
    return t.length !== e.length
      ? (this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`), t)
      : e
  }
  getLevelsForPathway(e) {
    return this.levels === null ? [] : this.levels.filter((t) => e === t.pathwayId)
  }
  updatePathwayPriority(e) {
    this.pathwayPriority = e
    let t
    const r = this.penalizedPathways,
      n = performance.now()
    Object.keys(r).forEach((i) => {
      n - r[i] > gd && delete r[i]
    })
    for (let i = 0; i < e.length; i++) {
      const a = e[i]
      if (r[a]) continue
      if (a === this.pathwayId) return
      const o = this.hls.nextLoadLevel,
        l = this.hls.levels[o]
      if (((t = this.getLevelsForPathway(a)), t.length > 0)) {
        this.log(`Setting Pathway to "${a}"`),
          (this.pathwayId = a),
          this.hls.trigger(O.LEVELS_UPDATED, { levels: t })
        const u = this.hls.levels[o]
        l &&
          u &&
          this.levels &&
          (u.attrs['STABLE-VARIANT-ID'] !== l.attrs['STABLE-VARIANT-ID'] &&
            u.bitrate !== l.bitrate &&
            this.log(`Unstable Pathways change from bitrate ${l.bitrate} to ${u.bitrate}`),
          (this.hls.nextLoadLevel = o))
        break
      }
    }
  }
  clonePathways(e) {
    const t = this.levels
    if (!t) return
    const r = {},
      n = {}
    e.forEach((i) => {
      const { ID: a, 'BASE-ID': o, 'URI-REPLACEMENT': l } = i
      if (t.some((c) => c.pathwayId === a)) return
      const u = this.getLevelsForPathway(o).map((c) => {
        const f = Te({}, c)
        ;(f.details = void 0),
          (f.url = Ua(c.uri, c.attrs['STABLE-VARIANT-ID'], 'PER-VARIANT-URIS', l))
        const d = new ye(c.attrs)
        d['PATHWAY-ID'] = a
        const m = d.AUDIO && `${d.AUDIO}_clone_${a}`,
          p = d.SUBTITLES && `${d.SUBTITLES}_clone_${a}`
        m && ((r[d.AUDIO] = m), (d.AUDIO = m)),
          p && ((n[d.SUBTITLES] = p), (d.SUBTITLES = p)),
          (f.attrs = d)
        const v = new Ht(f)
        return mr(v, 'audio', m), mr(v, 'text', p), v
      })
      t.push(...u), ps(this.audioTracks, r, l, a), ps(this.subtitleTracks, n, l, a)
    })
  }
  loadSteeringManifest(e) {
    const t = this.hls.config,
      r = t.loader
    this.loader && this.loader.destroy(), (this.loader = new r(t))
    let n
    try {
      n = new self.URL(e)
    } catch {
      ;(this.enabled = !1), this.log(`Failed to parse Steering Manifest URI: ${e}`)
      return
    }
    if (n.protocol !== 'data:') {
      const c = (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate) | 0
      n.searchParams.set('_HLS_pathway', this.pathwayId),
        n.searchParams.set('_HLS_throughput', '' + c)
    }
    const i = { responseType: 'json', url: n.href },
      a = t.steeringManifestLoadPolicy.default,
      o = a.errorRetry || a.timeoutRetry || {},
      l = {
        loadPolicy: a,
        timeout: a.maxLoadTimeMs,
        maxRetry: o.maxNumRetry || 0,
        retryDelay: o.retryDelayMs || 0,
        maxRetryDelay: o.maxRetryDelayMs || 0
      },
      u = {
        onSuccess: (c, f, d, m) => {
          this.log(`Loaded steering manifest: "${n}"`)
          const p = c.data
          if (p.VERSION !== 1) {
            this.log(`Steering VERSION ${p.VERSION} not supported!`)
            return
          }
          ;(this.updated = performance.now()), (this.timeToLoad = p.TTL)
          const { 'RELOAD-URI': v, 'PATHWAY-CLONES': E, 'PATHWAY-PRIORITY': x } = p
          if (v)
            try {
              this.uri = new self.URL(v, n).href
            } catch {
              ;(this.enabled = !1), this.log(`Failed to parse Steering Manifest RELOAD-URI: ${v}`)
              return
            }
          this.scheduleRefresh(this.uri || d.url),
            E && this.clonePathways(E),
            x && this.updatePathwayPriority(x)
        },
        onError: (c, f, d, m) => {
          if (
            (this.log(`Error loading steering manifest: ${c.code} ${c.text} (${f.url})`),
            this.stopLoad(),
            c.code === 410)
          ) {
            ;(this.enabled = !1), this.log(`Steering manifest ${f.url} no longer available`)
            return
          }
          let p = this.timeToLoad * 1e3
          if (c.code === 429) {
            const v = this.loader
            if (typeof (v == null ? void 0 : v.getResponseHeader) == 'function') {
              const E = v.getResponseHeader('Retry-After')
              E && (p = parseFloat(E) * 1e3)
            }
            this.log(`Steering manifest ${f.url} rate limited`)
            return
          }
          this.scheduleRefresh(this.uri || f.url, p)
        },
        onTimeout: (c, f, d) => {
          this.log(`Timeout loading steering manifest (${f.url})`),
            this.scheduleRefresh(this.uri || f.url)
        }
      }
    this.log(`Requesting steering manifest: ${n}`), this.loader.load(i, l, u)
  }
  scheduleRefresh(e, t = this.timeToLoad * 1e3) {
    self.clearTimeout(this.reloadTimer),
      (this.reloadTimer = self.setTimeout(() => {
        this.loadSteeringManifest(e)
      }, t))
  }
}
function ps(s, e, t, r) {
  s &&
    Object.keys(e).forEach((n) => {
      const i = s
        .filter((a) => a.groupId === n)
        .map((a) => {
          const o = Te({}, a)
          return (
            (o.details = void 0),
            (o.attrs = new ye(o.attrs)),
            (o.url = o.attrs.URI =
              Ua(a.url, a.attrs['STABLE-RENDITION-ID'], 'PER-RENDITION-URIS', t)),
            (o.groupId = o.attrs['GROUP-ID'] = e[n]),
            (o.attrs['PATHWAY-ID'] = r),
            o
          )
        })
      s.push(...i)
    })
}
function Ua(s, e, t, r) {
  const { HOST: n, PARAMS: i, [t]: a } = r
  let o
  e && ((o = a == null ? void 0 : a[e]), o && (s = o))
  const l = new self.URL(s)
  return (
    n && !o && (l.host = n),
    i &&
      Object.keys(i)
        .sort()
        .forEach((u) => {
          u && l.searchParams.set(u, i[u])
        }),
    l.href
  )
}
const vd = /^age:\s*[\d.]+\s*$/im
class Ba {
  constructor(e) {
    ;(this.xhrSetup = void 0),
      (this.requestTimeout = void 0),
      (this.retryTimeout = void 0),
      (this.retryDelay = void 0),
      (this.config = null),
      (this.callbacks = null),
      (this.context = void 0),
      (this.loader = null),
      (this.stats = void 0),
      (this.xhrSetup = (e && e.xhrSetup) || null),
      (this.stats = new _r()),
      (this.retryDelay = 0)
  }
  destroy() {
    ;(this.callbacks = null), this.abortInternal(), (this.loader = null), (this.config = null)
  }
  abortInternal() {
    const e = this.loader
    self.clearTimeout(this.requestTimeout),
      self.clearTimeout(this.retryTimeout),
      e &&
        ((e.onreadystatechange = null),
        (e.onprogress = null),
        e.readyState !== 4 && ((this.stats.aborted = !0), e.abort()))
  }
  abort() {
    var e
    this.abortInternal(),
      (e = this.callbacks) != null &&
        e.onAbort &&
        this.callbacks.onAbort(this.stats, this.context, this.loader)
  }
  load(e, t, r) {
    if (this.stats.loading.start) throw new Error('Loader can only be used once.')
    ;(this.stats.loading.start = self.performance.now()),
      (this.context = e),
      (this.config = t),
      (this.callbacks = r),
      this.loadInternal()
  }
  loadInternal() {
    const { config: e, context: t } = this
    if (!e) return
    const r = (this.loader = new self.XMLHttpRequest()),
      n = this.stats
    ;(n.loading.first = 0), (n.loaded = 0), (n.aborted = !1)
    const i = this.xhrSetup
    i
      ? Promise.resolve()
          .then(() => {
            if (!this.stats.aborted) return i(r, t.url)
          })
          .catch((a) => (r.open('GET', t.url, !0), i(r, t.url)))
          .then(() => {
            this.stats.aborted || this.openAndSendXhr(r, t, e)
          })
          .catch((a) => {
            this.callbacks.onError({ code: r.status, text: a.message }, t, r, n)
          })
      : this.openAndSendXhr(r, t, e)
  }
  openAndSendXhr(e, t, r) {
    e.readyState || e.open('GET', t.url, !0)
    const n = this.context.headers,
      { maxTimeToFirstByteMs: i, maxLoadTimeMs: a } = r.loadPolicy
    if (n) for (const o in n) e.setRequestHeader(o, n[o])
    t.rangeEnd && e.setRequestHeader('Range', 'bytes=' + t.rangeStart + '-' + (t.rangeEnd - 1)),
      (e.onreadystatechange = this.readystatechange.bind(this)),
      (e.onprogress = this.loadprogress.bind(this)),
      (e.responseType = t.responseType),
      self.clearTimeout(this.requestTimeout),
      (r.timeout = i && J(i) ? i : a),
      (this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.timeout)),
      e.send()
  }
  readystatechange() {
    const { context: e, loader: t, stats: r } = this
    if (!e || !t) return
    const n = t.readyState,
      i = this.config
    if (
      !r.aborted &&
      n >= 2 &&
      (r.loading.first === 0 &&
        ((r.loading.first = Math.max(self.performance.now(), r.loading.start)),
        i.timeout !== i.loadPolicy.maxLoadTimeMs &&
          (self.clearTimeout(this.requestTimeout),
          (i.timeout = i.loadPolicy.maxLoadTimeMs),
          (this.requestTimeout = self.setTimeout(
            this.loadtimeout.bind(this),
            i.loadPolicy.maxLoadTimeMs - (r.loading.first - r.loading.start)
          )))),
      n === 4)
    ) {
      self.clearTimeout(this.requestTimeout), (t.onreadystatechange = null), (t.onprogress = null)
      const a = t.status,
        o = t.responseType !== 'text'
      if (a >= 200 && a < 300 && ((o && t.response) || t.responseText !== null)) {
        r.loading.end = Math.max(self.performance.now(), r.loading.first)
        const l = o ? t.response : t.responseText,
          u = t.responseType === 'arraybuffer' ? l.byteLength : l.length
        if (
          ((r.loaded = r.total = u),
          (r.bwEstimate = (r.total * 8e3) / (r.loading.end - r.loading.first)),
          !this.callbacks)
        )
          return
        const c = this.callbacks.onProgress
        if ((c && c(r, e, l, t), !this.callbacks)) return
        const f = { url: t.responseURL, data: l, code: a }
        this.callbacks.onSuccess(f, r, e, t)
      } else {
        const l = i.loadPolicy.errorRetry,
          u = r.retry
        pr(l, u, !1, a)
          ? this.retry(l)
          : (G.error(`${a} while loading ${e.url}`),
            this.callbacks.onError({ code: a, text: t.statusText }, e, t, r))
      }
    }
  }
  loadtimeout() {
    var e
    const t = (e = this.config) == null ? void 0 : e.loadPolicy.timeoutRetry,
      r = this.stats.retry
    if (pr(t, r, !0)) this.retry(t)
    else {
      G.warn(`timeout while loading ${this.context.url}`)
      const n = this.callbacks
      n && (this.abortInternal(), n.onTimeout(this.stats, this.context, this.loader))
    }
  }
  retry(e) {
    const { context: t, stats: r } = this
    ;(this.retryDelay = Mn(e, r.retry)),
      r.retry++,
      G.warn(
        `${status ? 'HTTP Status ' + status : 'Timeout'} while loading ${t.url}, retrying ${
          r.retry
        }/${e.maxNumRetry} in ${this.retryDelay}ms`
      ),
      this.abortInternal(),
      (this.loader = null),
      self.clearTimeout(this.retryTimeout),
      (this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay))
  }
  loadprogress(e) {
    const t = this.stats
    ;(t.loaded = e.loaded), e.lengthComputable && (t.total = e.total)
  }
  getCacheAge() {
    let e = null
    if (this.loader && vd.test(this.loader.getAllResponseHeaders())) {
      const t = this.loader.getResponseHeader('age')
      e = t ? parseFloat(t) : null
    }
    return e
  }
  getResponseHeader(e) {
    return this.loader &&
      new RegExp(`^${e}:\\s*[\\d.]+\\s*$`, 'im').test(this.loader.getAllResponseHeaders())
      ? this.loader.getResponseHeader(e)
      : null
  }
}
function _d() {
  if (self.fetch && self.AbortController && self.ReadableStream && self.Request)
    try {
      return new self.ReadableStream({}), !0
    } catch {}
  return !1
}
const Ed = /(\d+)-(\d+)\/(\d+)/
class ms {
  constructor(e) {
    ;(this.fetchSetup = void 0),
      (this.requestTimeout = void 0),
      (this.request = void 0),
      (this.response = void 0),
      (this.controller = void 0),
      (this.context = void 0),
      (this.config = null),
      (this.callbacks = null),
      (this.stats = void 0),
      (this.loader = null),
      (this.fetchSetup = e.fetchSetup || bd),
      (this.controller = new self.AbortController()),
      (this.stats = new _r())
  }
  destroy() {
    ;(this.loader = this.callbacks = null), this.abortInternal()
  }
  abortInternal() {
    const e = this.response
    ;(e != null && e.ok) || ((this.stats.aborted = !0), this.controller.abort())
  }
  abort() {
    var e
    this.abortInternal(),
      (e = this.callbacks) != null &&
        e.onAbort &&
        this.callbacks.onAbort(this.stats, this.context, this.response)
  }
  load(e, t, r) {
    const n = this.stats
    if (n.loading.start) throw new Error('Loader can only be used once.')
    n.loading.start = self.performance.now()
    const i = xd(e, this.controller.signal),
      a = r.onProgress,
      o = e.responseType === 'arraybuffer',
      l = o ? 'byteLength' : 'length',
      { maxTimeToFirstByteMs: u, maxLoadTimeMs: c } = t.loadPolicy
    ;(this.context = e),
      (this.config = t),
      (this.callbacks = r),
      (this.request = this.fetchSetup(e, i)),
      self.clearTimeout(this.requestTimeout),
      (t.timeout = u && J(u) ? u : c),
      (this.requestTimeout = self.setTimeout(() => {
        this.abortInternal(), r.onTimeout(n, e, this.response)
      }, t.timeout)),
      self
        .fetch(this.request)
        .then((f) => {
          this.response = this.loader = f
          const d = Math.max(self.performance.now(), n.loading.start)
          if (
            (self.clearTimeout(this.requestTimeout),
            (t.timeout = c),
            (this.requestTimeout = self.setTimeout(() => {
              this.abortInternal(), r.onTimeout(n, e, this.response)
            }, c - (d - n.loading.start))),
            !f.ok)
          ) {
            const { status: m, statusText: p } = f
            throw new Ld(p || 'fetch, bad network response', m, f)
          }
          return (
            (n.loading.first = d),
            (n.total = Td(f.headers) || n.total),
            a && J(t.highWaterMark)
              ? this.loadProgressively(f, n, e, t.highWaterMark, a)
              : o
              ? f.arrayBuffer()
              : e.responseType === 'json'
              ? f.json()
              : f.text()
          )
        })
        .then((f) => {
          const { response: d } = this
          self.clearTimeout(this.requestTimeout),
            (n.loading.end = Math.max(self.performance.now(), n.loading.first))
          const m = f[l]
          m && (n.loaded = n.total = m)
          const p = { url: d.url, data: f, code: d.status }
          a && !J(t.highWaterMark) && a(n, e, f, d), r.onSuccess(p, n, e, d)
        })
        .catch((f) => {
          if ((self.clearTimeout(this.requestTimeout), n.aborted)) return
          const d = (f && f.code) || 0,
            m = f ? f.message : null
          r.onError({ code: d, text: m }, e, f ? f.details : null, n)
        })
  }
  getCacheAge() {
    let e = null
    if (this.response) {
      const t = this.response.headers.get('age')
      e = t ? parseFloat(t) : null
    }
    return e
  }
  getResponseHeader(e) {
    return this.response ? this.response.headers.get(e) : null
  }
  loadProgressively(e, t, r, n = 0, i) {
    const a = new Ia(),
      o = e.body.getReader(),
      l = () =>
        o
          .read()
          .then((u) => {
            if (u.done)
              return a.dataLength && i(t, r, a.flush(), e), Promise.resolve(new ArrayBuffer(0))
            const c = u.value,
              f = c.length
            return (
              (t.loaded += f),
              f < n || a.dataLength
                ? (a.push(c), a.dataLength >= n && i(t, r, a.flush(), e))
                : i(t, r, c, e),
              l()
            )
          })
          .catch(() => Promise.reject())
    return l()
  }
}
function xd(s, e) {
  const t = {
    method: 'GET',
    mode: 'cors',
    credentials: 'same-origin',
    signal: e,
    headers: new self.Headers(Te({}, s.headers))
  }
  return (
    s.rangeEnd && t.headers.set('Range', 'bytes=' + s.rangeStart + '-' + String(s.rangeEnd - 1)), t
  )
}
function Sd(s) {
  const e = Ed.exec(s)
  if (e) return parseInt(e[2]) - parseInt(e[1]) + 1
}
function Td(s) {
  const e = s.get('Content-Range')
  if (e) {
    const r = Sd(e)
    if (J(r)) return r
  }
  const t = s.get('Content-Length')
  if (t) return parseInt(t)
}
function bd(s, e) {
  return new self.Request(s.url, e)
}
class Ld extends Error {
  constructor(e, t, r) {
    super(e), (this.code = void 0), (this.details = void 0), (this.code = t), (this.details = r)
  }
}
const Ad = /\s/,
  Rd = {
    newCue(s, e, t, r) {
      const n = []
      let i, a, o, l, u
      const c = self.VTTCue || self.TextTrackCue
      for (let d = 0; d < r.rows.length; d++)
        if (((i = r.rows[d]), (o = !0), (l = 0), (u = ''), !i.isEmpty())) {
          var f
          for (let v = 0; v < i.chars.length; v++)
            Ad.test(i.chars[v].uchar) && o ? l++ : ((u += i.chars[v].uchar), (o = !1))
          ;(i.cueStartTime = e), e === t && (t += 1e-4), l >= 16 ? l-- : l++
          const m = ka(u.trim()),
            p = Wn(e, t, m)
          ;(s != null && (f = s.cues) != null && f.getCueById(p)) ||
            ((a = new c(e, t, m)),
            (a.id = p),
            (a.line = d + 1),
            (a.align = 'left'),
            (a.position = 10 + Math.min(80, Math.floor((l * 8) / 32) * 10)),
            n.push(a))
        }
      return (
        s &&
          n.length &&
          (n.sort((d, m) =>
            d.line === 'auto' || m.line === 'auto'
              ? 0
              : d.line > 8 && m.line > 8
              ? m.line - d.line
              : d.line - m.line
          ),
          n.forEach((d) => aa(s, d))),
        n
      )
    }
  },
  Id = { maxTimeToFirstByteMs: 8e3, maxLoadTimeMs: 2e4, timeoutRetry: null, errorRetry: null },
  Pd = Ve(
    Ve(
      {
        autoStartLoad: !0,
        startPosition: -1,
        defaultAudioCodec: void 0,
        debug: !1,
        capLevelOnFPSDrop: !1,
        capLevelToPlayerSize: !1,
        ignoreDevicePixelRatio: !1,
        initialLiveManifestSize: 1,
        maxBufferLength: 30,
        backBufferLength: 1 / 0,
        maxBufferSize: 60 * 1e3 * 1e3,
        maxBufferHole: 0.1,
        highBufferWatchdogPeriod: 2,
        nudgeOffset: 0.1,
        nudgeMaxRetry: 3,
        maxFragLookUpTolerance: 0.25,
        liveSyncDurationCount: 3,
        liveMaxLatencyDurationCount: 1 / 0,
        liveSyncDuration: void 0,
        liveMaxLatencyDuration: void 0,
        maxLiveSyncPlaybackRate: 1,
        liveDurationInfinity: !1,
        liveBackBufferLength: null,
        maxMaxBufferLength: 600,
        enableWorker: !0,
        workerPath: null,
        enableSoftwareAES: !0,
        startLevel: void 0,
        startFragPrefetch: !1,
        fpsDroppedMonitoringPeriod: 5e3,
        fpsDroppedMonitoringThreshold: 0.2,
        appendErrorMaxRetry: 3,
        loader: Ba,
        fLoader: void 0,
        pLoader: void 0,
        xhrSetup: void 0,
        licenseXhrSetup: void 0,
        licenseResponseCallback: void 0,
        abrController: Cf,
        bufferController: Kf,
        capLevelController: Yn,
        errorController: bc,
        fpsController: hd,
        stretchShortVideoTrack: !1,
        maxAudioFramesDrift: 1,
        forceKeyFrameOnDiscontinuity: !0,
        abrEwmaFastLive: 3,
        abrEwmaSlowLive: 9,
        abrEwmaFastVoD: 3,
        abrEwmaSlowVoD: 9,
        abrEwmaDefaultEstimate: 5e5,
        abrBandWidthFactor: 0.95,
        abrBandWidthUpFactor: 0.7,
        abrMaxWithRealBitrate: !1,
        maxStarvationDelay: 4,
        maxLoadingDelay: 4,
        minAutoBitrate: 0,
        emeEnabled: !1,
        widevineLicenseUrl: void 0,
        drmSystems: {},
        drmSystemOptions: {},
        requestMediaKeySystemAccessFunc: Ys,
        testBandwidth: !0,
        progressive: !1,
        lowLatencyMode: !0,
        cmcd: void 0,
        enableDateRangeMetadataCues: !0,
        enableEmsgMetadataCues: !0,
        enableID3MetadataCues: !0,
        certLoadPolicy: { default: Id },
        keyLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 8e3,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
              maxNumRetry: 1,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 2e4,
              backoff: 'linear'
            },
            errorRetry: {
              maxNumRetry: 8,
              retryDelayMs: 1e3,
              maxRetryDelayMs: 2e4,
              backoff: 'linear'
            }
          }
        },
        manifestLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1 / 0,
            maxLoadTimeMs: 2e4,
            timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 },
            errorRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 }
          }
        },
        playlistLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 2e4,
            timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 },
            errorRetry: { maxNumRetry: 2, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 }
          }
        },
        fragLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 12e4,
            timeoutRetry: { maxNumRetry: 4, retryDelayMs: 0, maxRetryDelayMs: 0 },
            errorRetry: { maxNumRetry: 6, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 }
          }
        },
        steeringManifestLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 2e4,
            timeoutRetry: { maxNumRetry: 2, retryDelayMs: 0, maxRetryDelayMs: 0 },
            errorRetry: { maxNumRetry: 1, retryDelayMs: 1e3, maxRetryDelayMs: 8e3 }
          }
        },
        manifestLoadingTimeOut: 1e4,
        manifestLoadingMaxRetry: 1,
        manifestLoadingRetryDelay: 1e3,
        manifestLoadingMaxRetryTimeout: 64e3,
        levelLoadingTimeOut: 1e4,
        levelLoadingMaxRetry: 4,
        levelLoadingRetryDelay: 1e3,
        levelLoadingMaxRetryTimeout: 64e3,
        fragLoadingTimeOut: 2e4,
        fragLoadingMaxRetry: 6,
        fragLoadingRetryDelay: 1e3,
        fragLoadingMaxRetryTimeout: 64e3
      },
      Dd()
    ),
    {},
    {
      subtitleStreamController: Uf,
      subtitleTrackController: Gf,
      timelineController: cd,
      audioStreamController: Mf,
      audioTrackController: Ff,
      emeController: Dt,
      cmcdController: ct,
      contentSteeringController: yd
    }
  )
function Dd() {
  return {
    cueHandler: Rd,
    enableWebVTT: !0,
    enableIMSC1: !0,
    enableCEA708Captions: !0,
    captionsTextTrack1Label: 'English',
    captionsTextTrack1LanguageCode: 'en',
    captionsTextTrack2Label: 'Spanish',
    captionsTextTrack2LanguageCode: 'es',
    captionsTextTrack3Label: 'Unknown CC',
    captionsTextTrack3LanguageCode: '',
    captionsTextTrack4Label: 'Unknown CC',
    captionsTextTrack4LanguageCode: '',
    renderTextTracksNatively: !0
  }
}
function Od(s, e) {
  if (
    (e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) &&
    (e.liveSyncDuration || e.liveMaxLatencyDuration)
  )
    throw new Error(
      "Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration"
    )
  if (
    e.liveMaxLatencyDurationCount !== void 0 &&
    (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount)
  )
    throw new Error(
      'Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"'
    )
  if (
    e.liveMaxLatencyDuration !== void 0 &&
    (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration <= e.liveSyncDuration)
  )
    throw new Error(
      'Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"'
    )
  const t = Rn(s),
    r = ['manifest', 'level', 'frag'],
    n = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout']
  return (
    r.forEach((i) => {
      const a = `${i === 'level' ? 'playlist' : i}LoadPolicy`,
        o = e[a] === void 0,
        l = []
      n.forEach((u) => {
        const c = `${i}Loading${u}`,
          f = e[c]
        if (f !== void 0 && o) {
          l.push(c)
          const d = t[a].default
          switch (((e[a] = { default: d }), u)) {
            case 'TimeOut':
              ;(d.maxLoadTimeMs = f), (d.maxTimeToFirstByteMs = f)
              break
            case 'MaxRetry':
              ;(d.errorRetry.maxNumRetry = f), (d.timeoutRetry.maxNumRetry = f)
              break
            case 'RetryDelay':
              ;(d.errorRetry.retryDelayMs = f), (d.timeoutRetry.retryDelayMs = f)
              break
            case 'MaxRetryTimeout':
              ;(d.errorRetry.maxRetryDelayMs = f), (d.timeoutRetry.maxRetryDelayMs = f)
              break
          }
        }
      }),
        l.length &&
          G.warn(
            `hls.js config: "${l.join(
              '", "'
            )}" setting(s) are deprecated, use "${a}": ${JSON.stringify(e[a])}`
          )
    }),
    Ve(Ve({}, t), e)
  )
}
function Rn(s) {
  return s && typeof s == 'object'
    ? Array.isArray(s)
      ? s.map(Rn)
      : Object.keys(s).reduce((e, t) => ((e[t] = Rn(s[t])), e), {})
    : s
}
function wd(s) {
  const e = s.loader
  e !== ms && e !== Ba
    ? (G.log('[config]: Custom loader detected, cannot enable progressive streaming'),
      (s.progressive = !1))
    : _d() &&
      ((s.loader = ms),
      (s.progressive = !0),
      (s.enableSoftwareAES = !0),
      G.log('[config]: Progressive streaming enabled, using FetchLoader'))
}
class mt {
  static get version() {
    return '1.4.12'
  }
  static isSupported() {
    return jc()
  }
  static get Events() {
    return O
  }
  static get ErrorTypes() {
    return ne
  }
  static get ErrorDetails() {
    return K
  }
  static get DefaultConfig() {
    return mt.defaultConfig ? mt.defaultConfig : Pd
  }
  static set DefaultConfig(e) {
    mt.defaultConfig = e
  }
  constructor(e = {}) {
    ;(this.config = void 0),
      (this.userConfig = void 0),
      (this.coreComponents = void 0),
      (this.networkControllers = void 0),
      (this._emitter = new Vn()),
      (this._autoLevelCapping = void 0),
      (this._maxHdcpLevel = null),
      (this.abrController = void 0),
      (this.bufferController = void 0),
      (this.capLevelController = void 0),
      (this.latencyController = void 0),
      (this.levelController = void 0),
      (this.streamController = void 0),
      (this.audioTrackController = void 0),
      (this.subtitleTrackController = void 0),
      (this.emeController = void 0),
      (this.cmcdController = void 0),
      (this._media = null),
      (this.url = null),
      mu(e.debug || !1, 'Hls instance')
    const t = (this.config = Od(mt.DefaultConfig, e))
    ;(this.userConfig = e), (this._autoLevelCapping = -1), t.progressive && wd(t)
    const {
        abrController: r,
        bufferController: n,
        capLevelController: i,
        errorController: a,
        fpsController: o
      } = t,
      l = new a(this),
      u = (this.abrController = new r(this)),
      c = (this.bufferController = new n(this)),
      f = (this.capLevelController = new i(this)),
      d = new o(this),
      m = new sc(this),
      p = new cc(this),
      v = t.contentSteeringController,
      E = v ? new v(this) : null,
      x = (this.levelController = new Ac(this, E)),
      T = new Rc(this),
      b = new Pc(this.config),
      R = (this.streamController = new Of(this, T, b))
    f.setStreamController(R), d.setStreamController(R)
    const g = [m, x, R]
    E && g.splice(1, 0, E), (this.networkControllers = g)
    const A = [u, c, f, d, p, T]
    this.audioTrackController = this.createController(t.audioTrackController, g)
    const S = t.audioStreamController
    S && g.push(new S(this, T, b)),
      (this.subtitleTrackController = this.createController(t.subtitleTrackController, g))
    const h = t.subtitleStreamController
    h && g.push(new h(this, T, b)),
      this.createController(t.timelineController, A),
      (b.emeController = this.emeController = this.createController(t.emeController, A)),
      (this.cmcdController = this.createController(t.cmcdController, A)),
      (this.latencyController = this.createController(fc, A)),
      (this.coreComponents = A),
      g.push(l)
    const _ = l.onErrorOut
    typeof _ == 'function' && this.on(O.ERROR, _, l)
  }
  createController(e, t) {
    if (e) {
      const r = new e(this)
      return t && t.push(r), r
    }
    return null
  }
  on(e, t, r = this) {
    this._emitter.on(e, t, r)
  }
  once(e, t, r = this) {
    this._emitter.once(e, t, r)
  }
  removeAllListeners(e) {
    this._emitter.removeAllListeners(e)
  }
  off(e, t, r = this, n) {
    this._emitter.off(e, t, r, n)
  }
  listeners(e) {
    return this._emitter.listeners(e)
  }
  emit(e, t, r) {
    return this._emitter.emit(e, t, r)
  }
  trigger(e, t) {
    if (this.config.debug) return this.emit(e, e, t)
    try {
      return this.emit(e, e, t)
    } catch (r) {
      G.error(
        'An internal error happened while handling event ' +
          e +
          '. Error message: "' +
          r.message +
          '". Here is a stacktrace:',
        r
      ),
        this.trigger(O.ERROR, {
          type: ne.OTHER_ERROR,
          details: K.INTERNAL_EXCEPTION,
          fatal: !1,
          event: e,
          error: r
        })
    }
    return !1
  }
  listenerCount(e) {
    return this._emitter.listenerCount(e)
  }
  destroy() {
    G.log('destroy'),
      this.trigger(O.DESTROYING, void 0),
      this.detachMedia(),
      this.removeAllListeners(),
      (this._autoLevelCapping = -1),
      (this.url = null),
      this.networkControllers.forEach((t) => t.destroy()),
      (this.networkControllers.length = 0),
      this.coreComponents.forEach((t) => t.destroy()),
      (this.coreComponents.length = 0)
    const e = this.config
    ;(e.xhrSetup = e.fetchSetup = void 0), (this.userConfig = null)
  }
  attachMedia(e) {
    G.log('attachMedia'), (this._media = e), this.trigger(O.MEDIA_ATTACHING, { media: e })
  }
  detachMedia() {
    G.log('detachMedia'), this.trigger(O.MEDIA_DETACHING, void 0), (this._media = null)
  }
  loadSource(e) {
    this.stopLoad()
    const t = this.media,
      r = this.url,
      n = (this.url = wn.buildAbsoluteURL(self.location.href, e, { alwaysNormalize: !0 }))
    G.log(`loadSource:${n}`),
      t &&
        r &&
        (r !== n || this.bufferController.hasSourceTypes()) &&
        (this.detachMedia(), this.attachMedia(t)),
      this.trigger(O.MANIFEST_LOADING, { url: e })
  }
  startLoad(e = -1) {
    G.log(`startLoad(${e})`),
      this.networkControllers.forEach((t) => {
        t.startLoad(e)
      })
  }
  stopLoad() {
    G.log('stopLoad'),
      this.networkControllers.forEach((e) => {
        e.stopLoad()
      })
  }
  swapAudioCodec() {
    G.log('swapAudioCodec'), this.streamController.swapAudioCodec()
  }
  recoverMediaError() {
    G.log('recoverMediaError')
    const e = this._media
    this.detachMedia(), e && this.attachMedia(e)
  }
  removeLevel(e, t = 0) {
    this.levelController.removeLevel(e, t)
  }
  get levels() {
    const e = this.levelController.levels
    return e || []
  }
  get currentLevel() {
    return this.streamController.currentLevel
  }
  set currentLevel(e) {
    G.log(`set currentLevel:${e}`),
      (this.loadLevel = e),
      this.abrController.clearTimer(),
      this.streamController.immediateLevelSwitch()
  }
  get nextLevel() {
    return this.streamController.nextLevel
  }
  set nextLevel(e) {
    G.log(`set nextLevel:${e}`),
      (this.levelController.manualLevel = e),
      this.streamController.nextLevelSwitch()
  }
  get loadLevel() {
    return this.levelController.level
  }
  set loadLevel(e) {
    G.log(`set loadLevel:${e}`), (this.levelController.manualLevel = e)
  }
  get nextLoadLevel() {
    return this.levelController.nextLoadLevel
  }
  set nextLoadLevel(e) {
    this.levelController.nextLoadLevel = e
  }
  get firstLevel() {
    return Math.max(this.levelController.firstLevel, this.minAutoLevel)
  }
  set firstLevel(e) {
    G.log(`set firstLevel:${e}`), (this.levelController.firstLevel = e)
  }
  get startLevel() {
    return this.levelController.startLevel
  }
  set startLevel(e) {
    G.log(`set startLevel:${e}`),
      e !== -1 && (e = Math.max(e, this.minAutoLevel)),
      (this.levelController.startLevel = e)
  }
  get capLevelToPlayerSize() {
    return this.config.capLevelToPlayerSize
  }
  set capLevelToPlayerSize(e) {
    const t = !!e
    t !== this.config.capLevelToPlayerSize &&
      (t
        ? this.capLevelController.startCapping()
        : (this.capLevelController.stopCapping(),
          (this.autoLevelCapping = -1),
          this.streamController.nextLevelSwitch()),
      (this.config.capLevelToPlayerSize = t))
  }
  get autoLevelCapping() {
    return this._autoLevelCapping
  }
  get bandwidthEstimate() {
    const { bwEstimator: e } = this.abrController
    return e ? e.getEstimate() : NaN
  }
  get ttfbEstimate() {
    const { bwEstimator: e } = this.abrController
    return e ? e.getEstimateTTFB() : NaN
  }
  set autoLevelCapping(e) {
    this._autoLevelCapping !== e &&
      (G.log(`set autoLevelCapping:${e}`), (this._autoLevelCapping = e))
  }
  get maxHdcpLevel() {
    return this._maxHdcpLevel
  }
  set maxHdcpLevel(e) {
    Sn.indexOf(e) > -1 && (this._maxHdcpLevel = e)
  }
  get autoLevelEnabled() {
    return this.levelController.manualLevel === -1
  }
  get manualLevel() {
    return this.levelController.manualLevel
  }
  get minAutoLevel() {
    const {
      levels: e,
      config: { minAutoBitrate: t }
    } = this
    if (!e) return 0
    const r = e.length
    for (let n = 0; n < r; n++) if (e[n].maxBitrate >= t) return n
    return 0
  }
  get maxAutoLevel() {
    const { levels: e, autoLevelCapping: t, maxHdcpLevel: r } = this
    let n
    if ((t === -1 && e && e.length ? (n = e.length - 1) : (n = t), r))
      for (let i = n; i--; ) {
        const a = e[i].attrs['HDCP-LEVEL']
        if (a && a <= r) return i
      }
    return n
  }
  get nextAutoLevel() {
    return Math.min(
      Math.max(this.abrController.nextAutoLevel, this.minAutoLevel),
      this.maxAutoLevel
    )
  }
  set nextAutoLevel(e) {
    this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e)
  }
  get playingDate() {
    return this.streamController.currentProgramDateTime
  }
  get mainForwardBufferInfo() {
    return this.streamController.getMainFwdBufferInfo()
  }
  get audioTracks() {
    const e = this.audioTrackController
    return e ? e.audioTracks : []
  }
  get audioTrack() {
    const e = this.audioTrackController
    return e ? e.audioTrack : -1
  }
  set audioTrack(e) {
    const t = this.audioTrackController
    t && (t.audioTrack = e)
  }
  get subtitleTracks() {
    const e = this.subtitleTrackController
    return e ? e.subtitleTracks : []
  }
  get subtitleTrack() {
    const e = this.subtitleTrackController
    return e ? e.subtitleTrack : -1
  }
  get media() {
    return this._media
  }
  set subtitleTrack(e) {
    const t = this.subtitleTrackController
    t && (t.subtitleTrack = e)
  }
  get subtitleDisplay() {
    const e = this.subtitleTrackController
    return e ? e.subtitleDisplay : !1
  }
  set subtitleDisplay(e) {
    const t = this.subtitleTrackController
    t && (t.subtitleDisplay = e)
  }
  get lowLatencyMode() {
    return this.config.lowLatencyMode
  }
  set lowLatencyMode(e) {
    this.config.lowLatencyMode = e
  }
  get liveSyncPosition() {
    return this.latencyController.liveSyncPosition
  }
  get latency() {
    return this.latencyController.latency
  }
  get maxLatency() {
    return this.latencyController.maxLatency
  }
  get targetLatency() {
    return this.latencyController.targetLatency
  }
  get drift() {
    return this.latencyController.drift
  }
  get forceStartLoad() {
    return this.streamController.forceStartLoad
  }
}
mt.defaultConfig = void 0
window.Hls = mt
const Bd = () => {
  const s = ee.useRef(null),
    [e, t] = so.useMessage(),
    [r, n] = ee.useState(0),
    [i, a] = ee.useState('直播'),
    [o, l] = ee.useState(''),
    [u, c] = ee.useState('http://127.0.0.1:8887/live/mylive2/index.m3u8'),
    f = () => {
      c(o), m()
    },
    d = [
      { key: '1', label: '视频直播', children: 'Content of Tab Pane 1' },
      { key: '2', label: '录播', children: 'Content of Tab Pane 2' },
      {
        key: '3',
        label: '自定义播放',
        children: xt(ao.Compact, {
          style: { width: '100%' },
          children: [
            Ae(oo, {
              placeholder: '请输入自定义视频地址',
              defaultValue: '请输入自定义视频地址',
              onChange: (x) => l(x.target.value),
              value: o
            }),
            Ae(zt, { type: 'primary', onClick: f, children: '播放' })
          ]
        })
      }
    ],
    m = () => {
      n(r + 1)
    },
    p = async () => {
      await lu()
    },
    v = (x) => {
      var b
      const T = ((b = d.find((R) => R.key === x)) == null ? void 0 : b.label) || ''
      a(T)
    },
    E = () => {
      e.open({ type: 'error', content: '播放失败,请确定播放地址是否正确或重新加载播放!' })
    }
  return (
    ee.useEffect(() => {
      p()
    }, []),
    xt(uo, {
      title: '工作台',
      source: '您的工作台',
      children: [
        t,
        xt('div', {
          className: 'live-box',
          children: [
            Ae(wt, {
              title: '聊天',
              bordered: !1,
              style: { width: 300 },
              children: Ae('p', { children: 'Card content' })
            }),
            xt('div', {
              className: 'live-content',
              children: [
                Ae(wt, {
                  title: i,
                  bordered: !1,
                  children: Ae('div', {
                    className: 'live-video',
                    children: Ae(
                      au,
                      {
                        ref: s,
                        className: 'live-player',
                        onError: E,
                        url: u,
                        config: {
                          file: {
                            attributes: {
                              poster:
                                'https://gitee.com/jiuxiangyangguang/myimg/raw/master/tree/master/c759ef18204881fd870e0450ddf50b0.jpg1695697934393'
                            },
                            hlsOptions: { autoStartLoad: !0 },
                            hlsVersion: '1.4.12',
                            forceHLS: !0
                          }
                        },
                        controls: !0,
                        playing: !0
                      },
                      r
                    )
                  })
                }),
                Ae(wt, {
                  title: '',
                  bordered: !1,
                  children: Ae(co, { defaultActiveKey: '1', onChange: v, items: d })
                })
              ]
            }),
            xt('div', {
              className: 'live-info',
              children: [
                Ae(wt, {
                  title: '直播数据',
                  bordered: !1,
                  style: { width: 300 },
                  children: Ae('p', { children: 'Card content' })
                }),
                xt(wt, {
                  title: '快捷操作',
                  bordered: !1,
                  style: { width: 300 },
                  children: [
                    Ae(Ro, { options: ['普通', '超清'] }),
                    Ae(zt, {
                      block: !0,
                      type: 'dashed',
                      onClick: m,
                      style: { marginTop: '10px' },
                      children: '重新加载'
                    }),
                    Ae(zt, {
                      block: !0,
                      type: 'dashed',
                      style: { marginTop: '10px' },
                      children: '全屏播放'
                    }),
                    Ae(fo, {
                      title: '关闭直播',
                      description: '确定关闭直播吗?',
                      icon: Ae(lo, { style: { color: 'red' } }),
                      children: Ae(zt, {
                        style: { marginTop: '10px' },
                        block: !0,
                        type: 'dashed',
                        danger: !0,
                        icon: Ae(go, {}),
                        children: '关闭直播'
                      })
                    })
                  ]
                })
              ]
            })
          ]
        })
      ]
    })
  )
}
export { Bd as default }
//# sourceMappingURL=index-d99e18bb.js.map
