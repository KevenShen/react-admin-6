import { A as Ld, r as fP, j as uv, H as hP } from './index-7ec5c925.js'
const F1 = () => [['cartesian']]
F1.props = {}
const z1 = (t = {}) => {
    const e = {
      startAngle: -Math.PI / 2,
      endAngle: (Math.PI * 3) / 2,
      innerRadius: 0,
      outerRadius: 1
    }
    return Object.assign(Object.assign({}, e), t)
  },
  bs = (t) => {
    const { startAngle: e, endAngle: n, innerRadius: r, outerRadius: i } = z1(t)
    return [['translate', 0, 0.5], ['reflect.y'], ['translate', 0, -0.5], ['polar', e, n, r, i]]
  }
bs.props = {}
const Nd = () => [['transpose'], ['translate', 0.5, 0.5], ['reflect.x'], ['translate', -0.5, -0.5]]
Nd.props = { transform: !0 }
const dP = (t = {}) => {
    const e = {
      startAngle: -Math.PI / 2,
      endAngle: (Math.PI * 3) / 2,
      innerRadius: 0,
      outerRadius: 1
    }
    return Object.assign(Object.assign({}, e), t)
  },
  G1 = (t) => {
    const { startAngle: e, endAngle: n, innerRadius: r, outerRadius: i } = dP(t)
    return [...Nd(), ...bs({ startAngle: e, endAngle: n, innerRadius: r, outerRadius: i })]
  }
G1.props = {}
const W1 = (t = {}) => {
    const e = {
      startAngle: -Math.PI / 2,
      endAngle: (Math.PI * 3) / 2,
      innerRadius: 0,
      outerRadius: 1
    }
    return Object.assign(Object.assign({}, e), t)
  },
  Rd = (t) => {
    const { startAngle: e, endAngle: n, innerRadius: r, outerRadius: i } = W1(t)
    return [
      ['transpose'],
      ['translate', 0.5, 0.5],
      ['reflect'],
      ['translate', -0.5, -0.5],
      ...bs({ startAngle: e, endAngle: n, innerRadius: r, outerRadius: i })
    ]
  }
Rd.props = {}
const Id = () => [['parallel', 0, 1, 0, 1]]
Id.props = {}
const Y1 = ({
  focusX: t = 0,
  focusY: e = 0,
  distortionX: n = 2,
  distortionY: r = 2,
  visual: i = !1
}) => [['fisheye', t, e, n, r, i]]
Y1.props = { transform: !0 }
const H1 = (t) => {
  const {
    startAngle: e = -Math.PI / 2,
    endAngle: n = (Math.PI * 3) / 2,
    innerRadius: r = 0,
    outerRadius: i = 1
  } = t
  return [...Id(), ...bs({ startAngle: e, endAngle: n, innerRadius: r, outerRadius: i })]
}
H1.props = {}
const V1 =
  ({ value: t }) =>
  (e) =>
    e.map(() => t)
V1.props = {}
const X1 =
  ({ value: t }) =>
  (e) =>
    e.map(t)
X1.props = {}
const U1 =
  ({ value: t }) =>
  (e) =>
    e.map((n) => n[t])
U1.props = {}
const q1 =
  ({ value: t }) =>
  () =>
    t
q1.props = {}
var pP = function (t) {
  return t !== null && typeof t != 'function' && isFinite(t.length)
}
const Uf = pP,
  mn = function (t) {
    return typeof t == 'function'
  }
var vP = function (t) {
  return t == null
}
const nt = vP
var gP = {}.toString,
  yP = function (t, e) {
    return gP.call(t) === '[object ' + e + ']'
  }
const xs = yP,
  bn = function (t) {
    return Array.isArray ? Array.isArray(t) : xs(t, 'Array')
  },
  Ei = function (t) {
    var e = typeof t
    return (t !== null && e === 'object') || e === 'function'
  }
function mP(t, e) {
  if (t) {
    var n
    if (bn(t)) for (var r = 0, i = t.length; r < i && ((n = e(t[r], r)), n !== !1); r++);
    else if (Ei(t)) {
      for (var a in t) if (t.hasOwnProperty(a) && ((n = e(t[a], a)), n === !1)) break
    }
  }
}
var bP = function (t) {
  return typeof t == 'object' && t !== null
}
const qf = bP
var xP = function (t) {
  if (!qf(t) || !xs(t, 'Object')) return !1
  if (Object.getPrototypeOf(t) === null) return !0
  for (var e = t; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e)
  return Object.getPrototypeOf(t) === e
}
const ki = xP,
  qc = function (t) {
    if (bn(t))
      return t.reduce(function (e, n) {
        return Math.max(e, n)
      }, t[0])
  },
  Kc = function (t) {
    if (bn(t))
      return t.reduce(function (e, n) {
        return Math.min(e, n)
      }, t[0])
  }
var wP = function (t, e, n) {
  if (!bn(t) && !ki(t)) return t
  var r = n
  return (
    mP(t, function (i, a) {
      r = e(r, i, a)
    }),
    r
  )
}
const OP = wP,
  ne = function (t) {
    return xs(t, 'String')
  }
function SP(t) {
  if (Uf(t)) {
    var e = t
    return e[e.length - 1]
  }
}
var _P = function (t, e, n) {
  return t < e ? e : t > n ? n : t
}
const se = _P
var MP = function (t) {
  return xs(t, 'Number')
}
const ve = MP
var EP = 1e-5
function No(t, e, n) {
  return n === void 0 && (n = EP), Math.abs(t - e) < n
}
const TP = function (t, e) {
    if (bn(t)) {
      for (var n, r = -1 / 0, i = 0; i < t.length; i++) {
        var a = t[i],
          o = mn(e) ? e(a) : a[e]
        o > r && ((n = a), (r = o))
      }
      return n
    }
  },
  PP = function (t, e) {
    if (bn(t)) {
      for (var n, r = 1 / 0, i = 0; i < t.length; i++) {
        var a = t[i],
          o = mn(e) ? e(a) : a[e]
        o < r && ((n = a), (r = o))
      }
      return n
    }
  }
var AP = function (t, e) {
  return ((t % e) + e) % e
}
const K1 = AP,
  Z1 = function (t) {
    return nt(t) ? '' : t.toString()
  }
var kP = function (t) {
  var e = Z1(t)
  return e.charAt(0).toLowerCase() + e.substring(1)
}
const Q1 = kP
function CP(t, e) {
  return !t || !e
    ? t
    : t.replace(/\\?\{([^{}]+)\}/g, function (n, r) {
        return n.charAt(0) === '\\' ? n.slice(1) : e[r] === void 0 ? '' : e[r]
      })
}
var LP = function (t) {
  var e = Z1(t)
  return e.charAt(0).toUpperCase() + e.substring(1)
}
const ni = LP
var NP = function (t) {
  return xs(t, 'Boolean')
}
const fv = NP
var RP = function (t) {
  return t === void 0
}
const Qt = RP
var Kf = function (t) {
  if (typeof t != 'object' || t === null) return t
  var e
  if (bn(t)) {
    e = []
    for (var n = 0, r = t.length; n < r; n++)
      typeof t[n] == 'object' && t[n] != null ? (e[n] = Kf(t[n])) : (e[n] = t[n])
  } else {
    e = {}
    for (var i in t) typeof t[i] == 'object' && t[i] != null ? (e[i] = Kf(t[i])) : (e[i] = t[i])
  }
  return e
}
const jd = Kf
function J1(t, e, n) {
  var r
  return function () {
    var i = this,
      a = arguments,
      o = function () {
        ;(r = null), n || t.apply(i, a)
      },
      s = n && !r
    clearTimeout(r), (r = setTimeout(o, e)), s && t.apply(i, a)
  }
}
function Dd(t) {
  var e,
    n,
    r,
    i = t || 1
  function a(s, c) {
    ++e > i && ((r = n), o(1), ++e), (n[s] = c)
  }
  function o(s) {
    ;(e = 0), (n = Object.create(null)), s || (r = Object.create(null))
  }
  return (
    o(),
    {
      clear: o,
      has: function (s) {
        return n[s] !== void 0 || r[s] !== void 0
      },
      get: function (s) {
        var c = n[s]
        if (c !== void 0) return c
        if ((c = r[s]) !== void 0) return a(s, c), c
      },
      set: function (s, c) {
        n[s] !== void 0 ? (n[s] = c) : a(s, c)
      }
    }
  )
}
const IP = function (t, e, n) {
  if ((n === void 0 && (n = 128), !mn(t))) throw new TypeError('Expected a function')
  var r = function () {
    for (var i = [], a = 0; a < arguments.length; a++) i[a] = arguments[a]
    var o = e ? e.apply(this, i) : i[0],
      s = r.cache
    if (s.has(o)) return s.get(o)
    var c = t.apply(this, i)
    return s.set(o, c), c
  }
  return (r.cache = Dd(n)), r
}
var jP = 5
function DP(t, e) {
  if (Object.hasOwn) return Object.hasOwn(t, e)
  if (t == null) throw new TypeError('Cannot convert undefined or null to object')
  return Object.prototype.hasOwnProperty.call(Object(t), e)
}
function tb(t, e, n, r) {
  ;(n = n || 0), (r = r || jP)
  for (var i in e)
    if (DP(e, i)) {
      var a = e[i]
      a !== null && ki(a)
        ? (ki(t[i]) || (t[i] = {}), n < r ? tb(t[i], a, n + 1, r) : (t[i] = e[i]))
        : bn(a)
        ? ((t[i] = []), (t[i] = t[i].concat(a)))
        : a !== void 0 && (t[i] = a)
    }
}
var $P = function (t) {
  for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n]
  for (var r = 0; r < e.length; r += 1) tb(t, e[r])
  return t
}
const X = $P
var Zf = function (t, e) {
  if (t === e) return !0
  if (!t || !e || ne(t) || ne(e)) return !1
  if (Uf(t) || Uf(e)) {
    if (t.length !== e.length) return !1
    for (var n = !0, r = 0; r < t.length && ((n = Zf(t[r], e[r])), !!n); r++);
    return n
  }
  if (qf(t) || qf(e)) {
    var i = Object.keys(t),
      a = Object.keys(e)
    if (i.length !== a.length) return !1
    for (var n = !0, r = 0; r < i.length && ((n = Zf(t[i[r]], e[i[r]])), !!n); r++);
    return n
  }
  return !1
}
const eb = Zf,
  nb = function (t, e, n) {
    for (var r = 0, i = ne(e) ? e.split('.') : e; t && r < i.length; ) t = t[i[r++]]
    return t === void 0 || r < i.length ? n : t
  },
  BP = function (t, e, n) {
    var r = t,
      i = ne(e) ? e.split('.') : e
    return (
      i.forEach(function (a, o) {
        o < i.length - 1 ? (Ei(r[a]) || (r[a] = ve(i[o + 1]) ? [] : {}), (r = r[a])) : (r[a] = n)
      }),
      t
    )
  },
  rb = function (t, e) {
    return OP(
      t,
      function (n, r, i) {
        return e.includes(i) || (n[i] = r), n
      },
      {}
    )
  },
  Ci = function (t, e, n) {
    var r,
      i,
      a,
      o,
      s = 0
    n || (n = {})
    var c = function () {
        ;(s = n.leading === !1 ? 0 : Date.now()),
          (r = null),
          (o = t.apply(i, a)),
          r || (i = a = null)
      },
      l = function () {
        var u = Date.now()
        !s && n.leading === !1 && (s = u)
        var f = e - (u - s)
        return (
          (i = this),
          (a = arguments),
          f <= 0 || f > e
            ? (r && (clearTimeout(r), (r = null)),
              (s = u),
              (o = t.apply(i, a)),
              r || (i = a = null))
            : !r && n.trailing !== !1 && (r = setTimeout(c, f)),
          o
        )
      }
    return (
      (l.cancel = function () {
        clearTimeout(r), (s = 0), (r = i = a = null)
      }),
      l
    )
  },
  Gu = function () {}
var Xt = 1e-6,
  fe = typeof Float32Array < 'u' ? Float32Array : Array
Math.hypot ||
  (Math.hypot = function () {
    for (var t = 0, e = arguments.length; e--; ) t += arguments[e] * arguments[e]
    return Math.sqrt(t)
  })
function Ua() {
  var t = new fe(9)
  return (
    fe != Float32Array && ((t[1] = 0), (t[2] = 0), (t[3] = 0), (t[5] = 0), (t[6] = 0), (t[7] = 0)),
    (t[0] = 1),
    (t[4] = 1),
    (t[8] = 1),
    t
  )
}
function FP(t, e) {
  return (
    (t[0] = e[0]),
    (t[1] = e[1]),
    (t[2] = e[2]),
    (t[3] = e[4]),
    (t[4] = e[5]),
    (t[5] = e[6]),
    (t[6] = e[8]),
    (t[7] = e[9]),
    (t[8] = e[10]),
    t
  )
}
function zP(t) {
  var e = new fe(9)
  return (
    (e[0] = t[0]),
    (e[1] = t[1]),
    (e[2] = t[2]),
    (e[3] = t[3]),
    (e[4] = t[4]),
    (e[5] = t[5]),
    (e[6] = t[6]),
    (e[7] = t[7]),
    (e[8] = t[8]),
    e
  )
}
function GP(t, e, n, r, i, a, o, s, c) {
  var l = new fe(9)
  return (
    (l[0] = t),
    (l[1] = e),
    (l[2] = n),
    (l[3] = r),
    (l[4] = i),
    (l[5] = a),
    (l[6] = o),
    (l[7] = s),
    (l[8] = c),
    l
  )
}
function WP(t, e) {
  var n = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = e[4],
    s = e[5],
    c = e[6],
    l = e[7],
    u = e[8],
    f = u * o - s * l,
    h = -u * a + s * c,
    d = l * a - o * c,
    p = n * f + r * h + i * d
  return p
    ? ((p = 1 / p),
      (t[0] = f * p),
      (t[1] = (-u * r + i * l) * p),
      (t[2] = (s * r - i * o) * p),
      (t[3] = h * p),
      (t[4] = (u * n - i * c) * p),
      (t[5] = (-s * n + i * a) * p),
      (t[6] = d * p),
      (t[7] = (-l * n + r * c) * p),
      (t[8] = (o * n - r * a) * p),
      t)
    : null
}
function YP(t, e, n) {
  var r = e[0],
    i = e[1],
    a = e[2],
    o = e[3],
    s = e[4],
    c = e[5],
    l = e[6],
    u = e[7],
    f = e[8],
    h = n[0],
    d = n[1],
    p = n[2],
    v = n[3],
    g = n[4],
    y = n[5],
    m = n[6],
    b = n[7],
    x = n[8]
  return (
    (t[0] = h * r + d * o + p * l),
    (t[1] = h * i + d * s + p * u),
    (t[2] = h * a + d * c + p * f),
    (t[3] = v * r + g * o + y * l),
    (t[4] = v * i + g * s + y * u),
    (t[5] = v * a + g * c + y * f),
    (t[6] = m * r + b * o + x * l),
    (t[7] = m * i + b * s + x * u),
    (t[8] = m * a + b * c + x * f),
    t
  )
}
function HP(t, e) {
  return (
    (t[0] = 1),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = 1),
    (t[5] = 0),
    (t[6] = e[0]),
    (t[7] = e[1]),
    (t[8] = 1),
    t
  )
}
function VP(t, e) {
  var n = Math.sin(e),
    r = Math.cos(e)
  return (
    (t[0] = r),
    (t[1] = n),
    (t[2] = 0),
    (t[3] = -n),
    (t[4] = r),
    (t[5] = 0),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = 1),
    t
  )
}
function XP(t, e) {
  return (
    (t[0] = e[0]),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = e[1]),
    (t[5] = 0),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = 1),
    t
  )
}
var UP = YP
function Nt() {
  var t = new fe(16)
  return (
    fe != Float32Array &&
      ((t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = 0),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = 0),
      (t[9] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0)),
    (t[0] = 1),
    (t[5] = 1),
    (t[10] = 1),
    (t[15] = 1),
    t
  )
}
function $d(t) {
  var e = new fe(16)
  return (
    (e[0] = t[0]),
    (e[1] = t[1]),
    (e[2] = t[2]),
    (e[3] = t[3]),
    (e[4] = t[4]),
    (e[5] = t[5]),
    (e[6] = t[6]),
    (e[7] = t[7]),
    (e[8] = t[8]),
    (e[9] = t[9]),
    (e[10] = t[10]),
    (e[11] = t[11]),
    (e[12] = t[12]),
    (e[13] = t[13]),
    (e[14] = t[14]),
    (e[15] = t[15]),
    e
  )
}
function Li(t, e) {
  return (
    (t[0] = e[0]),
    (t[1] = e[1]),
    (t[2] = e[2]),
    (t[3] = e[3]),
    (t[4] = e[4]),
    (t[5] = e[5]),
    (t[6] = e[6]),
    (t[7] = e[7]),
    (t[8] = e[8]),
    (t[9] = e[9]),
    (t[10] = e[10]),
    (t[11] = e[11]),
    (t[12] = e[12]),
    (t[13] = e[13]),
    (t[14] = e[14]),
    (t[15] = e[15]),
    t
  )
}
function qP(t, e, n, r, i, a, o, s, c, l, u, f, h, d, p, v) {
  var g = new fe(16)
  return (
    (g[0] = t),
    (g[1] = e),
    (g[2] = n),
    (g[3] = r),
    (g[4] = i),
    (g[5] = a),
    (g[6] = o),
    (g[7] = s),
    (g[8] = c),
    (g[9] = l),
    (g[10] = u),
    (g[11] = f),
    (g[12] = h),
    (g[13] = d),
    (g[14] = p),
    (g[15] = v),
    g
  )
}
function Qf(t, e, n, r, i, a, o, s, c, l, u, f, h, d, p, v, g) {
  return (
    (t[0] = e),
    (t[1] = n),
    (t[2] = r),
    (t[3] = i),
    (t[4] = a),
    (t[5] = o),
    (t[6] = s),
    (t[7] = c),
    (t[8] = l),
    (t[9] = u),
    (t[10] = f),
    (t[11] = h),
    (t[12] = d),
    (t[13] = p),
    (t[14] = v),
    (t[15] = g),
    t
  )
}
function ws(t) {
  return (
    (t[0] = 1),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = 0),
    (t[5] = 1),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = 0),
    (t[9] = 0),
    (t[10] = 1),
    (t[11] = 0),
    (t[12] = 0),
    (t[13] = 0),
    (t[14] = 0),
    (t[15] = 1),
    t
  )
}
function ib(t, e) {
  if (t === e) {
    var n = e[1],
      r = e[2],
      i = e[3],
      a = e[6],
      o = e[7],
      s = e[11]
    ;(t[1] = e[4]),
      (t[2] = e[8]),
      (t[3] = e[12]),
      (t[4] = n),
      (t[6] = e[9]),
      (t[7] = e[13]),
      (t[8] = r),
      (t[9] = a),
      (t[11] = e[14]),
      (t[12] = i),
      (t[13] = o),
      (t[14] = s)
  } else
    (t[0] = e[0]),
      (t[1] = e[4]),
      (t[2] = e[8]),
      (t[3] = e[12]),
      (t[4] = e[1]),
      (t[5] = e[5]),
      (t[6] = e[9]),
      (t[7] = e[13]),
      (t[8] = e[2]),
      (t[9] = e[6]),
      (t[10] = e[10]),
      (t[11] = e[14]),
      (t[12] = e[3]),
      (t[13] = e[7]),
      (t[14] = e[11]),
      (t[15] = e[15])
  return t
}
function zn(t, e) {
  var n = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = e[4],
    s = e[5],
    c = e[6],
    l = e[7],
    u = e[8],
    f = e[9],
    h = e[10],
    d = e[11],
    p = e[12],
    v = e[13],
    g = e[14],
    y = e[15],
    m = n * s - r * o,
    b = n * c - i * o,
    x = n * l - a * o,
    w = r * c - i * s,
    O = r * l - a * s,
    S = i * l - a * c,
    _ = u * v - f * p,
    M = u * g - h * p,
    E = u * y - d * p,
    T = f * g - h * v,
    C = f * y - d * v,
    A = h * y - d * g,
    P = m * A - b * C + x * T + w * E - O * M + S * _
  return P
    ? ((P = 1 / P),
      (t[0] = (s * A - c * C + l * T) * P),
      (t[1] = (i * C - r * A - a * T) * P),
      (t[2] = (v * S - g * O + y * w) * P),
      (t[3] = (h * O - f * S - d * w) * P),
      (t[4] = (c * E - o * A - l * M) * P),
      (t[5] = (n * A - i * E + a * M) * P),
      (t[6] = (g * x - p * S - y * b) * P),
      (t[7] = (u * S - h * x + d * b) * P),
      (t[8] = (o * C - s * E + l * _) * P),
      (t[9] = (r * E - n * C - a * _) * P),
      (t[10] = (p * O - v * x + y * m) * P),
      (t[11] = (f * x - u * O - d * m) * P),
      (t[12] = (s * M - o * T - c * _) * P),
      (t[13] = (n * T - r * M + i * _) * P),
      (t[14] = (v * b - p * w - g * m) * P),
      (t[15] = (u * w - f * b + h * m) * P),
      t)
    : null
}
function KP(t, e) {
  var n = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = e[4],
    s = e[5],
    c = e[6],
    l = e[7],
    u = e[8],
    f = e[9],
    h = e[10],
    d = e[11],
    p = e[12],
    v = e[13],
    g = e[14],
    y = e[15]
  return (
    (t[0] = s * (h * y - d * g) - f * (c * y - l * g) + v * (c * d - l * h)),
    (t[1] = -(r * (h * y - d * g) - f * (i * y - a * g) + v * (i * d - a * h))),
    (t[2] = r * (c * y - l * g) - s * (i * y - a * g) + v * (i * l - a * c)),
    (t[3] = -(r * (c * d - l * h) - s * (i * d - a * h) + f * (i * l - a * c))),
    (t[4] = -(o * (h * y - d * g) - u * (c * y - l * g) + p * (c * d - l * h))),
    (t[5] = n * (h * y - d * g) - u * (i * y - a * g) + p * (i * d - a * h)),
    (t[6] = -(n * (c * y - l * g) - o * (i * y - a * g) + p * (i * l - a * c))),
    (t[7] = n * (c * d - l * h) - o * (i * d - a * h) + u * (i * l - a * c)),
    (t[8] = o * (f * y - d * v) - u * (s * y - l * v) + p * (s * d - l * f)),
    (t[9] = -(n * (f * y - d * v) - u * (r * y - a * v) + p * (r * d - a * f))),
    (t[10] = n * (s * y - l * v) - o * (r * y - a * v) + p * (r * l - a * s)),
    (t[11] = -(n * (s * d - l * f) - o * (r * d - a * f) + u * (r * l - a * s))),
    (t[12] = -(o * (f * g - h * v) - u * (s * g - c * v) + p * (s * h - c * f))),
    (t[13] = n * (f * g - h * v) - u * (r * g - i * v) + p * (r * h - i * f)),
    (t[14] = -(n * (s * g - c * v) - o * (r * g - i * v) + p * (r * c - i * s))),
    (t[15] = n * (s * h - c * f) - o * (r * h - i * f) + u * (r * c - i * s)),
    t
  )
}
function ab(t) {
  var e = t[0],
    n = t[1],
    r = t[2],
    i = t[3],
    a = t[4],
    o = t[5],
    s = t[6],
    c = t[7],
    l = t[8],
    u = t[9],
    f = t[10],
    h = t[11],
    d = t[12],
    p = t[13],
    v = t[14],
    g = t[15],
    y = e * o - n * a,
    m = e * s - r * a,
    b = e * c - i * a,
    x = n * s - r * o,
    w = n * c - i * o,
    O = r * c - i * s,
    S = l * p - u * d,
    _ = l * v - f * d,
    M = l * g - h * d,
    E = u * v - f * p,
    T = u * g - h * p,
    C = f * g - h * v
  return y * C - m * T + b * E + x * M - w * _ + O * S
}
function Re(t, e, n) {
  var r = e[0],
    i = e[1],
    a = e[2],
    o = e[3],
    s = e[4],
    c = e[5],
    l = e[6],
    u = e[7],
    f = e[8],
    h = e[9],
    d = e[10],
    p = e[11],
    v = e[12],
    g = e[13],
    y = e[14],
    m = e[15],
    b = n[0],
    x = n[1],
    w = n[2],
    O = n[3]
  return (
    (t[0] = b * r + x * s + w * f + O * v),
    (t[1] = b * i + x * c + w * h + O * g),
    (t[2] = b * a + x * l + w * d + O * y),
    (t[3] = b * o + x * u + w * p + O * m),
    (b = n[4]),
    (x = n[5]),
    (w = n[6]),
    (O = n[7]),
    (t[4] = b * r + x * s + w * f + O * v),
    (t[5] = b * i + x * c + w * h + O * g),
    (t[6] = b * a + x * l + w * d + O * y),
    (t[7] = b * o + x * u + w * p + O * m),
    (b = n[8]),
    (x = n[9]),
    (w = n[10]),
    (O = n[11]),
    (t[8] = b * r + x * s + w * f + O * v),
    (t[9] = b * i + x * c + w * h + O * g),
    (t[10] = b * a + x * l + w * d + O * y),
    (t[11] = b * o + x * u + w * p + O * m),
    (b = n[12]),
    (x = n[13]),
    (w = n[14]),
    (O = n[15]),
    (t[12] = b * r + x * s + w * f + O * v),
    (t[13] = b * i + x * c + w * h + O * g),
    (t[14] = b * a + x * l + w * d + O * y),
    (t[15] = b * o + x * u + w * p + O * m),
    t
  )
}
function Gr(t, e, n) {
  var r = n[0],
    i = n[1],
    a = n[2],
    o,
    s,
    c,
    l,
    u,
    f,
    h,
    d,
    p,
    v,
    g,
    y
  return (
    e === t
      ? ((t[12] = e[0] * r + e[4] * i + e[8] * a + e[12]),
        (t[13] = e[1] * r + e[5] * i + e[9] * a + e[13]),
        (t[14] = e[2] * r + e[6] * i + e[10] * a + e[14]),
        (t[15] = e[3] * r + e[7] * i + e[11] * a + e[15]))
      : ((o = e[0]),
        (s = e[1]),
        (c = e[2]),
        (l = e[3]),
        (u = e[4]),
        (f = e[5]),
        (h = e[6]),
        (d = e[7]),
        (p = e[8]),
        (v = e[9]),
        (g = e[10]),
        (y = e[11]),
        (t[0] = o),
        (t[1] = s),
        (t[2] = c),
        (t[3] = l),
        (t[4] = u),
        (t[5] = f),
        (t[6] = h),
        (t[7] = d),
        (t[8] = p),
        (t[9] = v),
        (t[10] = g),
        (t[11] = y),
        (t[12] = o * r + u * i + p * a + e[12]),
        (t[13] = s * r + f * i + v * a + e[13]),
        (t[14] = c * r + h * i + g * a + e[14]),
        (t[15] = l * r + d * i + y * a + e[15])),
    t
  )
}
function Zc(t, e, n) {
  var r = n[0],
    i = n[1],
    a = n[2]
  return (
    (t[0] = e[0] * r),
    (t[1] = e[1] * r),
    (t[2] = e[2] * r),
    (t[3] = e[3] * r),
    (t[4] = e[4] * i),
    (t[5] = e[5] * i),
    (t[6] = e[6] * i),
    (t[7] = e[7] * i),
    (t[8] = e[8] * a),
    (t[9] = e[9] * a),
    (t[10] = e[10] * a),
    (t[11] = e[11] * a),
    (t[12] = e[12]),
    (t[13] = e[13]),
    (t[14] = e[14]),
    (t[15] = e[15]),
    t
  )
}
function ZP(t, e, n, r) {
  var i = r[0],
    a = r[1],
    o = r[2],
    s = Math.hypot(i, a, o),
    c,
    l,
    u,
    f,
    h,
    d,
    p,
    v,
    g,
    y,
    m,
    b,
    x,
    w,
    O,
    S,
    _,
    M,
    E,
    T,
    C,
    A,
    P,
    k
  return s < Xt
    ? null
    : ((s = 1 / s),
      (i *= s),
      (a *= s),
      (o *= s),
      (c = Math.sin(n)),
      (l = Math.cos(n)),
      (u = 1 - l),
      (f = e[0]),
      (h = e[1]),
      (d = e[2]),
      (p = e[3]),
      (v = e[4]),
      (g = e[5]),
      (y = e[6]),
      (m = e[7]),
      (b = e[8]),
      (x = e[9]),
      (w = e[10]),
      (O = e[11]),
      (S = i * i * u + l),
      (_ = a * i * u + o * c),
      (M = o * i * u - a * c),
      (E = i * a * u - o * c),
      (T = a * a * u + l),
      (C = o * a * u + i * c),
      (A = i * o * u + a * c),
      (P = a * o * u - i * c),
      (k = o * o * u + l),
      (t[0] = f * S + v * _ + b * M),
      (t[1] = h * S + g * _ + x * M),
      (t[2] = d * S + y * _ + w * M),
      (t[3] = p * S + m * _ + O * M),
      (t[4] = f * E + v * T + b * C),
      (t[5] = h * E + g * T + x * C),
      (t[6] = d * E + y * T + w * C),
      (t[7] = p * E + m * T + O * C),
      (t[8] = f * A + v * P + b * k),
      (t[9] = h * A + g * P + x * k),
      (t[10] = d * A + y * P + w * k),
      (t[11] = p * A + m * P + O * k),
      e !== t && ((t[12] = e[12]), (t[13] = e[13]), (t[14] = e[14]), (t[15] = e[15])),
      t)
}
function ob(t, e, n) {
  var r = Math.sin(n),
    i = Math.cos(n),
    a = e[4],
    o = e[5],
    s = e[6],
    c = e[7],
    l = e[8],
    u = e[9],
    f = e[10],
    h = e[11]
  return (
    e !== t &&
      ((t[0] = e[0]),
      (t[1] = e[1]),
      (t[2] = e[2]),
      (t[3] = e[3]),
      (t[12] = e[12]),
      (t[13] = e[13]),
      (t[14] = e[14]),
      (t[15] = e[15])),
    (t[4] = a * i + l * r),
    (t[5] = o * i + u * r),
    (t[6] = s * i + f * r),
    (t[7] = c * i + h * r),
    (t[8] = l * i - a * r),
    (t[9] = u * i - o * r),
    (t[10] = f * i - s * r),
    (t[11] = h * i - c * r),
    t
  )
}
function sb(t, e, n) {
  var r = Math.sin(n),
    i = Math.cos(n),
    a = e[0],
    o = e[1],
    s = e[2],
    c = e[3],
    l = e[8],
    u = e[9],
    f = e[10],
    h = e[11]
  return (
    e !== t &&
      ((t[4] = e[4]),
      (t[5] = e[5]),
      (t[6] = e[6]),
      (t[7] = e[7]),
      (t[12] = e[12]),
      (t[13] = e[13]),
      (t[14] = e[14]),
      (t[15] = e[15])),
    (t[0] = a * i - l * r),
    (t[1] = o * i - u * r),
    (t[2] = s * i - f * r),
    (t[3] = c * i - h * r),
    (t[8] = a * r + l * i),
    (t[9] = o * r + u * i),
    (t[10] = s * r + f * i),
    (t[11] = c * r + h * i),
    t
  )
}
function QP(t, e, n) {
  var r = Math.sin(n),
    i = Math.cos(n),
    a = e[0],
    o = e[1],
    s = e[2],
    c = e[3],
    l = e[4],
    u = e[5],
    f = e[6],
    h = e[7]
  return (
    e !== t &&
      ((t[8] = e[8]),
      (t[9] = e[9]),
      (t[10] = e[10]),
      (t[11] = e[11]),
      (t[12] = e[12]),
      (t[13] = e[13]),
      (t[14] = e[14]),
      (t[15] = e[15])),
    (t[0] = a * i + l * r),
    (t[1] = o * i + u * r),
    (t[2] = s * i + f * r),
    (t[3] = c * i + h * r),
    (t[4] = l * i - a * r),
    (t[5] = u * i - o * r),
    (t[6] = f * i - s * r),
    (t[7] = h * i - c * r),
    t
  )
}
function Bd(t, e) {
  return (
    (t[0] = 1),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = 0),
    (t[5] = 1),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = 0),
    (t[9] = 0),
    (t[10] = 1),
    (t[11] = 0),
    (t[12] = e[0]),
    (t[13] = e[1]),
    (t[14] = e[2]),
    (t[15] = 1),
    t
  )
}
function Fd(t, e) {
  return (
    (t[0] = e[0]),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = 0),
    (t[5] = e[1]),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = 0),
    (t[9] = 0),
    (t[10] = e[2]),
    (t[11] = 0),
    (t[12] = 0),
    (t[13] = 0),
    (t[14] = 0),
    (t[15] = 1),
    t
  )
}
function JP(t, e, n) {
  var r = n[0],
    i = n[1],
    a = n[2],
    o = Math.hypot(r, i, a),
    s,
    c,
    l
  return o < Xt
    ? null
    : ((o = 1 / o),
      (r *= o),
      (i *= o),
      (a *= o),
      (s = Math.sin(e)),
      (c = Math.cos(e)),
      (l = 1 - c),
      (t[0] = r * r * l + c),
      (t[1] = i * r * l + a * s),
      (t[2] = a * r * l - i * s),
      (t[3] = 0),
      (t[4] = r * i * l - a * s),
      (t[5] = i * i * l + c),
      (t[6] = a * i * l + r * s),
      (t[7] = 0),
      (t[8] = r * a * l + i * s),
      (t[9] = i * a * l - r * s),
      (t[10] = a * a * l + c),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      t)
}
function tA(t, e) {
  var n = Math.sin(e),
    r = Math.cos(e)
  return (
    (t[0] = 1),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = 0),
    (t[5] = r),
    (t[6] = n),
    (t[7] = 0),
    (t[8] = 0),
    (t[9] = -n),
    (t[10] = r),
    (t[11] = 0),
    (t[12] = 0),
    (t[13] = 0),
    (t[14] = 0),
    (t[15] = 1),
    t
  )
}
function eA(t, e) {
  var n = Math.sin(e),
    r = Math.cos(e)
  return (
    (t[0] = r),
    (t[1] = 0),
    (t[2] = -n),
    (t[3] = 0),
    (t[4] = 0),
    (t[5] = 1),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = n),
    (t[9] = 0),
    (t[10] = r),
    (t[11] = 0),
    (t[12] = 0),
    (t[13] = 0),
    (t[14] = 0),
    (t[15] = 1),
    t
  )
}
function nA(t, e) {
  var n = Math.sin(e),
    r = Math.cos(e)
  return (
    (t[0] = r),
    (t[1] = n),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = -n),
    (t[5] = r),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = 0),
    (t[9] = 0),
    (t[10] = 1),
    (t[11] = 0),
    (t[12] = 0),
    (t[13] = 0),
    (t[14] = 0),
    (t[15] = 1),
    t
  )
}
function cb(t, e, n) {
  var r = e[0],
    i = e[1],
    a = e[2],
    o = e[3],
    s = r + r,
    c = i + i,
    l = a + a,
    u = r * s,
    f = r * c,
    h = r * l,
    d = i * c,
    p = i * l,
    v = a * l,
    g = o * s,
    y = o * c,
    m = o * l
  return (
    (t[0] = 1 - (d + v)),
    (t[1] = f + m),
    (t[2] = h - y),
    (t[3] = 0),
    (t[4] = f - m),
    (t[5] = 1 - (u + v)),
    (t[6] = p + g),
    (t[7] = 0),
    (t[8] = h + y),
    (t[9] = p - g),
    (t[10] = 1 - (u + d)),
    (t[11] = 0),
    (t[12] = n[0]),
    (t[13] = n[1]),
    (t[14] = n[2]),
    (t[15] = 1),
    t
  )
}
function rA(t, e) {
  var n = new fe(3),
    r = -e[0],
    i = -e[1],
    a = -e[2],
    o = e[3],
    s = e[4],
    c = e[5],
    l = e[6],
    u = e[7],
    f = r * r + i * i + a * a + o * o
  return (
    f > 0
      ? ((n[0] = ((s * o + u * r + c * a - l * i) * 2) / f),
        (n[1] = ((c * o + u * i + l * r - s * a) * 2) / f),
        (n[2] = ((l * o + u * a + s * i - c * r) * 2) / f))
      : ((n[0] = (s * o + u * r + c * a - l * i) * 2),
        (n[1] = (c * o + u * i + l * r - s * a) * 2),
        (n[2] = (l * o + u * a + s * i - c * r) * 2)),
    cb(t, e, n),
    t
  )
}
function Qc(t, e) {
  return (t[0] = e[12]), (t[1] = e[13]), (t[2] = e[14]), t
}
function Ma(t, e) {
  var n = e[0],
    r = e[1],
    i = e[2],
    a = e[4],
    o = e[5],
    s = e[6],
    c = e[8],
    l = e[9],
    u = e[10]
  return (t[0] = Math.hypot(n, r, i)), (t[1] = Math.hypot(a, o, s)), (t[2] = Math.hypot(c, l, u)), t
}
function Jc(t, e) {
  var n = new fe(3)
  Ma(n, e)
  var r = 1 / n[0],
    i = 1 / n[1],
    a = 1 / n[2],
    o = e[0] * r,
    s = e[1] * i,
    c = e[2] * a,
    l = e[4] * r,
    u = e[5] * i,
    f = e[6] * a,
    h = e[8] * r,
    d = e[9] * i,
    p = e[10] * a,
    v = o + u + p,
    g = 0
  return (
    v > 0
      ? ((g = Math.sqrt(v + 1) * 2),
        (t[3] = 0.25 * g),
        (t[0] = (f - d) / g),
        (t[1] = (h - c) / g),
        (t[2] = (s - l) / g))
      : o > u && o > p
      ? ((g = Math.sqrt(1 + o - u - p) * 2),
        (t[3] = (f - d) / g),
        (t[0] = 0.25 * g),
        (t[1] = (s + l) / g),
        (t[2] = (h + c) / g))
      : u > p
      ? ((g = Math.sqrt(1 + u - o - p) * 2),
        (t[3] = (h - c) / g),
        (t[0] = (s + l) / g),
        (t[1] = 0.25 * g),
        (t[2] = (f + d) / g))
      : ((g = Math.sqrt(1 + p - o - u) * 2),
        (t[3] = (s - l) / g),
        (t[0] = (h + c) / g),
        (t[1] = (f + d) / g),
        (t[2] = 0.25 * g)),
    t
  )
}
function iA(t, e, n, r) {
  var i = e[0],
    a = e[1],
    o = e[2],
    s = e[3],
    c = i + i,
    l = a + a,
    u = o + o,
    f = i * c,
    h = i * l,
    d = i * u,
    p = a * l,
    v = a * u,
    g = o * u,
    y = s * c,
    m = s * l,
    b = s * u,
    x = r[0],
    w = r[1],
    O = r[2]
  return (
    (t[0] = (1 - (p + g)) * x),
    (t[1] = (h + b) * x),
    (t[2] = (d - m) * x),
    (t[3] = 0),
    (t[4] = (h - b) * w),
    (t[5] = (1 - (f + g)) * w),
    (t[6] = (v + y) * w),
    (t[7] = 0),
    (t[8] = (d + m) * O),
    (t[9] = (v - y) * O),
    (t[10] = (1 - (f + p)) * O),
    (t[11] = 0),
    (t[12] = n[0]),
    (t[13] = n[1]),
    (t[14] = n[2]),
    (t[15] = 1),
    t
  )
}
function Ro(t, e, n, r, i) {
  var a = e[0],
    o = e[1],
    s = e[2],
    c = e[3],
    l = a + a,
    u = o + o,
    f = s + s,
    h = a * l,
    d = a * u,
    p = a * f,
    v = o * u,
    g = o * f,
    y = s * f,
    m = c * l,
    b = c * u,
    x = c * f,
    w = r[0],
    O = r[1],
    S = r[2],
    _ = i[0],
    M = i[1],
    E = i[2],
    T = (1 - (v + y)) * w,
    C = (d + x) * w,
    A = (p - b) * w,
    P = (d - x) * O,
    k = (1 - (h + y)) * O,
    L = (g + m) * O,
    R = (p + b) * S,
    j = (g - m) * S,
    I = (1 - (h + v)) * S
  return (
    (t[0] = T),
    (t[1] = C),
    (t[2] = A),
    (t[3] = 0),
    (t[4] = P),
    (t[5] = k),
    (t[6] = L),
    (t[7] = 0),
    (t[8] = R),
    (t[9] = j),
    (t[10] = I),
    (t[11] = 0),
    (t[12] = n[0] + _ - (T * _ + P * M + R * E)),
    (t[13] = n[1] + M - (C * _ + k * M + j * E)),
    (t[14] = n[2] + E - (A * _ + L * M + I * E)),
    (t[15] = 1),
    t
  )
}
function zd(t, e) {
  var n = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = n + n,
    s = r + r,
    c = i + i,
    l = n * o,
    u = r * o,
    f = r * s,
    h = i * o,
    d = i * s,
    p = i * c,
    v = a * o,
    g = a * s,
    y = a * c
  return (
    (t[0] = 1 - f - p),
    (t[1] = u + y),
    (t[2] = h - g),
    (t[3] = 0),
    (t[4] = u - y),
    (t[5] = 1 - l - p),
    (t[6] = d + v),
    (t[7] = 0),
    (t[8] = h + g),
    (t[9] = d - v),
    (t[10] = 1 - l - f),
    (t[11] = 0),
    (t[12] = 0),
    (t[13] = 0),
    (t[14] = 0),
    (t[15] = 1),
    t
  )
}
function aA(t, e, n, r, i, a, o) {
  var s = 1 / (n - e),
    c = 1 / (i - r),
    l = 1 / (a - o)
  return (
    (t[0] = a * 2 * s),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = 0),
    (t[5] = a * 2 * c),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = (n + e) * s),
    (t[9] = (i + r) * c),
    (t[10] = (o + a) * l),
    (t[11] = -1),
    (t[12] = 0),
    (t[13] = 0),
    (t[14] = o * a * 2 * l),
    (t[15] = 0),
    t
  )
}
function lb(t, e, n, r, i) {
  var a = 1 / Math.tan(e / 2),
    o
  return (
    (t[0] = a / n),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = 0),
    (t[5] = a),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = 0),
    (t[9] = 0),
    (t[11] = -1),
    (t[12] = 0),
    (t[13] = 0),
    (t[15] = 0),
    i != null && i !== 1 / 0
      ? ((o = 1 / (r - i)), (t[10] = (i + r) * o), (t[14] = 2 * i * r * o))
      : ((t[10] = -1), (t[14] = -2 * r)),
    t
  )
}
var oA = lb
function sA(t, e, n, r, i) {
  var a = 1 / Math.tan(e / 2),
    o
  return (
    (t[0] = a / n),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = 0),
    (t[5] = a),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = 0),
    (t[9] = 0),
    (t[11] = -1),
    (t[12] = 0),
    (t[13] = 0),
    (t[15] = 0),
    i != null && i !== 1 / 0
      ? ((o = 1 / (r - i)), (t[10] = i * o), (t[14] = i * r * o))
      : ((t[10] = -1), (t[14] = -r)),
    t
  )
}
function cA(t, e, n, r) {
  var i = Math.tan((e.upDegrees * Math.PI) / 180),
    a = Math.tan((e.downDegrees * Math.PI) / 180),
    o = Math.tan((e.leftDegrees * Math.PI) / 180),
    s = Math.tan((e.rightDegrees * Math.PI) / 180),
    c = 2 / (o + s),
    l = 2 / (i + a)
  return (
    (t[0] = c),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = 0),
    (t[5] = l),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = -((o - s) * c * 0.5)),
    (t[9] = (i - a) * l * 0.5),
    (t[10] = r / (n - r)),
    (t[11] = -1),
    (t[12] = 0),
    (t[13] = 0),
    (t[14] = (r * n) / (n - r)),
    (t[15] = 0),
    t
  )
}
function ub(t, e, n, r, i, a, o) {
  var s = 1 / (e - n),
    c = 1 / (r - i),
    l = 1 / (a - o)
  return (
    (t[0] = -2 * s),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = 0),
    (t[5] = -2 * c),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = 0),
    (t[9] = 0),
    (t[10] = 2 * l),
    (t[11] = 0),
    (t[12] = (e + n) * s),
    (t[13] = (i + r) * c),
    (t[14] = (o + a) * l),
    (t[15] = 1),
    t
  )
}
var fb = ub
function hb(t, e, n, r, i, a, o) {
  var s = 1 / (e - n),
    c = 1 / (r - i),
    l = 1 / (a - o)
  return (
    (t[0] = -2 * s),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = 0),
    (t[5] = -2 * c),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = 0),
    (t[9] = 0),
    (t[10] = l),
    (t[11] = 0),
    (t[12] = (e + n) * s),
    (t[13] = (i + r) * c),
    (t[14] = a * l),
    (t[15] = 1),
    t
  )
}
function db(t, e, n, r) {
  var i,
    a,
    o,
    s,
    c,
    l,
    u,
    f,
    h,
    d,
    p = e[0],
    v = e[1],
    g = e[2],
    y = r[0],
    m = r[1],
    b = r[2],
    x = n[0],
    w = n[1],
    O = n[2]
  return Math.abs(p - x) < Xt && Math.abs(v - w) < Xt && Math.abs(g - O) < Xt
    ? ws(t)
    : ((u = p - x),
      (f = v - w),
      (h = g - O),
      (d = 1 / Math.hypot(u, f, h)),
      (u *= d),
      (f *= d),
      (h *= d),
      (i = m * h - b * f),
      (a = b * u - y * h),
      (o = y * f - m * u),
      (d = Math.hypot(i, a, o)),
      d ? ((d = 1 / d), (i *= d), (a *= d), (o *= d)) : ((i = 0), (a = 0), (o = 0)),
      (s = f * o - h * a),
      (c = h * i - u * o),
      (l = u * a - f * i),
      (d = Math.hypot(s, c, l)),
      d ? ((d = 1 / d), (s *= d), (c *= d), (l *= d)) : ((s = 0), (c = 0), (l = 0)),
      (t[0] = i),
      (t[1] = s),
      (t[2] = u),
      (t[3] = 0),
      (t[4] = a),
      (t[5] = c),
      (t[6] = f),
      (t[7] = 0),
      (t[8] = o),
      (t[9] = l),
      (t[10] = h),
      (t[11] = 0),
      (t[12] = -(i * p + a * v + o * g)),
      (t[13] = -(s * p + c * v + l * g)),
      (t[14] = -(u * p + f * v + h * g)),
      (t[15] = 1),
      t)
}
function lA(t, e, n, r) {
  var i = e[0],
    a = e[1],
    o = e[2],
    s = r[0],
    c = r[1],
    l = r[2],
    u = i - n[0],
    f = a - n[1],
    h = o - n[2],
    d = u * u + f * f + h * h
  d > 0 && ((d = 1 / Math.sqrt(d)), (u *= d), (f *= d), (h *= d))
  var p = c * h - l * f,
    v = l * u - s * h,
    g = s * f - c * u
  return (
    (d = p * p + v * v + g * g),
    d > 0 && ((d = 1 / Math.sqrt(d)), (p *= d), (v *= d), (g *= d)),
    (t[0] = p),
    (t[1] = v),
    (t[2] = g),
    (t[3] = 0),
    (t[4] = f * g - h * v),
    (t[5] = h * p - u * g),
    (t[6] = u * v - f * p),
    (t[7] = 0),
    (t[8] = u),
    (t[9] = f),
    (t[10] = h),
    (t[11] = 0),
    (t[12] = i),
    (t[13] = a),
    (t[14] = o),
    (t[15] = 1),
    t
  )
}
function uA(t) {
  return (
    'mat4(' +
    t[0] +
    ', ' +
    t[1] +
    ', ' +
    t[2] +
    ', ' +
    t[3] +
    ', ' +
    t[4] +
    ', ' +
    t[5] +
    ', ' +
    t[6] +
    ', ' +
    t[7] +
    ', ' +
    t[8] +
    ', ' +
    t[9] +
    ', ' +
    t[10] +
    ', ' +
    t[11] +
    ', ' +
    t[12] +
    ', ' +
    t[13] +
    ', ' +
    t[14] +
    ', ' +
    t[15] +
    ')'
  )
}
function fA(t) {
  return Math.hypot(
    t[0],
    t[1],
    t[2],
    t[3],
    t[4],
    t[5],
    t[6],
    t[7],
    t[8],
    t[9],
    t[10],
    t[11],
    t[12],
    t[13],
    t[14],
    t[15]
  )
}
function hA(t, e, n) {
  return (
    (t[0] = e[0] + n[0]),
    (t[1] = e[1] + n[1]),
    (t[2] = e[2] + n[2]),
    (t[3] = e[3] + n[3]),
    (t[4] = e[4] + n[4]),
    (t[5] = e[5] + n[5]),
    (t[6] = e[6] + n[6]),
    (t[7] = e[7] + n[7]),
    (t[8] = e[8] + n[8]),
    (t[9] = e[9] + n[9]),
    (t[10] = e[10] + n[10]),
    (t[11] = e[11] + n[11]),
    (t[12] = e[12] + n[12]),
    (t[13] = e[13] + n[13]),
    (t[14] = e[14] + n[14]),
    (t[15] = e[15] + n[15]),
    t
  )
}
function pb(t, e, n) {
  return (
    (t[0] = e[0] - n[0]),
    (t[1] = e[1] - n[1]),
    (t[2] = e[2] - n[2]),
    (t[3] = e[3] - n[3]),
    (t[4] = e[4] - n[4]),
    (t[5] = e[5] - n[5]),
    (t[6] = e[6] - n[6]),
    (t[7] = e[7] - n[7]),
    (t[8] = e[8] - n[8]),
    (t[9] = e[9] - n[9]),
    (t[10] = e[10] - n[10]),
    (t[11] = e[11] - n[11]),
    (t[12] = e[12] - n[12]),
    (t[13] = e[13] - n[13]),
    (t[14] = e[14] - n[14]),
    (t[15] = e[15] - n[15]),
    t
  )
}
function dA(t, e, n) {
  return (
    (t[0] = e[0] * n),
    (t[1] = e[1] * n),
    (t[2] = e[2] * n),
    (t[3] = e[3] * n),
    (t[4] = e[4] * n),
    (t[5] = e[5] * n),
    (t[6] = e[6] * n),
    (t[7] = e[7] * n),
    (t[8] = e[8] * n),
    (t[9] = e[9] * n),
    (t[10] = e[10] * n),
    (t[11] = e[11] * n),
    (t[12] = e[12] * n),
    (t[13] = e[13] * n),
    (t[14] = e[14] * n),
    (t[15] = e[15] * n),
    t
  )
}
function pA(t, e, n, r) {
  return (
    (t[0] = e[0] + n[0] * r),
    (t[1] = e[1] + n[1] * r),
    (t[2] = e[2] + n[2] * r),
    (t[3] = e[3] + n[3] * r),
    (t[4] = e[4] + n[4] * r),
    (t[5] = e[5] + n[5] * r),
    (t[6] = e[6] + n[6] * r),
    (t[7] = e[7] + n[7] * r),
    (t[8] = e[8] + n[8] * r),
    (t[9] = e[9] + n[9] * r),
    (t[10] = e[10] + n[10] * r),
    (t[11] = e[11] + n[11] * r),
    (t[12] = e[12] + n[12] * r),
    (t[13] = e[13] + n[13] * r),
    (t[14] = e[14] + n[14] * r),
    (t[15] = e[15] + n[15] * r),
    t
  )
}
function vA(t, e) {
  return (
    t[0] === e[0] &&
    t[1] === e[1] &&
    t[2] === e[2] &&
    t[3] === e[3] &&
    t[4] === e[4] &&
    t[5] === e[5] &&
    t[6] === e[6] &&
    t[7] === e[7] &&
    t[8] === e[8] &&
    t[9] === e[9] &&
    t[10] === e[10] &&
    t[11] === e[11] &&
    t[12] === e[12] &&
    t[13] === e[13] &&
    t[14] === e[14] &&
    t[15] === e[15]
  )
}
function gA(t, e) {
  var n = t[0],
    r = t[1],
    i = t[2],
    a = t[3],
    o = t[4],
    s = t[5],
    c = t[6],
    l = t[7],
    u = t[8],
    f = t[9],
    h = t[10],
    d = t[11],
    p = t[12],
    v = t[13],
    g = t[14],
    y = t[15],
    m = e[0],
    b = e[1],
    x = e[2],
    w = e[3],
    O = e[4],
    S = e[5],
    _ = e[6],
    M = e[7],
    E = e[8],
    T = e[9],
    C = e[10],
    A = e[11],
    P = e[12],
    k = e[13],
    L = e[14],
    R = e[15]
  return (
    Math.abs(n - m) <= Xt * Math.max(1, Math.abs(n), Math.abs(m)) &&
    Math.abs(r - b) <= Xt * Math.max(1, Math.abs(r), Math.abs(b)) &&
    Math.abs(i - x) <= Xt * Math.max(1, Math.abs(i), Math.abs(x)) &&
    Math.abs(a - w) <= Xt * Math.max(1, Math.abs(a), Math.abs(w)) &&
    Math.abs(o - O) <= Xt * Math.max(1, Math.abs(o), Math.abs(O)) &&
    Math.abs(s - S) <= Xt * Math.max(1, Math.abs(s), Math.abs(S)) &&
    Math.abs(c - _) <= Xt * Math.max(1, Math.abs(c), Math.abs(_)) &&
    Math.abs(l - M) <= Xt * Math.max(1, Math.abs(l), Math.abs(M)) &&
    Math.abs(u - E) <= Xt * Math.max(1, Math.abs(u), Math.abs(E)) &&
    Math.abs(f - T) <= Xt * Math.max(1, Math.abs(f), Math.abs(T)) &&
    Math.abs(h - C) <= Xt * Math.max(1, Math.abs(h), Math.abs(C)) &&
    Math.abs(d - A) <= Xt * Math.max(1, Math.abs(d), Math.abs(A)) &&
    Math.abs(p - P) <= Xt * Math.max(1, Math.abs(p), Math.abs(P)) &&
    Math.abs(v - k) <= Xt * Math.max(1, Math.abs(v), Math.abs(k)) &&
    Math.abs(g - L) <= Xt * Math.max(1, Math.abs(g), Math.abs(L)) &&
    Math.abs(y - R) <= Xt * Math.max(1, Math.abs(y), Math.abs(R))
  )
}
var vb = Re,
  yA = pb
const mA = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      add: hA,
      adjoint: KP,
      clone: $d,
      copy: Li,
      create: Nt,
      determinant: ab,
      equals: gA,
      exactEquals: vA,
      frob: fA,
      fromQuat: zd,
      fromQuat2: rA,
      fromRotation: JP,
      fromRotationTranslation: cb,
      fromRotationTranslationScale: iA,
      fromRotationTranslationScaleOrigin: Ro,
      fromScaling: Fd,
      fromTranslation: Bd,
      fromValues: qP,
      fromXRotation: tA,
      fromYRotation: eA,
      fromZRotation: nA,
      frustum: aA,
      getRotation: Jc,
      getScaling: Ma,
      getTranslation: Qc,
      identity: ws,
      invert: zn,
      lookAt: db,
      mul: vb,
      multiply: Re,
      multiplyScalar: dA,
      multiplyScalarAndAdd: pA,
      ortho: fb,
      orthoNO: ub,
      orthoZO: hb,
      perspective: oA,
      perspectiveFromFieldOfView: cA,
      perspectiveNO: lb,
      perspectiveZO: sA,
      rotate: ZP,
      rotateX: ob,
      rotateY: sb,
      rotateZ: QP,
      scale: Zc,
      set: Qf,
      str: uA,
      sub: yA,
      subtract: pb,
      targetTo: lA,
      translate: Gr,
      transpose: ib
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function yt() {
  var t = new fe(3)
  return fe != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)), t
}
function dr(t) {
  var e = new fe(3)
  return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), e
}
function vr(t) {
  var e = t[0],
    n = t[1],
    r = t[2]
  return Math.hypot(e, n, r)
}
function St(t, e, n) {
  var r = new fe(3)
  return (r[0] = t), (r[1] = e), (r[2] = n), r
}
function Qe(t, e) {
  return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), t
}
function $n(t, e, n, r) {
  return (t[0] = e), (t[1] = n), (t[2] = r), t
}
function va(t, e, n) {
  return (t[0] = e[0] + n[0]), (t[1] = e[1] + n[1]), (t[2] = e[2] + n[2]), t
}
function hv(t, e, n) {
  return (t[0] = e[0] - n[0]), (t[1] = e[1] - n[1]), (t[2] = e[2] - n[2]), t
}
function bA(t, e, n) {
  return (t[0] = e[0] * n[0]), (t[1] = e[1] * n[1]), (t[2] = e[2] * n[2]), t
}
function Jf(t, e, n) {
  return (t[0] = e[0] * n), (t[1] = e[1] * n), (t[2] = e[2] * n), t
}
function xA(t, e) {
  var n = e[0] - t[0],
    r = e[1] - t[1],
    i = e[2] - t[2]
  return Math.hypot(n, r, i)
}
function Ti(t, e) {
  var n = e[0],
    r = e[1],
    i = e[2],
    a = n * n + r * r + i * i
  return a > 0 && (a = 1 / Math.sqrt(a)), (t[0] = e[0] * a), (t[1] = e[1] * a), (t[2] = e[2] * a), t
}
function Jn(t, e) {
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
}
function jc(t, e, n) {
  var r = e[0],
    i = e[1],
    a = e[2],
    o = n[0],
    s = n[1],
    c = n[2]
  return (t[0] = i * c - a * s), (t[1] = a * o - r * c), (t[2] = r * s - i * o), t
}
function th(t, e, n, r) {
  var i = e[0],
    a = e[1],
    o = e[2]
  return (t[0] = i + r * (n[0] - i)), (t[1] = a + r * (n[1] - a)), (t[2] = o + r * (n[2] - o)), t
}
function be(t, e, n) {
  var r = e[0],
    i = e[1],
    a = e[2],
    o = n[3] * r + n[7] * i + n[11] * a + n[15]
  return (
    (o = o || 1),
    (t[0] = (n[0] * r + n[4] * i + n[8] * a + n[12]) / o),
    (t[1] = (n[1] * r + n[5] * i + n[9] * a + n[13]) / o),
    (t[2] = (n[2] * r + n[6] * i + n[10] * a + n[14]) / o),
    t
  )
}
function gb(t, e, n) {
  var r = e[0],
    i = e[1],
    a = e[2]
  return (
    (t[0] = r * n[0] + i * n[3] + a * n[6]),
    (t[1] = r * n[1] + i * n[4] + a * n[7]),
    (t[2] = r * n[2] + i * n[5] + a * n[8]),
    t
  )
}
function wA(t, e, n) {
  var r = n[0],
    i = n[1],
    a = n[2],
    o = n[3],
    s = e[0],
    c = e[1],
    l = e[2],
    u = i * l - a * c,
    f = a * s - r * l,
    h = r * c - i * s,
    d = i * h - a * f,
    p = a * u - r * h,
    v = r * f - i * u,
    g = o * 2
  return (
    (u *= g),
    (f *= g),
    (h *= g),
    (d *= 2),
    (p *= 2),
    (v *= 2),
    (t[0] = s + u + d),
    (t[1] = c + f + p),
    (t[2] = l + h + v),
    t
  )
}
function co(t, e) {
  var n = t[0],
    r = t[1],
    i = t[2],
    a = e[0],
    o = e[1],
    s = e[2]
  return (
    Math.abs(n - a) <= Xt * Math.max(1, Math.abs(n), Math.abs(a)) &&
    Math.abs(r - o) <= Xt * Math.max(1, Math.abs(r), Math.abs(o)) &&
    Math.abs(i - s) <= Xt * Math.max(1, Math.abs(i), Math.abs(s))
  )
}
var dv = xA,
  yb = vr
;(function () {
  var t = yt()
  return function (e, n, r, i, a, o) {
    var s, c
    for (
      n || (n = 3), r || (r = 0), i ? (c = Math.min(i * n + r, e.length)) : (c = e.length), s = r;
      s < c;
      s += n
    )
      (t[0] = e[s]),
        (t[1] = e[s + 1]),
        (t[2] = e[s + 2]),
        a(t, t, o),
        (e[s] = t[0]),
        (e[s + 1] = t[1]),
        (e[s + 2] = t[2])
    return e
  }
})()
function ca() {
  var t = new fe(4)
  return fe != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0), (t[3] = 0)), t
}
function OA(t, e, n, r) {
  var i = new fe(4)
  return (i[0] = t), (i[1] = e), (i[2] = n), (i[3] = r), i
}
function SA(t, e) {
  return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), (t[3] = e[3]), t
}
function _A(t, e) {
  var n = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = n * n + r * r + i * i + a * a
  return (
    o > 0 && (o = 1 / Math.sqrt(o)),
    (t[0] = n * o),
    (t[1] = r * o),
    (t[2] = i * o),
    (t[3] = a * o),
    t
  )
}
function la(t, e, n) {
  var r = e[0],
    i = e[1],
    a = e[2],
    o = e[3]
  return (
    (t[0] = n[0] * r + n[4] * i + n[8] * a + n[12] * o),
    (t[1] = n[1] * r + n[5] * i + n[9] * a + n[13] * o),
    (t[2] = n[2] * r + n[6] * i + n[10] * a + n[14] * o),
    (t[3] = n[3] * r + n[7] * i + n[11] * a + n[15] * o),
    t
  )
}
;(function () {
  var t = ca()
  return function (e, n, r, i, a, o) {
    var s, c
    for (
      n || (n = 4), r || (r = 0), i ? (c = Math.min(i * n + r, e.length)) : (c = e.length), s = r;
      s < c;
      s += n
    )
      (t[0] = e[s]),
        (t[1] = e[s + 1]),
        (t[2] = e[s + 2]),
        (t[3] = e[s + 3]),
        a(t, t, o),
        (e[s] = t[0]),
        (e[s + 1] = t[1]),
        (e[s + 2] = t[2]),
        (e[s + 3] = t[3])
    return e
  }
})()
function pe() {
  var t = new fe(4)
  return fe != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)), (t[3] = 1), t
}
function Br(t, e, n) {
  n = n * 0.5
  var r = Math.sin(n)
  return (t[0] = r * e[0]), (t[1] = r * e[1]), (t[2] = r * e[2]), (t[3] = Math.cos(n)), t
}
function Wr(t, e, n) {
  var r = e[0],
    i = e[1],
    a = e[2],
    o = e[3],
    s = n[0],
    c = n[1],
    l = n[2],
    u = n[3]
  return (
    (t[0] = r * u + o * s + i * l - a * c),
    (t[1] = i * u + o * c + a * s - r * l),
    (t[2] = a * u + o * l + r * c - i * s),
    (t[3] = o * u - r * s - i * c - a * l),
    t
  )
}
function Wu(t, e, n, r) {
  var i = e[0],
    a = e[1],
    o = e[2],
    s = e[3],
    c = n[0],
    l = n[1],
    u = n[2],
    f = n[3],
    h,
    d,
    p,
    v,
    g
  return (
    (d = i * c + a * l + o * u + s * f),
    d < 0 && ((d = -d), (c = -c), (l = -l), (u = -u), (f = -f)),
    1 - d > Xt
      ? ((h = Math.acos(d)),
        (p = Math.sin(h)),
        (v = Math.sin((1 - r) * h) / p),
        (g = Math.sin(r * h) / p))
      : ((v = 1 - r), (g = r)),
    (t[0] = v * i + g * c),
    (t[1] = v * a + g * l),
    (t[2] = v * o + g * u),
    (t[3] = v * s + g * f),
    t
  )
}
function Yu(t, e) {
  var n = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = n * n + r * r + i * i + a * a,
    s = o ? 1 / o : 0
  return (t[0] = -n * s), (t[1] = -r * s), (t[2] = -i * s), (t[3] = a * s), t
}
function MA(t, e) {
  var n = e[0] + e[4] + e[8],
    r
  if (n > 0)
    (r = Math.sqrt(n + 1)),
      (t[3] = 0.5 * r),
      (r = 0.5 / r),
      (t[0] = (e[5] - e[7]) * r),
      (t[1] = (e[6] - e[2]) * r),
      (t[2] = (e[1] - e[3]) * r)
  else {
    var i = 0
    e[4] > e[0] && (i = 1), e[8] > e[i * 3 + i] && (i = 2)
    var a = (i + 1) % 3,
      o = (i + 2) % 3
    ;(r = Math.sqrt(e[i * 3 + i] - e[a * 3 + a] - e[o * 3 + o] + 1)),
      (t[i] = 0.5 * r),
      (r = 0.5 / r),
      (t[3] = (e[a * 3 + o] - e[o * 3 + a]) * r),
      (t[a] = (e[a * 3 + i] + e[i * 3 + a]) * r),
      (t[o] = (e[o * 3 + i] + e[i * 3 + o]) * r)
  }
  return t
}
function Vs(t, e, n, r) {
  var i = (0.5 * Math.PI) / 180
  ;(e *= i), (n *= i), (r *= i)
  var a = Math.sin(e),
    o = Math.cos(e),
    s = Math.sin(n),
    c = Math.cos(n),
    l = Math.sin(r),
    u = Math.cos(r)
  return (
    (t[0] = a * c * u - o * s * l),
    (t[1] = o * s * u + a * c * l),
    (t[2] = o * c * l - a * s * u),
    (t[3] = o * c * u + a * s * l),
    t
  )
}
var Hu = OA,
  Xs = SA,
  pv = Wr,
  tl = _A
;(function () {
  var t = yt(),
    e = St(1, 0, 0),
    n = St(0, 1, 0)
  return function (r, i, a) {
    var o = Jn(i, a)
    return o < -0.999999
      ? (jc(t, e, i), yb(t) < 1e-6 && jc(t, n, i), Ti(t, t), Br(r, t, Math.PI), r)
      : o > 0.999999
      ? ((r[0] = 0), (r[1] = 0), (r[2] = 0), (r[3] = 1), r)
      : (jc(t, i, a), (r[0] = t[0]), (r[1] = t[1]), (r[2] = t[2]), (r[3] = 1 + o), tl(r, r))
  }
})()
;(function () {
  var t = pe(),
    e = pe()
  return function (n, r, i, a, o, s) {
    return Wu(t, r, o, s), Wu(e, i, a, s), Wu(n, t, e, 2 * s * (1 - s)), n
  }
})()
;(function () {
  var t = Ua()
  return function (e, n, r, i) {
    return (
      (t[0] = r[0]),
      (t[3] = r[1]),
      (t[6] = r[2]),
      (t[1] = i[0]),
      (t[4] = i[1]),
      (t[7] = i[2]),
      (t[2] = -n[0]),
      (t[5] = -n[1]),
      (t[8] = -n[2]),
      tl(e, MA(e, t))
    )
  }
})()
function EA() {
  var t = new fe(2)
  return fe != Float32Array && ((t[0] = 0), (t[1] = 0)), t
}
function TA(t, e) {
  var n = new fe(2)
  return (n[0] = t), (n[1] = e), n
}
function PA(t, e) {
  return (t[0] = e[0]), (t[1] = e[1]), t
}
function AA(t, e) {
  var n = e[0],
    r = e[1],
    i = n * n + r * r
  return i > 0 && (i = 1 / Math.sqrt(i)), (t[0] = e[0] * i), (t[1] = e[1] * i), t
}
function kA(t, e) {
  return t[0] * e[0] + t[1] * e[1]
}
function CA(t, e) {
  return t[0] === e[0] && t[1] === e[1]
}
;(function () {
  var t = EA()
  return function (e, n, r, i, a, o) {
    var s, c
    for (
      n || (n = 2), r || (r = 0), i ? (c = Math.min(i * n + r, e.length)) : (c = e.length), s = r;
      s < c;
      s += n
    )
      (t[0] = e[s]), (t[1] = e[s + 1]), a(t, t, o), (e[s] = t[0]), (e[s + 1] = t[1])
    return e
  }
})()
var eh = function (t, e) {
  return (
    (eh =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (n, r) {
          n.__proto__ = r
        }) ||
      function (n, r) {
        for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i])
      }),
    eh(t, e)
  )
}
function rt(t, e) {
  if (typeof e != 'function' && e !== null)
    throw new TypeError('Class extends value ' + String(e) + ' is not a constructor or null')
  eh(t, e)
  function n() {
    this.constructor = t
  }
  t.prototype = e === null ? Object.create(e) : ((n.prototype = e.prototype), new n())
}
var z = function () {
  return (
    (z =
      Object.assign ||
      function (e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r]
          for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a])
        }
        return e
      }),
    z.apply(this, arguments)
  )
}
function Dt(t, e) {
  var n = {}
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
  if (t != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]])
  return n
}
function LA(t, e, n, r) {
  var i = arguments.length,
    a = i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, n)) : r,
    o
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
    a = Reflect.decorate(t, e, n, r)
  else
    for (var s = t.length - 1; s >= 0; s--)
      (o = t[s]) && (a = (i < 3 ? o(a) : i > 3 ? o(e, n, a) : o(e, n)) || a)
  return i > 3 && a && Object.defineProperty(e, n, a), a
}
function Ea(t, e, n, r) {
  function i(a) {
    return a instanceof n
      ? a
      : new n(function (o) {
          o(a)
        })
  }
  return new (n || (n = Promise))(function (a, o) {
    function s(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }
    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }
    function l(u) {
      u.done ? a(u.value) : i(u.value).then(s, c)
    }
    l((r = r.apply(t, e || [])).next())
  })
}
function Ta(t, e) {
  var n = {
      label: 0,
      sent: function () {
        if (a[0] & 1) throw a[1]
        return a[1]
      },
      trys: [],
      ops: []
    },
    r,
    i,
    a,
    o
  return (
    (o = { next: s(0), throw: s(1), return: s(2) }),
    typeof Symbol == 'function' &&
      (o[Symbol.iterator] = function () {
        return this
      }),
    o
  )
  function s(l) {
    return function (u) {
      return c([l, u])
    }
  }
  function c(l) {
    if (r) throw new TypeError('Generator is already executing.')
    for (; o && ((o = 0), l[0] && (n = 0)), n; )
      try {
        if (
          ((r = 1),
          i &&
            (a =
              l[0] & 2 ? i.return : l[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) &&
            !(a = a.call(i, l[1])).done)
        )
          return a
        switch (((i = 0), a && (l = [l[0] & 2, a.value]), l[0])) {
          case 0:
          case 1:
            a = l
            break
          case 4:
            return n.label++, { value: l[1], done: !1 }
          case 5:
            n.label++, (i = l[1]), (l = [0])
            continue
          case 7:
            ;(l = n.ops.pop()), n.trys.pop()
            continue
          default:
            if (
              ((a = n.trys), !(a = a.length > 0 && a[a.length - 1]) && (l[0] === 6 || l[0] === 2))
            ) {
              n = 0
              continue
            }
            if (l[0] === 3 && (!a || (l[1] > a[0] && l[1] < a[3]))) {
              n.label = l[1]
              break
            }
            if (l[0] === 6 && n.label < a[1]) {
              ;(n.label = a[1]), (a = l)
              break
            }
            if (a && n.label < a[2]) {
              ;(n.label = a[2]), n.ops.push(l)
              break
            }
            a[2] && n.ops.pop(), n.trys.pop()
            continue
        }
        l = e.call(t, n)
      } catch (u) {
        ;(l = [6, u]), (i = 0)
      } finally {
        r = a = 0
      }
    if (l[0] & 5) throw l[1]
    return { value: l[0] ? l[1] : void 0, done: !0 }
  }
}
function hn(t) {
  var e = typeof Symbol == 'function' && Symbol.iterator,
    n = e && t[e],
    r = 0
  if (n) return n.call(t)
  if (t && typeof t.length == 'number')
    return {
      next: function () {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
      }
    }
  throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
}
function N(t, e) {
  var n = typeof Symbol == 'function' && t[Symbol.iterator]
  if (!n) return t
  var r = n.call(t),
    i,
    a = [],
    o
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
  } catch (s) {
    o = { error: s }
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r)
    } finally {
      if (o) throw o.error
    }
  }
  return a
}
function NA() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length
  for (var r = Array(t), i = 0, e = 0; e < n; e++)
    for (var a = arguments[e], o = 0, s = a.length; o < s; o++, i++) r[i] = a[o]
  return r
}
function q(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, a; r < i; r++)
      (a || !(r in e)) && (a || (a = Array.prototype.slice.call(e, 0, r)), (a[r] = e[r]))
  return t.concat(a || Array.prototype.slice.call(e))
}
function Vu(t, e, n, r) {
  if (n === 'a' && !r) throw new TypeError('Private accessor was defined without a getter')
  if (typeof e == 'function' ? t !== e || !r : !e.has(t))
    throw new TypeError('Cannot read private member from an object whose class did not declare it')
  return n === 'm' ? r : n === 'a' ? r.call(t) : r ? r.value : e.get(t)
}
var mb = { x1: 0, y1: 0, x2: 0, y2: 0, x: 0, y: 0, qx: null, qy: null }
function RA(t, e, n) {
  if (t[n].length > 7) {
    t[n].shift()
    for (var r = t[n], i = n; r.length; )
      (e[n] = 'A'), t.splice((i += 1), 0, ['C'].concat(r.splice(0, 6)))
    t.splice(n, 1)
  }
}
var Io = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 }
function bb(t) {
  return (
    Array.isArray(t) &&
    t.every(function (e) {
      var n = e[0].toLowerCase()
      return Io[n] === e.length - 1 && 'achlmqstvz'.includes(n)
    })
  )
}
function xb(t) {
  return (
    bb(t) &&
    t.every(function (e) {
      var n = e[0]
      return n === n.toUpperCase()
    })
  )
}
function wb(t) {
  return (
    xb(t) &&
    t.every(function (e) {
      var n = e[0]
      return 'ACLMQZ'.includes(n)
    })
  )
}
function vv(t) {
  for (
    var e = t.pathValue[t.segmentStart], n = e.toLowerCase(), r = t.data;
    r.length >= Io[n] &&
    (n === 'm' && r.length > 2
      ? (t.segments.push([e].concat(r.splice(0, 2))), (n = 'l'), (e = e === 'm' ? 'l' : 'L'))
      : t.segments.push([e].concat(r.splice(0, Io[n]))),
    !!Io[n]);

  );
}
function IA(t) {
  var e = t.index,
    n = t.pathValue,
    r = n.charCodeAt(e)
  if (r === 48) {
    ;(t.param = 0), (t.index += 1)
    return
  }
  if (r === 49) {
    ;(t.param = 1), (t.index += 1)
    return
  }
  t.err = '[path-util]: invalid Arc flag "' + n[e] + '", expecting 0 or 1 at index ' + e
}
function jA(t) {
  return (t >= 48 && t <= 57) || t === 43 || t === 45 || t === 46
}
function Zi(t) {
  return t >= 48 && t <= 57
}
function DA(t) {
  var e = t.max,
    n = t.pathValue,
    r = t.index,
    i = r,
    a = !1,
    o = !1,
    s = !1,
    c = !1,
    l
  if (i >= e) {
    t.err = '[path-util]: Invalid path value at index ' + i + ', "pathValue" is missing param'
    return
  }
  if (
    ((l = n.charCodeAt(i)),
    (l === 43 || l === 45) && ((i += 1), (l = n.charCodeAt(i))),
    !Zi(l) && l !== 46)
  ) {
    t.err = '[path-util]: Invalid path value at index ' + i + ', "' + n[i] + '" is not a number'
    return
  }
  if (l !== 46) {
    if (((a = l === 48), (i += 1), (l = n.charCodeAt(i)), a && i < e && l && Zi(l))) {
      t.err = '[path-util]: Invalid path value at index ' + r + ', "' + n[r] + '" illegal number'
      return
    }
    for (; i < e && Zi(n.charCodeAt(i)); ) (i += 1), (o = !0)
    l = n.charCodeAt(i)
  }
  if (l === 46) {
    for (c = !0, i += 1; Zi(n.charCodeAt(i)); ) (i += 1), (s = !0)
    l = n.charCodeAt(i)
  }
  if (l === 101 || l === 69) {
    if (c && !o && !s) {
      t.err =
        '[path-util]: Invalid path value at index ' + i + ', "' + n[i] + '" invalid float exponent'
      return
    }
    if (
      ((i += 1),
      (l = n.charCodeAt(i)),
      (l === 43 || l === 45) && (i += 1),
      i < e && Zi(n.charCodeAt(i)))
    )
      for (; i < e && Zi(n.charCodeAt(i)); ) i += 1
    else {
      t.err =
        '[path-util]: Invalid path value at index ' +
        i +
        ', "' +
        n[i] +
        '" invalid integer exponent'
      return
    }
  }
  ;(t.index = i), (t.param = +t.pathValue.slice(r, i))
}
function $A(t) {
  var e = [
    5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288,
    65279
  ]
  return (
    t === 10 ||
    t === 13 ||
    t === 8232 ||
    t === 8233 ||
    t === 32 ||
    t === 9 ||
    t === 11 ||
    t === 12 ||
    t === 160 ||
    (t >= 5760 && e.includes(t))
  )
}
function Dc(t) {
  for (var e = t.pathValue, n = t.max; t.index < n && $A(e.charCodeAt(t.index)); ) t.index += 1
}
function BA(t) {
  switch (t | 32) {
    case 109:
    case 122:
    case 108:
    case 104:
    case 118:
    case 99:
    case 115:
    case 113:
    case 116:
    case 97:
      return !0
    default:
      return !1
  }
}
function FA(t) {
  return (t | 32) === 97
}
function zA(t) {
  var e = t.max,
    n = t.pathValue,
    r = t.index,
    i = n.charCodeAt(r),
    a = Io[n[r].toLowerCase()]
  if (((t.segmentStart = r), !BA(i))) {
    t.err = '[path-util]: Invalid path value "' + n[r] + '" is not a path command'
    return
  }
  if (((t.index += 1), Dc(t), (t.data = []), !a)) {
    vv(t)
    return
  }
  for (;;) {
    for (var o = a; o > 0; o -= 1) {
      if ((FA(i) && (o === 3 || o === 4) ? IA(t) : DA(t), t.err.length)) return
      t.data.push(t.param),
        Dc(t),
        t.index < e && n.charCodeAt(t.index) === 44 && ((t.index += 1), Dc(t))
    }
    if (t.index >= t.max || !jA(n.charCodeAt(t.index))) break
  }
  vv(t)
}
var GA = (function () {
  function t(e) {
    ;(this.pathValue = e),
      (this.segments = []),
      (this.max = e.length),
      (this.index = 0),
      (this.param = 0),
      (this.segmentStart = 0),
      (this.data = []),
      (this.err = '')
  }
  return t
})()
function WA(t) {
  if (bb(t)) return [].concat(t)
  var e = new GA(t)
  for (Dc(e); e.index < e.max && !e.err.length; ) zA(e)
  return e.err ? e.err : e.segments
}
function YA(t) {
  if (xb(t)) return [].concat(t)
  var e = WA(t),
    n = 0,
    r = 0,
    i = 0,
    a = 0
  return e.map(function (o) {
    var s = o.slice(1).map(Number),
      c = o[0],
      l = c.toUpperCase()
    if (c === 'M') return (n = s[0]), (r = s[1]), (i = n), (a = r), ['M', n, r]
    var u
    if (c !== l)
      switch (l) {
        case 'A':
          u = [l, s[0], s[1], s[2], s[3], s[4], s[5] + n, s[6] + r]
          break
        case 'V':
          u = [l, s[0] + r]
          break
        case 'H':
          u = [l, s[0] + n]
          break
        default: {
          var f = s.map(function (d, p) {
            return d + (p % 2 ? r : n)
          })
          u = [l].concat(f)
        }
      }
    else u = [l].concat(s)
    var h = u.length
    switch (l) {
      case 'Z':
        ;(n = i), (r = a)
        break
      case 'H':
        n = u[1]
        break
      case 'V':
        r = u[1]
        break
      default:
        ;(n = u[h - 2]), (r = u[h - 1]), l === 'M' && ((i = n), (a = r))
    }
    return u
  })
}
function HA(t, e) {
  var n = t[0],
    r = e.x1,
    i = e.y1,
    a = e.x2,
    o = e.y2,
    s = t.slice(1).map(Number),
    c = t
  if (('TQ'.includes(n) || ((e.qx = null), (e.qy = null)), n === 'H')) c = ['L', t[1], i]
  else if (n === 'V') c = ['L', r, t[1]]
  else if (n === 'S') {
    var l = r * 2 - a,
      u = i * 2 - o
    ;(e.x1 = l), (e.y1 = u), (c = ['C', l, u].concat(s))
  } else if (n === 'T') {
    var f = r * 2 - e.qx,
      h = i * 2 - e.qy
    ;(e.qx = f), (e.qy = h), (c = ['Q', f, h].concat(s))
  } else if (n === 'Q') {
    var d = s[0],
      p = s[1]
    ;(e.qx = d), (e.qy = p)
  }
  return c
}
function el(t) {
  if (wb(t)) return [].concat(t)
  for (var e = YA(t), n = z({}, mb), r = 0; r < e.length; r += 1) {
    e[r] = HA(e[r], n)
    var i = e[r],
      a = i.length
    ;(n.x1 = +i[a - 2]), (n.y1 = +i[a - 1]), (n.x2 = +i[a - 4] || n.x1), (n.y2 = +i[a - 3] || n.y1)
  }
  return e
}
function VA(t) {
  return (
    wb(t) &&
    t.every(function (e) {
      var n = e[0]
      return 'MC'.includes(n)
    })
  )
}
function Us(t, e, n) {
  var r = t * Math.cos(n) - e * Math.sin(n),
    i = t * Math.sin(n) + e * Math.cos(n)
  return { x: r, y: i }
}
function Gd(t, e, n, r, i, a, o, s, c, l) {
  var u = t,
    f = e,
    h = n,
    d = r,
    p = s,
    v = c,
    g = (Math.PI * 120) / 180,
    y = (Math.PI / 180) * (+i || 0),
    m = [],
    b,
    x,
    w,
    O,
    S
  if (l) (x = l[0]), (w = l[1]), (O = l[2]), (S = l[3])
  else {
    ;(b = Us(u, f, -y)), (u = b.x), (f = b.y), (b = Us(p, v, -y)), (p = b.x), (v = b.y)
    var _ = (u - p) / 2,
      M = (f - v) / 2,
      E = (_ * _) / (h * h) + (M * M) / (d * d)
    E > 1 && ((E = Math.sqrt(E)), (h *= E), (d *= E))
    var T = h * h,
      C = d * d,
      A =
        (a === o ? -1 : 1) *
        Math.sqrt(Math.abs((T * C - T * M * M - C * _ * _) / (T * M * M + C * _ * _)))
    ;(O = (A * h * M) / d + (u + p) / 2),
      (S = (A * -d * _) / h + (f + v) / 2),
      (x = Math.asin(((((f - S) / d) * Math.pow(10, 9)) >> 0) / Math.pow(10, 9))),
      (w = Math.asin(((((v - S) / d) * Math.pow(10, 9)) >> 0) / Math.pow(10, 9))),
      (x = u < O ? Math.PI - x : x),
      (w = p < O ? Math.PI - w : w),
      x < 0 && (x = Math.PI * 2 + x),
      w < 0 && (w = Math.PI * 2 + w),
      o && x > w && (x -= Math.PI * 2),
      !o && w > x && (w -= Math.PI * 2)
  }
  var P = w - x
  if (Math.abs(P) > g) {
    var k = w,
      L = p,
      R = v
    ;(w = x + g * (o && w > x ? 1 : -1)),
      (p = O + h * Math.cos(w)),
      (v = S + d * Math.sin(w)),
      (m = Gd(p, v, h, d, i, 0, o, L, R, [w, k, O, S]))
  }
  P = w - x
  var j = Math.cos(x),
    I = Math.sin(x),
    D = Math.cos(w),
    $ = Math.sin(w),
    B = Math.tan(P / 4),
    F = (4 / 3) * h * B,
    W = (4 / 3) * d * B,
    U = [u, f],
    K = [u + F * I, f - W * j],
    V = [p + F * $, v - W * D],
    H = [p, v]
  if (((K[0] = 2 * U[0] - K[0]), (K[1] = 2 * U[1] - K[1]), l)) return K.concat(V, H, m)
  m = K.concat(V, H, m)
  for (var Q = [], tt = 0, it = m.length; tt < it; tt += 1)
    Q[tt] = tt % 2 ? Us(m[tt - 1], m[tt], y).y : Us(m[tt], m[tt + 1], y).x
  return Q
}
function XA(t, e, n, r, i, a) {
  var o = 0.3333333333333333,
    s = 2 / 3
  return [o * t + s * n, o * e + s * r, o * i + s * n, o * a + s * r, i, a]
}
function Nr(t, e, n) {
  var r = t[0],
    i = t[1],
    a = e[0],
    o = e[1]
  return [r + (a - r) * n, i + (o - i) * n]
}
var gv = function (t, e, n, r) {
  var i = 0.5,
    a = Nr([t, e], [n, r], i)
  return q(q([], a, !0), [n, r, n, r], !1)
}
function UA(t, e) {
  var n = t[0],
    r = t.slice(1).map(Number),
    i = r[0],
    a = r[1],
    o,
    s = e.x1,
    c = e.y1,
    l = e.x,
    u = e.y
  switch (('TQ'.includes(n) || ((e.qx = null), (e.qy = null)), n)) {
    case 'M':
      return (e.x = i), (e.y = a), t
    case 'A':
      return (
        (o = [s, c].concat(r)),
        ['C'].concat(Gd(o[0], o[1], o[2], o[3], o[4], o[5], o[6], o[7], o[8], o[9]))
      )
    case 'Q':
      return (
        (e.qx = i),
        (e.qy = a),
        (o = [s, c].concat(r)),
        ['C'].concat(XA(o[0], o[1], o[2], o[3], o[4], o[5]))
      )
    case 'L':
      return ['C'].concat(gv(s, c, i, a))
    case 'Z':
      return s === l && c === u ? ['C', s, c, l, u, l, u] : ['C'].concat(gv(s, c, l, u))
  }
  return t
}
function nh(t, e) {
  if ((e === void 0 && (e = !1), VA(t))) {
    var n = [].concat(t)
    return e ? [n, []] : n
  }
  for (
    var r = el(t), i = z({}, mb), a = [], o = '', s = r.length, c, l, u = [], f = 0;
    f < s;
    f += 1
  ) {
    r[f] && (o = r[f][0]), (a[f] = o)
    var h = UA(r[f], i)
    ;(r[f] = h),
      RA(r, a, f),
      (s = r.length),
      o === 'Z' && u.push(f),
      (c = r[f]),
      (l = c.length),
      (i.x1 = +c[l - 2]),
      (i.y1 = +c[l - 1]),
      (i.x2 = +c[l - 4] || i.x1),
      (i.y2 = +c[l - 3] || i.y1)
  }
  return e ? [r, u] : r
}
function qA(t) {
  return t.map(function (e) {
    return Array.isArray(e) ? [].concat(e) : e
  })
}
function KA(t) {
  var e = t
    .slice(1)
    .map(function (n, r, i) {
      return r ? i[r - 1].slice(-2).concat(n.slice(1)) : t[0].slice(1).concat(n.slice(1))
    })
    .map(function (n) {
      return n.map(function (r, i) {
        return n[n.length - i - 2 * (1 - (i % 2))]
      })
    })
    .reverse()
  return [['M'].concat(e[0].slice(0, 2))].concat(
    e.map(function (n) {
      return ['C'].concat(n.slice(2))
    })
  )
}
function Ze(t, e) {
  return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
}
function rh(t, e, n, r, i) {
  var a = Ze([t, e], [n, r]),
    o = { x: 0, y: 0 }
  if (typeof i == 'number')
    if (i <= 0) o = { x: t, y: e }
    else if (i >= a) o = { x: n, y: r }
    else {
      var s = Nr([t, e], [n, r], i / a),
        c = s[0],
        l = s[1]
      o = { x: c, y: l }
    }
  return {
    length: a,
    point: o,
    min: { x: Math.min(t, n), y: Math.min(e, r) },
    max: { x: Math.max(t, n), y: Math.max(e, r) }
  }
}
function yv(t, e) {
  var n = t.x,
    r = t.y,
    i = e.x,
    a = e.y,
    o = n * i + r * a,
    s = Math.sqrt((Math.pow(n, 2) + Math.pow(r, 2)) * (Math.pow(i, 2) + Math.pow(a, 2))),
    c = n * a - r * i < 0 ? -1 : 1,
    l = c * Math.acos(o / s)
  return l
}
function ZA(t, e, n, r, i, a, o, s, c, l) {
  var u = Math.abs,
    f = Math.sin,
    h = Math.cos,
    d = Math.sqrt,
    p = Math.PI,
    v = u(n),
    g = u(r),
    y = ((i % 360) + 360) % 360,
    m = y * (p / 180)
  if (t === s && e === c) return { x: t, y: e }
  if (v === 0 || g === 0) return rh(t, e, s, c, l).point
  var b = (t - s) / 2,
    x = (e - c) / 2,
    w = { x: h(m) * b + f(m) * x, y: -f(m) * b + h(m) * x },
    O = Math.pow(w.x, 2) / Math.pow(v, 2) + Math.pow(w.y, 2) / Math.pow(g, 2)
  O > 1 && ((v *= d(O)), (g *= d(O)))
  var S =
      Math.pow(v, 2) * Math.pow(g, 2) -
      Math.pow(v, 2) * Math.pow(w.y, 2) -
      Math.pow(g, 2) * Math.pow(w.x, 2),
    _ = Math.pow(v, 2) * Math.pow(w.y, 2) + Math.pow(g, 2) * Math.pow(w.x, 2),
    M = S / _
  M = M < 0 ? 0 : M
  var E = (a !== o ? 1 : -1) * d(M),
    T = { x: E * ((v * w.y) / g), y: E * (-(g * w.x) / v) },
    C = { x: h(m) * T.x - f(m) * T.y + (t + s) / 2, y: f(m) * T.x + h(m) * T.y + (e + c) / 2 },
    A = { x: (w.x - T.x) / v, y: (w.y - T.y) / g },
    P = yv({ x: 1, y: 0 }, A),
    k = { x: (-w.x - T.x) / v, y: (-w.y - T.y) / g },
    L = yv(A, k)
  !o && L > 0 ? (L -= 2 * p) : o && L < 0 && (L += 2 * p), (L %= 2 * p)
  var R = P + L * l,
    j = v * h(R),
    I = g * f(R),
    D = { x: h(m) * j - f(m) * I + C.x, y: f(m) * j + h(m) * I + C.y }
  return D
}
function QA(t, e, n, r, i, a, o, s, c, l, u) {
  var f,
    h = u.bbox,
    d = h === void 0 ? !0 : h,
    p = u.length,
    v = p === void 0 ? !0 : p,
    g = u.sampleSize,
    y = g === void 0 ? 30 : g,
    m = typeof l == 'number',
    b = t,
    x = e,
    w = 0,
    O = [b, x, w],
    S = [b, x],
    _ = 0,
    M = { x: 0, y: 0 },
    E = [{ x: b, y: x }]
  m && l <= 0 && (M = { x: b, y: x })
  for (var T = 0; T <= y; T += 1) {
    if (
      ((_ = T / y),
      (f = ZA(t, e, n, r, i, a, o, s, c, _)),
      (b = f.x),
      (x = f.y),
      d && E.push({ x: b, y: x }),
      v && (w += Ze(S, [b, x])),
      (S = [b, x]),
      m && w >= l && l > O[2])
    ) {
      var C = (w - l) / (w - O[2])
      M = { x: S[0] * (1 - C) + O[0] * C, y: S[1] * (1 - C) + O[1] * C }
    }
    O = [b, x, w]
  }
  return (
    m && l >= w && (M = { x: s, y: c }),
    {
      length: w,
      point: M,
      min: {
        x: Math.min.apply(
          null,
          E.map(function (A) {
            return A.x
          })
        ),
        y: Math.min.apply(
          null,
          E.map(function (A) {
            return A.y
          })
        )
      },
      max: {
        x: Math.max.apply(
          null,
          E.map(function (A) {
            return A.x
          })
        ),
        y: Math.max.apply(
          null,
          E.map(function (A) {
            return A.y
          })
        )
      }
    }
  )
}
function JA(t, e, n, r, i, a, o, s, c) {
  var l = 1 - c
  return {
    x:
      Math.pow(l, 3) * t +
      3 * Math.pow(l, 2) * c * n +
      3 * l * Math.pow(c, 2) * i +
      Math.pow(c, 3) * o,
    y:
      Math.pow(l, 3) * e +
      3 * Math.pow(l, 2) * c * r +
      3 * l * Math.pow(c, 2) * a +
      Math.pow(c, 3) * s
  }
}
function Ob(t, e, n, r, i, a, o, s, c, l) {
  var u,
    f = l.bbox,
    h = f === void 0 ? !0 : f,
    d = l.length,
    p = d === void 0 ? !0 : d,
    v = l.sampleSize,
    g = v === void 0 ? 10 : v,
    y = typeof c == 'number',
    m = t,
    b = e,
    x = 0,
    w = [m, b, x],
    O = [m, b],
    S = 0,
    _ = { x: 0, y: 0 },
    M = [{ x: m, y: b }]
  y && c <= 0 && (_ = { x: m, y: b })
  for (var E = 0; E <= g; E += 1) {
    if (
      ((S = E / g),
      (u = JA(t, e, n, r, i, a, o, s, S)),
      (m = u.x),
      (b = u.y),
      h && M.push({ x: m, y: b }),
      p && (x += Ze(O, [m, b])),
      (O = [m, b]),
      y && x >= c && c > w[2])
    ) {
      var T = (x - c) / (x - w[2])
      _ = { x: O[0] * (1 - T) + w[0] * T, y: O[1] * (1 - T) + w[1] * T }
    }
    w = [m, b, x]
  }
  return (
    y && c >= x && (_ = { x: o, y: s }),
    {
      length: x,
      point: _,
      min: {
        x: Math.min.apply(
          null,
          M.map(function (C) {
            return C.x
          })
        ),
        y: Math.min.apply(
          null,
          M.map(function (C) {
            return C.y
          })
        )
      },
      max: {
        x: Math.max.apply(
          null,
          M.map(function (C) {
            return C.x
          })
        ),
        y: Math.max.apply(
          null,
          M.map(function (C) {
            return C.y
          })
        )
      }
    }
  )
}
function tk(t, e, n, r, i, a, o) {
  var s = 1 - o
  return {
    x: Math.pow(s, 2) * t + 2 * s * o * n + Math.pow(o, 2) * i,
    y: Math.pow(s, 2) * e + 2 * s * o * r + Math.pow(o, 2) * a
  }
}
function ek(t, e, n, r, i, a, o, s) {
  var c,
    l = s.bbox,
    u = l === void 0 ? !0 : l,
    f = s.length,
    h = f === void 0 ? !0 : f,
    d = s.sampleSize,
    p = d === void 0 ? 10 : d,
    v = typeof o == 'number',
    g = t,
    y = e,
    m = 0,
    b = [g, y, m],
    x = [g, y],
    w = 0,
    O = { x: 0, y: 0 },
    S = [{ x: g, y }]
  v && o <= 0 && (O = { x: g, y })
  for (var _ = 0; _ <= p; _ += 1) {
    if (
      ((w = _ / p),
      (c = tk(t, e, n, r, i, a, w)),
      (g = c.x),
      (y = c.y),
      u && S.push({ x: g, y }),
      h && (m += Ze(x, [g, y])),
      (x = [g, y]),
      v && m >= o && o > b[2])
    ) {
      var M = (m - o) / (m - b[2])
      O = { x: x[0] * (1 - M) + b[0] * M, y: x[1] * (1 - M) + b[1] * M }
    }
    b = [g, y, m]
  }
  return (
    v && o >= m && (O = { x: i, y: a }),
    {
      length: m,
      point: O,
      min: {
        x: Math.min.apply(
          null,
          S.map(function (E) {
            return E.x
          })
        ),
        y: Math.min.apply(
          null,
          S.map(function (E) {
            return E.y
          })
        )
      },
      max: {
        x: Math.max.apply(
          null,
          S.map(function (E) {
            return E.x
          })
        ),
        y: Math.max.apply(
          null,
          S.map(function (E) {
            return E.y
          })
        )
      }
    }
  )
}
function Sb(t, e, n) {
  for (
    var r,
      i,
      a,
      o,
      s,
      c,
      l = el(t),
      u = typeof e == 'number',
      f,
      h = [],
      d,
      p = 0,
      v = 0,
      g = 0,
      y = 0,
      m,
      b = [],
      x = [],
      w = 0,
      O = { x: 0, y: 0 },
      S = O,
      _ = O,
      M = O,
      E = 0,
      T = 0,
      C = l.length;
    T < C;
    T += 1
  )
    (m = l[T]),
      (d = m[0]),
      (f = d === 'M'),
      (h = f ? h : [p, v].concat(m.slice(1))),
      f
        ? ((g = m[1]), (y = m[2]), (O = { x: g, y }), (S = O), (w = 0), u && e < 0.001 && (M = O))
        : d === 'L'
        ? ((r = rh(h[0], h[1], h[2], h[3], (e || 0) - E)),
          (w = r.length),
          (O = r.min),
          (S = r.max),
          (_ = r.point))
        : d === 'A'
        ? ((i = QA(h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7], h[8], (e || 0) - E, n || {})),
          (w = i.length),
          (O = i.min),
          (S = i.max),
          (_ = i.point))
        : d === 'C'
        ? ((a = Ob(h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7], (e || 0) - E, n || {})),
          (w = a.length),
          (O = a.min),
          (S = a.max),
          (_ = a.point))
        : d === 'Q'
        ? ((o = ek(h[0], h[1], h[2], h[3], h[4], h[5], (e || 0) - E, n || {})),
          (w = o.length),
          (O = o.min),
          (S = o.max),
          (_ = o.point))
        : d === 'Z' &&
          ((h = [p, v, g, y]),
          (s = rh(h[0], h[1], h[2], h[3], (e || 0) - E)),
          (w = s.length),
          (O = s.min),
          (S = s.max),
          (_ = s.point)),
      u && E < e && E + w >= e && (M = _),
      x.push(S),
      b.push(O),
      (E += w),
      (c = d !== 'Z' ? m.slice(-2) : [g, y]),
      (p = c[0]),
      (v = c[1])
  return (
    u && e >= E && (M = { x: p, y: v }),
    {
      length: E,
      point: M,
      min: {
        x: Math.min.apply(
          null,
          b.map(function (A) {
            return A.x
          })
        ),
        y: Math.min.apply(
          null,
          b.map(function (A) {
            return A.y
          })
        )
      },
      max: {
        x: Math.max.apply(
          null,
          x.map(function (A) {
            return A.x
          })
        ),
        y: Math.max.apply(
          null,
          x.map(function (A) {
            return A.y
          })
        )
      }
    }
  )
}
function nk(t, e) {
  return Sb(t, void 0, z(z({}, e), { bbox: !1, length: !0 })).length
}
function rk(t) {
  var e = t.length,
    n = e - 1
  return t.map(function (r, i) {
    return t.map(function (a, o) {
      var s = i + o,
        c
      return o === 0 || (t[s] && t[s][0] === 'M')
        ? ((c = t[s]), ['M'].concat(c.slice(-2)))
        : (s >= e && (s -= n), t[s])
    })
  })
}
function ik(t, e) {
  var n = t.length - 1,
    r = [],
    i = 0,
    a = 0,
    o = rk(t)
  return (
    o.forEach(function (s, c) {
      t.slice(1).forEach(function (l, u) {
        a += Ze(t[(c + u) % n].slice(-2), e[u % n].slice(-2))
      }),
        (r[c] = a),
        (a = 0)
    }),
    (i = r.indexOf(Math.min.apply(null, r))),
    o[i]
  )
}
function ak(t, e, n, r, i, a, o, s) {
  return (
    (3 *
      ((s - e) * (n + i) -
        (o - t) * (r + a) +
        r * (t - i) -
        n * (e - a) +
        s * (i + t / 3) -
        o * (a + e / 3))) /
    20
  )
}
function ok(t) {
  var e = 0,
    n = 0,
    r = 0
  return nh(t)
    .map(function (i) {
      var a
      switch (i[0]) {
        case 'M':
          return (e = i[1]), (n = i[2]), 0
        default:
          var o = i.slice(1),
            s = o[0],
            c = o[1],
            l = o[2],
            u = o[3],
            f = o[4],
            h = o[5]
          return (r = ak(e, n, s, c, l, u, f, h)), (a = i.slice(-2)), (e = a[0]), (n = a[1]), r
      }
    })
    .reduce(function (i, a) {
      return i + a
    }, 0)
}
function mv(t) {
  return ok(t) >= 0
}
function sk(t, e, n) {
  return Sb(t, e, z(z({}, n), { bbox: !1, length: !0 })).point
}
function ck(t, e) {
  e === void 0 && (e = 0.5)
  var n = t.slice(0, 2),
    r = t.slice(2, 4),
    i = t.slice(4, 6),
    a = t.slice(6, 8),
    o = Nr(n, r, e),
    s = Nr(r, i, e),
    c = Nr(i, a, e),
    l = Nr(o, s, e),
    u = Nr(s, c, e),
    f = Nr(l, u, e)
  return [['C'].concat(o, l, f), ['C'].concat(u, c, a)]
}
function bv(t) {
  return t.map(function (e, n, r) {
    var i = n && r[n - 1].slice(-2).concat(e.slice(1)),
      a = n ? Ob(i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7], i[8], { bbox: !1 }).length : 0,
      o
    return n ? (o = a ? ck(i) : [e, e]) : (o = [e]), { s: e, ss: o, l: a }
  })
}
function _b(t, e, n) {
  var r = bv(t),
    i = bv(e),
    a = r.length,
    o = i.length,
    s = r.filter(function (g) {
      return g.l
    }).length,
    c = i.filter(function (g) {
      return g.l
    }).length,
    l =
      r
        .filter(function (g) {
          return g.l
        })
        .reduce(function (g, y) {
          var m = y.l
          return g + m
        }, 0) / s || 0,
    u =
      i
        .filter(function (g) {
          return g.l
        })
        .reduce(function (g, y) {
          var m = y.l
          return g + m
        }, 0) / c || 0,
    f = n || Math.max(a, o),
    h = [l, u],
    d = [f - a, f - o],
    p = 0,
    v = [r, i].map(function (g, y) {
      return g.l === f
        ? g.map(function (m) {
            return m.s
          })
        : g
            .map(function (m, b) {
              return (p = b && d[y] && m.l >= h[y]), (d[y] -= p ? 1 : 0), p ? m.ss : [m.s]
            })
            .flat()
    })
  return v[0].length === v[1].length ? v : _b(v[0], v[1], f)
}
function xv(t) {
  var e = document.createElement('div')
  e.innerHTML = t
  var n = e.childNodes[0]
  return n && e.contains(n) && e.removeChild(n), n
}
function he(t, e) {
  if (t !== null) return { type: 'column', value: t, field: e }
}
function Hl(t, e) {
  const n = he(t, e)
  return Object.assign(Object.assign({}, n), { inferred: !0 })
}
function nl(t, e) {
  if (t !== null) return { type: 'column', value: t, field: e, visual: !0 }
}
function lk(t, e) {
  const n = he(t, e)
  return Object.assign(Object.assign({}, n), { constant: !1 })
}
function Yr(t, e) {
  const n = []
  for (const r of t) n[r] = e
  return n
}
function wt(t, e) {
  const n = t[e]
  if (!n) return [null, null]
  const { value: r, field: i = null } = n
  return [r, i]
}
function Yo(t, ...e) {
  for (const n of e)
    if (typeof n == 'string') {
      const [r, i] = wt(t, n)
      if (r !== null) return [r, i]
    } else return [n, null]
  return [null, null]
}
function Wd(t) {
  return t instanceof Date ? !1 : typeof t == 'object'
}
const Os = () => (t, e) => {
  const { encode: n } = e,
    { y1: r } = n
  return r !== void 0 ? [t, e] : [t, X({}, e, { encode: { y1: Hl(Yr(t, 0)) } })]
}
Os.props = {}
function ae(t, e) {
  return t == null || e == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
}
function uk(t, e) {
  return t == null || e == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN
}
function Pa(t) {
  let e, n, r
  t.length !== 2
    ? ((e = ae), (n = (s, c) => ae(t(s), c)), (r = (s, c) => t(s) - c))
    : ((e = t === ae || t === uk ? t : fk), (n = t), (r = t))
  function i(s, c, l = 0, u = s.length) {
    if (l < u) {
      if (e(c, c) !== 0) return u
      do {
        const f = (l + u) >>> 1
        n(s[f], c) < 0 ? (l = f + 1) : (u = f)
      } while (l < u)
    }
    return l
  }
  function a(s, c, l = 0, u = s.length) {
    if (l < u) {
      if (e(c, c) !== 0) return u
      do {
        const f = (l + u) >>> 1
        n(s[f], c) <= 0 ? (l = f + 1) : (u = f)
      } while (l < u)
    }
    return l
  }
  function o(s, c, l = 0, u = s.length) {
    const f = i(s, c, l, u - 1)
    return f > l && r(s[f - 1], c) > -r(s[f], c) ? f - 1 : f
  }
  return { left: i, center: o, right: a }
}
function fk() {
  return 0
}
function ih(t) {
  return t === null ? NaN : +t
}
function* hk(t, e) {
  if (e === void 0) for (let n of t) n != null && (n = +n) >= n && (yield n)
  else {
    let n = -1
    for (let r of t) (r = e(r, ++n, t)) != null && (r = +r) >= r && (yield r)
  }
}
const Mb = Pa(ae),
  dk = Mb.right,
  pk = Mb.left,
  vk = Pa(ih).center,
  gk = dk
function Eb(t, e) {
  let n = 0
  if (e === void 0) for (let r of t) r != null && (r = +r) >= r && ++n
  else {
    let r = -1
    for (let i of t) (i = e(i, ++r, t)) != null && (i = +i) >= i && ++n
  }
  return n
}
function yk(t, e) {
  let n = 0,
    r,
    i = 0,
    a = 0
  if (e === void 0)
    for (let o of t) o != null && (o = +o) >= o && ((r = o - i), (i += r / ++n), (a += r * (o - i)))
  else {
    let o = -1
    for (let s of t)
      (s = e(s, ++o, t)) != null &&
        (s = +s) >= s &&
        ((r = s - i), (i += r / ++n), (a += r * (s - i)))
  }
  if (n > 1) return a / (n - 1)
}
function Tb(t, e) {
  const n = yk(t, e)
  return n && Math.sqrt(n)
}
function br(t, e) {
  let n, r
  if (e === void 0)
    for (const i of t)
      i != null && (n === void 0 ? i >= i && (n = r = i) : (n > i && (n = i), r < i && (r = i)))
  else {
    let i = -1
    for (let a of t)
      (a = e(a, ++i, t)) != null &&
        (n === void 0 ? a >= a && (n = r = a) : (n > a && (n = a), r < a && (r = a)))
  }
  return [n, r]
}
class Ni {
  constructor() {
    ;(this._partials = new Float64Array(32)), (this._n = 0)
  }
  add(e) {
    const n = this._partials
    let r = 0
    for (let i = 0; i < this._n && i < 32; i++) {
      const a = n[i],
        o = e + a,
        s = Math.abs(e) < Math.abs(a) ? e - (o - a) : a - (o - e)
      s && (n[r++] = s), (e = o)
    }
    return (n[r] = e), (this._n = r + 1), this
  }
  valueOf() {
    const e = this._partials
    let n = this._n,
      r,
      i,
      a,
      o = 0
    if (n > 0) {
      for (o = e[--n]; n > 0 && ((r = o), (i = e[--n]), (o = r + i), (a = i - (o - r)), !a); );
      n > 0 &&
        ((a < 0 && e[n - 1] < 0) || (a > 0 && e[n - 1] > 0)) &&
        ((i = a * 2), (r = o + i), i == r - o && (o = r))
    }
    return o
  }
}
let mk = class extends Map {
  constructor(e, n = wk) {
    if (
      (super(),
      Object.defineProperties(this, { _intern: { value: new Map() }, _key: { value: n } }),
      e != null)
    )
      for (const [r, i] of e) this.set(r, i)
  }
  get(e) {
    return super.get(wv(this, e))
  }
  has(e) {
    return super.has(wv(this, e))
  }
  set(e, n) {
    return super.set(bk(this, e), n)
  }
  delete(e) {
    return super.delete(xk(this, e))
  }
}
function wv({ _intern: t, _key: e }, n) {
  const r = e(n)
  return t.has(r) ? t.get(r) : n
}
function bk({ _intern: t, _key: e }, n) {
  const r = e(n)
  return t.has(r) ? t.get(r) : (t.set(r, n), n)
}
function xk({ _intern: t, _key: e }, n) {
  const r = e(n)
  return t.has(r) && ((n = t.get(r)), t.delete(r)), n
}
function wk(t) {
  return t !== null && typeof t == 'object' ? t.valueOf() : t
}
function Ho(t) {
  return t
}
function qt(t, ...e) {
  return Vl(t, Ho, Ho, e)
}
function Yd(t, ...e) {
  return Vl(t, Array.from, Ho, e)
}
function Hd(t, e, ...n) {
  return Vl(t, Ho, e, n)
}
function Pb(t, e, ...n) {
  return Vl(t, Array.from, e, n)
}
function Vl(t, e, n, r) {
  return (function i(a, o) {
    if (o >= r.length) return n(a)
    const s = new mk(),
      c = r[o++]
    let l = -1
    for (const u of a) {
      const f = c(u, ++l, a),
        h = s.get(f)
      h ? h.push(u) : s.set(f, [u])
    }
    for (const [u, f] of s) s.set(u, i(f, o))
    return e(s)
  })(t, 0)
}
function Ok(t, e) {
  return Array.from(e, (n) => t[n])
}
function xr(t, ...e) {
  if (typeof t[Symbol.iterator] != 'function') throw new TypeError('values is not iterable')
  t = Array.from(t)
  let [n] = e
  if ((n && n.length !== 2) || e.length > 1) {
    const r = Uint32Array.from(t, (i, a) => a)
    return (
      e.length > 1
        ? ((e = e.map((i) => t.map(i))),
          r.sort((i, a) => {
            for (const o of e) {
              const s = Vo(o[i], o[a])
              if (s) return s
            }
          }))
        : ((n = t.map(n)), r.sort((i, a) => Vo(n[i], n[a]))),
      Ok(t, r)
    )
  }
  return t.sort(Ab(n))
}
function Ab(t = ae) {
  if (t === ae) return Vo
  if (typeof t != 'function') throw new TypeError('compare is not a function')
  return (e, n) => {
    const r = t(e, n)
    return r || r === 0 ? r : (t(n, n) === 0) - (t(e, e) === 0)
  }
}
function Vo(t, e) {
  return (t == null || !(t >= t)) - (e == null || !(e >= e)) || (t < e ? -1 : t > e ? 1 : 0)
}
function Sk(t, e, n) {
  return (
    e.length !== 2
      ? xr(Hd(t, e, n), ([r, i], [a, o]) => ae(i, o) || ae(r, a))
      : xr(qt(t, n), ([r, i], [a, o]) => e(i, o) || ae(r, a))
  ).map(([r]) => r)
}
var _k = Array.prototype,
  Mk = _k.slice
function Xu(t) {
  return () => t
}
const Ek = Math.sqrt(50),
  Tk = Math.sqrt(10),
  Pk = Math.sqrt(2)
function rl(t, e, n) {
  const r = (e - t) / Math.max(0, n),
    i = Math.floor(Math.log10(r)),
    a = r / Math.pow(10, i),
    o = a >= Ek ? 10 : a >= Tk ? 5 : a >= Pk ? 2 : 1
  let s, c, l
  return (
    i < 0
      ? ((l = Math.pow(10, -i) / o),
        (s = Math.round(t * l)),
        (c = Math.round(e * l)),
        s / l < t && ++s,
        c / l > e && --c,
        (l = -l))
      : ((l = Math.pow(10, i) * o),
        (s = Math.round(t / l)),
        (c = Math.round(e / l)),
        s * l < t && ++s,
        c * l > e && --c),
    c < s && 0.5 <= n && n < 2 ? rl(t, e, n * 2) : [s, c, l]
  )
}
function Ak(t, e, n) {
  if (((e = +e), (t = +t), (n = +n), !(n > 0))) return []
  if (t === e) return [t]
  const r = e < t,
    [i, a, o] = r ? rl(e, t, n) : rl(t, e, n)
  if (!(a >= i)) return []
  const s = a - i + 1,
    c = new Array(s)
  if (r)
    if (o < 0) for (let l = 0; l < s; ++l) c[l] = (a - l) / -o
    else for (let l = 0; l < s; ++l) c[l] = (a - l) * o
  else if (o < 0) for (let l = 0; l < s; ++l) c[l] = (i + l) / -o
  else for (let l = 0; l < s; ++l) c[l] = (i + l) * o
  return c
}
function ah(t, e, n) {
  return (e = +e), (t = +t), (n = +n), rl(t, e, n)[2]
}
function kk(t, e, n) {
  let r
  for (;;) {
    const i = ah(t, e, n)
    if (i === r || i === 0 || !isFinite(i)) return [t, e]
    i > 0
      ? ((t = Math.floor(t / i) * i), (e = Math.ceil(e / i) * i))
      : i < 0 && ((t = Math.ceil(t * i) / i), (e = Math.floor(e * i) / i)),
      (r = i)
  }
}
function Ck(t) {
  return Math.max(1, Math.ceil(Math.log(Eb(t)) / Math.LN2) + 1)
}
function Lk() {
  var t = Ho,
    e = br,
    n = Ck
  function r(i) {
    Array.isArray(i) || (i = Array.from(i))
    var a,
      o = i.length,
      s,
      c,
      l = new Array(o)
    for (a = 0; a < o; ++a) l[a] = t(i[a], a, i)
    var u = e(l),
      f = u[0],
      h = u[1],
      d = n(l, f, h)
    if (!Array.isArray(d)) {
      const b = h,
        x = +d
      if (
        (e === br && ([f, h] = kk(f, h, x)),
        (d = Ak(f, h, x)),
        d[0] <= f && (c = ah(f, h, x)),
        d[d.length - 1] >= h)
      )
        if (b >= h && e === br) {
          const w = ah(f, h, x)
          isFinite(w) &&
            (w > 0
              ? (h = (Math.floor(h / w) + 1) * w)
              : w < 0 && (h = (Math.ceil(h * -w) + 1) / -w))
        } else d.pop()
    }
    for (var p = d.length, v = 0, g = p; d[v] <= f; ) ++v
    for (; d[g - 1] > h; ) --g
    ;(v || g < p) && ((d = d.slice(v, g)), (p = g - v))
    var y = new Array(p + 1),
      m
    for (a = 0; a <= p; ++a)
      (m = y[a] = []), (m.x0 = a > 0 ? d[a - 1] : f), (m.x1 = a < p ? d[a] : h)
    if (isFinite(c)) {
      if (c > 0)
        for (a = 0; a < o; ++a)
          (s = l[a]) != null &&
            f <= s &&
            s <= h &&
            y[Math.min(p, Math.floor((s - f) / c))].push(i[a])
      else if (c < 0) {
        for (a = 0; a < o; ++a)
          if ((s = l[a]) != null && f <= s && s <= h) {
            const b = Math.floor((f - s) * c)
            y[Math.min(p, b + (d[b] <= s))].push(i[a])
          }
      }
    } else
      for (a = 0; a < o; ++a) (s = l[a]) != null && f <= s && s <= h && y[gk(d, s, 0, p)].push(i[a])
    return y
  }
  return (
    (r.value = function (i) {
      return arguments.length ? ((t = typeof i == 'function' ? i : Xu(i)), r) : t
    }),
    (r.domain = function (i) {
      return arguments.length ? ((e = typeof i == 'function' ? i : Xu([i[0], i[1]])), r) : e
    }),
    (r.thresholds = function (i) {
      return arguments.length
        ? ((n = typeof i == 'function' ? i : Xu(Array.isArray(i) ? Mk.call(i) : i)), r)
        : n
    }),
    r
  )
}
function Ct(t, e) {
  let n
  if (e === void 0) for (const r of t) r != null && (n < r || (n === void 0 && r >= r)) && (n = r)
  else {
    let r = -1
    for (let i of t) (i = e(i, ++r, t)) != null && (n < i || (n === void 0 && i >= i)) && (n = i)
  }
  return n
}
function qa(t, e) {
  let n,
    r = -1,
    i = -1
  if (e === void 0)
    for (const a of t) ++i, a != null && (n < a || (n === void 0 && a >= a)) && ((n = a), (r = i))
  else
    for (let a of t)
      (a = e(a, ++i, t)) != null && (n < a || (n === void 0 && a >= a)) && ((n = a), (r = i))
  return r
}
function gn(t, e) {
  let n
  if (e === void 0) for (const r of t) r != null && (n > r || (n === void 0 && r >= r)) && (n = r)
  else {
    let r = -1
    for (let i of t) (i = e(i, ++r, t)) != null && (n > i || (n === void 0 && i >= i)) && (n = i)
  }
  return n
}
function Xl(t, e) {
  let n,
    r = -1,
    i = -1
  if (e === void 0)
    for (const a of t) ++i, a != null && (n > a || (n === void 0 && a >= a)) && ((n = a), (r = i))
  else
    for (let a of t)
      (a = e(a, ++i, t)) != null && (n > a || (n === void 0 && a >= a)) && ((n = a), (r = i))
  return r
}
function Vd(t, e, n = 0, r = 1 / 0, i) {
  if (
    ((e = Math.floor(e)),
    (n = Math.floor(Math.max(0, n))),
    (r = Math.floor(Math.min(t.length - 1, r))),
    !(n <= e && e <= r))
  )
    return t
  for (i = i === void 0 ? Vo : Ab(i); r > n; ) {
    if (r - n > 600) {
      const c = r - n + 1,
        l = e - n + 1,
        u = Math.log(c),
        f = 0.5 * Math.exp((2 * u) / 3),
        h = 0.5 * Math.sqrt((u * f * (c - f)) / c) * (l - c / 2 < 0 ? -1 : 1),
        d = Math.max(n, Math.floor(e - (l * f) / c + h)),
        p = Math.min(r, Math.floor(e + ((c - l) * f) / c + h))
      Vd(t, e, d, p, i)
    }
    const a = t[e]
    let o = n,
      s = r
    for (lo(t, n, e), i(t[r], a) > 0 && lo(t, n, r); o < s; ) {
      for (lo(t, o, s), ++o, --s; i(t[o], a) < 0; ) ++o
      for (; i(t[s], a) > 0; ) --s
    }
    i(t[n], a) === 0 ? lo(t, n, s) : (++s, lo(t, s, r)),
      s <= e && (n = s + 1),
      e <= s && (r = s - 1)
  }
  return t
}
function lo(t, e, n) {
  const r = t[e]
  ;(t[e] = t[n]), (t[n] = r)
}
function Nk(t, e = ae) {
  let n,
    r = !1
  if (e.length === 1) {
    let i
    for (const a of t) {
      const o = e(a)
      ;(r ? ae(o, i) > 0 : ae(o, o) === 0) && ((n = a), (i = o), (r = !0))
    }
  } else for (const i of t) (r ? e(i, n) > 0 : e(i, i) === 0) && ((n = i), (r = !0))
  return n
}
function Ul(t, e, n) {
  if (((t = Float64Array.from(hk(t, n))), !(!(r = t.length) || isNaN((e = +e))))) {
    if (e <= 0 || r < 2) return gn(t)
    if (e >= 1) return Ct(t)
    var r,
      i = (r - 1) * e,
      a = Math.floor(i),
      o = Ct(Vd(t, a).subarray(0, a + 1)),
      s = gn(t.subarray(a + 1))
    return o + (s - o) * (i - a)
  }
}
function Rk(t, e, n = ih) {
  if (!isNaN((e = +e))) {
    if (((r = Float64Array.from(t, (s, c) => ih(n(t[c], c, t)))), e <= 0)) return Xl(r)
    if (e >= 1) return qa(r)
    var r,
      i = Uint32Array.from(t, (s, c) => c),
      a = r.length - 1,
      o = Math.floor(a * e)
    return (
      Vd(i, o, 0, a, (s, c) => Vo(r[s], r[c])),
      (o = Nk(i.subarray(0, o + 1), (s) => r[s])),
      o >= 0 ? o : -1
    )
  }
}
function Ik(t, e, n) {
  const r = Eb(t),
    i = Tb(t)
  return r && i ? Math.ceil(((n - e) * Math.cbrt(r)) / (3.49 * i)) : 1
}
function Xo(t, e) {
  let n = 0,
    r = 0
  if (e === void 0) for (let i of t) i != null && (i = +i) >= i && (++n, (r += i))
  else {
    let i = -1
    for (let a of t) (a = e(a, ++i, t)) != null && (a = +a) >= a && (++n, (r += a))
  }
  if (n) return r / n
}
function Xd(t, e) {
  return Ul(t, 0.5, e)
}
function jk(t, e) {
  return Rk(t, 0.5, e)
}
function* Dk(t) {
  for (const e of t) yield* e
}
function kb(t) {
  return Array.from(Dk(t))
}
function ua(t, e, n) {
  ;(t = +t), (e = +e), (n = (i = arguments.length) < 2 ? ((e = t), (t = 0), 1) : i < 3 ? 1 : +n)
  for (var r = -1, i = Math.max(0, Math.ceil((e - t) / n)) | 0, a = new Array(i); ++r < i; )
    a[r] = t + r * n
  return a
}
function Pn(t, e) {
  let n = 0
  if (e === void 0) for (let r of t) (r = +r) && (n += r)
  else {
    let r = -1
    for (let i of t) (i = +e(i, ++r, t)) && (n += i)
  }
  return n
}
var $k =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(a) {
      return a instanceof n
        ? a
        : new n(function (o) {
            o(a)
          })
    }
    return new (n || (n = Promise))(function (a, o) {
      function s(u) {
        try {
          l(r.next(u))
        } catch (f) {
          o(f)
        }
      }
      function c(u) {
        try {
          l(r.throw(u))
        } catch (f) {
          o(f)
        }
      }
      function l(u) {
        u.done ? a(u.value) : i(u.value).then(s, c)
      }
      l((r = r.apply(t, e || [])).next())
    })
  }
function Ri(t) {
  return t
}
function Ud(t) {
  return t.reduce(
    (e, n) =>
      (r, ...i) =>
        n(e(r, ...i), ...i),
    Ri
  )
}
function Bk(t) {
  return t.reduce(
    (e, n) => (r) =>
      $k(this, void 0, void 0, function* () {
        const i = yield e(r)
        return n(i)
      }),
    Ri
  )
}
function qd(t) {
  return t.replace(/( |^)[a-z]/g, (e) => e.toUpperCase())
}
function ql(t = '') {
  throw new Error(t)
}
function Kd(t, e) {
  const { attributes: n } = e,
    r = new Set(['id', 'className'])
  for (const [i, a] of Object.entries(n))
    r.has(i) || (i === 'transform' && t.attr(i, ''), t.attr(i, a))
}
function Gt(t) {
  return t != null && !Number.isNaN(t)
}
function Fk(t) {
  const e = new Map()
  return (n) => {
    if (e.has(n)) return e.get(n)
    const r = t(n)
    return e.set(n, r), r
  }
}
function zk(t, e) {
  const { transform: n } = t.style,
    i = ((a) => a === 'none' || a === void 0)(n) ? '' : n
  t.style.transform = `${i} ${e}`.trimStart()
}
function et(t, e) {
  return Cb(t, e) || {}
}
function Cb(t, e) {
  const n = Object.entries(t || {})
    .filter(([r]) => r.startsWith(e))
    .map(([r, i]) => [Q1(r.replace(e, '').trim()), i])
    .filter(([r]) => !!r)
  return n.length === 0 ? null : Object.fromEntries(n)
}
function Gk(t, e) {
  return Object.fromEntries(Object.entries(t).filter(([n]) => e.find((r) => n.startsWith(r))))
}
function Uu(t, ...e) {
  return Object.fromEntries(Object.entries(t).filter(([n]) => e.every((r) => !n.startsWith(r))))
}
function Ov(t, e) {
  if (t === void 0) return null
  if (typeof t == 'number') return t
  const n = +t.replace('%', '')
  return Number.isNaN(n) ? null : (n / 100) * e
}
function Uo(t) {
  return typeof t == 'object' && !(t instanceof Date) && t !== null && !Array.isArray(t)
}
function Er(t) {
  return t === null || t === !1
}
function Lb(t, e, n = 5, r = 0) {
  if (!(r >= n)) {
    for (const i of Object.keys(e)) {
      const a = e[i]
      !ki(a) || !ki(t[i]) ? (t[i] = a) : Lb(t[i], a, n, r + 1)
    }
    return t
  }
}
function ri(t, e) {
  return Object.entries(t).reduce((n, [r, i]) => ((n[r] = e(i, r, t)), n), {})
}
function Yi(t) {
  return t.map((e, n) => n)
}
function Wk(t) {
  return t[0]
}
function Nb(t) {
  return t[t.length - 1]
}
function Yk(t) {
  return Array.from(new Set(t))
}
function Rb(t, e) {
  const n = [[], []]
  return (
    t.forEach((r) => {
      n[e(r) ? 0 : 1].push(r)
    }),
    n
  )
}
function Ib(t, e = t.length) {
  if (e === 1) return t.map((r) => [r])
  const n = []
  for (let r = 0; r < t.length; r++) {
    const i = t.slice(r + 1)
    Ib(i, e - 1).forEach((o) => {
      n.push([t[r], ...o])
    })
  }
  return n
}
function Hk(t) {
  if (t.length === 1) return [t]
  const e = []
  for (let n = 1; n <= t.length; n++) e.push(...Ib(t, n))
  return e
}
function ii(t, e, n) {
  const { encode: r } = n
  if (t === null) return [e]
  const i = Vk(t)
      .map((o) => {
        var s
        return [o, (s = wt(r, o)) === null || s === void 0 ? void 0 : s[0]]
      })
      .filter(([, o]) => Gt(o)),
    a = (o) => i.map(([, s]) => s[o]).join('-')
  return Array.from(qt(e, a).values())
}
function jb(t) {
  return Array.isArray(t)
    ? qk(t)
    : typeof t == 'function'
    ? Uk(t)
    : t === 'series'
    ? Xk
    : t === 'value'
    ? Kk
    : t === 'sum'
    ? Zk
    : t === 'maxIndex'
    ? Qk
    : () => null
}
function Db(t, e) {
  for (const n of t) n.sort(e)
}
function $b(t, e) {
  return (e == null ? void 0 : e.domain) || Array.from(new Set(t))
}
function Vk(t) {
  return Array.isArray(t) ? t : [t]
}
function Xk(t, e, n) {
  return Ss((r) => n[r])
}
function Uk(t) {
  return (e, n, r) => Ss((i) => t(e[i]))
}
function qk(t) {
  return (e, n, r) => (i, a) => t.reduce((o, s) => (o !== 0 ? o : ae(e[i][s], e[a][s])), 0)
}
function Kk(t, e, n) {
  return Ss((r) => e[r])
}
function Zk(t, e, n) {
  const r = Yi(t),
    i = Array.from(qt(r, (o) => n[+o]).entries()),
    a = new Map(i.map(([o, s]) => [o, s.reduce((c, l) => c + +e[l])]))
  return Ss((o) => a.get(n[o]))
}
function Qk(t, e, n) {
  const r = Yi(t),
    i = Array.from(qt(r, (o) => n[+o]).entries()),
    a = new Map(i.map(([o, s]) => [o, qa(s, (c) => e[c])]))
  return Ss((o) => a.get(n[o]))
}
function Ss(t) {
  return (e, n) => ae(t(e), t(n))
}
const Bb = (t = {}) => {
  const {
    groupBy: e = 'x',
    orderBy: n = null,
    reverse: r = !1,
    y: i = 'y',
    y1: a = 'y1',
    series: o = !0
  } = t
  return (s, c) => {
    const { data: l, encode: u, style: f = {} } = c,
      [h, d] = wt(u, 'y'),
      [p, v] = wt(u, 'y1'),
      [g] = o ? Yo(u, 'series', 'color') : wt(u, 'color'),
      y = ii(e, s, c),
      b = jb(n)(l, h, g)
    b && Db(y, b)
    const x = new Array(s.length),
      w = new Array(s.length),
      O = new Array(s.length),
      S = [],
      _ = []
    for (const A of y) {
      r && A.reverse()
      const P = p ? +p[A[0]] : 0,
        k = [],
        L = []
      for (const F of A) {
        const W = (O[F] = +h[F] - P)
        W < 0 ? L.push(F) : W >= 0 && k.push(F)
      }
      const R = k.length > 0 ? k : L,
        j = L.length > 0 ? L : k
      let I = k.length - 1,
        D = 0
      for (; I > 0 && h[R[I]] === 0; ) I--
      for (; D < j.length - 1 && h[j[D]] === 0; ) D++
      S.push(R[I]), _.push(j[D])
      let $ = P
      for (const F of L.reverse()) {
        const W = O[F]
        $ = x[F] = (w[F] = $) + W
      }
      let B = P
      for (const F of k) {
        const W = O[F]
        W > 0 ? (B = x[F] = (w[F] = B) + W) : (x[F] = w[F] = B)
      }
    }
    const M = new Set(S),
      E = new Set(_),
      T = i === 'y' ? x : w,
      C = a === 'y' ? x : w
    return [
      s,
      X({}, c, {
        encode: { y0: Hl(h, d), y: he(T, d), y1: he(C, v) },
        style: Object.assign({ first: (A, P) => M.has(P), last: (A, P) => E.has(P) }, f)
      })
    ]
  }
}
Bb.props = {}
const Kl = (t = {}) => {
  const { channel: e = 'x' } = t
  return (n, r) => {
    const { encode: i } = r,
      { tooltip: a } = r
    if (Er(a)) return [n, r]
    const { title: o } = a
    if (o !== void 0) return [n, r]
    const s = Object.keys(i)
      .filter((l) => l.startsWith(e))
      .filter((l) => !i[l].inferred)
      .map((l) => wt(i, l))
      .filter(([l]) => l)
      .map((l) => l[0])
    if (s.length === 0) return [n, r]
    const c = []
    for (const l of n) c[l] = { value: s.map((u) => u[l]).join(', ') }
    return [n, X({}, r, { tooltip: { title: c } })]
  }
}
Kl.props = {}
const Hi = () => (t, e) => {
  const { encode: n } = e,
    { x: r } = n
  return r !== void 0
    ? [t, e]
    : [t, X({}, e, { encode: { x: Hl(Yr(t, 0)) }, scale: { x: { guide: null } } })]
}
Hi.props = {}
const Zl = () => (t, e) => {
  const { encode: n } = e,
    { y: r } = n
  return r !== void 0
    ? [t, e]
    : [t, X({}, e, { encode: { y: Hl(Yr(t, 0)) }, scale: { y: { guide: null } } })]
}
Zl.props = {}
const Fb = () => (t, e) => {
  const { encode: n } = e,
    { size: r } = n
  return r !== void 0 ? [t, e] : [t, X({}, e, { encode: { size: nl(Yr(t, 3)) } })]
}
Fb.props = {}
var Jk =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const zb = () => (t, e) => {
  const { encode: n } = e,
    { key: r } = n,
    i = Jk(n, ['key'])
  if (r !== void 0) return [t, e]
  const a = Object.values(i).map(({ value: s }) => s),
    o = t.map((s) =>
      a
        .filter(Array.isArray)
        .map((c) => c[s])
        .join('-')
    )
  return [t, X({}, e, { encode: { key: he(o) } })]
}
zb.props = {}
const Zd = () => (t, e) => {
  const { encode: n } = e,
    { series: r, color: i } = n
  if (r !== void 0 || i === void 0) return [t, e]
  const [a, o] = wt(n, 'color')
  return [t, X({}, e, { encode: { series: he(a, o) } })]
}
Zd.props = {}
const Gb = () => (t, e) => {
  const { data: n } = e
  return !Array.isArray(n) || n.some(Wd) ? [t, e] : [t, X({}, e, { encode: { y: he(n) } })]
}
Gb.props = {}
const Wb = () => (t, e) => {
  const { data: n } = e
  return !Array.isArray(n) || n.some(Wd) ? [t, e] : [t, X({}, e, { encode: { x: he(n) } })]
}
Wb.props = {}
const Yb = () => (t, e) => {
  const { encode: n } = e,
    { y1: r } = n
  if (r) return [t, e]
  const [i] = wt(n, 'y')
  return [t, X({}, e, { encode: { y1: he([...i]) } })]
}
Yb.props = {}
const Hb = () => (t, e) => {
  const { encode: n } = e,
    { x1: r } = n
  if (r) return [t, e]
  const [i] = wt(n, 'x')
  return [t, X({}, e, { encode: { x1: he([...i]) } })]
}
Hb.props = {}
const Ql = (t) => {
  const { channel: e } = t
  return (n, r) => {
    const { encode: i, tooltip: a } = r
    if (Er(a)) return [n, r]
    const { items: o = [] } = a
    if (!o || o.length > 0) return [n, r]
    const c = (Array.isArray(e) ? e : [e]).flatMap((l) =>
      Object.keys(i)
        .filter((u) => u.startsWith(l))
        .map((u) => {
          const { field: f, value: h, inferred: d = !1, aggregate: p } = i[u]
          return d ? null : p && h ? { channel: u } : f ? { field: f } : h ? { channel: u } : null
        })
        .filter((u) => u !== null)
    )
    return [n, X({}, r, { tooltip: { items: c } })]
  }
}
Ql.props = {}
const Qd = () => (t, e) => [t, X({ scale: { x: { padding: 0 }, y: { padding: 0 } } }, e)]
Qd.props = {}
var Sv =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const Jl = () => (t, e) => {
  const { data: n, style: r = {} } = e,
    i = Sv(e, ['data', 'style']),
    { x: a, y: o } = r,
    s = Sv(r, ['x', 'y'])
  if (a == null || o == null) return [t, e]
  const c = a || 0,
    l = o || 0
  return [
    [0],
    X({}, i, {
      data: [0],
      cartesian: !0,
      encode: { x: he([c]), y: he([l]) },
      scale: {
        x: { type: 'identity', independent: !0, guide: null },
        y: { type: 'identity', independent: !0, guide: null }
      },
      style: s
    })
  ]
}
Jl.props = {}
const Vb = () => (t, e) => {
  const { style: n = {} } = e
  return [
    t,
    X({}, e, {
      style: Object.assign(
        Object.assign({}, n),
        Object.fromEntries(
          Object.entries(n)
            .filter(([, r]) => typeof r == 'function')
            .map(([r, i]) => [r, () => i])
        )
      )
    })
  ]
}
Vb.props = {}
const tu = () => (t, e) => {
  const { data: n } = e
  if (!Array.isArray(n) || n.some(Wd)) return [t, e]
  const r = Array.isArray(n[0]) ? n : [n],
    i = r.map((o) => o[0]),
    a = r.map((o) => o[1])
  return [t, X({}, e, { encode: { x: he(i), y: he(a) } })]
}
tu.props = {}
const Xb = () => (t, e) => {
  const { style: n = {}, encode: r } = e,
    { series: i } = r,
    { gradient: a } = n
  return !a || i ? [t, e] : [t, X({}, e, { encode: { series: nl(Yr(t, void 0)) } })]
}
Xb.props = {}
var t5 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const Ub = (t = {}) => {
  const { groupBy: e = 'x', reverse: n = !1, orderBy: r, padding: i } = t
  return (
    t5(t, ['groupBy', 'reverse', 'orderBy', 'padding']),
    (a, o) => {
      const { data: s, encode: c, scale: l } = o,
        { series: u } = l,
        [f] = wt(c, 'y'),
        [h] = Yo(c, 'series', 'color'),
        d = $b(h, u),
        p = ii(e, a, o),
        g = jb(r)(s, f, h)
      g && Db(p, g)
      const y = new Array(a.length)
      for (const m of p) {
        n && m.reverse()
        for (let b = 0; b < m.length; b++) y[m[b]] = d[b]
      }
      return [
        a,
        X({}, o, { scale: { series: { domain: d, paddingInner: i } }, encode: { series: he(y) } })
      ]
    }
  )
}
Ub.props = {}
const qb = (t) => {
  const {
    groupBy: e = ['x'],
    reducer: n = (o, s) => s[o[0]],
    orderBy: r = null,
    reverse: i = !1,
    duration: a
  } = t
  return (o, s) => {
    const { encode: c } = s,
      u = (Array.isArray(e) ? e : [e]).map((g) => [g, wt(c, g)[0]])
    if (u.length === 0) return [o, s]
    let f = [o]
    for (const [, g] of u) {
      const y = []
      for (const m of f) {
        const b = Array.from(qt(m, (x) => g[x]).values())
        y.push(...b)
      }
      f = y
    }
    if (r) {
      const [g] = wt(c, r)
      g && f.sort((y, m) => n(y, g) - n(m, g)), i && f.reverse()
    }
    const h = (a || 3e3) / f.length,
      [d] = a ? [Yr(o, h)] : Yo(c, 'enterDuration', Yr(o, h)),
      [p] = Yo(c, 'enterDelay', Yr(o, 0)),
      v = new Array(o.length)
    for (let g = 0, y = 0; g < f.length; g++) {
      const m = f[g],
        b = Ct(m, (x) => +d[x])
      for (const x of m) v[x] = +p[x] + y
      y += b
    }
    return [o, X({}, s, { encode: { enterDuration: nl(d), enterDelay: nl(v) } })]
  }
}
qb.props = {}
var e5 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function n5(t) {
  return typeof t == 'function'
    ? t
    : {
        min: (n, r) => gn(n, (i) => r[+i]),
        max: (n, r) => Ct(n, (i) => r[+i]),
        first: (n, r) => r[n[0]],
        last: (n, r) => r[n[n.length - 1]],
        mean: (n, r) => Xo(n, (i) => r[+i]),
        median: (n, r) => Xd(n, (i) => r[+i]),
        sum: (n, r) => Pn(n, (i) => r[+i]),
        deviation: (n, r) => Tb(n, (i) => r[+i])
      }[t] || Ct
}
const Kb = (t = {}) => {
  const { groupBy: e = 'x', basis: n = 'max' } = t
  return (r, i) => {
    const { encode: a, tooltip: o } = i,
      s = e5(a, ['x']),
      c = Object.entries(s)
        .filter(([p]) => p.startsWith('y'))
        .map(([p]) => [p, wt(a, p)[0]]),
      [, l] = c.find(([p]) => p === 'y'),
      u = c.map(([p]) => [p, new Array(r.length)]),
      f = ii(e, r, i),
      h = n5(n)
    for (const p of f) {
      const v = h(p, l)
      for (const g of p)
        for (let y = 0; y < c.length; y++) {
          const [, m] = c[y],
            [, b] = u[y]
          b[g] = +m[g] / v
        }
    }
    const d =
      Er(o) || ((o == null ? void 0 : o.items) && (o == null ? void 0 : o.items.length) !== 0)
    return [
      r,
      X(
        {},
        i,
        Object.assign(
          { encode: Object.fromEntries(u.map(([p, v]) => [p, he(v, wt(a, p)[1])])) },
          !d && a.y0 && { tooltip: { items: [{ channel: 'y0' }] } }
        )
      )
    ]
  }
}
Kb.props = {}
function Xr(t, ...e) {
  return e.reduce((n, r) => (i) => n(r(i)), t)
}
function Aa(t, e) {
  return e - t ? (n) => (n - t) / (e - t) : (n) => 0.5
}
function r5(t, e) {
  const n = e < t ? e : t,
    r = t > e ? t : e
  return (i) => Math.min(Math.max(n, i), r)
}
function Jd(t, e, n, r, i) {
  let a = n || 0,
    o = r || t.length
  const s = i || ((c) => c)
  for (; a < o; ) {
    const c = Math.floor((a + o) / 2)
    s(t[c]) > e ? (o = c) : (a = c + 1)
  }
  return a
}
const oh = Math.sqrt(50),
  sh = Math.sqrt(10),
  ch = Math.sqrt(2)
function $c(t, e, n) {
  const r = (e - t) / Math.max(0, n),
    i = Math.floor(Math.log(r) / Math.LN10),
    a = r / 10 ** i
  return i >= 0
    ? (a >= oh ? 10 : a >= sh ? 5 : a >= ch ? 2 : 1) * 10 ** i
    : -(10 ** -i) / (a >= oh ? 10 : a >= sh ? 5 : a >= ch ? 2 : 1)
}
function _v(t, e, n) {
  const r = Math.abs(e - t) / Math.max(0, n)
  let i = 10 ** Math.floor(Math.log(r) / Math.LN10)
  const a = r / i
  return a >= oh ? (i *= 10) : a >= sh ? (i *= 5) : a >= ch && (i *= 2), e < t ? -i : i
}
const Zb = (t, e, n = 5) => {
    const r = [t, e]
    let i = 0,
      a = r.length - 1,
      o = r[i],
      s = r[a],
      c
    return (
      s < o && (([o, s] = [s, o]), ([i, a] = [a, i])),
      (c = $c(o, s, n)),
      c > 0
        ? ((o = Math.floor(o / c) * c), (s = Math.ceil(s / c) * c), (c = $c(o, s, n)))
        : c < 0 && ((o = Math.ceil(o * c) / c), (s = Math.floor(s * c) / c), (c = $c(o, s, n))),
      c > 0
        ? ((r[i] = Math.floor(o / c) * c), (r[a] = Math.ceil(s / c) * c))
        : c < 0 && ((r[i] = Math.ceil(o * c) / c), (r[a] = Math.floor(s * c) / c)),
      r
    )
  },
  qo = 1e3,
  Ko = qo * 60,
  Zo = Ko * 60,
  Ii = Zo * 24,
  ga = Ii * 7,
  Qb = Ii * 30,
  Jb = Ii * 365
function De(t, e, n, r) {
  const i = (l, u) => {
      const f = (d) => r(d) % u === 0
      let h = u
      for (; h && !f(l); ) n(l, -1), (h -= 1)
      return l
    },
    a = (l, u) => {
      u && i(l, u), e(l)
    },
    o = (l, u) => {
      const f = new Date(+l)
      return a(f, u), f
    },
    s = (l, u) => {
      const f = new Date(+l - 1)
      return a(f, u), n(f, u), a(f), f
    }
  return {
    ceil: s,
    floor: o,
    range: (l, u, f, h) => {
      const d = [],
        p = Math.floor(f),
        v = h ? s(l, f) : s(l)
      for (let g = v; +g < +u; n(g, p), a(g)) d.push(new Date(+g))
      return d
    },
    duration: t
  }
}
const i5 = De(
    1,
    (t) => t,
    (t, e = 1) => {
      t.setTime(+t + e)
    },
    (t) => t.getTime()
  ),
  a5 = De(
    qo,
    (t) => {
      t.setMilliseconds(0)
    },
    (t, e = 1) => {
      t.setTime(+t + qo * e)
    },
    (t) => t.getSeconds()
  ),
  o5 = De(
    Ko,
    (t) => {
      t.setSeconds(0, 0)
    },
    (t, e = 1) => {
      t.setTime(+t + Ko * e)
    },
    (t) => t.getMinutes()
  ),
  s5 = De(
    Zo,
    (t) => {
      t.setMinutes(0, 0, 0)
    },
    (t, e = 1) => {
      t.setTime(+t + Zo * e)
    },
    (t) => t.getHours()
  ),
  c5 = De(
    Ii,
    (t) => {
      t.setHours(0, 0, 0, 0)
    },
    (t, e = 1) => {
      t.setTime(+t + Ii * e)
    },
    (t) => t.getDate() - 1
  ),
  tx = De(
    Qb,
    (t) => {
      t.setDate(1), t.setHours(0, 0, 0, 0)
    },
    (t, e = 1) => {
      const n = t.getMonth()
      t.setMonth(n + e)
    },
    (t) => t.getMonth()
  ),
  l5 = De(
    ga,
    (t) => {
      t.setDate(t.getDate() - (t.getDay() % 7)), t.setHours(0, 0, 0, 0)
    },
    (t, e = 1) => {
      t.setTime(+t + ga * e)
    },
    (t) => {
      const e = tx.floor(t),
        n = new Date(+t)
      return Math.floor((+n - +e) / ga)
    }
  ),
  u5 = De(
    Jb,
    (t) => {
      t.setMonth(0, 1), t.setHours(0, 0, 0, 0)
    },
    (t, e = 1) => {
      const n = t.getFullYear()
      t.setFullYear(n + e)
    },
    (t) => t.getFullYear()
  ),
  ex = {
    millisecond: i5,
    second: a5,
    minute: o5,
    hour: s5,
    day: c5,
    week: l5,
    month: tx,
    year: u5
  },
  f5 = De(
    1,
    (t) => t,
    (t, e = 1) => {
      t.setTime(+t + e)
    },
    (t) => t.getTime()
  ),
  h5 = De(
    qo,
    (t) => {
      t.setUTCMilliseconds(0)
    },
    (t, e = 1) => {
      t.setTime(+t + qo * e)
    },
    (t) => t.getUTCSeconds()
  ),
  d5 = De(
    Ko,
    (t) => {
      t.setUTCSeconds(0, 0)
    },
    (t, e = 1) => {
      t.setTime(+t + Ko * e)
    },
    (t) => t.getUTCMinutes()
  ),
  p5 = De(
    Zo,
    (t) => {
      t.setUTCMinutes(0, 0, 0)
    },
    (t, e = 1) => {
      t.setTime(+t + Zo * e)
    },
    (t) => t.getUTCHours()
  ),
  v5 = De(
    Ii,
    (t) => {
      t.setUTCHours(0, 0, 0, 0)
    },
    (t, e = 1) => {
      t.setTime(+t + Ii * e)
    },
    (t) => t.getUTCDate() - 1
  ),
  nx = De(
    Qb,
    (t) => {
      t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0)
    },
    (t, e = 1) => {
      const n = t.getUTCMonth()
      t.setUTCMonth(n + e)
    },
    (t) => t.getUTCMonth()
  ),
  g5 = De(
    ga,
    (t) => {
      t.setUTCDate(t.getUTCDate() - ((t.getUTCDay() + 7) % 7)), t.setUTCHours(0, 0, 0, 0)
    },
    (t, e = 1) => {
      t.setTime(+t + ga * e)
    },
    (t) => {
      const e = nx.floor(t),
        n = new Date(+t)
      return Math.floor((+n - +e) / ga)
    }
  ),
  y5 = De(
    Jb,
    (t) => {
      t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0)
    },
    (t, e = 1) => {
      const n = t.getUTCFullYear()
      t.setUTCFullYear(n + e)
    },
    (t) => t.getUTCFullYear()
  ),
  rx = { millisecond: f5, second: h5, minute: d5, hour: p5, day: v5, week: g5, month: nx, year: y5 }
function m5(t) {
  const e = t ? rx : ex,
    { year: n, month: r, week: i, day: a, hour: o, minute: s, second: c, millisecond: l } = e
  return {
    tickIntervals: [
      [c, 1],
      [c, 5],
      [c, 15],
      [c, 30],
      [s, 1],
      [s, 5],
      [s, 15],
      [s, 30],
      [o, 1],
      [o, 3],
      [o, 6],
      [o, 12],
      [a, 1],
      [a, 2],
      [i, 1],
      [r, 1],
      [r, 3],
      [n, 1]
    ],
    year: n,
    millisecond: l
  }
}
function ix(t, e, n, r, i) {
  const a = +t,
    o = +e,
    { tickIntervals: s, year: c, millisecond: l } = m5(i),
    u = ([g, y]) => g.duration * y,
    f = r ? (o - a) / r : n || 5,
    h = r || (o - a) / f,
    d = s.length,
    p = Jd(s, h, 0, d, u)
  let v
  if (p === d) {
    const g = _v(a / c.duration, o / c.duration, f)
    v = [c, g]
  } else if (p) {
    const g = h / u(s[p - 1]) < u(s[p]) / h,
      [y, m] = g ? s[p - 1] : s[p],
      b = r ? Math.ceil(r / y.duration) : m
    v = [y, b]
  } else {
    const g = Math.max(_v(a, o, f), 1)
    v = [l, g]
  }
  return v
}
const b5 = (t, e, n, r, i) => {
  const a = t > e,
    o = a ? e : t,
    s = a ? t : e,
    [c, l] = ix(o, s, n, r, i),
    u = [c.floor(o, l), c.ceil(s, l)]
  return a ? u.reverse() : u
}
var ax = function (t) {
    return t !== null && typeof t != 'function' && isFinite(t.length)
  },
  x5 = {}.toString,
  _s = function (t, e) {
    return x5.call(t) === '[object ' + e + ']'
  }
const ox = function (t) {
  return _s(t, 'Function')
}
var w5 = function (t) {
  return t == null
}
const sx = function (t) {
    return Array.isArray ? Array.isArray(t) : _s(t, 'Array')
  },
  O5 = function (t) {
    var e = typeof t
    return (t !== null && e === 'object') || e === 'function'
  }
function S5(t, e) {
  if (t) {
    var n
    if (sx(t)) for (var r = 0, i = t.length; r < i && ((n = e(t[r], r)), n !== !1); r++);
    else if (O5(t)) {
      for (var a in t) if (t.hasOwnProperty(a) && ((n = e(t[a], a)), n === !1)) break
    }
  }
}
var _5 = function (t) {
    return typeof t == 'object' && t !== null
  },
  Mv = function (t) {
    if (!_5(t) || !_s(t, 'Object')) return !1
    if (Object.getPrototypeOf(t) === null) return !0
    for (var e = t; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e)
    return Object.getPrototypeOf(t) === e
  }
const M5 = function (t) {
  return _s(t, 'String')
}
var Qo = function (t) {
    return _s(t, 'Number')
  },
  E5 = Object.values
    ? function (t) {
        return Object.values(t)
      }
    : function (t) {
        var e = []
        return (
          S5(t, function (n, r) {
            ;(ox(t) && r === 'prototype') || e.push(n)
          }),
          e
        )
      },
  T5 = function (t) {
    return t === null
  },
  P5 = function (t) {
    return t === void 0
  }
const A5 = function (t, e) {
  if (!ox(t)) throw new TypeError('Expected a function')
  var n = function () {
    for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i]
    var a = e ? e.apply(this, r) : r[0],
      o = n.cache
    if (o.has(a)) return o.get(a)
    var s = t.apply(this, r)
    return o.set(a, s), s
  }
  return (n.cache = new Map()), n
}
var k5 = 5
function cx(t, e, n, r) {
  ;(n = n || 0), (r = r || k5)
  for (var i in e)
    if (e.hasOwnProperty(i)) {
      var a = e[i]
      a !== null && Mv(a)
        ? (Mv(t[i]) || (t[i] = {}), n < r ? cx(t[i], a, n + 1, r) : (t[i] = e[i]))
        : sx(a)
        ? ((t[i] = []), (t[i] = t[i].concat(a)))
        : a !== void 0 && (t[i] = a)
    }
}
var il = function (t) {
    for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n]
    for (var r = 0; r < e.length; r += 1) cx(t, e[r])
    return t
  },
  lx = function (t, e) {
    if (!ax(t)) return -1
    var n = Array.prototype.indexOf
    if (n) return n.call(t, e)
    for (var r = -1, i = 0; i < t.length; i++)
      if (t[i] === e) {
        r = i
        break
      }
    return r
  }
const Wn = function (t) {
  return t
}
function ux(t) {
  return w5(t) ? 0 : ax(t) ? t.length : Object.keys(t).length
}
var qs
A5(
  function (t, e) {
    e === void 0 && (e = {})
    var n = e.fontSize,
      r = e.fontFamily,
      i = e.fontWeight,
      a = e.fontStyle,
      o = e.fontVariant
    return (
      qs || (qs = document.createElement('canvas').getContext('2d')),
      (qs.font = [a, o, i, n + 'px', r].join(' ')),
      qs.measureText(M5(t) ? t : '').width
    )
  },
  function (t, e) {
    return e === void 0 && (e = {}), NA([t], E5(e)).join('')
  }
)
function al(t) {
  return !P5(t) && !T5(t) && !Number.isNaN(t)
}
const fx = (t) => (e) => -t(-e),
  tp = (t, e) => {
    const n = Math.log(t),
      r =
        t === Math.E
          ? Math.log
          : t === 10
          ? Math.log10
          : t === 2
          ? Math.log2
          : (i) => Math.log(i) / n
    return e ? fx(r) : r
  },
  ep = (t, e) => {
    const n = t === Math.E ? Math.exp : (r) => t ** r
    return e ? fx(n) : n
  },
  C5 = (t, e, n, r) => {
    const i = t < 0,
      a = tp(r, i),
      o = ep(r, i),
      s = t > e,
      c = s ? e : t,
      l = s ? t : e,
      u = [o(Math.floor(a(c))), o(Math.ceil(a(l)))]
    return s ? u.reverse() : u
  },
  L5 = (t) => (e) => {
    const n = t(e)
    return Qo(n) ? Math.round(n) : n
  }
function hx(t, e) {
  return (n) => {
    ;(n.prototype.rescale = function () {
      this.initRange(), this.nice()
      const [r] = this.chooseTransforms()
      this.composeOutput(r, this.chooseClamp(r))
    }),
      (n.prototype.initRange = function () {
        const { interpolator: r } = this.options
        this.options.range = t(r)
      }),
      (n.prototype.composeOutput = function (r, i) {
        const { domain: a, interpolator: o, round: s } = this.getOptions(),
          c = e(a.map(r)),
          l = s ? L5(o) : o
        this.output = Xr(l, c, i, r)
      }),
      (n.prototype.invert = void 0)
  }
}
var dx = { exports: {} },
  N5 = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  },
  px = { exports: {} },
  R5 = function (e) {
    return !e || typeof e == 'string'
      ? !1
      : e instanceof Array ||
          Array.isArray(e) ||
          (e.length >= 0 &&
            (e.splice instanceof Function ||
              (Object.getOwnPropertyDescriptor(e, e.length - 1) &&
                e.constructor.name !== 'String')))
  },
  I5 = R5,
  j5 = Array.prototype.concat,
  D5 = Array.prototype.slice,
  Ev = (px.exports = function (e) {
    for (var n = [], r = 0, i = e.length; r < i; r++) {
      var a = e[r]
      I5(a) ? (n = j5.call(n, D5.call(a))) : n.push(a)
    }
    return n
  })
Ev.wrap = function (t) {
  return function () {
    return t(Ev(arguments))
  }
}
var $5 = px.exports,
  jo = N5,
  Ms = $5,
  vx = Object.hasOwnProperty,
  gx = Object.create(null)
for (var qu in jo) vx.call(jo, qu) && (gx[jo[qu]] = qu)
var dn = (dx.exports = { to: {}, get: {} })
dn.get = function (t) {
  var e = t.substring(0, 3).toLowerCase(),
    n,
    r
  switch (e) {
    case 'hsl':
      ;(n = dn.get.hsl(t)), (r = 'hsl')
      break
    case 'hwb':
      ;(n = dn.get.hwb(t)), (r = 'hwb')
      break
    default:
      ;(n = dn.get.rgb(t)), (r = 'rgb')
      break
  }
  return n ? { model: r, value: n } : null
}
dn.get.rgb = function (t) {
  if (!t) return null
  var e = /^#([a-f0-9]{3,4})$/i,
    n = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i,
    r =
      /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/,
    i =
      /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/,
    a = /^(\w+)$/,
    o = [0, 0, 0, 1],
    s,
    c,
    l
  if ((s = t.match(n))) {
    for (l = s[2], s = s[1], c = 0; c < 3; c++) {
      var u = c * 2
      o[c] = parseInt(s.slice(u, u + 2), 16)
    }
    l && (o[3] = parseInt(l, 16) / 255)
  } else if ((s = t.match(e))) {
    for (s = s[1], l = s[3], c = 0; c < 3; c++) o[c] = parseInt(s[c] + s[c], 16)
    l && (o[3] = parseInt(l + l, 16) / 255)
  } else if ((s = t.match(r))) {
    for (c = 0; c < 3; c++) o[c] = parseInt(s[c + 1], 0)
    s[4] && (s[5] ? (o[3] = parseFloat(s[4]) * 0.01) : (o[3] = parseFloat(s[4])))
  } else if ((s = t.match(i))) {
    for (c = 0; c < 3; c++) o[c] = Math.round(parseFloat(s[c + 1]) * 2.55)
    s[4] && (s[5] ? (o[3] = parseFloat(s[4]) * 0.01) : (o[3] = parseFloat(s[4])))
  } else
    return (s = t.match(a))
      ? s[1] === 'transparent'
        ? [0, 0, 0, 0]
        : vx.call(jo, s[1])
        ? ((o = jo[s[1]]), (o[3] = 1), o)
        : null
      : null
  for (c = 0; c < 3; c++) o[c] = Hr(o[c], 0, 255)
  return (o[3] = Hr(o[3], 0, 1)), o
}
dn.get.hsl = function (t) {
  if (!t) return null
  var e =
      /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/,
    n = t.match(e)
  if (n) {
    var r = parseFloat(n[4]),
      i = ((parseFloat(n[1]) % 360) + 360) % 360,
      a = Hr(parseFloat(n[2]), 0, 100),
      o = Hr(parseFloat(n[3]), 0, 100),
      s = Hr(isNaN(r) ? 1 : r, 0, 1)
    return [i, a, o, s]
  }
  return null
}
dn.get.hwb = function (t) {
  if (!t) return null
  var e =
      /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/,
    n = t.match(e)
  if (n) {
    var r = parseFloat(n[4]),
      i = ((parseFloat(n[1]) % 360) + 360) % 360,
      a = Hr(parseFloat(n[2]), 0, 100),
      o = Hr(parseFloat(n[3]), 0, 100),
      s = Hr(isNaN(r) ? 1 : r, 0, 1)
    return [i, a, o, s]
  }
  return null
}
dn.to.hex = function () {
  var t = Ms(arguments)
  return '#' + Ks(t[0]) + Ks(t[1]) + Ks(t[2]) + (t[3] < 1 ? Ks(Math.round(t[3] * 255)) : '')
}
dn.to.rgb = function () {
  var t = Ms(arguments)
  return t.length < 4 || t[3] === 1
    ? 'rgb(' + Math.round(t[0]) + ', ' + Math.round(t[1]) + ', ' + Math.round(t[2]) + ')'
    : 'rgba(' +
        Math.round(t[0]) +
        ', ' +
        Math.round(t[1]) +
        ', ' +
        Math.round(t[2]) +
        ', ' +
        t[3] +
        ')'
}
dn.to.rgb.percent = function () {
  var t = Ms(arguments),
    e = Math.round((t[0] / 255) * 100),
    n = Math.round((t[1] / 255) * 100),
    r = Math.round((t[2] / 255) * 100)
  return t.length < 4 || t[3] === 1
    ? 'rgb(' + e + '%, ' + n + '%, ' + r + '%)'
    : 'rgba(' + e + '%, ' + n + '%, ' + r + '%, ' + t[3] + ')'
}
dn.to.hsl = function () {
  var t = Ms(arguments)
  return t.length < 4 || t[3] === 1
    ? 'hsl(' + t[0] + ', ' + t[1] + '%, ' + t[2] + '%)'
    : 'hsla(' + t[0] + ', ' + t[1] + '%, ' + t[2] + '%, ' + t[3] + ')'
}
dn.to.hwb = function () {
  var t = Ms(arguments),
    e = ''
  return (
    t.length >= 4 && t[3] !== 1 && (e = ', ' + t[3]),
    'hwb(' + t[0] + ', ' + t[1] + '%, ' + t[2] + '%' + e + ')'
  )
}
dn.to.keyword = function (t) {
  return gx[t.slice(0, 3)]
}
function Hr(t, e, n) {
  return Math.min(Math.max(e, t), n)
}
function Ks(t) {
  var e = Math.round(t).toString(16).toUpperCase()
  return e.length < 2 ? '0' + e : e
}
var B5 = dx.exports
const F5 = Ld(B5)
function Ku(t, e, n) {
  let r = n
  return (
    r < 0 && (r += 1),
    r > 1 && (r -= 1),
    r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t
  )
}
function z5(t) {
  const e = t[0] / 360,
    n = t[1] / 100,
    r = t[2] / 100,
    i = t[3]
  if (n === 0) return [r * 255, r * 255, r * 255, i]
  const a = r < 0.5 ? r * (1 + n) : r + n - r * n,
    o = 2 * r - a,
    s = Ku(o, a, e + 1 / 3),
    c = Ku(o, a, e),
    l = Ku(o, a, e - 1 / 3)
  return [s * 255, c * 255, l * 255, i]
}
function Tv(t) {
  const e = F5.get(t)
  if (!e) return null
  const { model: n, value: r } = e
  return n === 'rgb' ? r : n === 'hsl' ? z5(r) : null
}
const Ur = (t, e) => (n) => t * (1 - n) + e * n,
  G5 = (t, e) => {
    const n = Tv(t),
      r = Tv(e)
    return n === null || r === null
      ? n
        ? () => t
        : () => e
      : (i) => {
          const a = new Array(4)
          for (let u = 0; u < 4; u += 1) {
            const f = n[u],
              h = r[u]
            a[u] = f * (1 - i) + h * i
          }
          const [o, s, c, l] = a
          return `rgba(${Math.round(o)}, ${Math.round(s)}, ${Math.round(c)}, ${l})`
        }
  },
  Es = (t, e) =>
    typeof t == 'number' && typeof e == 'number'
      ? Ur(t, e)
      : typeof t == 'string' && typeof e == 'string'
      ? G5(t, e)
      : () => t,
  W5 = (t, e) => {
    const n = Ur(t, e)
    return (r) => Math.round(n(r))
  }
function Y5(t, e) {
  const { second: n, minute: r, hour: i, day: a, week: o, month: s, year: c } = e
  return n.floor(t) < t
    ? '.SSS'
    : r.floor(t) < t
    ? ':ss'
    : i.floor(t) < t
    ? 'hh:mm'
    : a.floor(t) < t
    ? 'hh A'
    : s.floor(t) < t
    ? o.floor(t) < t
      ? 'MMM DD'
      : 'ddd DD'
    : c.floor(t) < t
    ? 'MMMM'
    : 'YYYY'
}
function Pv({ map: t, initKey: e }, n) {
  const r = e(n)
  return t.has(r) ? t.get(r) : n
}
function H5({ map: t, initKey: e }, n) {
  const r = e(n)
  return t.has(r) ? t.get(r) : (t.set(r, n), n)
}
function V5({ map: t, initKey: e }, n) {
  const r = e(n)
  return t.has(r) && ((n = t.get(r)), t.delete(r)), n
}
function X5(t) {
  return typeof t == 'object' ? t.valueOf() : t
}
class Av extends Map {
  constructor(e) {
    if ((super(), (this.map = new Map()), (this.initKey = X5), e !== null))
      for (const [n, r] of e) this.set(n, r)
  }
  get(e) {
    return super.get(Pv({ map: this.map, initKey: this.initKey }, e))
  }
  has(e) {
    return super.has(Pv({ map: this.map, initKey: this.initKey }, e))
  }
  set(e, n) {
    return super.set(H5({ map: this.map, initKey: this.initKey }, e), n)
  }
  delete(e) {
    return super.delete(V5({ map: this.map, initKey: this.initKey }, e))
  }
}
class Ts {
  constructor(e) {
    ;(this.options = il({}, this.getDefaultOptions())), this.update(e)
  }
  getOptions() {
    return this.options
  }
  update(e = {}) {
    ;(this.options = il({}, this.options, e)), this.rescale(e)
  }
  rescale(e) {}
}
const eu = Symbol('defaultUnknown')
function kv(t, e, n) {
  for (let r = 0; r < e.length; r += 1) t.has(e[r]) || t.set(n(e[r]), r)
}
function Cv(t) {
  const { value: e, from: n, to: r, mapper: i, notFoundReturn: a } = t
  let o = i.get(e)
  if (o === void 0) {
    if (a !== eu) return a
    ;(o = n.push(e) - 1), i.set(e, o)
  }
  return r[o % r.length]
}
function Lv(t) {
  return t instanceof Date
    ? (e) => `${e}`
    : typeof t == 'object'
    ? (e) => JSON.stringify(e)
    : (e) => e
}
let yx = class mx extends Ts {
  getDefaultOptions() {
    return { domain: [], range: [], unknown: eu }
  }
  constructor(e) {
    super(e)
  }
  map(e) {
    return (
      this.domainIndexMap.size === 0 && kv(this.domainIndexMap, this.getDomain(), this.domainKey),
      Cv({
        value: this.domainKey(e),
        mapper: this.domainIndexMap,
        from: this.getDomain(),
        to: this.getRange(),
        notFoundReturn: this.options.unknown
      })
    )
  }
  invert(e) {
    return (
      this.rangeIndexMap.size === 0 && kv(this.rangeIndexMap, this.getRange(), this.rangeKey),
      Cv({
        value: this.rangeKey(e),
        mapper: this.rangeIndexMap,
        from: this.getRange(),
        to: this.getDomain(),
        notFoundReturn: this.options.unknown
      })
    )
  }
  rescale(e) {
    const [n] = this.options.domain,
      [r] = this.options.range
    if (((this.domainKey = Lv(n)), (this.rangeKey = Lv(r)), !this.rangeIndexMap)) {
      ;(this.rangeIndexMap = new Map()), (this.domainIndexMap = new Map())
      return
    }
    ;(!e || e.range) && this.rangeIndexMap.clear(),
      (!e || e.domain || e.compare) && (this.domainIndexMap.clear(), (this.sortedDomain = void 0))
  }
  clone() {
    return new mx(this.options)
  }
  getRange() {
    return this.options.range
  }
  getDomain() {
    if (this.sortedDomain) return this.sortedDomain
    const { domain: e, compare: n } = this.options
    return (this.sortedDomain = n ? [...e].sort(n) : e), this.sortedDomain
  }
}
function U5(t) {
  const e = Math.min(...t)
  return t.map((n) => n / e)
}
function q5(t, e) {
  const n = t.length,
    r = e - n
  return r > 0 ? [...t, ...new Array(r).fill(1)] : r < 0 ? t.slice(0, e) : t
}
function K5(t) {
  return Math.round(t * 1e12) / 1e12
}
function Z5(t) {
  const { domain: e, range: n, paddingOuter: r, paddingInner: i, flex: a, round: o, align: s } = t,
    c = e.length,
    l = q5(a, c),
    [u, f] = n,
    h = f - u,
    d = (2 / c) * r + 1 - (1 / c) * i,
    p = h / d,
    v = (p * i) / c,
    g = p - c * v,
    y = U5(l),
    m = y.reduce((C, A) => C + A),
    b = g / m,
    x = new Av(
      e.map((C, A) => {
        const P = y[A] * b
        return [C, o ? Math.floor(P) : P]
      })
    ),
    w = new Av(
      e.map((C, A) => {
        const k = y[A] * b + v
        return [C, o ? Math.floor(k) : k]
      })
    ),
    O = Array.from(w.values()).reduce((C, A) => C + A),
    _ = (h - (O - (O / c) * i)) * s,
    M = u + _
  let E = o ? Math.round(M) : M
  const T = new Array(c)
  for (let C = 0; C < c; C += 1) {
    T[C] = K5(E)
    const A = e[C]
    E += w.get(A)
  }
  return { valueBandWidth: x, valueStep: w, adjustedRange: T }
}
function Q5(t) {
  var e
  const { domain: n } = t,
    r = n.length
  if (r === 0) return { valueBandWidth: void 0, valueStep: void 0, adjustedRange: [] }
  if (!!(!((e = t.flex) === null || e === void 0) && e.length)) return Z5(t)
  const { range: a, paddingOuter: o, paddingInner: s, round: c, align: l } = t
  let u,
    f,
    h = a[0]
  const p = a[1] - h,
    v = o * 2,
    g = r - s
  ;(u = p / Math.max(1, v + g)),
    c && (u = Math.floor(u)),
    (h += (p - u * (r - s)) * l),
    (f = u * (1 - s)),
    c && ((h = Math.round(h)), (f = Math.round(f)))
  const y = new Array(r).fill(0).map((m, b) => h + b * u)
  return { valueStep: u, valueBandWidth: f, adjustedRange: y }
}
let ka = class bx extends yx {
  getDefaultOptions() {
    return {
      domain: [],
      range: [0, 1],
      align: 0.5,
      round: !1,
      paddingInner: 0,
      paddingOuter: 0,
      padding: 0,
      unknown: eu,
      flex: []
    }
  }
  constructor(e) {
    super(e)
  }
  clone() {
    return new bx(this.options)
  }
  getStep(e) {
    return this.valueStep === void 0
      ? 1
      : typeof this.valueStep == 'number'
      ? this.valueStep
      : e === void 0
      ? Array.from(this.valueStep.values())[0]
      : this.valueStep.get(e)
  }
  getBandWidth(e) {
    return this.valueBandWidth === void 0
      ? 1
      : typeof this.valueBandWidth == 'number'
      ? this.valueBandWidth
      : e === void 0
      ? Array.from(this.valueBandWidth.values())[0]
      : this.valueBandWidth.get(e)
  }
  getRange() {
    return this.adjustedRange
  }
  getPaddingInner() {
    const { padding: e, paddingInner: n } = this.options
    return e > 0 ? e : n
  }
  getPaddingOuter() {
    const { padding: e, paddingOuter: n } = this.options
    return e > 0 ? e : n
  }
  rescale() {
    super.rescale()
    const { align: e, domain: n, range: r, round: i, flex: a } = this.options,
      {
        adjustedRange: o,
        valueBandWidth: s,
        valueStep: c
      } = Q5({
        align: e,
        range: r,
        round: i,
        flex: a,
        paddingInner: this.getPaddingInner(),
        paddingOuter: this.getPaddingOuter(),
        domain: n
      })
    ;(this.valueStep = c), (this.valueBandWidth = s), (this.adjustedRange = o)
  }
}
const qr = (t, e, n) => {
  let r,
    i,
    a = t,
    o = e
  if (a === o && n > 0) return [a]
  let s = $c(a, o, n)
  if (s === 0 || !Number.isFinite(s)) return []
  if (s > 0) {
    ;(a = Math.ceil(a / s)), (o = Math.floor(o / s)), (i = new Array((r = Math.ceil(o - a + 1))))
    for (let c = 0; c < r; c += 1) i[c] = (a + c) * s
  } else {
    ;(s = -s),
      (a = Math.ceil(a * s)),
      (o = Math.floor(o * s)),
      (i = new Array((r = Math.ceil(o - a + 1))))
    for (let c = 0; c < r; c += 1) i[c] = (a + c) / s
  }
  return i
}
let np = class xx extends Ts {
  getDefaultOptions() {
    return { range: [0], domain: [0, 1], unknown: void 0, tickCount: 5, tickMethod: qr }
  }
  map(e) {
    const [n] = this.options.range
    return n !== void 0 ? n : this.options.unknown
  }
  invert(e) {
    const [n] = this.options.range
    return e === n && n !== void 0 ? this.options.domain : []
  }
  getTicks() {
    const { tickMethod: e, domain: n, tickCount: r } = this.options,
      [i, a] = n
    return !Qo(i) || !Qo(a) ? [] : e(i, a, r)
  }
  clone() {
    return new xx(this.options)
  }
}
function uo(t) {
  return Math.abs(t) < 1e-15 ? t : parseFloat(t.toFixed(15))
}
const J5 = [1, 5, 2, 2.5, 4, 3],
  Nv = Number.EPSILON * 100
function t3(t, e) {
  return ((t % e) + e) % e
}
function e3(t) {
  return Math.round(t * 1e12) / 1e12
}
function n3(t, e, n, r, i, a) {
  const o = ux(e),
    s = lx(e, t)
  let c = 0
  const l = t3(r, a)
  return (l < Nv || a - l < Nv) && r <= 0 && i >= 0 && (c = 1), 1 - s / (o - 1) - n + c
}
function r3(t, e, n) {
  const r = ux(e),
    i = lx(e, t),
    a = 1
  return 1 - i / (r - 1) - n + a
}
function i3(t, e, n, r, i, a) {
  const o = (t - 1) / (a - i),
    s = (e - 1) / (Math.max(a, r) - Math.min(n, i))
  return 2 - Math.max(o / s, s / o)
}
function a3(t, e) {
  return t >= e ? 2 - (t - 1) / (e - 1) : 1
}
function o3(t, e, n, r) {
  const i = e - t
  return 1 - (0.5 * ((e - r) ** 2 + (t - n) ** 2)) / (0.1 * i) ** 2
}
function s3(t, e, n) {
  const r = e - t
  return n > r ? 1 - ((n - r) / 2) ** 2 / (0.1 * r) ** 2 : 1
}
function c3() {
  return 1
}
const rp = (t, e, n = 5, r = !0, i = J5, a = [0.25, 0.2, 0.5, 0.05]) => {
  const o = n < 0 ? 0 : Math.round(n)
  if (Number.isNaN(t) || Number.isNaN(e) || typeof t != 'number' || typeof e != 'number' || !o)
    return []
  if (e - t < 1e-15 || o === 1) return [t]
  const s = { score: -2, lmin: 0, lmax: 0, lstep: 0 }
  let c = 1
  for (; c < 1 / 0; ) {
    for (let p = 0; p < i.length; p += 1) {
      const v = i[p],
        g = r3(v, i, c)
      if (a[0] * g + a[1] + a[2] + a[3] < s.score) {
        c = 1 / 0
        break
      }
      let y = 2
      for (; y < 1 / 0; ) {
        const m = a3(y, o)
        if (a[0] * g + a[1] + a[2] * m + a[3] < s.score) break
        const b = (e - t) / (y + 1) / c / v
        let x = Math.ceil(Math.log10(b))
        for (; x < 1 / 0; ) {
          const w = c * v * 10 ** x,
            O = s3(t, e, w * (y - 1))
          if (a[0] * g + a[1] * O + a[2] * m + a[3] < s.score) break
          const S = Math.floor(e / w) * c - (y - 1) * c,
            _ = Math.ceil(t / w) * c
          if (S <= _) {
            const M = _ - S
            for (let E = 0; E <= M; E += 1) {
              const C = (S + E) * (w / c),
                A = C + w * (y - 1),
                P = w,
                k = n3(v, i, c, C, A, P),
                L = o3(t, e, C, A),
                R = i3(y, o, t, e, C, A),
                j = c3(),
                I = a[0] * k + a[1] * L + a[2] * R + a[3] * j
              I > s.score &&
                (!r || (C <= t && A >= e)) &&
                ((s.lmin = C), (s.lmax = A), (s.lstep = P), (s.score = I))
            }
          }
          x += 1
        }
        y += 1
      }
    }
    c += 1
  }
  const l = uo(s.lmax),
    u = uo(s.lmin),
    f = uo(s.lstep),
    h = Math.floor(e3((l - u) / f)) + 1,
    d = new Array(h)
  d[0] = uo(u)
  for (let p = 1; p < h; p += 1) d[p] = uo(d[p - 1] + f)
  return d
}
let wx = class Ox extends Ts {
  getDefaultOptions() {
    return { domain: [0, 1], range: [0, 1], tickCount: 5, unknown: void 0, tickMethod: rp }
  }
  map(e) {
    return al(e) ? e : this.options.unknown
  }
  invert(e) {
    return this.map(e)
  }
  clone() {
    return new Ox(this.options)
  }
  getTicks() {
    const { domain: e, tickCount: n, tickMethod: r } = this.options,
      [i, a] = e
    return !Qo(i) || !Qo(a) ? [] : r(i, a, n)
  }
}
const l3 = (t, e, n) => {
    const [r, i] = t,
      [a, o] = e
    let s, c
    return r < i ? ((s = Aa(r, i)), (c = n(a, o))) : ((s = Aa(i, r)), (c = n(o, a))), Xr(c, s)
  },
  u3 = (t, e, n) => {
    const r = Math.min(t.length, e.length) - 1,
      i = new Array(r),
      a = new Array(r),
      o = t[0] > t[r],
      s = o ? [...t].reverse() : t,
      c = o ? [...e].reverse() : e
    for (let l = 0; l < r; l += 1) (i[l] = Aa(s[l], s[l + 1])), (a[l] = n(c[l], c[l + 1]))
    return (l) => {
      const u = Jd(t, l, 1, r) - 1,
        f = i[u],
        h = a[u]
      return Xr(h, f)(l)
    }
  },
  Rv = (t, e, n, r) => (Math.min(t.length, e.length) > 2 ? u3 : l3)(t, e, r ? W5 : n)
let nu = class extends Ts {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        nice: !1,
        clamp: !1,
        round: !1,
        interpolate: Ur,
        tickCount: 5
      }
    }
    map(e) {
      return al(e) ? this.output(e) : this.options.unknown
    }
    invert(e) {
      return al(e) ? this.input(e) : this.options.unknown
    }
    nice() {
      if (!this.options.nice) return
      const [e, n, r, ...i] = this.getTickMethodOptions()
      this.options.domain = this.chooseNice()(e, n, r, ...i)
    }
    getTicks() {
      const { tickMethod: e } = this.options,
        [n, r, i, ...a] = this.getTickMethodOptions()
      return e(n, r, i, ...a)
    }
    getTickMethodOptions() {
      const { domain: e, tickCount: n } = this.options,
        r = e[0],
        i = e[e.length - 1]
      return [r, i, n]
    }
    chooseNice() {
      return Zb
    }
    rescale() {
      this.nice()
      const [e, n] = this.chooseTransforms()
      this.composeOutput(e, this.chooseClamp(e)), this.composeInput(e, n, this.chooseClamp(n))
    }
    chooseClamp(e) {
      const { clamp: n, range: r } = this.options,
        i = this.options.domain.map(e),
        a = Math.min(i.length, r.length)
      return n ? r5(i[0], i[a - 1]) : Wn
    }
    composeOutput(e, n) {
      const { domain: r, range: i, round: a, interpolate: o } = this.options,
        s = Rv(r.map(e), i, o, a)
      this.output = Xr(s, n, e)
    }
    composeInput(e, n, r) {
      const { domain: i, range: a } = this.options,
        o = Rv(a, i.map(e), Ur)
      this.input = Xr(n, r, o)
    }
  },
  Ft = class Sx extends nu {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        unknown: void 0,
        nice: !1,
        clamp: !1,
        round: !1,
        interpolate: Es,
        tickMethod: qr,
        tickCount: 5
      }
    }
    chooseTransforms() {
      return [Wn, Wn]
    }
    clone() {
      return new Sx(this.options)
    }
  },
  _x = class Mx extends ka {
    getDefaultOptions() {
      return {
        domain: [],
        range: [0, 1],
        align: 0.5,
        round: !1,
        padding: 0,
        unknown: eu,
        paddingInner: 1,
        paddingOuter: 0
      }
    }
    constructor(e) {
      super(e)
    }
    getPaddingInner() {
      return 1
    }
    clone() {
      return new Mx(this.options)
    }
    update(e) {
      super.update(e)
    }
    getPaddingOuter() {
      return this.options.padding
    }
  }
const f3 = (t) => (e) => e < 0 ? -((-e) ** t) : e ** t,
  h3 = (t) => (e) => e < 0 ? -((-e) ** (1 / t)) : e ** (1 / t),
  d3 = (t) => (t < 0 ? -Math.sqrt(-t) : Math.sqrt(t))
let Ex = class Tx extends nu {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        nice: !1,
        clamp: !1,
        round: !1,
        exponent: 2,
        interpolate: Es,
        tickMethod: qr,
        tickCount: 5
      }
    }
    constructor(e) {
      super(e)
    }
    chooseTransforms() {
      const { exponent: e } = this.options
      if (e === 1) return [Wn, Wn]
      const n = e === 0.5 ? d3 : f3(e),
        r = h3(e)
      return [n, r]
    }
    clone() {
      return new Tx(this.options)
    }
  },
  p3 = class Px extends Ex {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        nice: !1,
        clamp: !1,
        round: !1,
        interpolate: Es,
        tickMethod: qr,
        tickCount: 5,
        exponent: 0.5
      }
    }
    constructor(e) {
      super(e)
    }
    update(e) {
      super.update(e)
    }
    clone() {
      return new Px(this.options)
    }
  },
  ru = class Ax extends Ts {
    getDefaultOptions() {
      return { domain: [0.5], range: [0, 1] }
    }
    constructor(e) {
      super(e)
    }
    map(e) {
      if (!al(e)) return this.options.unknown
      const n = Jd(this.thresholds, e, 0, this.n)
      return this.options.range[n]
    }
    invert(e) {
      const { range: n } = this.options,
        r = n.indexOf(e),
        i = this.thresholds
      return [i[r - 1], i[r]]
    }
    clone() {
      return new Ax(this.options)
    }
    rescale() {
      const { domain: e, range: n } = this.options
      ;(this.n = Math.min(e.length, n.length - 1)), (this.thresholds = e)
    }
  }
const v3 = (t, e, n, r = 10) => {
  const i = t < 0,
    a = ep(r, i),
    o = tp(r, i),
    s = e < t,
    c = s ? e : t,
    l = s ? t : e
  let u = o(c),
    f = o(l),
    h = []
  if (!(r % 1) && f - u < n) {
    if (((u = Math.floor(u)), (f = Math.ceil(f)), i))
      for (; u <= f; u += 1) {
        const d = a(u)
        for (let p = r - 1; p >= 1; p -= 1) {
          const v = d * p
          if (v > l) break
          v >= c && h.push(v)
        }
      }
    else
      for (; u <= f; u += 1) {
        const d = a(u)
        for (let p = 1; p < r; p += 1) {
          const v = d * p
          if (v > l) break
          v >= c && h.push(v)
        }
      }
    h.length * 2 < n && (h = qr(c, l, n))
  } else {
    const d = n === -1 ? f - u : Math.min(f - u, n)
    h = qr(u, f, d).map(a)
  }
  return s ? h.reverse() : h
}
let g3 = class kx extends nu {
    getDefaultOptions() {
      return {
        domain: [1, 10],
        range: [0, 1],
        base: 10,
        interpolate: Es,
        tickMethod: v3,
        tickCount: 5
      }
    }
    chooseNice() {
      return C5
    }
    getTickMethodOptions() {
      const { domain: e, tickCount: n, base: r } = this.options,
        i = e[0],
        a = e[e.length - 1]
      return [i, a, n, r]
    }
    chooseTransforms() {
      const { base: e, domain: n } = this.options,
        r = n[0] < 0
      return [tp(e, r), ep(e, r)]
    }
    clone() {
      return new kx(this.options)
    }
  },
  Cx = class Lx extends ru {
    getDefaultOptions() {
      return { domain: [0, 1], range: [0.5], nice: !1, tickCount: 5, tickMethod: rp }
    }
    constructor(e) {
      super(e)
    }
    nice() {
      const { nice: e } = this.options
      if (e) {
        const [n, r, i] = this.getTickMethodOptions()
        this.options.domain = Zb(n, r, i)
      }
    }
    getTicks() {
      const { tickMethod: e } = this.options,
        [n, r, i] = this.getTickMethodOptions()
      return e(n, r, i)
    }
    getTickMethodOptions() {
      const { domain: e, tickCount: n } = this.options,
        r = e[0],
        i = e[e.length - 1]
      return [r, i, n]
    }
    rescale() {
      this.nice()
      const { range: e, domain: n } = this.options,
        [r, i] = n
      ;(this.n = e.length - 1), (this.thresholds = new Array(this.n))
      for (let a = 0; a < this.n; a += 1)
        this.thresholds[a] = ((a + 1) * i - (a - this.n) * r) / (this.n + 1)
    }
    invert(e) {
      const [n, r] = super.invert(e),
        [i, a] = this.options.domain
      return n === void 0 && r === void 0 ? [n, r] : [n || i, r || a]
    }
    getThresholds() {
      return this.thresholds
    }
    clone() {
      return new Lx(this.options)
    }
  }
function y3(t, e) {
  const n = t.length
  if (!n) return
  if (n < 2) return t[n - 1]
  const r = (n - 1) * e,
    i = Math.floor(r),
    a = t[i],
    o = t[i + 1]
  return a + (o - a) * (r - i)
}
function m3(t, e, n = !1) {
  const r = t
  n || r.sort((a, o) => a - o)
  const i = []
  for (let a = 1; a < e; a += 1) i.push(y3(r, a / e))
  return i
}
let Nx = class Rx extends ru {
  getDefaultOptions() {
    return { domain: [], range: [], tickCount: 5, unknown: void 0, tickMethod: rp }
  }
  constructor(e) {
    super(e)
  }
  rescale() {
    const { domain: e, range: n } = this.options
    ;(this.n = n.length - 1), (this.thresholds = m3(e, this.n + 1, !1))
  }
  invert(e) {
    const [n, r] = super.invert(e),
      { domain: i } = this.options,
      a = i[0],
      o = i[i.length - 1]
    return n === void 0 && r === void 0 ? [n, r] : [n || a, r || o]
  }
  getThresholds() {
    return this.thresholds
  }
  clone() {
    return new Rx(this.options)
  }
  getTicks() {
    const { tickCount: e, domain: n, tickMethod: r } = this.options,
      i = n.length - 1,
      a = n[0],
      o = n[i]
    return r(a, o, e)
  }
}
var b3 = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g,
  x3 = /\[([^]*?)\]/gm
function Ix(t, e) {
  for (var n = [], r = 0, i = t.length; r < i; r++) n.push(t[r].substr(0, e))
  return n
}
function lh(t) {
  for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n]
  for (var r = 0, i = e; r < i.length; r++) {
    var a = i[r]
    for (var o in a) t[o] = a[o]
  }
  return t
}
var jx = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
  Dx = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December'
  ],
  w3 = Ix(Dx, 3),
  O3 = Ix(jx, 3),
  S3 = {
    dayNamesShort: O3,
    dayNames: jx,
    monthNamesShort: w3,
    monthNames: Dx,
    amPm: ['am', 'pm'],
    DoFn: function (t) {
      return t + ['th', 'st', 'nd', 'rd'][t % 10 > 3 ? 0 : ((t - (t % 10) !== 10 ? 1 : 0) * t) % 10]
    }
  },
  _3 = lh({}, S3),
  Xe = function (t, e) {
    for (e === void 0 && (e = 2), t = String(t); t.length < e; ) t = '0' + t
    return t
  },
  M3 = {
    D: function (t) {
      return String(t.getDate())
    },
    DD: function (t) {
      return Xe(t.getDate())
    },
    Do: function (t, e) {
      return e.DoFn(t.getDate())
    },
    d: function (t) {
      return String(t.getDay())
    },
    dd: function (t) {
      return Xe(t.getDay())
    },
    ddd: function (t, e) {
      return e.dayNamesShort[t.getDay()]
    },
    dddd: function (t, e) {
      return e.dayNames[t.getDay()]
    },
    M: function (t) {
      return String(t.getMonth() + 1)
    },
    MM: function (t) {
      return Xe(t.getMonth() + 1)
    },
    MMM: function (t, e) {
      return e.monthNamesShort[t.getMonth()]
    },
    MMMM: function (t, e) {
      return e.monthNames[t.getMonth()]
    },
    YY: function (t) {
      return Xe(String(t.getFullYear()), 4).substr(2)
    },
    YYYY: function (t) {
      return Xe(t.getFullYear(), 4)
    },
    h: function (t) {
      return String(t.getHours() % 12 || 12)
    },
    hh: function (t) {
      return Xe(t.getHours() % 12 || 12)
    },
    H: function (t) {
      return String(t.getHours())
    },
    HH: function (t) {
      return Xe(t.getHours())
    },
    m: function (t) {
      return String(t.getMinutes())
    },
    mm: function (t) {
      return Xe(t.getMinutes())
    },
    s: function (t) {
      return String(t.getSeconds())
    },
    ss: function (t) {
      return Xe(t.getSeconds())
    },
    S: function (t) {
      return String(Math.round(t.getMilliseconds() / 100))
    },
    SS: function (t) {
      return Xe(Math.round(t.getMilliseconds() / 10), 2)
    },
    SSS: function (t) {
      return Xe(t.getMilliseconds(), 3)
    },
    a: function (t, e) {
      return t.getHours() < 12 ? e.amPm[0] : e.amPm[1]
    },
    A: function (t, e) {
      return t.getHours() < 12 ? e.amPm[0].toUpperCase() : e.amPm[1].toUpperCase()
    },
    ZZ: function (t) {
      var e = t.getTimezoneOffset()
      return (e > 0 ? '-' : '+') + Xe(Math.floor(Math.abs(e) / 60) * 100 + (Math.abs(e) % 60), 4)
    },
    Z: function (t) {
      var e = t.getTimezoneOffset()
      return (
        (e > 0 ? '-' : '+') + Xe(Math.floor(Math.abs(e) / 60), 2) + ':' + Xe(Math.abs(e) % 60, 2)
      )
    }
  },
  Iv = {
    default: 'ddd MMM DD YYYY HH:mm:ss',
    shortDate: 'M/D/YY',
    mediumDate: 'MMM D, YYYY',
    longDate: 'MMMM D, YYYY',
    fullDate: 'dddd, MMMM D, YYYY',
    isoDate: 'YYYY-MM-DD',
    isoDateTime: 'YYYY-MM-DDTHH:mm:ssZ',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  },
  E3 = function (t, e, n) {
    if (
      (e === void 0 && (e = Iv.default),
      n === void 0 && (n = {}),
      typeof t == 'number' && (t = new Date(t)),
      Object.prototype.toString.call(t) !== '[object Date]' || isNaN(t.getTime()))
    )
      throw new Error('Invalid Date pass to format')
    e = Iv[e] || e
    var r = []
    e = e.replace(x3, function (a, o) {
      return r.push(o), '@@@'
    })
    var i = lh(lh({}, _3), n)
    return (
      (e = e.replace(b3, function (a) {
        return M3[a](t, i)
      })),
      e.replace(/@@@/g, function () {
        return r.shift()
      })
    )
  }
const T3 = (t, e, n, r, i) => {
  const a = t > e,
    o = a ? e : t,
    s = a ? t : e,
    [c, l] = ix(o, s, n, r, i),
    u = c.range(o, new Date(+s + 1), l, !0)
  return a ? u.reverse() : u
}
function P3(t) {
  const e = t.getTimezoneOffset(),
    n = new Date(t)
  return n.setMinutes(n.getMinutes() + e, n.getSeconds(), n.getMilliseconds()), n
}
let A3 = class $x extends nu {
  getDefaultOptions() {
    return {
      domain: [new Date(2e3, 0, 1), new Date(2e3, 0, 2)],
      range: [0, 1],
      nice: !1,
      tickCount: 5,
      tickInterval: void 0,
      unknown: void 0,
      clamp: !1,
      tickMethod: T3,
      interpolate: Ur,
      mask: void 0,
      utc: !1
    }
  }
  chooseTransforms() {
    return [(r) => +r, (r) => new Date(r)]
  }
  chooseNice() {
    return b5
  }
  getTickMethodOptions() {
    const { domain: e, tickCount: n, tickInterval: r, utc: i } = this.options,
      a = e[0],
      o = e[e.length - 1]
    return [a, o, n, r, i]
  }
  getFormatter() {
    const { mask: e, utc: n } = this.options,
      r = n ? rx : ex,
      i = n ? P3 : Wn
    return (a) => E3(i(a), e || Y5(a, r))
  }
  clone() {
    return new $x(this.options)
  }
}
var k3 =
    (globalThis && globalThis.__decorate) ||
    function (t, e, n, r) {
      var i = arguments.length,
        a = i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, n)) : r,
        o
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
        a = Reflect.decorate(t, e, n, r)
      else
        for (var s = t.length - 1; s >= 0; s--)
          (o = t[s]) && (a = (i < 3 ? o(a) : i > 3 ? o(e, n, a) : o(e, n)) || a)
      return i > 3 && a && Object.defineProperty(e, n, a), a
    },
  uh
function C3(t) {
  return [t(0), t(1)]
}
const L3 = (t) => {
  const [e, n] = t
  return Xr(Ur(0, 1), Aa(e, n))
}
let fh = (uh = class extends Ft {
  getDefaultOptions() {
    return {
      domain: [0, 1],
      unknown: void 0,
      nice: !1,
      clamp: !1,
      round: !1,
      interpolator: Wn,
      tickMethod: qr,
      tickCount: 5
    }
  }
  constructor(e) {
    super(e)
  }
  clone() {
    return new uh(this.options)
  }
})
fh = uh = k3([hx(C3, L3)], fh)
var N3 =
    (globalThis && globalThis.__decorate) ||
    function (t, e, n, r) {
      var i = arguments.length,
        a = i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, n)) : r,
        o
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
        a = Reflect.decorate(t, e, n, r)
      else
        for (var s = t.length - 1; s >= 0; s--)
          (o = t[s]) && (a = (i < 3 ? o(a) : i > 3 ? o(e, n, a) : o(e, n)) || a)
      return i > 3 && a && Object.defineProperty(e, n, a), a
    },
  hh
function R3(t) {
  return [t(0), t(0.5), t(1)]
}
const I3 = (t) => {
  const [e, n, r] = t,
    i = Xr(Ur(0, 0.5), Aa(e, n)),
    a = Xr(Ur(0.5, 1), Aa(n, r))
  return (o) => (e > r ? (o < n ? a(o) : i(o)) : o < n ? i(o) : a(o))
}
let jv = (hh = class extends Ft {
  getDefaultOptions() {
    return {
      domain: [0, 0.5, 1],
      unknown: void 0,
      nice: !1,
      clamp: !1,
      round: !1,
      interpolator: Wn,
      tickMethod: qr,
      tickCount: 5
    }
  }
  constructor(e) {
    super(e)
  }
  clone() {
    return new hh(this.options)
  }
})
jv = hh = N3([hx(R3, I3)], jv)
function dh(t, e, n) {
  if (t === null) return [-0.5, 0.5]
  const r = $b(t, e),
    a = new ka({ domain: r, range: [0, 1], padding: n }).getBandWidth()
  return [-a / 2, a / 2]
}
function ph(t, e, n) {
  return e * (1 - t) + n * t
}
const Bx = (t = {}) => {
  const { padding: e = 0, paddingX: n = e, paddingY: r = e, random: i = Math.random } = t
  return (a, o) => {
    const { encode: s, scale: c } = o,
      { x: l, y: u } = c,
      [f] = wt(s, 'x'),
      [h] = wt(s, 'y'),
      d = dh(f, l, n),
      p = dh(h, u, r),
      v = a.map(() => ph(i(), ...p)),
      g = a.map(() => ph(i(), ...d))
    return [
      a,
      X({ scale: { x: { padding: 0.5 }, y: { padding: 0.5 } } }, o, {
        encode: { dy: he(v), dx: he(g) }
      })
    ]
  }
}
Bx.props = {}
const Fx = (t = {}) => {
  const { padding: e = 0, random: n = Math.random } = t
  return (r, i) => {
    const { encode: a, scale: o } = i,
      { x: s } = o,
      [c] = wt(a, 'x'),
      l = dh(c, s, e),
      u = r.map(() => ph(n(), ...l))
    return [r, X({ scale: { x: { padding: 0.5 } } }, i, { encode: { dx: he(u) } })]
  }
}
Fx.props = {}
var j3 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const zx = (t = {}) => {
  const { groupBy: e = 'x' } = t
  return (n, r) => {
    const { encode: i } = r,
      a = j3(i, ['x']),
      o = Object.entries(a)
        .filter(([f]) => f.startsWith('y'))
        .map(([f]) => [f, wt(i, f)[0]]),
      s = o.map(([f]) => [f, new Array(n.length)]),
      c = ii(e, n, r),
      l = new Array(c.length)
    for (let f = 0; f < c.length; f++) {
      const d = c[f].flatMap((g) => o.map(([, y]) => +y[g])),
        [p, v] = br(d)
      l[f] = (p + v) / 2
    }
    const u = Math.max(...l)
    for (let f = 0; f < c.length; f++) {
      const h = u - l[f],
        d = c[f]
      for (const p of d)
        for (let v = 0; v < o.length; v++) {
          const [, g] = o[v],
            [, y] = s[v]
          y[p] = +g[p] + h
        }
    }
    return [n, X({}, r, { encode: Object.fromEntries(s.map(([f, h]) => [f, he(h, wt(i, f)[1])])) })]
  }
}
zx.props = {}
const Gx = (t = {}) => {
  const { groupBy: e = 'x', series: n = !0 } = t
  return (r, i) => {
    const { encode: a } = i,
      [o] = wt(a, 'y'),
      [s, c] = wt(a, 'y1')
    n ? Yo(a, 'series', 'color') : wt(a, 'color')
    const l = ii(e, r, i),
      u = new Array(r.length)
    for (const f of l) {
      const h = f.map((d) => +o[d])
      for (let d = 0; d < f.length; d++) {
        const p = f[d],
          v = Math.max(...h.filter((g, y) => y !== d))
        u[p] = o[p] > v ? v : o[p]
      }
    }
    return [r, X({}, i, { encode: { y1: he(u, c) } })]
  }
}
Gx.props = {}
function Dv(t, e) {
  return [t[0]]
}
function D3(t, e) {
  const n = t.length - 1
  return [t[n]]
}
function $3(t, e) {
  const n = qa(t, (r) => e[r])
  return [t[n]]
}
function B3(t, e) {
  const n = Xl(t, (r) => e[r])
  return [t[n]]
}
function F3(t) {
  return typeof t == 'function' ? t : { first: Dv, last: D3, max: $3, min: B3 }[t] || Dv
}
const iu = (t = {}) => {
  const { groupBy: e = 'series', channel: n, selector: r } = t
  return (i, a) => {
    const { encode: o } = a,
      s = ii(e, i, a),
      [c] = wt(o, n),
      l = F3(r)
    return [s.flatMap((u) => l(u, c)), a]
  }
}
iu.props = {}
var z3 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const Wx = (t = {}) => {
  const { selector: e } = t,
    n = z3(t, ['selector'])
  return iu(Object.assign({ channel: 'x', selector: e }, n))
}
Wx.props = {}
var G3 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const Yx = (t = {}) => {
  const { selector: e } = t,
    n = G3(t, ['selector'])
  return iu(Object.assign({ channel: 'y', selector: e }, n))
}
Yx.props = {}
var W3 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function ai(t) {
  return (e) => (e === null ? t : `${t} of ${e}`)
}
function Y3(t) {
  if (typeof t == 'function') return [t, null]
  const n = { mean: H3, max: X3, count: q3, first: Z3, last: Q3, sum: K3, min: U3, median: V3 }[t]
  if (!n) throw new Error(`Unknown reducer: ${t}.`)
  return n()
}
function H3() {
  const t = (n, r) => Xo(n, (i) => +r[i]),
    e = ai('mean')
  return [t, e]
}
function V3() {
  const t = (n, r) => Xd(n, (i) => +r[i]),
    e = ai('median')
  return [t, e]
}
function X3() {
  const t = (n, r) => Ct(n, (i) => +r[i]),
    e = ai('max')
  return [t, e]
}
function U3() {
  const t = (n, r) => gn(n, (i) => +r[i]),
    e = ai('min')
  return [t, e]
}
function q3() {
  const t = (n, r) => n.length,
    e = ai('count')
  return [t, e]
}
function K3() {
  const t = (n, r) => Pn(n, (i) => +r[i]),
    e = ai('sum')
  return [t, e]
}
function Z3() {
  const t = (n, r) => r[n[0]],
    e = ai('first')
  return [t, e]
}
function Q3() {
  const t = (n, r) => r[n[n.length - 1]],
    e = ai('last')
  return [t, e]
}
const ip = (t = {}) => {
  const { groupBy: e } = t,
    n = W3(t, ['groupBy'])
  return (r, i) => {
    const { data: a, encode: o } = i,
      s = e(r, i)
    if (!s) return [r, i]
    const c = (d, p) => {
        if (d) return d
        const { from: v } = p
        if (!v) return d
        const [, g] = wt(o, v)
        return g
      },
      l = Object.entries(n).map(([d, p]) => {
        const [v, g] = Y3(p),
          [y, m] = wt(o, d),
          b = c(m, p),
          x = s.map((w) => v(w, y ?? a))
        return [
          d,
          Object.assign(Object.assign({}, lk(x, (g == null ? void 0 : g(b)) || b)), {
            aggregate: !0
          })
        ]
      }),
      u = Object.keys(o).map((d) => {
        const [p, v] = wt(o, d),
          g = s.map((y) => p[y[0]])
        return [d, he(g, v)]
      }),
      f = s.map((d) => a[d[0]])
    return [Yi(s), X({}, i, { data: f, encode: Object.fromEntries([...u, ...l]) })]
  }
}
ip.props = {}
var J3 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const Ps = (t = {}) => {
  const { channels: e = ['x', 'y'] } = t,
    n = J3(t, ['channels']),
    r = (i, a) => ii(e, i, a)
  return ip(Object.assign(Object.assign({}, n), { groupBy: r }))
}
Ps.props = {}
const Hx = (t = {}) =>
  Ps(Object.assign(Object.assign({}, t), { channels: ['x', 'color', 'series'] }))
Hx.props = {}
const Vx = (t = {}) =>
  Ps(Object.assign(Object.assign({}, t), { channels: ['y', 'color', 'series'] }))
Vx.props = {}
const Xx = (t = {}) => Ps(Object.assign(Object.assign({}, t), { channels: ['color'] }))
Xx.props = {}
var Ux =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function tC(t, e, n) {
  const { by: r = t, reducer: i = 'max' } = e,
    [a] = wt(n, r)
  if (typeof i == 'function') return (o) => i(o, a)
  if (i === 'max') return (o) => Ct(o, (s) => +a[s])
  if (i === 'min') return (o) => gn(o, (s) => +a[s])
  if (i === 'sum') return (o) => Pn(o, (s) => +a[s])
  if (i === 'median') return (o) => Xd(o, (s) => +a[s])
  if (i === 'mean') return (o) => Xo(o, (s) => +a[s])
  if (i === 'first') return (o) => a[o[0]]
  if (i === 'last') return (o) => a[o[o.length - 1]]
  throw new Error(`Unknown reducer: ${i}`)
}
function eC(t, e, n) {
  const { reverse: r, channel: i } = n,
    { encode: a } = e,
    [o] = wt(a, i),
    s = xr(t, (c) => o[c])
  return r && s.reverse(), [s, e]
}
function nC(t, e, n) {
  if (!Array.isArray(n)) return t
  const r = new Set(n)
  return t.filter((i) => r.has(e[i]))
}
function rC(t, e, n) {
  var r
  const { reverse: i, slice: a, channel: o } = n,
    s = Ux(n, ['reverse', 'slice', 'channel']),
    { encode: c, scale: l = {} } = e,
    u = (r = l[o]) === null || r === void 0 ? void 0 : r.domain,
    [f] = wt(c, o),
    h = tC(o, s, c),
    d = nC(t, f, u),
    p = Sk(d, h, (y) => f[y])
  i && p.reverse()
  const v = typeof a == 'number' ? [0, a] : a,
    g = a ? p.slice(...v) : p
  return [t, X(e, { scale: { [o]: { domain: g } } })]
}
const au = (t = {}) => {
  const { reverse: e = !1, slice: n, channel: r, ordinal: i = !0 } = t,
    a = Ux(t, ['reverse', 'slice', 'channel', 'ordinal'])
  return (o, s) =>
    i
      ? rC(o, s, Object.assign({ reverse: e, slice: n, channel: r }, a))
      : eC(o, s, Object.assign({ reverse: e, slice: n, channel: r }, a))
}
au.props = {}
const qx = (t = {}) => au(Object.assign(Object.assign({}, t), { channel: 'x' }))
qx.props = {}
const Kx = (t = {}) => au(Object.assign(Object.assign({}, t), { channel: 'color' }))
Kx.props = {}
const Zx = (t = {}) => au(Object.assign(Object.assign({}, t), { channel: 'y' }))
Zx.props = {}
function iC(t, e) {
  return typeof e == 'string' ? t.map((n) => n[e]) : t.map(e)
}
function aC(t, e) {
  if (typeof t == 'function') return (n) => t(n, e)
  if (t === 'sum') return (n) => Pn(n, (r) => +e[r])
  throw new Error(`Unknown reducer: ${t}`)
}
const Qx = (t = {}) => {
  const { field: e, channel: n = 'y', reducer: r = 'sum' } = t
  return (i, a) => {
    const { data: o, encode: s } = a,
      [c] = wt(s, 'x'),
      l = e ? iC(o, e) : wt(s, n)[0],
      u = aC(r, l),
      f = Pb(i, u, (h) => c[h]).map((h) => h[1])
    return [i, X({}, a, { scale: { x: { flex: f } } })]
  }
}
Qx.props = {}
function oe([t, e], [n, r]) {
  return [t - n, e - r]
}
function Zs([t, e], [n, r]) {
  return [t + n, e + r]
}
function Ut([t, e], [n, r]) {
  return Math.sqrt(Math.pow(t - n, 2) + Math.pow(e - r, 2))
}
function kn([t, e]) {
  return Math.atan2(e, t)
}
function Ca([t, e]) {
  return kn([t, e]) + Math.PI / 2
}
function Jx(t, e) {
  const n = kn(t),
    r = kn(e)
  return n < r ? r - n : Math.PI * 2 - (n - r)
}
function ap(t) {
  let e = 1 / 0,
    n = -1 / 0,
    r = 1 / 0,
    i = -1 / 0
  for (const [s, c] of t)
    (e = Math.min(s, e)), (n = Math.max(s, n)), (r = Math.min(c, r)), (i = Math.max(c, i))
  const a = n - e,
    o = i - r
  return [e, r, a, o]
}
function t2([t, e], [n, r]) {
  return [(t + n) / 2, (e + r) / 2]
}
function oC(t, e, n) {
  const r = t.length
  if (r === 0) return []
  const { innerWidth: i, innerHeight: a } = n,
    o = a / i
  let s = Math.ceil(Math.sqrt(e / o)),
    c = i / s,
    l = Math.ceil(e / s),
    u = l * c
  for (; u > a; ) (s = s + 1), (c = i / s), (l = Math.ceil(e / s)), (u = l * c)
  const f = a - l * c,
    h = l <= 1 ? 0 : f / (l - 1),
    [d, p] = l <= 1 ? [(i - r * c) / (r - 1), (a - c) / 2] : [0, 0]
  return t.map((v, g) => {
    const [y, m, b, x] = ap(v),
      w = g % s,
      O = Math.floor(g / s),
      S = w * c,
      _ = (l - O - 1) * c + f,
      M = c / b,
      E = c / x,
      T = S - y + d * w,
      C = _ - m - h * O - p
    return `translate(${T}, ${C}) scale(${M}, ${E})`
  })
}
const e2 = () => (t, e) => [t, X({}, e, { modifier: oC, axis: !1 })]
e2.props = {}
var sC =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const $v = 'thresholds'
function cC(t) {
  const [e, n] = br(t)
  return Math.min(200, Ik(t, e, n))
}
const op = (t = {}) => {
  const { groupChannels: e = ['color'], binChannels: n = ['x', 'y'] } = t,
    r = sC(t, ['groupChannels', 'binChannels']),
    i = {},
    a = (o, s) => {
      const { encode: c } = s,
        l = n.map((p) => {
          const [v] = wt(c, p)
          return v
        }),
        u = et(r, $v),
        f = o.filter((p) => l.every((v) => Gt(v[p]))),
        h = [
          ...e
            .map((p) => {
              const [v] = wt(c, p)
              return v
            })
            .filter(Gt)
            .map((p) => (v) => p[v]),
          ...n.map((p, v) => {
            const g = l[v],
              y = u[p] || cC(g),
              m = Lk()
                .thresholds(y)
                .value((x) => +g[x])(f),
              b = new Map(
                m.flatMap((x) => {
                  const { x0: w, x1: O } = x,
                    S = `${w},${O}`
                  return x.map((_) => [_, S])
                })
              )
            return (i[p] = b), (x) => b.get(x)
          })
        ],
        d = (p) => h.map((v) => v(p)).join('-')
      return Array.from(qt(f, d).values())
    }
  return ip(
    Object.assign(
      Object.assign(
        Object.assign({}, Object.fromEntries(Object.entries(r).filter(([o]) => !o.startsWith($v)))),
        Object.fromEntries(
          n.flatMap((o) => {
            const s = ([l]) => +i[o].get(l).split(',')[0],
              c = ([l]) => +i[o].get(l).split(',')[1]
            return (
              (c.from = o),
              [
                [o, s],
                [`${o}1`, c]
              ]
            )
          })
        )
      ),
      { groupBy: a }
    )
  )
}
op.props = {}
const n2 = (t = {}) => {
  const { thresholds: e } = t
  return op(
    Object.assign(Object.assign({}, t), {
      thresholdsX: e,
      groupChannels: ['color'],
      binChannels: ['x']
    })
  )
}
n2.props = {}
function lC(t, e, n, r) {
  const i = t.length
  if (r >= i || r === 0) return t
  const a = (d) => e[t[d]] * 1,
    o = (d) => n[t[d]] * 1,
    s = [],
    c = (i - 2) / (r - 2)
  let l = 0,
    u,
    f,
    h
  s.push(l)
  for (let d = 0; d < r - 2; d++) {
    let p = 0,
      v = 0,
      g = Math.floor((d + 1) * c) + 1,
      y = Math.floor((d + 2) * c) + 1
    y = Math.min(y, i)
    const m = y - g
    for (; g < y; g++) (p += a(g)), (v += o(g))
    ;(p /= m), (v /= m)
    let b = Math.floor((d + 0) * c) + 1
    const x = Math.floor((d + 1) * c) + 1,
      w = [a(l), o(l)]
    for (u = f = -1; b < x; b++)
      (f = Math.abs((w[0] - p) * (a(b) - w[1]) - (w[0] - o(b)) * (v - w[0])) * 0.5),
        f > u && ((u = f), (h = b))
    s.push(h), (l = h)
  }
  return s.push(i - 1), s.map((d) => t[d])
}
function uC(t) {
  if (typeof t == 'function') return t
  if (t === 'lttb') return lC
  const e = {
      first: (r) => [r[0]],
      last: (r) => [r[r.length - 1]],
      min: (r, i, a) => [r[Xl(r, (o) => a[o])]],
      max: (r, i, a) => [r[qa(r, (o) => a[o])]],
      median: (r, i, a) => [r[jk(r, (o) => a[o])]]
    },
    n = e[t] || e.median
  return (r, i, a, o) => {
    const s = Math.max(1, Math.floor(r.length / o))
    return fC(r, s).flatMap((l) => n(l, i, a))
  }
}
function fC(t, e) {
  const n = t.length,
    r = []
  let i = 0
  for (; i < n; ) r.push(t.slice(i, (i += e)))
  return r
}
const r2 = (t = {}) => {
  const { strategy: e = 'median', thresholds: n = 2e3, groupBy: r = ['series', 'color'] } = t,
    i = uC(e)
  return (a, o) => {
    const { encode: s } = o,
      c = ii(r, a, o),
      [l] = wt(s, 'x'),
      [u] = wt(s, 'y')
    return [c.flatMap((f) => i(f, l, u, n)), o]
  }
}
r2.props = {}
function hC(t) {
  return typeof t == 'object' ? [t.value, t.ordinal] : [t, !0]
}
const i2 =
  (t = {}) =>
  (e, n) => {
    const { encode: r, data: i } = n,
      a = Object.entries(t)
        .map(([u, f]) => {
          const [h] = wt(r, u)
          if (!h) return null
          const [d, p = !0] = hC(f)
          if (typeof d == 'function') return (v) => d(h[v])
          if (p) {
            const v = Array.isArray(d) ? d : [d]
            return v.length === 0 ? null : (g) => v.includes(h[g])
          } else {
            const [v, g] = d
            return (y) => h[y] >= v && h[y] <= g
          }
        })
        .filter(Gt)
    if (a.length === 0) return [e, n]
    const o = (u) => a.every((f) => f(u)),
      s = e.filter(o),
      c = s.map((u, f) => f),
      l = Object.entries(r).map(([u, f]) => [
        u,
        Object.assign(Object.assign({}, f), { value: c.map((h) => f.value[s[h]]) })
      ])
    return [c, X({}, n, { encode: Object.fromEntries(l), data: s.map((u) => i[u]) })]
  }
i2.props = {}
function Vt(t) {
  return function () {
    return t
  }
}
const Bv = Math.abs,
  Ce = Math.atan2,
  vi = Math.cos,
  dC = Math.max,
  Zu = Math.min,
  Vn = Math.sin,
  fa = Math.sqrt,
  Le = 1e-12,
  Jo = Math.PI,
  ol = Jo / 2,
  pC = 2 * Jo
function vC(t) {
  return t > 1 ? 0 : t < -1 ? Jo : Math.acos(t)
}
function Fv(t) {
  return t >= 1 ? ol : t <= -1 ? -ol : Math.asin(t)
}
const vh = Math.PI,
  gh = 2 * vh,
  wi = 1e-6,
  gC = gh - wi
function a2(t) {
  this._ += t[0]
  for (let e = 1, n = t.length; e < n; ++e) this._ += arguments[e] + t[e]
}
function yC(t) {
  let e = Math.floor(t)
  if (!(e >= 0)) throw new Error(`invalid digits: ${t}`)
  if (e > 15) return a2
  const n = 10 ** e
  return function (r) {
    this._ += r[0]
    for (let i = 1, a = r.length; i < a; ++i) this._ += Math.round(arguments[i] * n) / n + r[i]
  }
}
let sp = class {
  constructor(e) {
    ;(this._x0 = this._y0 = this._x1 = this._y1 = null),
      (this._ = ''),
      (this._append = e == null ? a2 : yC(e))
  }
  moveTo(e, n) {
    this._append`M${(this._x0 = this._x1 = +e)},${(this._y0 = this._y1 = +n)}`
  }
  closePath() {
    this._x1 !== null && ((this._x1 = this._x0), (this._y1 = this._y0), this._append`Z`)
  }
  lineTo(e, n) {
    this._append`L${(this._x1 = +e)},${(this._y1 = +n)}`
  }
  quadraticCurveTo(e, n, r, i) {
    this._append`Q${+e},${+n},${(this._x1 = +r)},${(this._y1 = +i)}`
  }
  bezierCurveTo(e, n, r, i, a, o) {
    this._append`C${+e},${+n},${+r},${+i},${(this._x1 = +a)},${(this._y1 = +o)}`
  }
  arcTo(e, n, r, i, a) {
    if (((e = +e), (n = +n), (r = +r), (i = +i), (a = +a), a < 0))
      throw new Error(`negative radius: ${a}`)
    let o = this._x1,
      s = this._y1,
      c = r - e,
      l = i - n,
      u = o - e,
      f = s - n,
      h = u * u + f * f
    if (this._x1 === null) this._append`M${(this._x1 = e)},${(this._y1 = n)}`
    else if (h > wi)
      if (!(Math.abs(f * c - l * u) > wi) || !a) this._append`L${(this._x1 = e)},${(this._y1 = n)}`
      else {
        let d = r - o,
          p = i - s,
          v = c * c + l * l,
          g = d * d + p * p,
          y = Math.sqrt(v),
          m = Math.sqrt(h),
          b = a * Math.tan((vh - Math.acos((v + h - g) / (2 * y * m))) / 2),
          x = b / m,
          w = b / y
        Math.abs(x - 1) > wi && this._append`L${e + x * u},${n + x * f}`,
          this._append`A${a},${a},0,0,${+(f * d > u * p)},${(this._x1 = e + w * c)},${(this._y1 =
            n + w * l)}`
      }
  }
  arc(e, n, r, i, a, o) {
    if (((e = +e), (n = +n), (r = +r), (o = !!o), r < 0)) throw new Error(`negative radius: ${r}`)
    let s = r * Math.cos(i),
      c = r * Math.sin(i),
      l = e + s,
      u = n + c,
      f = 1 ^ o,
      h = o ? i - a : a - i
    this._x1 === null
      ? this._append`M${l},${u}`
      : (Math.abs(this._x1 - l) > wi || Math.abs(this._y1 - u) > wi) && this._append`L${l},${u}`,
      r &&
        (h < 0 && (h = (h % gh) + gh),
        h > gC
          ? this._append`A${r},${r},0,1,${f},${e - s},${n - c}A${r},${r},0,1,${f},${(this._x1 =
              l)},${(this._y1 = u)}`
          : h > wi &&
            this._append`A${r},${r},0,${+(h >= vh)},${f},${(this._x1 =
              e + r * Math.cos(a))},${(this._y1 = n + r * Math.sin(a))}`)
  }
  rect(e, n, r, i) {
    this._append`M${(this._x0 = this._x1 = +e)},${(this._y0 = this._y1 = +n)}h${(r =
      +r)}v${+i}h${-r}Z`
  }
  toString() {
    return this._
  }
}
function Nn() {
  return new sp()
}
Nn.prototype = sp.prototype
function cp(t) {
  let e = 3
  return (
    (t.digits = function (n) {
      if (!arguments.length) return e
      if (n == null) e = null
      else {
        const r = Math.floor(n)
        if (!(r >= 0)) throw new RangeError(`invalid digits: ${n}`)
        e = r
      }
      return t
    }),
    () => new sp(e)
  )
}
function mC(t) {
  return t.innerRadius
}
function bC(t) {
  return t.outerRadius
}
function xC(t) {
  return t.startAngle
}
function wC(t) {
  return t.endAngle
}
function OC(t) {
  return t && t.padAngle
}
function SC(t, e, n, r, i, a, o, s) {
  var c = n - t,
    l = r - e,
    u = o - i,
    f = s - a,
    h = f * c - u * l
  if (!(h * h < Le)) return (h = (u * (e - a) - f * (t - i)) / h), [t + h * c, e + h * l]
}
function Qs(t, e, n, r, i, a, o) {
  var s = t - n,
    c = e - r,
    l = (o ? a : -a) / fa(s * s + c * c),
    u = l * c,
    f = -l * s,
    h = t + u,
    d = e + f,
    p = n + u,
    v = r + f,
    g = (h + p) / 2,
    y = (d + v) / 2,
    m = p - h,
    b = v - d,
    x = m * m + b * b,
    w = i - a,
    O = h * v - p * d,
    S = (b < 0 ? -1 : 1) * fa(dC(0, w * w * x - O * O)),
    _ = (O * b - m * S) / x,
    M = (-O * m - b * S) / x,
    E = (O * b + m * S) / x,
    T = (-O * m + b * S) / x,
    C = _ - g,
    A = M - y,
    P = E - g,
    k = T - y
  return (
    C * C + A * A > P * P + k * k && ((_ = E), (M = T)),
    { cx: _, cy: M, x01: -u, y01: -f, x11: _ * (i / w - 1), y11: M * (i / w - 1) }
  )
}
function lp() {
  var t = mC,
    e = bC,
    n = Vt(0),
    r = null,
    i = xC,
    a = wC,
    o = OC,
    s = null,
    c = cp(l)
  function l() {
    var u,
      f,
      h = +t.apply(this, arguments),
      d = +e.apply(this, arguments),
      p = i.apply(this, arguments) - ol,
      v = a.apply(this, arguments) - ol,
      g = Bv(v - p),
      y = v > p
    if ((s || (s = u = c()), d < h && ((f = d), (d = h), (h = f)), !(d > Le))) s.moveTo(0, 0)
    else if (g > pC - Le)
      s.moveTo(d * vi(p), d * Vn(p)),
        s.arc(0, 0, d, p, v, !y),
        h > Le && (s.moveTo(h * vi(v), h * Vn(v)), s.arc(0, 0, h, v, p, y))
    else {
      var m = p,
        b = v,
        x = p,
        w = v,
        O = g,
        S = g,
        _ = o.apply(this, arguments) / 2,
        M = _ > Le && (r ? +r.apply(this, arguments) : fa(h * h + d * d)),
        E = Zu(Bv(d - h) / 2, +n.apply(this, arguments)),
        T = E,
        C = E,
        A,
        P
      if (M > Le) {
        var k = Fv((M / h) * Vn(_)),
          L = Fv((M / d) * Vn(_))
        ;(O -= k * 2) > Le
          ? ((k *= y ? 1 : -1), (x += k), (w -= k))
          : ((O = 0), (x = w = (p + v) / 2)),
          (S -= L * 2) > Le
            ? ((L *= y ? 1 : -1), (m += L), (b -= L))
            : ((S = 0), (m = b = (p + v) / 2))
      }
      var R = d * vi(m),
        j = d * Vn(m),
        I = h * vi(w),
        D = h * Vn(w)
      if (E > Le) {
        var $ = d * vi(b),
          B = d * Vn(b),
          F = h * vi(x),
          W = h * Vn(x),
          U
        if (g < Jo)
          if ((U = SC(R, j, F, W, $, B, I, D))) {
            var K = R - U[0],
              V = j - U[1],
              H = $ - U[0],
              Q = B - U[1],
              tt = 1 / Vn(vC((K * H + V * Q) / (fa(K * K + V * V) * fa(H * H + Q * Q))) / 2),
              it = fa(U[0] * U[0] + U[1] * U[1])
            ;(T = Zu(E, (h - it) / (tt - 1))), (C = Zu(E, (d - it) / (tt + 1)))
          } else T = C = 0
      }
      S > Le
        ? C > Le
          ? ((A = Qs(F, W, R, j, d, C, y)),
            (P = Qs($, B, I, D, d, C, y)),
            s.moveTo(A.cx + A.x01, A.cy + A.y01),
            C < E
              ? s.arc(A.cx, A.cy, C, Ce(A.y01, A.x01), Ce(P.y01, P.x01), !y)
              : (s.arc(A.cx, A.cy, C, Ce(A.y01, A.x01), Ce(A.y11, A.x11), !y),
                s.arc(0, 0, d, Ce(A.cy + A.y11, A.cx + A.x11), Ce(P.cy + P.y11, P.cx + P.x11), !y),
                s.arc(P.cx, P.cy, C, Ce(P.y11, P.x11), Ce(P.y01, P.x01), !y)))
          : (s.moveTo(R, j), s.arc(0, 0, d, m, b, !y))
        : s.moveTo(R, j),
        !(h > Le) || !(O > Le)
          ? s.lineTo(I, D)
          : T > Le
          ? ((A = Qs(I, D, $, B, h, -T, y)),
            (P = Qs(R, j, F, W, h, -T, y)),
            s.lineTo(A.cx + A.x01, A.cy + A.y01),
            T < E
              ? s.arc(A.cx, A.cy, T, Ce(A.y01, A.x01), Ce(P.y01, P.x01), !y)
              : (s.arc(A.cx, A.cy, T, Ce(A.y01, A.x01), Ce(A.y11, A.x11), !y),
                s.arc(0, 0, h, Ce(A.cy + A.y11, A.cx + A.x11), Ce(P.cy + P.y11, P.cx + P.x11), y),
                s.arc(P.cx, P.cy, T, Ce(P.y11, P.x11), Ce(P.y01, P.x01), !y)))
          : s.arc(0, 0, h, w, x, y)
    }
    if ((s.closePath(), u)) return (s = null), u + '' || null
  }
  return (
    (l.centroid = function () {
      var u = (+t.apply(this, arguments) + +e.apply(this, arguments)) / 2,
        f = (+i.apply(this, arguments) + +a.apply(this, arguments)) / 2 - Jo / 2
      return [vi(f) * u, Vn(f) * u]
    }),
    (l.innerRadius = function (u) {
      return arguments.length ? ((t = typeof u == 'function' ? u : Vt(+u)), l) : t
    }),
    (l.outerRadius = function (u) {
      return arguments.length ? ((e = typeof u == 'function' ? u : Vt(+u)), l) : e
    }),
    (l.cornerRadius = function (u) {
      return arguments.length ? ((n = typeof u == 'function' ? u : Vt(+u)), l) : n
    }),
    (l.padRadius = function (u) {
      return arguments.length
        ? ((r = u == null ? null : typeof u == 'function' ? u : Vt(+u)), l)
        : r
    }),
    (l.startAngle = function (u) {
      return arguments.length ? ((i = typeof u == 'function' ? u : Vt(+u)), l) : i
    }),
    (l.endAngle = function (u) {
      return arguments.length ? ((a = typeof u == 'function' ? u : Vt(+u)), l) : a
    }),
    (l.padAngle = function (u) {
      return arguments.length ? ((o = typeof u == 'function' ? u : Vt(+u)), l) : o
    }),
    (l.context = function (u) {
      return arguments.length ? ((s = u ?? null), l) : s
    }),
    l
  )
}
function o2(t) {
  return typeof t == 'object' && 'length' in t ? t : Array.from(t)
}
function s2(t) {
  this._context = t
}
s2.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    this._point = 0
  },
  lineEnd: function () {
    ;(this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
      (this._line = 1 - this._line)
  },
  point: function (t, e) {
    switch (((t = +t), (e = +e), this._point)) {
      case 0:
        ;(this._point = 1), this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e)
        break
      case 1:
        this._point = 2
      default:
        this._context.lineTo(t, e)
        break
    }
  }
}
function As(t) {
  return new s2(t)
}
function c2(t) {
  return t[0]
}
function l2(t) {
  return t[1]
}
function Kr(t, e) {
  var n = Vt(!0),
    r = null,
    i = As,
    a = null,
    o = cp(s)
  ;(t = typeof t == 'function' ? t : t === void 0 ? c2 : Vt(t)),
    (e = typeof e == 'function' ? e : e === void 0 ? l2 : Vt(e))
  function s(c) {
    var l,
      u = (c = o2(c)).length,
      f,
      h = !1,
      d
    for (r == null && (a = i((d = o()))), l = 0; l <= u; ++l)
      !(l < u && n((f = c[l]), l, c)) === h && ((h = !h) ? a.lineStart() : a.lineEnd()),
        h && a.point(+t(f, l, c), +e(f, l, c))
    if (d) return (a = null), d + '' || null
  }
  return (
    (s.x = function (c) {
      return arguments.length ? ((t = typeof c == 'function' ? c : Vt(+c)), s) : t
    }),
    (s.y = function (c) {
      return arguments.length ? ((e = typeof c == 'function' ? c : Vt(+c)), s) : e
    }),
    (s.defined = function (c) {
      return arguments.length ? ((n = typeof c == 'function' ? c : Vt(!!c)), s) : n
    }),
    (s.curve = function (c) {
      return arguments.length ? ((i = c), r != null && (a = i(r)), s) : i
    }),
    (s.context = function (c) {
      return arguments.length ? (c == null ? (r = a = null) : (a = i((r = c))), s) : r
    }),
    s
  )
}
function yh(t, e, n) {
  var r = null,
    i = Vt(!0),
    a = null,
    o = As,
    s = null,
    c = cp(l)
  ;(t = typeof t == 'function' ? t : t === void 0 ? c2 : Vt(+t)),
    (e = typeof e == 'function' ? e : Vt(e === void 0 ? 0 : +e)),
    (n = typeof n == 'function' ? n : n === void 0 ? l2 : Vt(+n))
  function l(f) {
    var h,
      d,
      p,
      v = (f = o2(f)).length,
      g,
      y = !1,
      m,
      b = new Array(v),
      x = new Array(v)
    for (a == null && (s = o((m = c()))), h = 0; h <= v; ++h) {
      if (!(h < v && i((g = f[h]), h, f)) === y)
        if ((y = !y)) (d = h), s.areaStart(), s.lineStart()
        else {
          for (s.lineEnd(), s.lineStart(), p = h - 1; p >= d; --p) s.point(b[p], x[p])
          s.lineEnd(), s.areaEnd()
        }
      y &&
        ((b[h] = +t(g, h, f)),
        (x[h] = +e(g, h, f)),
        s.point(r ? +r(g, h, f) : b[h], n ? +n(g, h, f) : x[h]))
    }
    if (m) return (s = null), m + '' || null
  }
  function u() {
    return Kr().defined(i).curve(o).context(a)
  }
  return (
    (l.x = function (f) {
      return arguments.length ? ((t = typeof f == 'function' ? f : Vt(+f)), (r = null), l) : t
    }),
    (l.x0 = function (f) {
      return arguments.length ? ((t = typeof f == 'function' ? f : Vt(+f)), l) : t
    }),
    (l.x1 = function (f) {
      return arguments.length
        ? ((r = f == null ? null : typeof f == 'function' ? f : Vt(+f)), l)
        : r
    }),
    (l.y = function (f) {
      return arguments.length ? ((e = typeof f == 'function' ? f : Vt(+f)), (n = null), l) : e
    }),
    (l.y0 = function (f) {
      return arguments.length ? ((e = typeof f == 'function' ? f : Vt(+f)), l) : e
    }),
    (l.y1 = function (f) {
      return arguments.length
        ? ((n = f == null ? null : typeof f == 'function' ? f : Vt(+f)), l)
        : n
    }),
    (l.lineX0 = l.lineY0 =
      function () {
        return u().x(t).y(e)
      }),
    (l.lineY1 = function () {
      return u().x(t).y(n)
    }),
    (l.lineX1 = function () {
      return u().x(r).y(e)
    }),
    (l.defined = function (f) {
      return arguments.length ? ((i = typeof f == 'function' ? f : Vt(!!f)), l) : i
    }),
    (l.curve = function (f) {
      return arguments.length ? ((o = f), a != null && (s = o(a)), l) : o
    }),
    (l.context = function (f) {
      return arguments.length ? (f == null ? (a = s = null) : (s = o((a = f))), l) : a
    }),
    l
  )
}
var u2 = up(As)
function f2(t) {
  this._curve = t
}
f2.prototype = {
  areaStart: function () {
    this._curve.areaStart()
  },
  areaEnd: function () {
    this._curve.areaEnd()
  },
  lineStart: function () {
    this._curve.lineStart()
  },
  lineEnd: function () {
    this._curve.lineEnd()
  },
  point: function (t, e) {
    this._curve.point(e * Math.sin(t), e * -Math.cos(t))
  }
}
function up(t) {
  function e(n) {
    return new f2(t(n))
  }
  return (e._curve = t), e
}
function mo(t) {
  var e = t.curve
  return (
    (t.angle = t.x),
    delete t.x,
    (t.radius = t.y),
    delete t.y,
    (t.curve = function (n) {
      return arguments.length ? e(up(n)) : e()._curve
    }),
    t
  )
}
function _C() {
  return mo(Kr().curve(u2))
}
function MC() {
  var t = yh().curve(u2),
    e = t.curve,
    n = t.lineX0,
    r = t.lineX1,
    i = t.lineY0,
    a = t.lineY1
  return (
    (t.angle = t.x),
    delete t.x,
    (t.startAngle = t.x0),
    delete t.x0,
    (t.endAngle = t.x1),
    delete t.x1,
    (t.radius = t.y),
    delete t.y,
    (t.innerRadius = t.y0),
    delete t.y0,
    (t.outerRadius = t.y1),
    delete t.y1,
    (t.lineStartAngle = function () {
      return mo(n())
    }),
    delete t.lineX0,
    (t.lineEndAngle = function () {
      return mo(r())
    }),
    delete t.lineX1,
    (t.lineInnerRadius = function () {
      return mo(i())
    }),
    delete t.lineY0,
    (t.lineOuterRadius = function () {
      return mo(a())
    }),
    delete t.lineY1,
    (t.curve = function (o) {
      return arguments.length ? e(up(o)) : e()._curve
    }),
    t
  )
}
function La() {}
function mh(t, e, n) {
  t._context.bezierCurveTo(
    t._x1 + t._k * (t._x2 - t._x0),
    t._y1 + t._k * (t._y2 - t._y0),
    t._x2 + t._k * (t._x1 - e),
    t._y2 + t._k * (t._y1 - n),
    t._x2,
    t._y2
  )
}
function fp(t, e) {
  ;(this._context = t), (this._k = (1 - e) / 6)
}
fp.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN), (this._point = 0)
  },
  lineEnd: function () {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2)
        break
      case 3:
        mh(this, this._x1, this._y1)
        break
    }
    ;(this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
      (this._line = 1 - this._line)
  },
  point: function (t, e) {
    switch (((t = +t), (e = +e), this._point)) {
      case 0:
        ;(this._point = 1), this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e)
        break
      case 1:
        ;(this._point = 2), (this._x1 = t), (this._y1 = e)
        break
      case 2:
        this._point = 3
      default:
        mh(this, t, e)
        break
    }
    ;(this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = t),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = e)
  }
}
;(function t(e) {
  function n(r) {
    return new fp(r, e)
  }
  return (
    (n.tension = function (r) {
      return t(+r)
    }),
    n
  )
})(0)
function hp(t, e) {
  ;(this._context = t), (this._k = (1 - e) / 6)
}
hp.prototype = {
  areaStart: La,
  areaEnd: La,
  lineStart: function () {
    ;(this._x0 =
      this._x1 =
      this._x2 =
      this._x3 =
      this._x4 =
      this._x5 =
      this._y0 =
      this._y1 =
      this._y2 =
      this._y3 =
      this._y4 =
      this._y5 =
        NaN),
      (this._point = 0)
  },
  lineEnd: function () {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath()
        break
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath()
        break
      }
      case 3: {
        this.point(this._x3, this._y3),
          this.point(this._x4, this._y4),
          this.point(this._x5, this._y5)
        break
      }
    }
  },
  point: function (t, e) {
    switch (((t = +t), (e = +e), this._point)) {
      case 0:
        ;(this._point = 1), (this._x3 = t), (this._y3 = e)
        break
      case 1:
        ;(this._point = 2), this._context.moveTo((this._x4 = t), (this._y4 = e))
        break
      case 2:
        ;(this._point = 3), (this._x5 = t), (this._y5 = e)
        break
      default:
        mh(this, t, e)
        break
    }
    ;(this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = t),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = e)
  }
}
;(function t(e) {
  function n(r) {
    return new hp(r, e)
  }
  return (
    (n.tension = function (r) {
      return t(+r)
    }),
    n
  )
})(0)
function h2(t, e, n) {
  var r = t._x1,
    i = t._y1,
    a = t._x2,
    o = t._y2
  if (t._l01_a > Le) {
    var s = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a,
      c = 3 * t._l01_a * (t._l01_a + t._l12_a)
    ;(r = (r * s - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / c),
      (i = (i * s - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / c)
  }
  if (t._l23_a > Le) {
    var l = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a,
      u = 3 * t._l23_a * (t._l23_a + t._l12_a)
    ;(a = (a * l + t._x1 * t._l23_2a - e * t._l12_2a) / u),
      (o = (o * l + t._y1 * t._l23_2a - n * t._l12_2a) / u)
  }
  t._context.bezierCurveTo(r, i, a, o, t._x2, t._y2)
}
function d2(t, e) {
  ;(this._context = t), (this._alpha = e)
}
d2.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN),
      (this._l01_a =
        this._l12_a =
        this._l23_a =
        this._l01_2a =
        this._l12_2a =
        this._l23_2a =
        this._point =
          0)
  },
  lineEnd: function () {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2)
        break
      case 3:
        this.point(this._x2, this._y2)
        break
    }
    ;(this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
      (this._line = 1 - this._line)
  },
  point: function (t, e) {
    if (((t = +t), (e = +e), this._point)) {
      var n = this._x2 - t,
        r = this._y2 - e
      this._l23_a = Math.sqrt((this._l23_2a = Math.pow(n * n + r * r, this._alpha)))
    }
    switch (this._point) {
      case 0:
        ;(this._point = 1), this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e)
        break
      case 1:
        this._point = 2
        break
      case 2:
        this._point = 3
      default:
        h2(this, t, e)
        break
    }
    ;(this._l01_a = this._l12_a),
      (this._l12_a = this._l23_a),
      (this._l01_2a = this._l12_2a),
      (this._l12_2a = this._l23_2a),
      (this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = t),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = e)
  }
}
const p2 = (function t(e) {
  function n(r) {
    return e ? new d2(r, e) : new fp(r, 0)
  }
  return (
    (n.alpha = function (r) {
      return t(+r)
    }),
    n
  )
})(0.5)
function v2(t, e) {
  ;(this._context = t), (this._alpha = e)
}
v2.prototype = {
  areaStart: La,
  areaEnd: La,
  lineStart: function () {
    ;(this._x0 =
      this._x1 =
      this._x2 =
      this._x3 =
      this._x4 =
      this._x5 =
      this._y0 =
      this._y1 =
      this._y2 =
      this._y3 =
      this._y4 =
      this._y5 =
        NaN),
      (this._l01_a =
        this._l12_a =
        this._l23_a =
        this._l01_2a =
        this._l12_2a =
        this._l23_2a =
        this._point =
          0)
  },
  lineEnd: function () {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath()
        break
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath()
        break
      }
      case 3: {
        this.point(this._x3, this._y3),
          this.point(this._x4, this._y4),
          this.point(this._x5, this._y5)
        break
      }
    }
  },
  point: function (t, e) {
    if (((t = +t), (e = +e), this._point)) {
      var n = this._x2 - t,
        r = this._y2 - e
      this._l23_a = Math.sqrt((this._l23_2a = Math.pow(n * n + r * r, this._alpha)))
    }
    switch (this._point) {
      case 0:
        ;(this._point = 1), (this._x3 = t), (this._y3 = e)
        break
      case 1:
        ;(this._point = 2), this._context.moveTo((this._x4 = t), (this._y4 = e))
        break
      case 2:
        ;(this._point = 3), (this._x5 = t), (this._y5 = e)
        break
      default:
        h2(this, t, e)
        break
    }
    ;(this._l01_a = this._l12_a),
      (this._l12_a = this._l23_a),
      (this._l01_2a = this._l12_2a),
      (this._l12_2a = this._l23_2a),
      (this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = t),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = e)
  }
}
const g2 = (function t(e) {
  function n(r) {
    return e ? new v2(r, e) : new hp(r, 0)
  }
  return (
    (n.alpha = function (r) {
      return t(+r)
    }),
    n
  )
})(0.5)
function y2(t) {
  this._context = t
}
y2.prototype = {
  areaStart: La,
  areaEnd: La,
  lineStart: function () {
    this._point = 0
  },
  lineEnd: function () {
    this._point && this._context.closePath()
  },
  point: function (t, e) {
    ;(t = +t),
      (e = +e),
      this._point ? this._context.lineTo(t, e) : ((this._point = 1), this._context.moveTo(t, e))
  }
}
function dp(t) {
  return new y2(t)
}
function ou(t, e) {
  ;(this._context = t), (this._t = e)
}
ou.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;(this._x = this._y = NaN), (this._point = 0)
  },
  lineEnd: function () {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y),
      (this._line || (this._line !== 0 && this._point === 1)) && this._context.closePath(),
      this._line >= 0 && ((this._t = 1 - this._t), (this._line = 1 - this._line))
  },
  point: function (t, e) {
    switch (((t = +t), (e = +e), this._point)) {
      case 0:
        ;(this._point = 1), this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e)
        break
      case 1:
        this._point = 2
      default: {
        if (this._t <= 0) this._context.lineTo(this._x, e), this._context.lineTo(t, e)
        else {
          var n = this._x * (1 - this._t) + t * this._t
          this._context.lineTo(n, this._y), this._context.lineTo(n, e)
        }
        break
      }
    }
    ;(this._x = t), (this._y = e)
  }
}
function m2(t) {
  return new ou(t, 0.5)
}
function b2(t) {
  return new ou(t, 0)
}
function x2(t) {
  return new ou(t, 1)
}
function ce(t) {
  const { transformations: e } = t.getOptions()
  return e.map(([r]) => r).filter((r) => r === 'transpose').length % 2 !== 0
}
function Zt(t) {
  const { transformations: e } = t.getOptions()
  return e.some(([n]) => n === 'polar')
}
function su(t) {
  const { transformations: e } = t.getOptions()
  return e.some(([n]) => n === 'reflect') && e.some(([n]) => n.startsWith('transpose'))
}
function w2(t) {
  const { transformations: e } = t.getOptions()
  return e.some(([n]) => n === 'helix')
}
function cu(t) {
  const { transformations: e } = t.getOptions()
  return e.some(([n]) => n === 'parallel')
}
function O2(t) {
  const { transformations: e } = t.getOptions()
  return e.some(([n]) => n === 'fisheye')
}
function EC(t) {
  return cu(t) && Zt(t)
}
function Ka(t) {
  return w2(t) || Zt(t)
}
function TC(t) {
  return Zt(t) && ce(t)
}
function PC(t) {
  if (Ka(t)) {
    const [e, n] = t.getSize(),
      r = t.getOptions().transformations.find((i) => i[0] === 'polar')
    if (r) return (Math.max(e, n) / 2) * r[4]
  }
  return 0
}
function lu(t) {
  const { transformations: e } = t.getOptions(),
    [, , , n, r] = e.find((i) => i[0] === 'polar')
  return [+n, +r]
}
function pp(t, e = !0) {
  const { transformations: n } = t.getOptions(),
    [, r, i] = n.find((a) => a[0] === 'polar')
  return e ? [(+r * 180) / Math.PI, (+i * 180) / Math.PI] : [r, i]
}
function AC(t, e) {
  const { transformations: n } = t.getOptions(),
    [, ...r] = n.find((i) => i[0] === e)
  return r
}
var S2 = { exports: {} }
;(function (t) {
  var e = Object.prototype.hasOwnProperty,
    n = '~'
  function r() {}
  Object.create && ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1))
  function i(c, l, u) {
    ;(this.fn = c), (this.context = l), (this.once = u || !1)
  }
  function a(c, l, u, f, h) {
    if (typeof u != 'function') throw new TypeError('The listener must be a function')
    var d = new i(u, f || c, h),
      p = n ? n + l : l
    return (
      c._events[p]
        ? c._events[p].fn
          ? (c._events[p] = [c._events[p], d])
          : c._events[p].push(d)
        : ((c._events[p] = d), c._eventsCount++),
      c
    )
  }
  function o(c, l) {
    --c._eventsCount === 0 ? (c._events = new r()) : delete c._events[l]
  }
  function s() {
    ;(this._events = new r()), (this._eventsCount = 0)
  }
  ;(s.prototype.eventNames = function () {
    var l = [],
      u,
      f
    if (this._eventsCount === 0) return l
    for (f in (u = this._events)) e.call(u, f) && l.push(n ? f.slice(1) : f)
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(u)) : l
  }),
    (s.prototype.listeners = function (l) {
      var u = n ? n + l : l,
        f = this._events[u]
      if (!f) return []
      if (f.fn) return [f.fn]
      for (var h = 0, d = f.length, p = new Array(d); h < d; h++) p[h] = f[h].fn
      return p
    }),
    (s.prototype.listenerCount = function (l) {
      var u = n ? n + l : l,
        f = this._events[u]
      return f ? (f.fn ? 1 : f.length) : 0
    }),
    (s.prototype.emit = function (l, u, f, h, d, p) {
      var v = n ? n + l : l
      if (!this._events[v]) return !1
      var g = this._events[v],
        y = arguments.length,
        m,
        b
      if (g.fn) {
        switch ((g.once && this.removeListener(l, g.fn, void 0, !0), y)) {
          case 1:
            return g.fn.call(g.context), !0
          case 2:
            return g.fn.call(g.context, u), !0
          case 3:
            return g.fn.call(g.context, u, f), !0
          case 4:
            return g.fn.call(g.context, u, f, h), !0
          case 5:
            return g.fn.call(g.context, u, f, h, d), !0
          case 6:
            return g.fn.call(g.context, u, f, h, d, p), !0
        }
        for (b = 1, m = new Array(y - 1); b < y; b++) m[b - 1] = arguments[b]
        g.fn.apply(g.context, m)
      } else {
        var x = g.length,
          w
        for (b = 0; b < x; b++)
          switch ((g[b].once && this.removeListener(l, g[b].fn, void 0, !0), y)) {
            case 1:
              g[b].fn.call(g[b].context)
              break
            case 2:
              g[b].fn.call(g[b].context, u)
              break
            case 3:
              g[b].fn.call(g[b].context, u, f)
              break
            case 4:
              g[b].fn.call(g[b].context, u, f, h)
              break
            default:
              if (!m) for (w = 1, m = new Array(y - 1); w < y; w++) m[w - 1] = arguments[w]
              g[b].fn.apply(g[b].context, m)
          }
      }
      return !0
    }),
    (s.prototype.on = function (l, u, f) {
      return a(this, l, u, f, !1)
    }),
    (s.prototype.once = function (l, u, f) {
      return a(this, l, u, f, !0)
    }),
    (s.prototype.removeListener = function (l, u, f, h) {
      var d = n ? n + l : l
      if (!this._events[d]) return this
      if (!u) return o(this, d), this
      var p = this._events[d]
      if (p.fn) p.fn === u && (!h || p.once) && (!f || p.context === f) && o(this, d)
      else {
        for (var v = 0, g = [], y = p.length; v < y; v++)
          (p[v].fn !== u || (h && !p[v].once) || (f && p[v].context !== f)) && g.push(p[v])
        g.length ? (this._events[d] = g.length === 1 ? g[0] : g) : o(this, d)
      }
      return this
    }),
    (s.prototype.removeAllListeners = function (l) {
      var u
      return (
        l
          ? ((u = n ? n + l : l), this._events[u] && o(this, u))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      )
    }),
    (s.prototype.off = s.prototype.removeListener),
    (s.prototype.addListener = s.prototype.on),
    (s.prefixed = n),
    (s.EventEmitter = s),
    (t.exports = s)
})(S2)
var kC = S2.exports
const vp = Ld(kC)
function gp(t, e, n) {
  ;(t.prototype = e.prototype = n), (n.constructor = t)
}
function _2(t, e) {
  var n = Object.create(t.prototype)
  for (var r in e) n[r] = e[r]
  return n
}
function ks() {}
var ts = 0.7,
  sl = 1 / ts,
  ya = '\\s*([+-]?\\d+)\\s*',
  es = '\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*',
  rr = '\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*',
  CC = /^#([0-9a-f]{3,8})$/,
  LC = new RegExp('^rgb\\(' + [ya, ya, ya] + '\\)$'),
  NC = new RegExp('^rgb\\(' + [rr, rr, rr] + '\\)$'),
  RC = new RegExp('^rgba\\(' + [ya, ya, ya, es] + '\\)$'),
  IC = new RegExp('^rgba\\(' + [rr, rr, rr, es] + '\\)$'),
  jC = new RegExp('^hsl\\(' + [es, rr, rr] + '\\)$'),
  DC = new RegExp('^hsla\\(' + [es, rr, rr, es] + '\\)$'),
  zv = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  }
gp(ks, uu, {
  copy: function (t) {
    return Object.assign(new this.constructor(), this, t)
  },
  displayable: function () {
    return this.rgb().displayable()
  },
  hex: Gv,
  formatHex: Gv,
  formatHsl: $C,
  formatRgb: Wv,
  toString: Wv
})
function Gv() {
  return this.rgb().formatHex()
}
function $C() {
  return M2(this).formatHsl()
}
function Wv() {
  return this.rgb().formatRgb()
}
function uu(t) {
  var e, n
  return (
    (t = (t + '').trim().toLowerCase()),
    (e = CC.exec(t))
      ? ((n = e[1].length),
        (e = parseInt(e[1], 16)),
        n === 6
          ? Yv(e)
          : n === 3
          ? new pn(
              ((e >> 8) & 15) | ((e >> 4) & 240),
              ((e >> 4) & 15) | (e & 240),
              ((e & 15) << 4) | (e & 15),
              1
            )
          : n === 8
          ? Js((e >> 24) & 255, (e >> 16) & 255, (e >> 8) & 255, (e & 255) / 255)
          : n === 4
          ? Js(
              ((e >> 12) & 15) | ((e >> 8) & 240),
              ((e >> 8) & 15) | ((e >> 4) & 240),
              ((e >> 4) & 15) | (e & 240),
              (((e & 15) << 4) | (e & 15)) / 255
            )
          : null)
      : (e = LC.exec(t))
      ? new pn(e[1], e[2], e[3], 1)
      : (e = NC.exec(t))
      ? new pn((e[1] * 255) / 100, (e[2] * 255) / 100, (e[3] * 255) / 100, 1)
      : (e = RC.exec(t))
      ? Js(e[1], e[2], e[3], e[4])
      : (e = IC.exec(t))
      ? Js((e[1] * 255) / 100, (e[2] * 255) / 100, (e[3] * 255) / 100, e[4])
      : (e = jC.exec(t))
      ? Xv(e[1], e[2] / 100, e[3] / 100, 1)
      : (e = DC.exec(t))
      ? Xv(e[1], e[2] / 100, e[3] / 100, e[4])
      : zv.hasOwnProperty(t)
      ? Yv(zv[t])
      : t === 'transparent'
      ? new pn(NaN, NaN, NaN, 0)
      : null
  )
}
function Yv(t) {
  return new pn((t >> 16) & 255, (t >> 8) & 255, t & 255, 1)
}
function Js(t, e, n, r) {
  return r <= 0 && (t = e = n = NaN), new pn(t, e, n, r)
}
function BC(t) {
  return (
    t instanceof ks || (t = uu(t)), t ? ((t = t.rgb()), new pn(t.r, t.g, t.b, t.opacity)) : new pn()
  )
}
function FC(t, e, n, r) {
  return arguments.length === 1 ? BC(t) : new pn(t, e, n, r ?? 1)
}
function pn(t, e, n, r) {
  ;(this.r = +t), (this.g = +e), (this.b = +n), (this.opacity = +r)
}
gp(
  pn,
  FC,
  _2(ks, {
    brighter: function (t) {
      return (
        (t = t == null ? sl : Math.pow(sl, t)),
        new pn(this.r * t, this.g * t, this.b * t, this.opacity)
      )
    },
    darker: function (t) {
      return (
        (t = t == null ? ts : Math.pow(ts, t)),
        new pn(this.r * t, this.g * t, this.b * t, this.opacity)
      )
    },
    rgb: function () {
      return this
    },
    displayable: function () {
      return (
        -0.5 <= this.r &&
        this.r < 255.5 &&
        -0.5 <= this.g &&
        this.g < 255.5 &&
        -0.5 <= this.b &&
        this.b < 255.5 &&
        0 <= this.opacity &&
        this.opacity <= 1
      )
    },
    hex: Hv,
    formatHex: Hv,
    formatRgb: Vv,
    toString: Vv
  })
)
function Hv() {
  return '#' + Qu(this.r) + Qu(this.g) + Qu(this.b)
}
function Vv() {
  var t = this.opacity
  return (
    (t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))),
    (t === 1 ? 'rgb(' : 'rgba(') +
      Math.max(0, Math.min(255, Math.round(this.r) || 0)) +
      ', ' +
      Math.max(0, Math.min(255, Math.round(this.g) || 0)) +
      ', ' +
      Math.max(0, Math.min(255, Math.round(this.b) || 0)) +
      (t === 1 ? ')' : ', ' + t + ')')
  )
}
function Qu(t) {
  return (t = Math.max(0, Math.min(255, Math.round(t) || 0))), (t < 16 ? '0' : '') + t.toString(16)
}
function Xv(t, e, n, r) {
  return (
    r <= 0 ? (t = e = n = NaN) : n <= 0 || n >= 1 ? (t = e = NaN) : e <= 0 && (t = NaN),
    new qn(t, e, n, r)
  )
}
function M2(t) {
  if (t instanceof qn) return new qn(t.h, t.s, t.l, t.opacity)
  if ((t instanceof ks || (t = uu(t)), !t)) return new qn()
  if (t instanceof qn) return t
  t = t.rgb()
  var e = t.r / 255,
    n = t.g / 255,
    r = t.b / 255,
    i = Math.min(e, n, r),
    a = Math.max(e, n, r),
    o = NaN,
    s = a - i,
    c = (a + i) / 2
  return (
    s
      ? (e === a
          ? (o = (n - r) / s + (n < r) * 6)
          : n === a
          ? (o = (r - e) / s + 2)
          : (o = (e - n) / s + 4),
        (s /= c < 0.5 ? a + i : 2 - a - i),
        (o *= 60))
      : (s = c > 0 && c < 1 ? 0 : o),
    new qn(o, s, c, t.opacity)
  )
}
function zC(t, e, n, r) {
  return arguments.length === 1 ? M2(t) : new qn(t, e, n, r ?? 1)
}
function qn(t, e, n, r) {
  ;(this.h = +t), (this.s = +e), (this.l = +n), (this.opacity = +r)
}
gp(
  qn,
  zC,
  _2(ks, {
    brighter: function (t) {
      return (
        (t = t == null ? sl : Math.pow(sl, t)), new qn(this.h, this.s, this.l * t, this.opacity)
      )
    },
    darker: function (t) {
      return (
        (t = t == null ? ts : Math.pow(ts, t)), new qn(this.h, this.s, this.l * t, this.opacity)
      )
    },
    rgb: function () {
      var t = (this.h % 360) + (this.h < 0) * 360,
        e = isNaN(t) || isNaN(this.s) ? 0 : this.s,
        n = this.l,
        r = n + (n < 0.5 ? n : 1 - n) * e,
        i = 2 * n - r
      return new pn(
        Ju(t >= 240 ? t - 240 : t + 120, i, r),
        Ju(t, i, r),
        Ju(t < 120 ? t + 240 : t - 120, i, r),
        this.opacity
      )
    },
    displayable: function () {
      return (
        ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
        0 <= this.l &&
        this.l <= 1 &&
        0 <= this.opacity &&
        this.opacity <= 1
      )
    },
    formatHsl: function () {
      var t = this.opacity
      return (
        (t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))),
        (t === 1 ? 'hsl(' : 'hsla(') +
          (this.h || 0) +
          ', ' +
          (this.s || 0) * 100 +
          '%, ' +
          (this.l || 0) * 100 +
          '%' +
          (t === 1 ? ')' : ', ' + t + ')')
      )
    }
  })
)
function Ju(t, e, n) {
  return (
    (t < 60 ? e + ((n - e) * t) / 60 : t < 180 ? n : t < 240 ? e + ((n - e) * (240 - t)) / 60 : e) *
    255
  )
}
function wr(t, e, n, r) {
  var i = t - n,
    a = e - r
  return Math.sqrt(i * i + a * a)
}
function E2(t, e) {
  var n = Math.min.apply(Math, q([], N(t), !1)),
    r = Math.min.apply(Math, q([], N(e), !1)),
    i = Math.max.apply(Math, q([], N(t), !1)),
    a = Math.max.apply(Math, q([], N(e), !1))
  return { x: n, y: r, width: i - n, height: a - r }
}
function GC(t, e, n) {
  return Math.atan((-e / t) * Math.tan(n))
}
function WC(t, e, n) {
  return Math.atan(e / (t * Math.tan(n)))
}
function YC(t, e, n, r, i, a) {
  return n * Math.cos(i) * Math.cos(a) - r * Math.sin(i) * Math.sin(a) + t
}
function HC(t, e, n, r, i, a) {
  return n * Math.sin(i) * Math.cos(a) + r * Math.cos(i) * Math.sin(a) + e
}
function VC(t, e, n, r, i, a, o) {
  for (
    var s = GC(n, r, i), c = 1 / 0, l = -1 / 0, u = [a, o], f = -Math.PI * 2;
    f <= Math.PI * 2;
    f += Math.PI
  ) {
    var h = s + f
    a < o ? a < h && h < o && u.push(h) : o < h && h < a && u.push(h)
  }
  for (var f = 0; f < u.length; f++) {
    var d = YC(t, e, n, r, i, u[f])
    d < c && (c = d), d > l && (l = d)
  }
  for (
    var p = WC(n, r, i), v = 1 / 0, g = -1 / 0, y = [a, o], f = -Math.PI * 2;
    f <= Math.PI * 2;
    f += Math.PI
  ) {
    var m = p + f
    a < o ? a < m && m < o && y.push(m) : o < m && m < a && y.push(m)
  }
  for (var f = 0; f < y.length; f++) {
    var b = HC(t, e, n, r, i, y[f])
    b < v && (v = b), b > g && (g = b)
  }
  return { x: c, y: v, width: l - c, height: g - v }
}
var XC = 1e-4
function T2(t, e, n, r, i, a) {
  var o = -1,
    s = 1 / 0,
    c = [n, r],
    l = 20
  a && a > 200 && (l = a / 10)
  for (var u = 1 / l, f = u / 10, h = 0; h <= l; h++) {
    var d = h * u,
      p = [
        i.apply(void 0, q([], N(t.concat([d])), !1)),
        i.apply(void 0, q([], N(e.concat([d])), !1))
      ],
      v = wr(c[0], c[1], p[0], p[1])
    v < s && ((o = d), (s = v))
  }
  if (o === 0) return { x: t[0], y: e[0] }
  if (o === 1) {
    var g = t.length
    return { x: t[g - 1], y: e[g - 1] }
  }
  s = 1 / 0
  for (var h = 0; h < 32 && !(f < XC); h++) {
    var y = o - f,
      m = o + f,
      p = [
        i.apply(void 0, q([], N(t.concat([y])), !1)),
        i.apply(void 0, q([], N(e.concat([y])), !1))
      ],
      v = wr(c[0], c[1], p[0], p[1])
    if (y >= 0 && v < s) (o = y), (s = v)
    else {
      var b = [
          i.apply(void 0, q([], N(t.concat([m])), !1)),
          i.apply(void 0, q([], N(e.concat([m])), !1))
        ],
        x = wr(c[0], c[1], b[0], b[1])
      m <= 1 && x < s ? ((o = m), (s = x)) : (f *= 0.5)
    }
  }
  return {
    x: i.apply(void 0, q([], N(t.concat([o])), !1)),
    y: i.apply(void 0, q([], N(e.concat([o])), !1))
  }
}
function P2(t, e, n, r) {
  return wr(t, e, n, r)
}
function A2(t, e, n, r, i) {
  return { x: (1 - i) * t + i * n, y: (1 - i) * e + i * r }
}
function UC(t, e, n, r, i, a) {
  var o = [n - t, r - e]
  if (CA(o, [0, 0])) return Math.sqrt((i - t) * (i - t) + (a - e) * (a - e))
  var s = [-o[1], o[0]]
  AA(s, s)
  var c = [i - t, a - e]
  return Math.abs(kA(c, s))
}
function bh(t, e, n, r, i) {
  var a = 1 - i
  return a * a * a * t + 3 * e * i * a * a + 3 * n * i * i * a + r * i * i * i
}
function Uv(t, e, n, r) {
  var i = -3 * t + 9 * e - 9 * n + 3 * r,
    a = 6 * t - 12 * e + 6 * n,
    o = 3 * e - 3 * t,
    s = [],
    c,
    l,
    u
  if (No(i, 0)) No(a, 0) || ((c = -o / a), c >= 0 && c <= 1 && s.push(c))
  else {
    var f = a * a - 4 * i * o
    No(f, 0)
      ? s.push(-a / (2 * i))
      : f > 0 &&
        ((u = Math.sqrt(f)),
        (c = (-a + u) / (2 * i)),
        (l = (-a - u) / (2 * i)),
        c >= 0 && c <= 1 && s.push(c),
        l >= 0 && l <= 1 && s.push(l))
  }
  return s
}
function qC(t, e, n, r, i, a, o, s) {
  for (var c = [t, o], l = [e, s], u = Uv(t, n, i, o), f = Uv(e, r, a, s), h = 0; h < u.length; h++)
    c.push(bh(t, n, i, o, u[h]))
  for (var h = 0; h < f.length; h++) l.push(bh(e, r, a, s, f[h]))
  return E2(c, l)
}
function KC(t, e, n, r, i, a, o, s, c, l, u) {
  return T2([t, n, i, o], [e, r, a, s], c, l, bh, u)
}
function qv(t, e, n, r, i, a, o, s, c, l, u) {
  var f = KC(t, e, n, r, i, a, o, s, c, l, u)
  return wr(f.x, f.y, c, l)
}
function ZC(t) {
  if (t.length < 2) return 0
  for (var e = 0, n = 0; n < t.length - 1; n++) {
    var r = t[n],
      i = t[n + 1]
    e += wr(r[0], r[1], i[0], i[1])
  }
  return e
}
function QC(t) {
  return ZC(t)
}
function xh(t, e, n, r) {
  var i = 1 - r
  return i * i * t + 2 * r * i * e + r * r * n
}
function Kv(t, e, n) {
  var r = t + n - 2 * e
  if (No(r, 0)) return [0.5]
  var i = (t - e) / r
  return i <= 1 && i >= 0 ? [i] : []
}
function JC(t, e, n, r, i, a) {
  var o = Kv(t, n, i)[0],
    s = Kv(e, r, a)[0],
    c = [t, i],
    l = [e, a]
  return o !== void 0 && c.push(xh(t, n, i, o)), s !== void 0 && l.push(xh(e, r, a, s)), E2(c, l)
}
function tL(t, e, n, r, i, a, o, s) {
  return T2([t, n, i], [e, r, a], o, s, xh)
}
function eL(t, e, n, r, i, a, o, s) {
  var c = tL(t, e, n, r, i, a, o, s)
  return wr(c.x, c.y, o, s)
}
var nL =
    typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
      ? window
      : typeof global < 'u'
      ? global
      : typeof self < 'u'
      ? self
      : {},
  k2 = { exports: {} }
;(function (t, e) {
  ;(function (n, r) {
    t.exports = r()
  })(nL, function () {
    function n(w, O, S, _, M) {
      r(w, O, S || 0, _ || w.length - 1, M || a)
    }
    function r(w, O, S, _, M) {
      for (; _ > S; ) {
        if (_ - S > 600) {
          var E = _ - S + 1,
            T = O - S + 1,
            C = Math.log(E),
            A = 0.5 * Math.exp((2 * C) / 3),
            P = 0.5 * Math.sqrt((C * A * (E - A)) / E) * (T - E / 2 < 0 ? -1 : 1),
            k = Math.max(S, Math.floor(O - (T * A) / E + P)),
            L = Math.min(_, Math.floor(O + ((E - T) * A) / E + P))
          r(w, O, k, L, M)
        }
        var R = w[O],
          j = S,
          I = _
        for (i(w, S, O), M(w[_], R) > 0 && i(w, S, _); j < I; ) {
          for (i(w, j, I), j++, I--; M(w[j], R) < 0; ) j++
          for (; M(w[I], R) > 0; ) I--
        }
        M(w[S], R) === 0 ? i(w, S, I) : (I++, i(w, I, _)),
          I <= O && (S = I + 1),
          O <= I && (_ = I - 1)
      }
    }
    function i(w, O, S) {
      var _ = w[O]
      ;(w[O] = w[S]), (w[S] = _)
    }
    function a(w, O) {
      return w < O ? -1 : w > O ? 1 : 0
    }
    var o = function (O) {
      O === void 0 && (O = 9),
        (this._maxEntries = Math.max(4, O)),
        (this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4))),
        this.clear()
    }
    ;(o.prototype.all = function () {
      return this._all(this.data, [])
    }),
      (o.prototype.search = function (O) {
        var S = this.data,
          _ = []
        if (!m(O, S)) return _
        for (var M = this.toBBox, E = []; S; ) {
          for (var T = 0; T < S.children.length; T++) {
            var C = S.children[T],
              A = S.leaf ? M(C) : C
            m(O, A) && (S.leaf ? _.push(C) : y(O, A) ? this._all(C, _) : E.push(C))
          }
          S = E.pop()
        }
        return _
      }),
      (o.prototype.collides = function (O) {
        var S = this.data
        if (!m(O, S)) return !1
        for (var _ = []; S; ) {
          for (var M = 0; M < S.children.length; M++) {
            var E = S.children[M],
              T = S.leaf ? this.toBBox(E) : E
            if (m(O, T)) {
              if (S.leaf || y(O, T)) return !0
              _.push(E)
            }
          }
          S = _.pop()
        }
        return !1
      }),
      (o.prototype.load = function (O) {
        if (!(O && O.length)) return this
        if (O.length < this._minEntries) {
          for (var S = 0; S < O.length; S++) this.insert(O[S])
          return this
        }
        var _ = this._build(O.slice(), 0, O.length - 1, 0)
        if (!this.data.children.length) this.data = _
        else if (this.data.height === _.height) this._splitRoot(this.data, _)
        else {
          if (this.data.height < _.height) {
            var M = this.data
            ;(this.data = _), (_ = M)
          }
          this._insert(_, this.data.height - _.height - 1, !0)
        }
        return this
      }),
      (o.prototype.insert = function (O) {
        return O && this._insert(O, this.data.height - 1), this
      }),
      (o.prototype.clear = function () {
        return (this.data = b([])), this
      }),
      (o.prototype.remove = function (O, S) {
        if (!O) return this
        for (var _ = this.data, M = this.toBBox(O), E = [], T = [], C, A, P; _ || E.length; ) {
          if ((_ || ((_ = E.pop()), (A = E[E.length - 1]), (C = T.pop()), (P = !0)), _.leaf)) {
            var k = s(O, _.children, S)
            if (k !== -1) return _.children.splice(k, 1), E.push(_), this._condense(E), this
          }
          !P && !_.leaf && y(_, M)
            ? (E.push(_), T.push(C), (C = 0), (A = _), (_ = _.children[0]))
            : A
            ? (C++, (_ = A.children[C]), (P = !1))
            : (_ = null)
        }
        return this
      }),
      (o.prototype.toBBox = function (O) {
        return O
      }),
      (o.prototype.compareMinX = function (O, S) {
        return O.minX - S.minX
      }),
      (o.prototype.compareMinY = function (O, S) {
        return O.minY - S.minY
      }),
      (o.prototype.toJSON = function () {
        return this.data
      }),
      (o.prototype.fromJSON = function (O) {
        return (this.data = O), this
      }),
      (o.prototype._all = function (O, S) {
        for (var _ = []; O; )
          O.leaf ? S.push.apply(S, O.children) : _.push.apply(_, O.children), (O = _.pop())
        return S
      }),
      (o.prototype._build = function (O, S, _, M) {
        var E = _ - S + 1,
          T = this._maxEntries,
          C
        if (E <= T) return (C = b(O.slice(S, _ + 1))), c(C, this.toBBox), C
        M || ((M = Math.ceil(Math.log(E) / Math.log(T))), (T = Math.ceil(E / Math.pow(T, M - 1)))),
          (C = b([])),
          (C.leaf = !1),
          (C.height = M)
        var A = Math.ceil(E / T),
          P = A * Math.ceil(Math.sqrt(T))
        x(O, S, _, P, this.compareMinX)
        for (var k = S; k <= _; k += P) {
          var L = Math.min(k + P - 1, _)
          x(O, k, L, A, this.compareMinY)
          for (var R = k; R <= L; R += A) {
            var j = Math.min(R + A - 1, L)
            C.children.push(this._build(O, R, j, M - 1))
          }
        }
        return c(C, this.toBBox), C
      }),
      (o.prototype._chooseSubtree = function (O, S, _, M) {
        for (; M.push(S), !(S.leaf || M.length - 1 === _); ) {
          for (var E = 1 / 0, T = 1 / 0, C = void 0, A = 0; A < S.children.length; A++) {
            var P = S.children[A],
              k = d(P),
              L = v(O, P) - k
            L < T ? ((T = L), (E = k < E ? k : E), (C = P)) : L === T && k < E && ((E = k), (C = P))
          }
          S = C || S.children[0]
        }
        return S
      }),
      (o.prototype._insert = function (O, S, _) {
        var M = _ ? O : this.toBBox(O),
          E = [],
          T = this._chooseSubtree(M, this.data, S, E)
        for (T.children.push(O), u(T, M); S >= 0 && E[S].children.length > this._maxEntries; )
          this._split(E, S), S--
        this._adjustParentBBoxes(M, E, S)
      }),
      (o.prototype._split = function (O, S) {
        var _ = O[S],
          M = _.children.length,
          E = this._minEntries
        this._chooseSplitAxis(_, E, M)
        var T = this._chooseSplitIndex(_, E, M),
          C = b(_.children.splice(T, _.children.length - T))
        ;(C.height = _.height),
          (C.leaf = _.leaf),
          c(_, this.toBBox),
          c(C, this.toBBox),
          S ? O[S - 1].children.push(C) : this._splitRoot(_, C)
      }),
      (o.prototype._splitRoot = function (O, S) {
        ;(this.data = b([O, S])),
          (this.data.height = O.height + 1),
          (this.data.leaf = !1),
          c(this.data, this.toBBox)
      }),
      (o.prototype._chooseSplitIndex = function (O, S, _) {
        for (var M, E = 1 / 0, T = 1 / 0, C = S; C <= _ - S; C++) {
          var A = l(O, 0, C, this.toBBox),
            P = l(O, C, _, this.toBBox),
            k = g(A, P),
            L = d(A) + d(P)
          k < E ? ((E = k), (M = C), (T = L < T ? L : T)) : k === E && L < T && ((T = L), (M = C))
        }
        return M || _ - S
      }),
      (o.prototype._chooseSplitAxis = function (O, S, _) {
        var M = O.leaf ? this.compareMinX : f,
          E = O.leaf ? this.compareMinY : h,
          T = this._allDistMargin(O, S, _, M),
          C = this._allDistMargin(O, S, _, E)
        T < C && O.children.sort(M)
      }),
      (o.prototype._allDistMargin = function (O, S, _, M) {
        O.children.sort(M)
        for (
          var E = this.toBBox, T = l(O, 0, S, E), C = l(O, _ - S, _, E), A = p(T) + p(C), P = S;
          P < _ - S;
          P++
        ) {
          var k = O.children[P]
          u(T, O.leaf ? E(k) : k), (A += p(T))
        }
        for (var L = _ - S - 1; L >= S; L--) {
          var R = O.children[L]
          u(C, O.leaf ? E(R) : R), (A += p(C))
        }
        return A
      }),
      (o.prototype._adjustParentBBoxes = function (O, S, _) {
        for (var M = _; M >= 0; M--) u(S[M], O)
      }),
      (o.prototype._condense = function (O) {
        for (var S = O.length - 1, _ = void 0; S >= 0; S--)
          O[S].children.length === 0
            ? S > 0
              ? ((_ = O[S - 1].children), _.splice(_.indexOf(O[S]), 1))
              : this.clear()
            : c(O[S], this.toBBox)
      })
    function s(w, O, S) {
      if (!S) return O.indexOf(w)
      for (var _ = 0; _ < O.length; _++) if (S(w, O[_])) return _
      return -1
    }
    function c(w, O) {
      l(w, 0, w.children.length, O, w)
    }
    function l(w, O, S, _, M) {
      M || (M = b(null)), (M.minX = 1 / 0), (M.minY = 1 / 0), (M.maxX = -1 / 0), (M.maxY = -1 / 0)
      for (var E = O; E < S; E++) {
        var T = w.children[E]
        u(M, w.leaf ? _(T) : T)
      }
      return M
    }
    function u(w, O) {
      return (
        (w.minX = Math.min(w.minX, O.minX)),
        (w.minY = Math.min(w.minY, O.minY)),
        (w.maxX = Math.max(w.maxX, O.maxX)),
        (w.maxY = Math.max(w.maxY, O.maxY)),
        w
      )
    }
    function f(w, O) {
      return w.minX - O.minX
    }
    function h(w, O) {
      return w.minY - O.minY
    }
    function d(w) {
      return (w.maxX - w.minX) * (w.maxY - w.minY)
    }
    function p(w) {
      return w.maxX - w.minX + (w.maxY - w.minY)
    }
    function v(w, O) {
      return (
        (Math.max(O.maxX, w.maxX) - Math.min(O.minX, w.minX)) *
        (Math.max(O.maxY, w.maxY) - Math.min(O.minY, w.minY))
      )
    }
    function g(w, O) {
      var S = Math.max(w.minX, O.minX),
        _ = Math.max(w.minY, O.minY),
        M = Math.min(w.maxX, O.maxX),
        E = Math.min(w.maxY, O.maxY)
      return Math.max(0, M - S) * Math.max(0, E - _)
    }
    function y(w, O) {
      return w.minX <= O.minX && w.minY <= O.minY && O.maxX <= w.maxX && O.maxY <= w.maxY
    }
    function m(w, O) {
      return O.minX <= w.maxX && O.minY <= w.maxY && O.maxX >= w.minX && O.maxY >= w.minY
    }
    function b(w) {
      return {
        children: w,
        height: 1,
        leaf: !0,
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0
      }
    }
    function x(w, O, S, _, M) {
      for (var E = [O, S]; E.length; )
        if (((S = E.pop()), (O = E.pop()), !(S - O <= _))) {
          var T = O + Math.ceil((S - O) / _ / 2) * _
          n(w, T, O, S, M), E.push(O, T, T, S)
        }
    }
    return o
  })
})(k2)
var rL = k2.exports,
  G
;(function (t) {
  ;(t.GROUP = 'g'),
    (t.CIRCLE = 'circle'),
    (t.ELLIPSE = 'ellipse'),
    (t.IMAGE = 'image'),
    (t.RECT = 'rect'),
    (t.LINE = 'line'),
    (t.POLYLINE = 'polyline'),
    (t.POLYGON = 'polygon'),
    (t.TEXT = 'text'),
    (t.PATH = 'path'),
    (t.HTML = 'html'),
    (t.MESH = 'mesh')
})(G || (G = {}))
var ma
;(function (t) {
  ;(t[(t.ZERO = 0)] = 'ZERO'), (t[(t.NEGATIVE_ONE = 1)] = 'NEGATIVE_ONE')
})(ma || (ma = {}))
var oi = (function () {
    function t() {
      this.plugins = []
    }
    return (
      (t.prototype.addRenderingPlugin = function (e) {
        this.plugins.push(e), this.context.renderingPlugins.push(e)
      }),
      (t.prototype.removeAllRenderingPlugins = function () {
        var e = this
        this.plugins.forEach(function (n) {
          var r = e.context.renderingPlugins.indexOf(n)
          r >= 0 && e.context.renderingPlugins.splice(r, 1)
        })
      }),
      t
    )
  })(),
  iL = (function () {
    function t(e) {
      ;(this.clipSpaceNearZ = ma.NEGATIVE_ONE),
        (this.plugins = []),
        (this.config = z(
          {
            enableDirtyCheck: !0,
            enableCulling: !1,
            enableAutoRendering: !0,
            enableDirtyRectangleRendering: !0,
            enableDirtyRectangleRenderingDebug: !1
          },
          e
        ))
    }
    return (
      (t.prototype.registerPlugin = function (e) {
        var n = this.plugins.findIndex(function (r) {
          return r === e
        })
        n === -1 && this.plugins.push(e)
      }),
      (t.prototype.unregisterPlugin = function (e) {
        var n = this.plugins.findIndex(function (r) {
          return r === e
        })
        n > -1 && this.plugins.splice(n, 1)
      }),
      (t.prototype.getPlugins = function () {
        return this.plugins
      }),
      (t.prototype.getPlugin = function (e) {
        return this.plugins.find(function (n) {
          return n.name === e
        })
      }),
      (t.prototype.getConfig = function () {
        return this.config
      }),
      (t.prototype.setConfig = function (e) {
        Object.assign(this.config, e)
      }),
      t
    )
  })()
function Qi(t, e) {
  return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), t
}
function tf(t, e, n) {
  return (t[0] = e[0] - n[0]), (t[1] = e[1] - n[1]), (t[2] = e[2] - n[2]), t
}
function Bc(t, e, n) {
  return (t[0] = e[0] + n[0]), (t[1] = e[1] + n[1]), (t[2] = e[2] + n[2]), t
}
function Zv(t, e, n) {
  return (t[0] = e[0] * n), (t[1] = e[1] * n), (t[2] = e[2] * n), t
}
function aL(t, e, n) {
  return (
    (t[0] = Math.max(e[0], n[0])), (t[1] = Math.max(e[1], n[1])), (t[2] = Math.max(e[2], n[2])), t
  )
}
function oL(t, e, n) {
  return (
    (t[0] = Math.min(e[0], n[0])), (t[1] = Math.min(e[1], n[1])), (t[2] = Math.min(e[2], n[2])), t
  )
}
function ba(t) {
  return t === void 0 ? 0 : t > 360 || t < -360 ? t % 360 : t
}
function Ge(t, e, n) {
  return (
    e === void 0 && (e = 0),
    n === void 0 && (n = 0),
    Array.isArray(t) && t.length === 3
      ? dr(t)
      : ve(t)
      ? St(t, e, n)
      : St(t[0], t[1] || e, t[2] || n)
  )
}
function Jt(t) {
  return t * (Math.PI / 180)
}
function Mn(t) {
  return t * (180 / Math.PI)
}
function sL(t) {
  return 360 * t
}
function cL(t, e) {
  var n = e[0],
    r = e[1],
    i = e[2],
    a = e[3],
    o = n * n,
    s = r * r,
    c = i * i,
    l = a * a,
    u = o + s + c + l,
    f = n * a - r * i
  return (
    f > 0.499995 * u
      ? ((t[0] = Math.PI / 2), (t[1] = 2 * Math.atan2(r, n)), (t[2] = 0))
      : f < -0.499995 * u
      ? ((t[0] = -Math.PI / 2), (t[1] = 2 * Math.atan2(r, n)), (t[2] = 0))
      : ((t[0] = Math.asin(2 * (n * i - a * r))),
        (t[1] = Math.atan2(2 * (n * a + r * i), 1 - 2 * (c + l))),
        (t[2] = Math.atan2(2 * (n * r + i * a), 1 - 2 * (s + c)))),
    t
  )
}
function lL(t, e) {
  var n,
    r,
    i = Math.PI * 0.5,
    a = N(Ma(yt(), e), 3),
    o = a[0],
    s = a[1],
    c = a[2],
    l = Math.asin(-e[2] / o)
  return (
    l < i
      ? l > -i
        ? ((n = Math.atan2(e[6] / s, e[10] / c)), (r = Math.atan2(e[1] / o, e[0] / o)))
        : ((r = 0), (n = -Math.atan2(e[4] / s, e[5] / s)))
      : ((r = 0), (n = Math.atan2(e[4] / s, e[5] / s))),
    (t[0] = n),
    (t[1] = l),
    (t[2] = r),
    t
  )
}
function ef(t, e) {
  return e.length === 16 ? lL(t, e) : cL(t, e)
}
function uL(t, e, n, r, i) {
  var a = Math.cos(t),
    o = Math.sin(t)
  return GP(r * a, i * o, 0, -r * o, i * a, 0, e, n, 1)
}
function fL(t, e, n, r, i, a, o, s) {
  s === void 0 && (s = !1)
  var c = (2 * a) / (n - e),
    l = (2 * a) / (r - i),
    u = (n + e) / (n - e),
    f = (r + i) / (r - i),
    h,
    d
  return (
    s
      ? ((h = -o / (o - a)), (d = (-o * a) / (o - a)))
      : ((h = -(o + a) / (o - a)), (d = (-2 * o * a) / (o - a))),
    (t[0] = c),
    (t[1] = 0),
    (t[2] = 0),
    (t[3] = 0),
    (t[4] = 0),
    (t[5] = l),
    (t[6] = 0),
    (t[7] = 0),
    (t[8] = u),
    (t[9] = f),
    (t[10] = h),
    (t[11] = -1),
    (t[12] = 0),
    (t[13] = 0),
    (t[14] = d),
    (t[15] = 0),
    t
  )
}
function Qv(t) {
  var e = t[0],
    n = t[1],
    r = t[3],
    i = t[4],
    a = Math.sqrt(e * e + n * n),
    o = Math.sqrt(r * r + i * i),
    s = e * i - n * r
  s < 0 && (e < i ? (a = -a) : (o = -o)),
    a && ((e *= 1 / a), (n *= 1 / a)),
    o && ((r *= 1 / o), (i *= 1 / o))
  var c = Math.atan2(n, e),
    l = Mn(c)
  return [t[6], t[7], a, o, l]
}
var Xn = Nt(),
  Dn = Nt(),
  fo = ca(),
  lt = [yt(), yt(), yt()],
  Jv = yt()
function hL(t, e, n, r, i, a) {
  if (
    !dL(Xn, t) ||
    (Li(Dn, Xn), (Dn[3] = 0), (Dn[7] = 0), (Dn[11] = 0), (Dn[15] = 1), Math.abs(ab(Dn)) < 1e-8)
  )
    return !1
  var o = Xn[3],
    s = Xn[7],
    c = Xn[11],
    l = Xn[12],
    u = Xn[13],
    f = Xn[14],
    h = Xn[15]
  if (o !== 0 || s !== 0 || c !== 0) {
    ;(fo[0] = o), (fo[1] = s), (fo[2] = c), (fo[3] = h)
    var d = zn(Dn, Dn)
    if (!d) return !1
    ib(Dn, Dn), la(i, fo, Dn)
  } else (i[0] = i[1] = i[2] = 0), (i[3] = 1)
  if (
    ((e[0] = l),
    (e[1] = u),
    (e[2] = f),
    pL(lt, Xn),
    (n[0] = vr(lt[0])),
    Ti(lt[0], lt[0]),
    (r[0] = Jn(lt[0], lt[1])),
    nf(lt[1], lt[1], lt[0], 1, -r[0]),
    (n[1] = vr(lt[1])),
    Ti(lt[1], lt[1]),
    (r[0] /= n[1]),
    (r[1] = Jn(lt[0], lt[2])),
    nf(lt[2], lt[2], lt[0], 1, -r[1]),
    (r[2] = Jn(lt[1], lt[2])),
    nf(lt[2], lt[2], lt[1], 1, -r[2]),
    (n[2] = vr(lt[2])),
    Ti(lt[2], lt[2]),
    (r[1] /= n[2]),
    (r[2] /= n[2]),
    jc(Jv, lt[1], lt[2]),
    Jn(lt[0], Jv) < 0)
  )
    for (var p = 0; p < 3; p++) (n[p] *= -1), (lt[p][0] *= -1), (lt[p][1] *= -1), (lt[p][2] *= -1)
  return (
    (a[0] = 0.5 * Math.sqrt(Math.max(1 + lt[0][0] - lt[1][1] - lt[2][2], 0))),
    (a[1] = 0.5 * Math.sqrt(Math.max(1 - lt[0][0] + lt[1][1] - lt[2][2], 0))),
    (a[2] = 0.5 * Math.sqrt(Math.max(1 - lt[0][0] - lt[1][1] + lt[2][2], 0))),
    (a[3] = 0.5 * Math.sqrt(Math.max(1 + lt[0][0] + lt[1][1] + lt[2][2], 0))),
    lt[2][1] > lt[1][2] && (a[0] = -a[0]),
    lt[0][2] > lt[2][0] && (a[1] = -a[1]),
    lt[1][0] > lt[0][1] && (a[2] = -a[2]),
    !0
  )
}
function dL(t, e) {
  var n = e[15]
  if (n === 0) return !1
  for (var r = 1 / n, i = 0; i < 16; i++) t[i] = e[i] * r
  return !0
}
function pL(t, e) {
  ;(t[0][0] = e[0]),
    (t[0][1] = e[1]),
    (t[0][2] = e[2]),
    (t[1][0] = e[4]),
    (t[1][1] = e[5]),
    (t[1][2] = e[6]),
    (t[2][0] = e[8]),
    (t[2][1] = e[9]),
    (t[2][2] = e[10])
}
function nf(t, e, n, r, i) {
  ;(t[0] = e[0] * r + n[0] * i), (t[1] = e[1] * r + n[1] * i), (t[2] = e[2] * r + n[2] * i)
}
var me = (function () {
    function t() {
      ;(this.center = [0, 0, 0]),
        (this.halfExtents = [0, 0, 0]),
        (this.min = [0, 0, 0]),
        (this.max = [0, 0, 0])
    }
    return (
      (t.isEmpty = function (e) {
        return !e || (e.halfExtents[0] === 0 && e.halfExtents[1] === 0 && e.halfExtents[2] === 0)
      }),
      (t.prototype.update = function (e, n) {
        Qi(this.center, e),
          Qi(this.halfExtents, n),
          tf(this.min, this.center, this.halfExtents),
          Bc(this.max, this.center, this.halfExtents)
      }),
      (t.prototype.setMinMax = function (e, n) {
        Bc(this.center, n, e),
          Zv(this.center, this.center, 0.5),
          tf(this.halfExtents, n, e),
          Zv(this.halfExtents, this.halfExtents, 0.5),
          Qi(this.min, e),
          Qi(this.max, n)
      }),
      (t.prototype.getMin = function () {
        return this.min
      }),
      (t.prototype.getMax = function () {
        return this.max
      }),
      (t.prototype.add = function (e) {
        if (!t.isEmpty(e)) {
          if (t.isEmpty(this)) {
            this.setMinMax(e.getMin(), e.getMax())
            return
          }
          var n = this.center,
            r = n[0],
            i = n[1],
            a = n[2],
            o = this.halfExtents,
            s = o[0],
            c = o[1],
            l = o[2],
            u = r - s,
            f = r + s,
            h = i - c,
            d = i + c,
            p = a - l,
            v = a + l,
            g = e.center,
            y = g[0],
            m = g[1],
            b = g[2],
            x = e.halfExtents,
            w = x[0],
            O = x[1],
            S = x[2],
            _ = y - w,
            M = y + w,
            E = m - O,
            T = m + O,
            C = b - S,
            A = b + S
          _ < u && (u = _),
            M > f && (f = M),
            E < h && (h = E),
            T > d && (d = T),
            C < p && (p = C),
            A > v && (v = A),
            (n[0] = (u + f) * 0.5),
            (n[1] = (h + d) * 0.5),
            (n[2] = (p + v) * 0.5),
            (o[0] = (f - u) * 0.5),
            (o[1] = (d - h) * 0.5),
            (o[2] = (v - p) * 0.5),
            (this.min[0] = u),
            (this.min[1] = h),
            (this.min[2] = p),
            (this.max[0] = f),
            (this.max[1] = d),
            (this.max[2] = v)
        }
      }),
      (t.prototype.setFromTransformedAABB = function (e, n) {
        var r = this.center,
          i = this.halfExtents,
          a = e.center,
          o = e.halfExtents,
          s = n[0],
          c = n[4],
          l = n[8],
          u = n[1],
          f = n[5],
          h = n[9],
          d = n[2],
          p = n[6],
          v = n[10],
          g = Math.abs(s),
          y = Math.abs(c),
          m = Math.abs(l),
          b = Math.abs(u),
          x = Math.abs(f),
          w = Math.abs(h),
          O = Math.abs(d),
          S = Math.abs(p),
          _ = Math.abs(v)
        ;(r[0] = n[12] + s * a[0] + c * a[1] + l * a[2]),
          (r[1] = n[13] + u * a[0] + f * a[1] + h * a[2]),
          (r[2] = n[14] + d * a[0] + p * a[1] + v * a[2]),
          (i[0] = g * o[0] + y * o[1] + m * o[2]),
          (i[1] = b * o[0] + x * o[1] + w * o[2]),
          (i[2] = O * o[0] + S * o[1] + _ * o[2]),
          tf(this.min, r, i),
          Bc(this.max, r, i)
      }),
      (t.prototype.intersects = function (e) {
        var n = this.getMax(),
          r = this.getMin(),
          i = e.getMax(),
          a = e.getMin()
        return (
          r[0] <= i[0] &&
          n[0] >= a[0] &&
          r[1] <= i[1] &&
          n[1] >= a[1] &&
          r[2] <= i[2] &&
          n[2] >= a[2]
        )
      }),
      (t.prototype.intersection = function (e) {
        if (!this.intersects(e)) return null
        var n = new t(),
          r = aL([0, 0, 0], this.getMin(), e.getMin()),
          i = oL([0, 0, 0], this.getMax(), e.getMax())
        return n.setMinMax(r, i), n
      }),
      (t.prototype.getNegativeFarPoint = function (e) {
        return e.pnVertexFlag === 273
          ? Qi([0, 0, 0], this.min)
          : e.pnVertexFlag === 272
          ? [this.min[0], this.min[1], this.max[2]]
          : e.pnVertexFlag === 257
          ? [this.min[0], this.max[1], this.min[2]]
          : e.pnVertexFlag === 256
          ? [this.min[0], this.max[1], this.max[2]]
          : e.pnVertexFlag === 17
          ? [this.max[0], this.min[1], this.min[2]]
          : e.pnVertexFlag === 16
          ? [this.max[0], this.min[1], this.max[2]]
          : e.pnVertexFlag === 1
          ? [this.max[0], this.max[1], this.min[2]]
          : [this.max[0], this.max[1], this.max[2]]
      }),
      (t.prototype.getPositiveFarPoint = function (e) {
        return e.pnVertexFlag === 273
          ? Qi([0, 0, 0], this.max)
          : e.pnVertexFlag === 272
          ? [this.max[0], this.max[1], this.min[2]]
          : e.pnVertexFlag === 257
          ? [this.max[0], this.min[1], this.max[2]]
          : e.pnVertexFlag === 256
          ? [this.max[0], this.min[1], this.min[2]]
          : e.pnVertexFlag === 17
          ? [this.min[0], this.max[1], this.max[2]]
          : e.pnVertexFlag === 16
          ? [this.min[0], this.max[1], this.min[2]]
          : e.pnVertexFlag === 1
          ? [this.min[0], this.min[1], this.max[2]]
          : [this.min[0], this.min[1], this.min[2]]
      }),
      t
    )
  })(),
  vL = (function () {
    function t(e, n) {
      ;(this.distance = e || 0), (this.normal = n || St(0, 1, 0)), this.updatePNVertexFlag()
    }
    return (
      (t.prototype.updatePNVertexFlag = function () {
        this.pnVertexFlag =
          (+(this.normal[0] >= 0) << 8) + (+(this.normal[1] >= 0) << 4) + +(this.normal[2] >= 0)
      }),
      (t.prototype.distanceToPoint = function (e) {
        return Jn(e, this.normal) - this.distance
      }),
      (t.prototype.normalize = function () {
        var e = 1 / yb(this.normal)
        Jf(this.normal, this.normal, e), (this.distance *= e)
      }),
      (t.prototype.intersectsLine = function (e, n, r) {
        var i = this.distanceToPoint(e),
          a = this.distanceToPoint(n),
          o = i / (i - a),
          s = o >= 0 && o <= 1
        return s && r && th(r, e, n, o), s
      }),
      t
    )
  })(),
  Rr
;(function (t) {
  ;(t[(t.OUTSIDE = 4294967295)] = 'OUTSIDE'),
    (t[(t.INSIDE = 0)] = 'INSIDE'),
    (t[(t.INDETERMINATE = 2147483647)] = 'INDETERMINATE')
})(Rr || (Rr = {}))
var gL = (function () {
    function t(e) {
      if (((this.planes = []), e)) this.planes = e
      else for (var n = 0; n < 6; n++) this.planes.push(new vL())
    }
    return (
      (t.prototype.extractFromVPMatrix = function (e) {
        var n = N(e, 16),
          r = n[0],
          i = n[1],
          a = n[2],
          o = n[3],
          s = n[4],
          c = n[5],
          l = n[6],
          u = n[7],
          f = n[8],
          h = n[9],
          d = n[10],
          p = n[11],
          v = n[12],
          g = n[13],
          y = n[14],
          m = n[15]
        $n(this.planes[0].normal, o - r, u - s, p - f),
          (this.planes[0].distance = m - v),
          $n(this.planes[1].normal, o + r, u + s, p + f),
          (this.planes[1].distance = m + v),
          $n(this.planes[2].normal, o + i, u + c, p + h),
          (this.planes[2].distance = m + g),
          $n(this.planes[3].normal, o - i, u - c, p - h),
          (this.planes[3].distance = m - g),
          $n(this.planes[4].normal, o - a, u - l, p - d),
          (this.planes[4].distance = m - y),
          $n(this.planes[5].normal, o + a, u + l, p + d),
          (this.planes[5].distance = m + y),
          this.planes.forEach(function (b) {
            b.normalize(), b.updatePNVertexFlag()
          })
      }),
      t
    )
  })(),
  Ee = (function () {
    function t(e, n) {
      e === void 0 && (e = 0),
        n === void 0 && (n = 0),
        (this.x = 0),
        (this.y = 0),
        (this.x = e),
        (this.y = n)
    }
    return (
      (t.prototype.clone = function () {
        return new t(this.x, this.y)
      }),
      (t.prototype.copyFrom = function (e) {
        ;(this.x = e.x), (this.y = e.y)
      }),
      t
    )
  })(),
  ji = (function () {
    function t(e, n, r, i) {
      ;(this.x = e),
        (this.y = n),
        (this.width = r),
        (this.height = i),
        (this.left = e),
        (this.right = e + r),
        (this.top = n),
        (this.bottom = n + i)
    }
    return (t.prototype.toJSON = function () {}), t
  })(),
  It = 'Method not implemented.',
  Ji = 'Use document.documentElement instead.',
  yL = 'Cannot append a destroyed element.',
  kt
;(function (t) {
  ;(t[(t.ORBITING = 0)] = 'ORBITING'),
    (t[(t.EXPLORING = 1)] = 'EXPLORING'),
    (t[(t.TRACKING = 2)] = 'TRACKING')
})(kt || (kt = {}))
var ns
;(function (t) {
  ;(t[(t.DEFAULT = 0)] = 'DEFAULT'),
    (t[(t.ROTATIONAL = 1)] = 'ROTATIONAL'),
    (t[(t.TRANSLATIONAL = 2)] = 'TRANSLATIONAL'),
    (t[(t.CINEMATIC = 3)] = 'CINEMATIC')
})(ns || (ns = {}))
var qe
;(function (t) {
  ;(t[(t.ORTHOGRAPHIC = 0)] = 'ORTHOGRAPHIC'), (t[(t.PERSPECTIVE = 1)] = 'PERSPECTIVE')
})(qe || (qe = {}))
var C2 = { UPDATED: 'updated' },
  tg = 2e-4,
  L2 = (function () {
    function t() {
      ;(this.clipSpaceNearZ = ma.NEGATIVE_ONE),
        (this.eventEmitter = new vp()),
        (this.matrix = Nt()),
        (this.right = St(1, 0, 0)),
        (this.up = St(0, 1, 0)),
        (this.forward = St(0, 0, 1)),
        (this.position = St(0, 0, 1)),
        (this.focalPoint = St(0, 0, 0)),
        (this.distanceVector = St(0, 0, -1)),
        (this.distance = 1),
        (this.azimuth = 0),
        (this.elevation = 0),
        (this.roll = 0),
        (this.relAzimuth = 0),
        (this.relElevation = 0),
        (this.relRoll = 0),
        (this.dollyingStep = 0),
        (this.maxDistance = 1 / 0),
        (this.minDistance = -1 / 0),
        (this.zoom = 1),
        (this.rotateWorld = !1),
        (this.fov = 30),
        (this.near = 0.1),
        (this.far = 1e3),
        (this.aspect = 1),
        (this.projectionMatrix = Nt()),
        (this.projectionMatrixInverse = Nt()),
        (this.jitteredProjectionMatrix = void 0),
        (this.enableUpdate = !0),
        (this.type = kt.EXPLORING),
        (this.trackingMode = ns.DEFAULT),
        (this.projectionMode = qe.PERSPECTIVE),
        (this.frustum = new gL()),
        (this.orthoMatrix = Nt())
    }
    return (
      (t.prototype.isOrtho = function () {
        return this.projectionMode === qe.ORTHOGRAPHIC
      }),
      (t.prototype.getProjectionMode = function () {
        return this.projectionMode
      }),
      (t.prototype.getPerspective = function () {
        return this.jitteredProjectionMatrix || this.projectionMatrix
      }),
      (t.prototype.getPerspectiveInverse = function () {
        return this.projectionMatrixInverse
      }),
      (t.prototype.getFrustum = function () {
        return this.frustum
      }),
      (t.prototype.getPosition = function () {
        return this.position
      }),
      (t.prototype.getFocalPoint = function () {
        return this.focalPoint
      }),
      (t.prototype.getDollyingStep = function () {
        return this.dollyingStep
      }),
      (t.prototype.getNear = function () {
        return this.near
      }),
      (t.prototype.getFar = function () {
        return this.far
      }),
      (t.prototype.getZoom = function () {
        return this.zoom
      }),
      (t.prototype.getOrthoMatrix = function () {
        return this.orthoMatrix
      }),
      (t.prototype.getView = function () {
        return this.view
      }),
      (t.prototype.setEnableUpdate = function (e) {
        this.enableUpdate = e
      }),
      (t.prototype.setType = function (e, n) {
        return (
          (this.type = e),
          this.type === kt.EXPLORING ? this.setWorldRotation(!0) : this.setWorldRotation(!1),
          this._getAngles(),
          this.type === kt.TRACKING && n !== void 0 && this.setTrackingMode(n),
          this
        )
      }),
      (t.prototype.setProjectionMode = function (e) {
        return (this.projectionMode = e), this
      }),
      (t.prototype.setTrackingMode = function (e) {
        if (this.type !== kt.TRACKING)
          throw new Error('Impossible to set a tracking mode if the camera is not of tracking type')
        return (this.trackingMode = e), this
      }),
      (t.prototype.setWorldRotation = function (e) {
        return (this.rotateWorld = e), this._getAngles(), this
      }),
      (t.prototype.getViewTransform = function () {
        return zn(Nt(), this.matrix)
      }),
      (t.prototype.getWorldTransform = function () {
        return this.matrix
      }),
      (t.prototype.jitterProjectionMatrix = function (e, n) {
        var r = Bd(Nt(), [e, n, 0])
        this.jitteredProjectionMatrix = Re(Nt(), r, this.projectionMatrix)
      }),
      (t.prototype.clearJitterProjectionMatrix = function () {
        this.jitteredProjectionMatrix = void 0
      }),
      (t.prototype.setMatrix = function (e) {
        return (this.matrix = e), this._update(), this
      }),
      (t.prototype.setFov = function (e) {
        return this.setPerspective(this.near, this.far, e, this.aspect), this
      }),
      (t.prototype.setAspect = function (e) {
        return this.setPerspective(this.near, this.far, this.fov, e), this
      }),
      (t.prototype.setNear = function (e) {
        return (
          this.projectionMode === qe.PERSPECTIVE
            ? this.setPerspective(e, this.far, this.fov, this.aspect)
            : this.setOrthographic(this.left, this.rright, this.top, this.bottom, e, this.far),
          this
        )
      }),
      (t.prototype.setFar = function (e) {
        return (
          this.projectionMode === qe.PERSPECTIVE
            ? this.setPerspective(this.near, e, this.fov, this.aspect)
            : this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, e),
          this
        )
      }),
      (t.prototype.setViewOffset = function (e, n, r, i, a, o) {
        return (
          (this.aspect = e / n),
          this.view === void 0 &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = e),
          (this.view.fullHeight = n),
          (this.view.offsetX = r),
          (this.view.offsetY = i),
          (this.view.width = a),
          (this.view.height = o),
          this.projectionMode === qe.PERSPECTIVE
            ? this.setPerspective(this.near, this.far, this.fov, this.aspect)
            : this.setOrthographic(
                this.left,
                this.rright,
                this.top,
                this.bottom,
                this.near,
                this.far
              ),
          this
        )
      }),
      (t.prototype.clearViewOffset = function () {
        return (
          this.view !== void 0 && (this.view.enabled = !1),
          this.projectionMode === qe.PERSPECTIVE
            ? this.setPerspective(this.near, this.far, this.fov, this.aspect)
            : this.setOrthographic(
                this.left,
                this.rright,
                this.top,
                this.bottom,
                this.near,
                this.far
              ),
          this
        )
      }),
      (t.prototype.setZoom = function (e) {
        return (
          (this.zoom = e),
          this.projectionMode === qe.ORTHOGRAPHIC
            ? this.setOrthographic(
                this.left,
                this.rright,
                this.top,
                this.bottom,
                this.near,
                this.far
              )
            : this.projectionMode === qe.PERSPECTIVE &&
              this.setPerspective(this.near, this.far, this.fov, this.aspect),
          this
        )
      }),
      (t.prototype.setZoomByViewportPoint = function (e, n) {
        var r = this.canvas.viewport2Canvas({ x: n[0], y: n[1] }),
          i = r.x,
          a = r.y,
          o = this.roll
        this.rotate(0, 0, -o),
          this.setPosition(i, a),
          this.setFocalPoint(i, a),
          this.setZoom(e),
          this.rotate(0, 0, o)
        var s = this.canvas.viewport2Canvas({ x: n[0], y: n[1] }),
          c = s.x,
          l = s.y,
          u = St(c - i, l - a, 0),
          f = Jn(u, this.right) / vr(this.right),
          h = Jn(u, this.up) / vr(this.up)
        return this.pan(-f, -h), this
      }),
      (t.prototype.setPerspective = function (e, n, r, i) {
        var a
        ;(this.projectionMode = qe.PERSPECTIVE),
          (this.fov = r),
          (this.near = e),
          (this.far = n),
          (this.aspect = i)
        var o = (this.near * Math.tan(Jt(0.5 * this.fov))) / this.zoom,
          s = 2 * o,
          c = this.aspect * s,
          l = -0.5 * c
        if (!((a = this.view) === null || a === void 0) && a.enabled) {
          var u = this.view.fullWidth,
            f = this.view.fullHeight
          ;(l += (this.view.offsetX * c) / u),
            (o -= (this.view.offsetY * s) / f),
            (c *= this.view.width / u),
            (s *= this.view.height / f)
        }
        return (
          fL(
            this.projectionMatrix,
            l,
            l + c,
            o,
            o - s,
            e,
            this.far,
            this.clipSpaceNearZ === ma.ZERO
          ),
          Zc(this.projectionMatrix, this.projectionMatrix, St(1, -1, 1)),
          zn(this.projectionMatrixInverse, this.projectionMatrix),
          this.triggerUpdate(),
          this
        )
      }),
      (t.prototype.setOrthographic = function (e, n, r, i, a, o) {
        var s
        ;(this.projectionMode = qe.ORTHOGRAPHIC),
          (this.rright = n),
          (this.left = e),
          (this.top = r),
          (this.bottom = i),
          (this.near = a),
          (this.far = o)
        var c = (this.rright - this.left) / (2 * this.zoom),
          l = (this.top - this.bottom) / (2 * this.zoom),
          u = (this.rright + this.left) / 2,
          f = (this.top + this.bottom) / 2,
          h = u - c,
          d = u + c,
          p = f + l,
          v = f - l
        if (!((s = this.view) === null || s === void 0) && s.enabled) {
          var g = (this.rright - this.left) / this.view.fullWidth / this.zoom,
            y = (this.top - this.bottom) / this.view.fullHeight / this.zoom
          ;(h += g * this.view.offsetX),
            (d = h + g * this.view.width),
            (p -= y * this.view.offsetY),
            (v = p - y * this.view.height)
        }
        return (
          this.clipSpaceNearZ === ma.NEGATIVE_ONE
            ? fb(this.projectionMatrix, h, d, v, p, a, o)
            : hb(this.projectionMatrix, h, d, v, p, a, o),
          Zc(this.projectionMatrix, this.projectionMatrix, St(1, -1, 1)),
          zn(this.projectionMatrixInverse, this.projectionMatrix),
          this._getOrthoMatrix(),
          this.triggerUpdate(),
          this
        )
      }),
      (t.prototype.setPosition = function (e, n, r) {
        n === void 0 && (n = this.position[1]), r === void 0 && (r = this.position[2])
        var i = Ge(e, n, r)
        return this._setPosition(i), this.setFocalPoint(this.focalPoint), this.triggerUpdate(), this
      }),
      (t.prototype.setFocalPoint = function (e, n, r) {
        n === void 0 && (n = this.focalPoint[1]), r === void 0 && (r = this.focalPoint[2])
        var i = St(0, 1, 0)
        if (((this.focalPoint = Ge(e, n, r)), this.trackingMode === ns.CINEMATIC)) {
          var a = hv(yt(), this.focalPoint, this.position)
          ;(e = a[0]), (n = a[1]), (r = a[2])
          var o = vr(a),
            s = Mn(Math.asin(n / o)),
            c = 90 + Mn(Math.atan2(r, e)),
            l = Nt()
          sb(l, l, Jt(c)), ob(l, l, Jt(s)), (i = be(yt(), [0, 1, 0], l))
        }
        return (
          zn(this.matrix, db(Nt(), this.position, this.focalPoint, i)),
          this._getAxes(),
          this._getDistance(),
          this._getAngles(),
          this.triggerUpdate(),
          this
        )
      }),
      (t.prototype.getDistance = function () {
        return this.distance
      }),
      (t.prototype.getDistanceVector = function () {
        return this.distanceVector
      }),
      (t.prototype.setDistance = function (e) {
        if (this.distance === e || e < 0) return this
        ;(this.distance = e),
          this.distance < tg && (this.distance = tg),
          (this.dollyingStep = this.distance / 100)
        var n = yt()
        e = this.distance
        var r = this.forward,
          i = this.focalPoint
        return (
          (n[0] = e * r[0] + i[0]),
          (n[1] = e * r[1] + i[1]),
          (n[2] = e * r[2] + i[2]),
          this._setPosition(n),
          this.triggerUpdate(),
          this
        )
      }),
      (t.prototype.setMaxDistance = function (e) {
        return (this.maxDistance = e), this
      }),
      (t.prototype.setMinDistance = function (e) {
        return (this.minDistance = e), this
      }),
      (t.prototype.setAzimuth = function (e) {
        return (
          (this.azimuth = ba(e)),
          this.computeMatrix(),
          this._getAxes(),
          this.type === kt.ORBITING || this.type === kt.EXPLORING
            ? this._getPosition()
            : this.type === kt.TRACKING && this._getFocalPoint(),
          this.triggerUpdate(),
          this
        )
      }),
      (t.prototype.getAzimuth = function () {
        return this.azimuth
      }),
      (t.prototype.setElevation = function (e) {
        return (
          (this.elevation = ba(e)),
          this.computeMatrix(),
          this._getAxes(),
          this.type === kt.ORBITING || this.type === kt.EXPLORING
            ? this._getPosition()
            : this.type === kt.TRACKING && this._getFocalPoint(),
          this.triggerUpdate(),
          this
        )
      }),
      (t.prototype.getElevation = function () {
        return this.elevation
      }),
      (t.prototype.setRoll = function (e) {
        return (
          (this.roll = ba(e)),
          this.computeMatrix(),
          this._getAxes(),
          this.type === kt.ORBITING || this.type === kt.EXPLORING
            ? this._getPosition()
            : this.type === kt.TRACKING && this._getFocalPoint(),
          this.triggerUpdate(),
          this
        )
      }),
      (t.prototype.getRoll = function () {
        return this.roll
      }),
      (t.prototype._update = function () {
        this._getAxes(),
          this._getPosition(),
          this._getDistance(),
          this._getAngles(),
          this._getOrthoMatrix(),
          this.triggerUpdate()
      }),
      (t.prototype.computeMatrix = function () {
        var e = Br(pe(), [0, 0, 1], Jt(this.roll))
        ws(this.matrix)
        var n = Br(
            pe(),
            [1, 0, 0],
            Jt(
              ((this.rotateWorld && this.type !== kt.TRACKING) || this.type === kt.TRACKING
                ? 1
                : -1) * this.elevation
            )
          ),
          r = Br(
            pe(),
            [0, 1, 0],
            Jt(
              ((this.rotateWorld && this.type !== kt.TRACKING) || this.type === kt.TRACKING
                ? 1
                : -1) * this.azimuth
            )
          ),
          i = Wr(pe(), r, n)
        i = Wr(pe(), i, e)
        var a = zd(Nt(), i)
        this.type === kt.ORBITING || this.type === kt.EXPLORING
          ? (Gr(this.matrix, this.matrix, this.focalPoint),
            Re(this.matrix, this.matrix, a),
            Gr(this.matrix, this.matrix, [0, 0, this.distance]))
          : this.type === kt.TRACKING &&
            (Gr(this.matrix, this.matrix, this.position), Re(this.matrix, this.matrix, a))
      }),
      (t.prototype._setPosition = function (e, n, r) {
        this.position = Ge(e, n, r)
        var i = this.matrix
        ;(i[12] = this.position[0]),
          (i[13] = this.position[1]),
          (i[14] = this.position[2]),
          (i[15] = 1),
          this._getOrthoMatrix()
      }),
      (t.prototype._getAxes = function () {
        Qe(this.right, Ge(la(ca(), [1, 0, 0, 0], this.matrix))),
          Qe(this.up, Ge(la(ca(), [0, 1, 0, 0], this.matrix))),
          Qe(this.forward, Ge(la(ca(), [0, 0, 1, 0], this.matrix))),
          Ti(this.right, this.right),
          Ti(this.up, this.up),
          Ti(this.forward, this.forward)
      }),
      (t.prototype._getAngles = function () {
        var e = this.distanceVector[0],
          n = this.distanceVector[1],
          r = this.distanceVector[2],
          i = vr(this.distanceVector)
        if (i === 0) {
          ;(this.elevation = 0), (this.azimuth = 0)
          return
        }
        this.type === kt.TRACKING
          ? ((this.elevation = Mn(Math.asin(n / i))), (this.azimuth = Mn(Math.atan2(-e, -r))))
          : this.rotateWorld
          ? ((this.elevation = Mn(Math.asin(n / i))), (this.azimuth = Mn(Math.atan2(-e, -r))))
          : ((this.elevation = -Mn(Math.asin(n / i))), (this.azimuth = -Mn(Math.atan2(-e, -r))))
      }),
      (t.prototype._getPosition = function () {
        Qe(this.position, Ge(la(ca(), [0, 0, 0, 1], this.matrix))), this._getDistance()
      }),
      (t.prototype._getFocalPoint = function () {
        gb(this.distanceVector, [0, 0, -this.distance], FP(Ua(), this.matrix)),
          va(this.focalPoint, this.position, this.distanceVector),
          this._getDistance()
      }),
      (t.prototype._getDistance = function () {
        ;(this.distanceVector = hv(yt(), this.focalPoint, this.position)),
          (this.distance = vr(this.distanceVector)),
          (this.dollyingStep = this.distance / 100)
      }),
      (t.prototype._getOrthoMatrix = function () {
        if (this.projectionMode === qe.ORTHOGRAPHIC) {
          var e = this.position,
            n = Br(pe(), [0, 0, 1], (-this.roll * Math.PI) / 180)
          Ro(
            this.orthoMatrix,
            n,
            St((this.rright - this.left) / 2 - e[0], (this.top - this.bottom) / 2 - e[1], 0),
            St(this.zoom, this.zoom, 1),
            e
          )
        }
      }),
      (t.prototype.triggerUpdate = function () {
        if (this.enableUpdate) {
          var e = this.getViewTransform(),
            n = Re(Nt(), this.getPerspective(), e)
          this.getFrustum().extractFromVPMatrix(n), this.eventEmitter.emit(C2.UPDATED)
        }
      }),
      (t.prototype.rotate = function (e, n, r) {
        throw new Error(It)
      }),
      (t.prototype.pan = function (e, n) {
        throw new Error(It)
      }),
      (t.prototype.dolly = function (e) {
        throw new Error(It)
      }),
      (t.prototype.createLandmark = function (e, n) {
        throw new Error(It)
      }),
      (t.prototype.gotoLandmark = function (e, n) {
        throw new Error(It)
      }),
      (t.prototype.cancelLandmarkAnimation = function () {
        throw new Error(It)
      }),
      t
    )
  })()
function $e(t, e) {
  if (typeof t != 'function' || (e != null && typeof e != 'function'))
    throw new TypeError('Expected a function')
  var n = function () {
    for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i]
    var a = e ? e.apply(this, r) : r[0],
      o = n.cache
    if (o.has(a)) return o.get(a)
    var s = t.apply(this, r)
    return (n.cache = o.set(a, s) || o), s
  }
  return (n.cache = new ($e.Cache || Map)()), n
}
$e.Cache = Map
var Z
;(function (t) {
  ;(t[(t.kUnknown = 0)] = 'kUnknown'),
    (t[(t.kNumber = 1)] = 'kNumber'),
    (t[(t.kPercentage = 2)] = 'kPercentage'),
    (t[(t.kEms = 3)] = 'kEms'),
    (t[(t.kPixels = 4)] = 'kPixels'),
    (t[(t.kRems = 5)] = 'kRems'),
    (t[(t.kDegrees = 6)] = 'kDegrees'),
    (t[(t.kRadians = 7)] = 'kRadians'),
    (t[(t.kGradians = 8)] = 'kGradians'),
    (t[(t.kTurns = 9)] = 'kTurns'),
    (t[(t.kMilliseconds = 10)] = 'kMilliseconds'),
    (t[(t.kSeconds = 11)] = 'kSeconds'),
    (t[(t.kInteger = 12)] = 'kInteger')
})(Z || (Z = {}))
var fn
;(function (t) {
  ;(t[(t.kUNumber = 0)] = 'kUNumber'),
    (t[(t.kUPercent = 1)] = 'kUPercent'),
    (t[(t.kULength = 2)] = 'kULength'),
    (t[(t.kUAngle = 3)] = 'kUAngle'),
    (t[(t.kUTime = 4)] = 'kUTime'),
    (t[(t.kUOther = 5)] = 'kUOther')
})(fn || (fn = {}))
var eg
;(function (t) {
  ;(t[(t.kAll = 0)] = 'kAll'),
    (t[(t.kNonNegative = 1)] = 'kNonNegative'),
    (t[(t.kInteger = 2)] = 'kInteger'),
    (t[(t.kNonNegativeInteger = 3)] = 'kNonNegativeInteger'),
    (t[(t.kPositiveInteger = 4)] = 'kPositiveInteger')
})(eg || (eg = {}))
var wh
;(function (t) {
  ;(t[(t.kYes = 0)] = 'kYes'), (t[(t.kNo = 1)] = 'kNo')
})(wh || (wh = {}))
var Oh
;(function (t) {
  ;(t[(t.kYes = 0)] = 'kYes'), (t[(t.kNo = 1)] = 'kNo')
})(Oh || (Oh = {}))
var mL = [
    { name: 'em', unit_type: Z.kEms },
    { name: 'px', unit_type: Z.kPixels },
    { name: 'deg', unit_type: Z.kDegrees },
    { name: 'rad', unit_type: Z.kRadians },
    { name: 'grad', unit_type: Z.kGradians },
    { name: 'ms', unit_type: Z.kMilliseconds },
    { name: 's', unit_type: Z.kSeconds },
    { name: 'rem', unit_type: Z.kRems },
    { name: 'turn', unit_type: Z.kTurns }
  ],
  Zr
;(function (t) {
  ;(t[(t.kUnknownType = 0)] = 'kUnknownType'),
    (t[(t.kUnparsedType = 1)] = 'kUnparsedType'),
    (t[(t.kKeywordType = 2)] = 'kKeywordType'),
    (t[(t.kUnitType = 3)] = 'kUnitType'),
    (t[(t.kSumType = 4)] = 'kSumType'),
    (t[(t.kProductType = 5)] = 'kProductType'),
    (t[(t.kNegateType = 6)] = 'kNegateType'),
    (t[(t.kInvertType = 7)] = 'kInvertType'),
    (t[(t.kMinType = 8)] = 'kMinType'),
    (t[(t.kMaxType = 9)] = 'kMaxType'),
    (t[(t.kClampType = 10)] = 'kClampType'),
    (t[(t.kTransformType = 11)] = 'kTransformType'),
    (t[(t.kPositionType = 12)] = 'kPositionType'),
    (t[(t.kURLImageType = 13)] = 'kURLImageType'),
    (t[(t.kColorType = 14)] = 'kColorType'),
    (t[(t.kUnsupportedColorType = 15)] = 'kUnsupportedColorType')
})(Zr || (Zr = {}))
var bL = function (t) {
    return mL.find(function (e) {
      return e.name === t
    }).unit_type
  },
  xL = function (t) {
    return t
      ? t === 'number'
        ? Z.kNumber
        : t === 'percent' || t === '%'
        ? Z.kPercentage
        : bL(t)
      : Z.kUnknown
  },
  wL = function (t) {
    switch (t) {
      case Z.kNumber:
      case Z.kInteger:
        return fn.kUNumber
      case Z.kPercentage:
        return fn.kUPercent
      case Z.kPixels:
        return fn.kULength
      case Z.kMilliseconds:
      case Z.kSeconds:
        return fn.kUTime
      case Z.kDegrees:
      case Z.kRadians:
      case Z.kGradians:
      case Z.kTurns:
        return fn.kUAngle
      default:
        return fn.kUOther
    }
  },
  OL = function (t) {
    switch (t) {
      case fn.kUNumber:
        return Z.kNumber
      case fn.kULength:
        return Z.kPixels
      case fn.kUPercent:
        return Z.kPercentage
      case fn.kUTime:
        return Z.kSeconds
      case fn.kUAngle:
        return Z.kDegrees
      default:
        return Z.kUnknown
    }
  },
  ng = function (t) {
    var e = 1
    switch (t) {
      case Z.kPixels:
      case Z.kDegrees:
      case Z.kSeconds:
        break
      case Z.kMilliseconds:
        e = 0.001
        break
      case Z.kRadians:
        e = 180 / Math.PI
        break
      case Z.kGradians:
        e = 0.9
        break
      case Z.kTurns:
        e = 360
        break
    }
    return e
  },
  Sh = function (t) {
    switch (t) {
      case Z.kNumber:
      case Z.kInteger:
        return ''
      case Z.kPercentage:
        return '%'
      case Z.kEms:
        return 'em'
      case Z.kRems:
        return 'rem'
      case Z.kPixels:
        return 'px'
      case Z.kDegrees:
        return 'deg'
      case Z.kRadians:
        return 'rad'
      case Z.kGradians:
        return 'grad'
      case Z.kMilliseconds:
        return 'ms'
      case Z.kSeconds:
        return 's'
      case Z.kTurns:
        return 'turn'
    }
    return ''
  },
  fu = (function () {
    function t() {}
    return (
      (t.isAngle = function (e) {
        return e === Z.kDegrees || e === Z.kRadians || e === Z.kGradians || e === Z.kTurns
      }),
      (t.isLength = function (e) {
        return e >= Z.kEms && e < Z.kDegrees
      }),
      (t.isRelativeUnit = function (e) {
        return e === Z.kPercentage || e === Z.kEms || e === Z.kRems
      }),
      (t.isTime = function (e) {
        return e === Z.kSeconds || e === Z.kMilliseconds
      }),
      (t.prototype.toString = function () {
        return this.buildCSSText(wh.kNo, Oh.kNo, '')
      }),
      (t.prototype.isNumericValue = function () {
        return this.getType() >= Zr.kUnitType && this.getType() <= Zr.kClampType
      }),
      t
    )
  })(),
  SL = (function (t) {
    rt(e, t)
    function e(n) {
      var r = t.call(this) || this
      return (r.colorSpace = n), r
    }
    return (
      (e.prototype.getType = function () {
        return Zr.kColorType
      }),
      (e.prototype.to = function (n) {
        return this
      }),
      e
    )
  })(fu),
  tr
;(function (t) {
  ;(t[(t.Constant = 0)] = 'Constant'),
    (t[(t.LinearGradient = 1)] = 'LinearGradient'),
    (t[(t.RadialGradient = 2)] = 'RadialGradient')
})(tr || (tr = {}))
var tc = (function (t) {
    rt(e, t)
    function e(n, r) {
      var i = t.call(this) || this
      return (i.type = n), (i.value = r), i
    }
    return (
      (e.prototype.clone = function () {
        return new e(this.type, this.value)
      }),
      (e.prototype.buildCSSText = function (n, r, i) {
        return i
      }),
      (e.prototype.getType = function () {
        return Zr.kColorType
      }),
      e
    )
  })(fu),
  en = (function (t) {
    rt(e, t)
    function e(n) {
      var r = t.call(this) || this
      return (r.value = n), r
    }
    return (
      (e.prototype.clone = function () {
        return new e(this.value)
      }),
      (e.prototype.getType = function () {
        return Zr.kKeywordType
      }),
      (e.prototype.buildCSSText = function (n, r, i) {
        return i + this.value
      }),
      e
    )
  })(fu),
  _L = $e(function (t) {
    return (
      t === void 0 && (t = ''),
      t.replace(/-([a-z])/g, function (e) {
        return e[1].toUpperCase()
      })
    )
  }),
  rg = function (t) {
    return t
      .split('')
      .map(function (e, n) {
        return e.toUpperCase() === e ? ''.concat(n !== 0 ? '-' : '').concat(e.toLowerCase()) : e
      })
      .join('')
  }
function ML(t) {
  if (!t) throw new Error()
}
function ha(t) {
  return typeof t == 'function'
}
function EL(t) {
  return typeof t == 'symbol'
}
var TL = {
    d: { alias: 'path' },
    strokeDasharray: { alias: 'lineDash' },
    strokeWidth: { alias: 'lineWidth' },
    textAnchor: { alias: 'textAlign' },
    src: { alias: 'img' }
  },
  _h = $e(function (t) {
    var e = _L(t),
      n = TL[e]
    return (e = (n == null ? void 0 : n.alias) || e), e
  }),
  PL = function (t, e) {
    e === void 0 && (e = '')
    var n = ''
    return (
      Number.isFinite(t)
        ? (ML(Number.isNaN(t)), (n = 'NaN'))
        : t > 0
        ? (n = 'infinity')
        : (n = '-infinity'),
      (n += e)
    )
  },
  Mh = function (t) {
    return OL(wL(t))
  },
  jt = (function (t) {
    rt(e, t)
    function e(n, r) {
      r === void 0 && (r = Z.kNumber)
      var i = t.call(this) || this,
        a
      return typeof r == 'string' ? (a = xL(r)) : (a = r), (i.unit = a), (i.value = n), i
    }
    return (
      (e.prototype.clone = function () {
        return new e(this.value, this.unit)
      }),
      (e.prototype.equals = function (n) {
        var r = n
        return this.value === r.value && this.unit === r.unit
      }),
      (e.prototype.getType = function () {
        return Zr.kUnitType
      }),
      (e.prototype.convertTo = function (n) {
        if (this.unit === n) return new e(this.value, this.unit)
        var r = Mh(this.unit)
        if (r !== Mh(n) || r === Z.kUnknown) return null
        var i = ng(this.unit) / ng(n)
        return new e(this.value * i, n)
      }),
      (e.prototype.buildCSSText = function (n, r, i) {
        var a
        switch (this.unit) {
          case Z.kUnknown:
            break
          case Z.kInteger:
            a = Number(this.value).toFixed(0)
            break
          case Z.kNumber:
          case Z.kPercentage:
          case Z.kEms:
          case Z.kRems:
          case Z.kPixels:
          case Z.kDegrees:
          case Z.kRadians:
          case Z.kGradians:
          case Z.kMilliseconds:
          case Z.kSeconds:
          case Z.kTurns: {
            var o = -999999,
              s = 999999,
              c = this.value,
              l = Sh(this.unit)
            if (c < o || c > s) {
              var u = Sh(this.unit)
              !Number.isFinite(c) || Number.isNaN(c) ? (a = PL(c, u)) : (a = c + (u || ''))
            } else a = ''.concat(c).concat(l)
          }
        }
        return (i += a), i
      }),
      e
    )
  })(fu),
  Me = new jt(0, 'px')
new jt(1, 'px')
var mr = new jt(0, 'deg'),
  yp = (function (t) {
    rt(e, t)
    function e(n, r, i, a, o) {
      a === void 0 && (a = 1), o === void 0 && (o = !1)
      var s = t.call(this, 'rgb') || this
      return (s.r = n), (s.g = r), (s.b = i), (s.alpha = a), (s.isNone = o), s
    }
    return (
      (e.prototype.clone = function () {
        return new e(this.r, this.g, this.b, this.alpha)
      }),
      (e.prototype.buildCSSText = function (n, r, i) {
        return (
          i +
          'rgba('
            .concat(this.r, ',')
            .concat(this.g, ',')
            .concat(this.b, ',')
            .concat(this.alpha, ')')
        )
      }),
      e
    )
  })(SL),
  zt = new en('unset'),
  AL = new en('initial'),
  kL = new en('inherit'),
  rf = { '': zt, unset: zt, initial: AL, inherit: kL },
  Eh = function (t) {
    return rf[t] || (rf[t] = new en(t)), rf[t]
  },
  Th = new yp(0, 0, 0, 0, !0),
  N2 = new yp(0, 0, 0, 0),
  CL = $e(
    function (t, e, n, r) {
      return new yp(t, e, n, r)
    },
    function (t, e, n, r) {
      return 'rgba('.concat(t, ',').concat(e, ',').concat(n, ',').concat(r, ')')
    }
  ),
  ee = function (t, e) {
    return e === void 0 && (e = Z.kNumber), new jt(t, e)
  },
  cl = new jt(50, '%'),
  Ph
;(function (t) {
  t[(t.Standard = 0)] = 'Standard'
})(Ph || (Ph = {}))
var Na
;(function (t) {
  ;(t[(t.ADDED = 0)] = 'ADDED'),
    (t[(t.REMOVED = 1)] = 'REMOVED'),
    (t[(t.Z_INDEX_CHANGED = 2)] = 'Z_INDEX_CHANGED')
})(Na || (Na = {}))
var R2 = {
    absolutePath: [],
    hasArc: !1,
    segments: [],
    polygons: [],
    polylines: [],
    curve: null,
    totalLength: 0,
    rect: new ji(0, 0, 0, 0)
  },
  J
;(function (t) {
  ;(t.COORDINATE = '<coordinate>'),
    (t.COLOR = '<color>'),
    (t.PAINT = '<paint>'),
    (t.NUMBER = '<number>'),
    (t.ANGLE = '<angle>'),
    (t.OPACITY_VALUE = '<opacity-value>'),
    (t.SHADOW_BLUR = '<shadow-blur>'),
    (t.LENGTH = '<length>'),
    (t.PERCENTAGE = '<percentage>'),
    (t.LENGTH_PERCENTAGE = '<length> | <percentage>'),
    (t.LENGTH_PERCENTAGE_12 = '[<length> | <percentage>]{1,2}'),
    (t.LENGTH_PERCENTAGE_14 = '[<length> | <percentage>]{1,4}'),
    (t.LIST_OF_POINTS = '<list-of-points>'),
    (t.PATH = '<path>'),
    (t.FILTER = '<filter>'),
    (t.Z_INDEX = '<z-index>'),
    (t.OFFSET_DISTANCE = '<offset-distance>'),
    (t.DEFINED_PATH = '<defined-path>'),
    (t.MARKER = '<marker>'),
    (t.TRANSFORM = '<transform>'),
    (t.TRANSFORM_ORIGIN = '<transform-origin>'),
    (t.TEXT = '<text>'),
    (t.TEXT_TRANSFORM = '<text-transform>')
})(J || (J = {}))
function LL(t) {
  var e = t.type,
    n = t.value
  return e === 'hex'
    ? '#'.concat(n)
    : e === 'literal'
    ? n
    : e === 'rgb'
    ? 'rgb('.concat(n.join(','), ')')
    : 'rgba('.concat(n.join(','), ')')
}
var NL = (function () {
  var t = {
      linearGradient: /^(linear\-gradient)/i,
      repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
      radialGradient: /^(radial\-gradient)/i,
      repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
      conicGradient: /^(conic\-gradient)/i,
      sideOrCorner:
        /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
      extentKeywords:
        /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
      positionKeywords: /^(left|center|right|top|bottom)/i,
      pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
      percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
      emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
      angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
      startCall: /^\(/,
      endCall: /^\)/,
      comma: /^,/,
      hexColor: /^\#([0-9a-fA-F]+)/,
      literalColor: /^([a-zA-Z]+)/,
      rgbColor: /^rgb/i,
      rgbaColor: /^rgba/i,
      number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
    },
    e = ''
  function n(R) {
    throw new Error(e + ': ' + R)
  }
  function r() {
    var R = i()
    return e.length > 0 && n('Invalid input not EOF'), R
  }
  function i() {
    return b(a)
  }
  function a() {
    return (
      o('linear-gradient', t.linearGradient, c) ||
      o('repeating-linear-gradient', t.repeatingLinearGradient, c) ||
      o('radial-gradient', t.radialGradient, f) ||
      o('repeating-radial-gradient', t.repeatingRadialGradient, f) ||
      o('conic-gradient', t.conicGradient, f)
    )
  }
  function o(R, j, I) {
    return s(j, function (D) {
      var $ = I()
      return (
        $ && (k(t.comma) || n('Missing comma before color stops')),
        { type: R, orientation: $, colorStops: b(x) }
      )
    })
  }
  function s(R, j) {
    var I = k(R)
    if (I) {
      k(t.startCall) || n('Missing (')
      var D = j(I)
      return k(t.endCall) || n('Missing )'), D
    }
  }
  function c() {
    return l() || u()
  }
  function l() {
    return P('directional', t.sideOrCorner, 1)
  }
  function u() {
    return P('angular', t.angleValue, 1)
  }
  function f() {
    var R,
      j = h(),
      I
    return (
      j && ((R = []), R.push(j), (I = e), k(t.comma) && ((j = h()), j ? R.push(j) : (e = I))), R
    )
  }
  function h() {
    var R = d() || p()
    if (R) R.at = g()
    else {
      var j = v()
      if (j) {
        R = j
        var I = g()
        I && (R.at = I)
      } else {
        var D = y()
        D && (R = { type: 'default-radial', at: D })
      }
    }
    return R
  }
  function d() {
    var R = P('shape', /^(circle)/i, 0)
    return R && (R.style = A() || v()), R
  }
  function p() {
    var R = P('shape', /^(ellipse)/i, 0)
    return R && (R.style = T() || v()), R
  }
  function v() {
    return P('extent-keyword', t.extentKeywords, 1)
  }
  function g() {
    if (P('position', /^at/, 0)) {
      var R = y()
      return R || n('Missing positioning value'), R
    }
  }
  function y() {
    var R = m()
    if (R.x || R.y) return { type: 'position', value: R }
  }
  function m() {
    return { x: T(), y: T() }
  }
  function b(R) {
    var j = R(),
      I = []
    if (j) for (I.push(j); k(t.comma); ) (j = R()), j ? I.push(j) : n('One extra comma')
    return I
  }
  function x() {
    var R = w()
    return R || n('Expected color definition'), (R.length = T()), R
  }
  function w() {
    return S() || M() || _() || O()
  }
  function O() {
    return P('literal', t.literalColor, 0)
  }
  function S() {
    return P('hex', t.hexColor, 1)
  }
  function _() {
    return s(t.rgbColor, function () {
      return { type: 'rgb', value: b(E) }
    })
  }
  function M() {
    return s(t.rgbaColor, function () {
      return { type: 'rgba', value: b(E) }
    })
  }
  function E() {
    return k(t.number)[1]
  }
  function T() {
    return P('%', t.percentageValue, 1) || C() || A()
  }
  function C() {
    return P('position-keyword', t.positionKeywords, 1)
  }
  function A() {
    return P('px', t.pixelValue, 1) || P('em', t.emValue, 1)
  }
  function P(R, j, I) {
    var D = k(j)
    if (D) return { type: R, value: D[I] }
  }
  function k(R) {
    var j = /^[\n\r\t\s]+/.exec(e)
    j && L(j[0].length)
    var I = R.exec(e)
    return I && L(I[0].length), I
  }
  function L(R) {
    e = e.substring(R)
  }
  return function (R) {
    return (e = R), r()
  }
})()
function RL(t, e, n) {
  var r = Jt(n.value),
    i = 0,
    a = 0,
    o = i + t / 2,
    s = a + e / 2,
    c = Math.abs(t * Math.cos(r)) + Math.abs(e * Math.sin(r)),
    l = o - (Math.cos(r) * c) / 2,
    u = s - (Math.sin(r) * c) / 2,
    f = o + (Math.cos(r) * c) / 2,
    h = s + (Math.sin(r) * c) / 2
  return { x1: l, y1: u, x2: f, y2: h }
}
function IL(t, e, n, r, i) {
  var a = n.value,
    o = r.value
  n.unit === Z.kPercentage && (a = (n.value / 100) * t),
    r.unit === Z.kPercentage && (o = (r.value / 100) * e)
  var s = Math.max(Ze([0, 0], [a, o]), Ze([0, e], [a, o]), Ze([t, e], [a, o]), Ze([t, 0], [a, o]))
  return (
    i &&
      (i instanceof jt
        ? (s = i.value)
        : i instanceof en &&
          (i.value === 'closest-side'
            ? (s = Math.min(a, t - a, o, e - o))
            : i.value === 'farthest-side'
            ? (s = Math.max(a, t - a, o, e - o))
            : i.value === 'closest-corner' &&
              (s = Math.min(
                Ze([0, 0], [a, o]),
                Ze([0, e], [a, o]),
                Ze([t, e], [a, o]),
                Ze([t, 0], [a, o])
              )))),
    { x: a, y: o, r: s }
  )
}
var jL = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i,
  DL = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i,
  $L = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i,
  I2 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi
function BL(t) {
  var e,
    n,
    r,
    i = t.length
  ;(t[i - 1].length =
    (e = t[i - 1].length) !== null && e !== void 0 ? e : { type: '%', value: '100' }),
    i > 1 &&
      (t[0].length = (n = t[0].length) !== null && n !== void 0 ? n : { type: '%', value: '0' })
  for (var a = 0, o = Number(t[0].length.value), s = 1; s < i; s++) {
    var c = (r = t[s].length) === null || r === void 0 ? void 0 : r.value
    if (!nt(c) && !nt(o)) {
      for (var l = 1; l < s - a; l++)
        t[a + l].length = { type: '%', value: ''.concat(o + ((Number(c) - o) * l) / (s - a)) }
      ;(a = s), (o = Number(c))
    }
  }
}
var FL = {
    left: 270 - 90,
    top: 0 - 90,
    bottom: 180 - 90,
    right: 90 - 90,
    'left top': 315 - 90,
    'top left': 315 - 90,
    'left bottom': 225 - 90,
    'bottom left': 225 - 90,
    'right top': 45 - 90,
    'top right': 45 - 90,
    'right bottom': 135 - 90,
    'bottom right': 135 - 90
  },
  zL = $e(function (t) {
    var e
    return t.type === 'angular' ? (e = Number(t.value)) : (e = FL[t.value] || 0), ee(e, 'deg')
  }),
  GL = $e(function (t) {
    var e = 50,
      n = 50,
      r = '%',
      i = '%'
    if ((t == null ? void 0 : t.type) === 'position') {
      var a = t.value,
        o = a.x,
        s = a.y
      ;(o == null ? void 0 : o.type) === 'position-keyword' &&
        (o.value === 'left'
          ? (e = 0)
          : o.value === 'center'
          ? (e = 50)
          : o.value === 'right'
          ? (e = 100)
          : o.value === 'top'
          ? (n = 0)
          : o.value === 'bottom' && (n = 100)),
        (s == null ? void 0 : s.type) === 'position-keyword' &&
          (s.value === 'left'
            ? (e = 0)
            : s.value === 'center'
            ? (n = 50)
            : s.value === 'right'
            ? (e = 100)
            : s.value === 'top'
            ? (n = 0)
            : s.value === 'bottom' && (n = 100)),
        ((o == null ? void 0 : o.type) === 'px' ||
          (o == null ? void 0 : o.type) === '%' ||
          (o == null ? void 0 : o.type) === 'em') &&
          ((r = o == null ? void 0 : o.type), (e = Number(o.value))),
        ((s == null ? void 0 : s.type) === 'px' ||
          (s == null ? void 0 : s.type) === '%' ||
          (s == null ? void 0 : s.type) === 'em') &&
          ((i = s == null ? void 0 : s.type), (n = Number(s.value)))
    }
    return { cx: ee(e, r), cy: ee(n, i) }
  }),
  WL = $e(function (t) {
    var e
    if (t.indexOf('linear') > -1 || t.indexOf('radial') > -1) {
      var n = NL(t)
      return n.map(function (s) {
        var c = s.type,
          l = s.orientation,
          u = s.colorStops
        BL(u)
        var f = u.map(function (b) {
          return { offset: ee(Number(b.length.value), '%'), color: LL(b) }
        })
        if (c === 'linear-gradient')
          return new tc(tr.LinearGradient, { angle: l ? zL(l) : mr, steps: f })
        if (
          c === 'radial-gradient' &&
          (l || (l = [{ type: 'shape', value: 'circle' }]),
          l[0].type === 'shape' && l[0].value === 'circle')
        ) {
          var h = GL(l[0].at),
            d = h.cx,
            p = h.cy,
            v = void 0
          if (l[0].style) {
            var g = l[0].style,
              y = g.type,
              m = g.value
            y === 'extent-keyword' ? (v = Eh(m)) : (v = ee(m, y))
          }
          return new tc(tr.RadialGradient, { cx: d, cy: p, size: v, steps: f })
        }
      })
    }
    var r = t[0]
    if (t[1] === '(' || t[2] === '(') {
      if (r === 'l') {
        var i = jL.exec(t)
        if (i) {
          var a =
            ((e = i[2].match(I2)) === null || e === void 0
              ? void 0
              : e.map(function (s) {
                  return s.split(':')
                })) || []
          return [
            new tc(tr.LinearGradient, {
              angle: ee(parseFloat(i[1]), 'deg'),
              steps: a.map(function (s) {
                var c = N(s, 2),
                  l = c[0],
                  u = c[1]
                return { offset: ee(Number(l) * 100, '%'), color: u }
              })
            })
          ]
        }
      } else if (r === 'r') {
        var o = YL(t)
        if (o)
          if (ne(o)) t = o
          else return [new tc(tr.RadialGradient, o)]
      } else if (r === 'p') return HL(t)
    }
  })
function YL(t) {
  var e,
    n = DL.exec(t)
  if (n) {
    var r =
      ((e = n[4].match(I2)) === null || e === void 0
        ? void 0
        : e.map(function (i) {
            return i.split(':')
          })) || []
    return {
      cx: ee(50, '%'),
      cy: ee(50, '%'),
      steps: r.map(function (i) {
        var a = N(i, 2),
          o = a[0],
          s = a[1]
        return { offset: ee(Number(o) * 100, '%'), color: s }
      })
    }
  }
  return null
}
function HL(t) {
  var e = $L.exec(t)
  if (e) {
    var n = e[1],
      r = e[2]
    switch (n) {
      case 'a':
        n = 'repeat'
        break
      case 'x':
        n = 'repeat-x'
        break
      case 'y':
        n = 'repeat-y'
        break
      case 'n':
        n = 'no-repeat'
        break
      default:
        n = 'no-repeat'
    }
    return { image: r, repetition: n }
  }
  return null
}
function rs(t) {
  return t && !!t.image
}
function ll(t) {
  return t && !nt(t.r) && !nt(t.g) && !nt(t.b)
}
var Or = $e(function (t) {
  if (rs(t)) return z({ repetition: 'repeat' }, t)
  if ((nt(t) && (t = ''), t === 'transparent')) return N2
  t === 'currentColor' && (t = 'black')
  var e = WL(t)
  if (e) return e
  var n = uu(t),
    r = [0, 0, 0, 0]
  return (
    n !== null && ((r[0] = n.r || 0), (r[1] = n.g || 0), (r[2] = n.b || 0), (r[3] = n.opacity)),
    CL.apply(void 0, q([], N(r), !1))
  )
})
function VL(t, e) {
  if (!(!ll(t) || !ll(e)))
    return [
      [Number(t.r), Number(t.g), Number(t.b), Number(t.alpha)],
      [Number(e.r), Number(e.g), Number(e.b), Number(e.alpha)],
      function (n) {
        var r = n.slice()
        if (r[3]) for (var i = 0; i < 3; i++) r[i] = Math.round(se(r[i], 0, 255))
        return (r[3] = se(r[3], 0, 1)), 'rgba('.concat(r.join(','), ')')
      }
    ]
}
function Cs(t, e) {
  if (nt(e)) return ee(0, 'px')
  if (((e = ''.concat(e).trim().toLowerCase()), isFinite(Number(e)))) {
    if ('px'.search(t) >= 0) return ee(Number(e), 'px')
    if ('deg'.search(t) >= 0) return ee(Number(e), 'deg')
  }
  var n = []
  e = e.replace(t, function (i) {
    return n.push(i), 'U' + i
  })
  var r = 'U(' + t.source + ')'
  return n.map(function (i) {
    return ee(Number(e.replace(new RegExp('U' + i, 'g'), '').replace(new RegExp(r, 'g'), '*0')), i)
  })[0]
}
var XL = $e(function (t) {
  return Cs(new RegExp('px', 'g'), t)
})
$e(function (t) {
  return Cs(new RegExp('%', 'g'), t)
})
var Ra = function (t) {
    return ve(t) || isFinite(Number(t))
      ? ee(Number(t) || 0, 'px')
      : Cs(new RegExp('px|%|em|rem', 'g'), t)
  },
  j2 = $e(function (t) {
    return Cs(new RegExp('deg|rad|grad|turn', 'g'), t)
  })
function UL(t, e, n, r, i) {
  i === void 0 && (i = 0)
  var a = '',
    o = t.value || 0,
    s = e.value || 0,
    c = Mh(t.unit),
    l = t.convertTo(c),
    u = e.convertTo(c)
  return (
    l && u
      ? ((o = l.value), (s = u.value), (a = Sh(t.unit)))
      : (jt.isLength(t.unit) || jt.isLength(e.unit)) &&
        ((o = ln(t, i, n)), (s = ln(e, i, n)), (a = 'px')),
    [
      o,
      s,
      function (f) {
        return r && (f = Math.max(f, 0)), f + a
      }
    ]
  )
}
function un(t) {
  var e = 0
  return (
    t.unit === Z.kDegrees
      ? (e = t.value)
      : t.unit === Z.kRadians
      ? (e = Mn(Number(t.value)))
      : t.unit === Z.kTurns && (e = sL(Number(t.value))),
    e
  )
}
function af(t, e) {
  var n
  return (
    Array.isArray(t)
      ? (n = t.map(function (r) {
          return Number(r)
        }))
      : ne(t)
      ? (n = t.split(' ').map(function (r) {
          return Number(r)
        }))
      : ve(t) && (n = [t]),
    e === 2
      ? n.length === 1
        ? [n[0], n[0]]
        : [n[0], n[1]]
      : n.length === 1
      ? [n[0], n[0], n[0], n[0]]
      : n.length === 2
      ? [n[0], n[1], n[0], n[1]]
      : n.length === 3
      ? [n[0], n[1], n[2], n[1]]
      : [n[0], n[1], n[2], n[3]]
  )
}
function D2(t) {
  return ne(t)
    ? t.split(' ').map(function (e) {
        return Ra(e)
      })
    : t.map(function (e) {
        return Ra(e.toString())
      })
}
function ln(t, e, n) {
  if (t.value === 0) return 0
  if (t.unit === Z.kPixels) return Number(t.value)
  if (t.unit === Z.kPercentage && n) {
    var r = n.nodeName === G.GROUP ? n.getLocalBounds() : n.geometry.contentBounds
    return (t.value / 100) * r.halfExtents[e] * 2
  }
  return 0
}
var qL = function (t) {
    return Cs(/deg|rad|grad|turn|px|%/g, t)
  },
  KL = [
    'blur',
    'brightness',
    'drop-shadow',
    'contrast',
    'grayscale',
    'sepia',
    'saturate',
    'hue-rotate',
    'invert'
  ]
function $2(t) {
  if ((t === void 0 && (t = ''), (t = t.toLowerCase().trim()), t === 'none')) return []
  for (var e = /\s*([\w-]+)\(([^)]*)\)/g, n = [], r, i = 0; (r = e.exec(t)); ) {
    if (r.index !== i) return []
    if (
      ((i = r.index + r[0].length),
      KL.indexOf(r[1]) > -1 &&
        n.push({
          name: r[1],
          params: r[2].split(' ').map(function (a) {
            return qL(a) || Or(a)
          })
        }),
      e.lastIndex === t.length)
    )
      return n
  }
  return []
}
function B2(t) {
  return t.toString()
}
var Di = $e(function (t) {
  return typeof t == 'number' ? ee(t) : /^\s*[-+]?(\d*\.)?\d+\s*$/.test(t) ? ee(Number(t)) : ee(0)
})
$e(function (t) {
  return ne(t) ? t.split(' ').map(Di) : t.map(Di)
})
function mp(t, e) {
  return [t, e, B2]
}
function bp(t, e) {
  return function (n, r) {
    return [
      n,
      r,
      function (i) {
        return B2(se(i, t, e))
      }
    ]
  }
}
function F2(t, e) {
  if (t.length === e.length)
    return [
      t,
      e,
      function (n) {
        return n
      }
    ]
}
function Ah(t) {
  return (
    t.parsedStyle.path.totalLength === 0 &&
      (t.parsedStyle.path.totalLength = nk(t.parsedStyle.path.absolutePath)),
    t.parsedStyle.path.totalLength
  )
}
function ZL(t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e - 1],
      r = t[e],
      i = r[0]
    if (i === 'M' && n) {
      var a = n[0],
        o = [r[1], r[2]],
        s = void 0
      a === 'L' || a === 'M'
        ? (s = [n[1], n[2]])
        : (a === 'C' || a === 'A' || a === 'Q') && (s = [n[n.length - 2], n[n.length - 1]]),
        s && ul(o, s) && (t.splice(e, 1), e--)
    }
  }
}
function QL(t) {
  for (var e = !1, n = t.length, r = 0; r < n; r++) {
    var i = t[r],
      a = i[0]
    if (a === 'C' || a === 'A' || a === 'Q') {
      e = !0
      break
    }
  }
  return e
}
function JL(t) {
  for (var e = [], n = [], r = [], i = 0; i < t.length; i++) {
    var a = t[i],
      o = a[0]
    o === 'M'
      ? (r.length && (n.push(r), (r = [])), r.push([a[1], a[2]]))
      : o === 'Z'
      ? r.length && (e.push(r), (r = []))
      : r.push([a[1], a[2]])
  }
  return r.length > 0 && n.push(r), { polygons: e, polylines: n }
}
function ul(t, e) {
  return t[0] === e[0] && t[1] === e[1]
}
function tN(t, e) {
  for (var n = [], r = [], i = [], a = 0; a < t.length; a++) {
    var o = t[a],
      s = o.currentPoint,
      c = o.params,
      l = o.prePoint,
      u = void 0
    switch (o.command) {
      case 'Q':
        u = JC(l[0], l[1], c[1], c[2], c[3], c[4])
        break
      case 'C':
        u = qC(l[0], l[1], c[1], c[2], c[3], c[4], c[5], c[6])
        break
      case 'A':
        var f = o.arcParams
        u = VC(f.cx, f.cy, f.rx, f.ry, f.xRotation, f.startAngle, f.endAngle)
        break
      default:
        n.push(s[0]), r.push(s[1])
        break
    }
    u && ((o.box = u), n.push(u.x, u.x + u.width), r.push(u.y, u.y + u.height)),
      e && (o.command === 'L' || o.command === 'M') && o.prePoint && o.nextPoint && i.push(o)
  }
  ;(n = n.filter(function (y) {
    return !Number.isNaN(y) && y !== 1 / 0 && y !== -1 / 0
  })),
    (r = r.filter(function (y) {
      return !Number.isNaN(y) && y !== 1 / 0 && y !== -1 / 0
    }))
  var h = Kc(n),
    d = Kc(r),
    p = qc(n),
    v = qc(r)
  if (i.length === 0) return { x: h, y: d, width: p - h, height: v - d }
  for (var a = 0; a < i.length; a++) {
    var o = i[a],
      s = o.currentPoint,
      g = void 0
    s[0] === h
      ? ((g = ec(o, e)), (h = h - g.xExtra))
      : s[0] === p && ((g = ec(o, e)), (p = p + g.xExtra)),
      s[1] === d
        ? ((g = ec(o, e)), (d = d - g.yExtra))
        : s[1] === v && ((g = ec(o, e)), (v = v + g.yExtra))
  }
  return { x: h, y: d, width: p - h, height: v - d }
}
function ec(t, e) {
  var n = t.prePoint,
    r = t.currentPoint,
    i = t.nextPoint,
    a = Math.pow(r[0] - n[0], 2) + Math.pow(r[1] - n[1], 2),
    o = Math.pow(r[0] - i[0], 2) + Math.pow(r[1] - i[1], 2),
    s = Math.pow(n[0] - i[0], 2) + Math.pow(n[1] - i[1], 2),
    c = Math.acos((a + o - s) / (2 * Math.sqrt(a) * Math.sqrt(o)))
  if (!c || Math.sin(c) === 0 || No(c, 0)) return { xExtra: 0, yExtra: 0 }
  var l = Math.abs(Math.atan2(i[1] - r[1], i[0] - r[0])),
    u = Math.abs(Math.atan2(i[0] - r[0], i[1] - r[1]))
  ;(l = l > Math.PI / 2 ? Math.PI - l : l), (u = u > Math.PI / 2 ? Math.PI - u : u)
  var f = {
    xExtra: Math.cos(c / 2 - l) * ((e / 2) * (1 / Math.sin(c / 2))) - e / 2 || 0,
    yExtra: Math.cos(u - c / 2) * ((e / 2) * (1 / Math.sin(c / 2))) - e / 2 || 0
  }
  return f
}
function ig(t, e) {
  return [e[0] + (e[0] - t[0]), e[1] + (e[1] - t[1])]
}
var ag = function (t, e) {
    var n = t.x * e.x + t.y * e.y,
      r = Math.sqrt((Math.pow(t.x, 2) + Math.pow(t.y, 2)) * (Math.pow(e.x, 2) + Math.pow(e.y, 2))),
      i = t.x * e.y - t.y * e.x < 0 ? -1 : 1,
      a = i * Math.acos(n / r)
    return a
  },
  og = function (t, e, n, r, i, a, o, s) {
    ;(e = Math.abs(e)), (n = Math.abs(n)), (r = K1(r, 360))
    var c = Jt(r)
    if (t.x === o.x && t.y === o.y) return { x: t.x, y: t.y, ellipticalArcAngle: 0 }
    if (e === 0 || n === 0) return { x: 0, y: 0, ellipticalArcAngle: 0 }
    var l = (t.x - o.x) / 2,
      u = (t.y - o.y) / 2,
      f = { x: Math.cos(c) * l + Math.sin(c) * u, y: -Math.sin(c) * l + Math.cos(c) * u },
      h = Math.pow(f.x, 2) / Math.pow(e, 2) + Math.pow(f.y, 2) / Math.pow(n, 2)
    h > 1 && ((e = Math.sqrt(h) * e), (n = Math.sqrt(h) * n))
    var d =
        Math.pow(e, 2) * Math.pow(n, 2) -
        Math.pow(e, 2) * Math.pow(f.y, 2) -
        Math.pow(n, 2) * Math.pow(f.x, 2),
      p = Math.pow(e, 2) * Math.pow(f.y, 2) + Math.pow(n, 2) * Math.pow(f.x, 2),
      v = d / p
    v = v < 0 ? 0 : v
    var g = (i !== a ? 1 : -1) * Math.sqrt(v),
      y = { x: g * ((e * f.y) / n), y: g * (-(n * f.x) / e) },
      m = {
        x: Math.cos(c) * y.x - Math.sin(c) * y.y + (t.x + o.x) / 2,
        y: Math.sin(c) * y.x + Math.cos(c) * y.y + (t.y + o.y) / 2
      },
      b = { x: (f.x - y.x) / e, y: (f.y - y.y) / n },
      x = ag({ x: 1, y: 0 }, b),
      w = { x: (-f.x - y.x) / e, y: (-f.y - y.y) / n },
      O = ag(b, w)
    !a && O > 0 ? (O -= 2 * Math.PI) : a && O < 0 && (O += 2 * Math.PI), (O %= 2 * Math.PI)
    var S = x + O * s,
      _ = e * Math.cos(S),
      M = n * Math.sin(S),
      E = {
        x: Math.cos(c) * _ - Math.sin(c) * M + m.x,
        y: Math.sin(c) * _ + Math.cos(c) * M + m.y,
        ellipticalArcStartAngle: x,
        ellipticalArcEndAngle: x + O,
        ellipticalArcAngle: S,
        ellipticalArcCenter: m,
        resultantRx: e,
        resultantRy: n
      }
    return E
  }
function eN(t) {
  for (var e = [], n = null, r = null, i = null, a = 0, o = t.length, s = 0; s < o; s++) {
    var c = t[s]
    r = t[s + 1]
    var l = c[0],
      u = {
        command: l,
        prePoint: n,
        params: c,
        startTangent: null,
        endTangent: null,
        currentPoint: null,
        nextPoint: null,
        arcParams: null,
        box: null,
        cubicParams: null
      }
    switch (l) {
      case 'M':
        ;(i = [c[1], c[2]]), (a = s)
        break
      case 'A':
        var f = nN(n, c)
        u.arcParams = f
        break
    }
    if (l === 'Z') (n = i), (r = t[a + 1])
    else {
      var h = c.length
      n = [c[h - 2], c[h - 1]]
    }
    r && r[0] === 'Z' && ((r = t[a]), e[a] && (e[a].prePoint = n)),
      (u.currentPoint = n),
      e[a] && ul(n, e[a].currentPoint) && (e[a].prePoint = u.prePoint)
    var d = r ? [r[r.length - 2], r[r.length - 1]] : null
    u.nextPoint = d
    var p = u.prePoint
    if (['L', 'H', 'V'].includes(l))
      (u.startTangent = [p[0] - n[0], p[1] - n[1]]), (u.endTangent = [n[0] - p[0], n[1] - p[1]])
    else if (l === 'Q') {
      var v = [c[1], c[2]]
      ;(u.startTangent = [p[0] - v[0], p[1] - v[1]]), (u.endTangent = [n[0] - v[0], n[1] - v[1]])
    } else if (l === 'T') {
      var g = e[s - 1],
        v = ig(g.currentPoint, p)
      g.command === 'Q'
        ? ((u.command = 'Q'),
          (u.startTangent = [p[0] - v[0], p[1] - v[1]]),
          (u.endTangent = [n[0] - v[0], n[1] - v[1]]))
        : ((u.command = 'TL'),
          (u.startTangent = [p[0] - n[0], p[1] - n[1]]),
          (u.endTangent = [n[0] - p[0], n[1] - p[1]]))
    } else if (l === 'C') {
      var y = [c[1], c[2]],
        m = [c[3], c[4]]
      ;(u.startTangent = [p[0] - y[0], p[1] - y[1]]),
        (u.endTangent = [n[0] - m[0], n[1] - m[1]]),
        u.startTangent[0] === 0 &&
          u.startTangent[1] === 0 &&
          (u.startTangent = [y[0] - m[0], y[1] - m[1]]),
        u.endTangent[0] === 0 &&
          u.endTangent[1] === 0 &&
          (u.endTangent = [m[0] - y[0], m[1] - y[1]])
    } else if (l === 'S') {
      var g = e[s - 1],
        y = ig(g.currentPoint, p),
        m = [c[1], c[2]]
      g.command === 'C'
        ? ((u.command = 'C'),
          (u.startTangent = [p[0] - y[0], p[1] - y[1]]),
          (u.endTangent = [n[0] - m[0], n[1] - m[1]]))
        : ((u.command = 'SQ'),
          (u.startTangent = [p[0] - m[0], p[1] - m[1]]),
          (u.endTangent = [n[0] - m[0], n[1] - m[1]]))
    } else if (l === 'A') {
      var b = sg(u, 0),
        x = b.x,
        w = b.y,
        O = sg(u, 1, !1),
        S = O.x,
        _ = O.y
      ;(u.startTangent = [x, w]), (u.endTangent = [S, _])
    }
    e.push(u)
  }
  return e
}
function sg(t, e, n) {
  n === void 0 && (n = !0)
  var r = t.arcParams,
    i = r.rx,
    a = i === void 0 ? 0 : i,
    o = r.ry,
    s = o === void 0 ? 0 : o,
    c = r.xRotation,
    l = r.arcFlag,
    u = r.sweepFlag,
    f = og(
      { x: t.prePoint[0], y: t.prePoint[1] },
      a,
      s,
      c,
      !!l,
      !!u,
      { x: t.currentPoint[0], y: t.currentPoint[1] },
      e
    ),
    h = og(
      { x: t.prePoint[0], y: t.prePoint[1] },
      a,
      s,
      c,
      !!l,
      !!u,
      { x: t.currentPoint[0], y: t.currentPoint[1] },
      n ? e + 0.005 : e - 0.005
    ),
    d = h.x - f.x,
    p = h.y - f.y,
    v = Math.sqrt(d * d + p * p)
  return { x: -d / v, y: -p / v }
}
function nc(t) {
  return Math.sqrt(t[0] * t[0] + t[1] * t[1])
}
function kh(t, e) {
  return nc(t) * nc(e) ? (t[0] * e[0] + t[1] * e[1]) / (nc(t) * nc(e)) : 1
}
function cg(t, e) {
  return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(kh(t, e))
}
function nN(t, e) {
  var n = e[1],
    r = e[2],
    i = K1(Jt(e[3]), Math.PI * 2),
    a = e[4],
    o = e[5],
    s = t[0],
    c = t[1],
    l = e[6],
    u = e[7],
    f = (Math.cos(i) * (s - l)) / 2 + (Math.sin(i) * (c - u)) / 2,
    h = (-1 * Math.sin(i) * (s - l)) / 2 + (Math.cos(i) * (c - u)) / 2,
    d = (f * f) / (n * n) + (h * h) / (r * r)
  d > 1 && ((n *= Math.sqrt(d)), (r *= Math.sqrt(d)))
  var p = n * n * (h * h) + r * r * (f * f),
    v = p ? Math.sqrt((n * n * (r * r) - p) / p) : 1
  a === o && (v *= -1), isNaN(v) && (v = 0)
  var g = r ? (v * n * h) / r : 0,
    y = n ? (v * -r * f) / n : 0,
    m = (s + l) / 2 + Math.cos(i) * g - Math.sin(i) * y,
    b = (c + u) / 2 + Math.sin(i) * g + Math.cos(i) * y,
    x = [(f - g) / n, (h - y) / r],
    w = [(-1 * f - g) / n, (-1 * h - y) / r],
    O = cg([1, 0], x),
    S = cg(x, w)
  return (
    kh(x, w) <= -1 && (S = Math.PI),
    kh(x, w) >= 1 && (S = 0),
    o === 0 && S > 0 && (S = S - 2 * Math.PI),
    o === 1 && S < 0 && (S = S + 2 * Math.PI),
    {
      cx: m,
      cy: b,
      rx: ul(t, [l, u]) ? 0 : n,
      ry: ul(t, [l, u]) ? 0 : r,
      startAngle: O,
      endAngle: O + S,
      xRotation: i,
      arcFlag: a,
      sweepFlag: o
    }
  )
}
function rN(t, e, n) {
  var r = e.parsedStyle,
    i = r.defX,
    a = i === void 0 ? 0 : i,
    o = r.defY,
    s = o === void 0 ? 0 : o
  return t.reduce(function (c, l) {
    var u = ''
    if (l[0] === 'M' || l[0] === 'L') {
      var f = St(l[1] - a, l[2] - s, 0)
      n && be(f, f, n), (u = ''.concat(l[0]).concat(f[0], ',').concat(f[1]))
    } else if (l[0] === 'Z') u = l[0]
    else if (l[0] === 'C') {
      var h = St(l[1] - a, l[2] - s, 0),
        d = St(l[3] - a, l[4] - s, 0),
        p = St(l[5] - a, l[6] - s, 0)
      n && (be(h, h, n), be(d, d, n), be(p, p, n)),
        (u = ''
          .concat(l[0])
          .concat(h[0], ',')
          .concat(h[1], ',')
          .concat(d[0], ',')
          .concat(d[1], ',')
          .concat(p[0], ',')
          .concat(p[1]))
    } else if (l[0] === 'A') {
      var v = St(l[6] - a, l[7] - s, 0)
      n && be(v, v, n),
        (u = ''
          .concat(l[0])
          .concat(l[1], ',')
          .concat(l[2], ',')
          .concat(l[3], ',')
          .concat(l[4], ',')
          .concat(l[5], ',')
          .concat(v[0], ',')
          .concat(v[1]))
    } else if (l[0] === 'Q') {
      var h = St(l[1] - a, l[2] - s, 0),
        d = St(l[3] - a, l[4] - s, 0)
      n && (be(h, h, n), be(d, d, n)),
        (u = ''
          .concat(l[0])
          .concat(l[1], ',')
          .concat(l[2], ',')
          .concat(l[3], ',')
          .concat(l[4], '}'))
    }
    return (c += u)
  }, '')
}
function iN(t, e, n, r) {
  return [
    ['M', t, e],
    ['L', n, r]
  ]
}
function lg(t, e, n, r) {
  var i = ((-1 + Math.sqrt(2)) / 3) * 4,
    a = t * i,
    o = e * i,
    s = n - t,
    c = n + t,
    l = r - e,
    u = r + e
  return [
    ['M', s, r],
    ['C', s, r - o, n - a, l, n, l],
    ['C', n + a, l, c, r - o, c, r],
    ['C', c, r + o, n + a, u, n, u],
    ['C', n - a, u, s, r + o, s, r],
    ['Z']
  ]
}
function aN(t, e) {
  var n = t.map(function (r, i) {
    return [i === 0 ? 'M' : 'L', r[0], r[1]]
  })
  return e && n.push(['Z']), n
}
function oN(t, e, n, r, i) {
  if (i) {
    var a = N(i, 4),
      o = a[0],
      s = a[1],
      c = a[2],
      l = a[3],
      u = t > 0 ? 1 : -1,
      f = e > 0 ? 1 : -1,
      h = u + f !== 0 ? 1 : 0
    return [
      ['M', u * o + n, r],
      ['L', t - u * s + n, r],
      s ? ['A', s, s, 0, 0, h, t + n, f * s + r] : null,
      ['L', t + n, e - f * c + r],
      c ? ['A', c, c, 0, 0, h, t + n - u * c, e + r] : null,
      ['L', n + u * l, e + r],
      l ? ['A', l, l, 0, 0, h, n, e + r - f * l] : null,
      ['L', n, f * o + r],
      o ? ['A', o, o, 0, 0, h, u * o + n, r] : null,
      ['Z']
    ].filter(function (d) {
      return d
    })
  }
  return [['M', n, r], ['L', n + t, r], ['L', n + t, r + e], ['L', n, r + e], ['Z']]
}
function z2(t, e) {
  e === void 0 && (e = t.getLocalTransform())
  var n = []
  switch (t.nodeName) {
    case G.LINE:
      var r = t.parsedStyle,
        i = r.x1,
        a = i === void 0 ? 0 : i,
        o = r.y1,
        s = o === void 0 ? 0 : o,
        c = r.x2,
        l = c === void 0 ? 0 : c,
        u = r.y2,
        f = u === void 0 ? 0 : u
      n = iN(a, s, l, f)
      break
    case G.CIRCLE: {
      var h = t.parsedStyle,
        d = h.r,
        p = d === void 0 ? 0 : d,
        v = h.cx,
        g = v === void 0 ? 0 : v,
        y = h.cy,
        m = y === void 0 ? 0 : y
      n = lg(p, p, g, m)
      break
    }
    case G.ELLIPSE: {
      var b = t.parsedStyle,
        x = b.rx,
        w = x === void 0 ? 0 : x,
        O = b.ry,
        S = O === void 0 ? 0 : O,
        _ = b.cx,
        g = _ === void 0 ? 0 : _,
        M = b.cy,
        m = M === void 0 ? 0 : M
      n = lg(w, S, g, m)
      break
    }
    case G.POLYLINE:
    case G.POLYGON:
      var E = t.parsedStyle.points
      n = aN(E.points, t.nodeName === G.POLYGON)
      break
    case G.RECT:
      var T = t.parsedStyle,
        C = T.width,
        A = C === void 0 ? 0 : C,
        P = T.height,
        k = P === void 0 ? 0 : P,
        L = T.x,
        R = L === void 0 ? 0 : L,
        j = T.y,
        I = j === void 0 ? 0 : j,
        D = T.radius,
        $ =
          D &&
          D.some(function (F) {
            return F !== 0
          })
      n = oN(
        A,
        k,
        R,
        I,
        $ &&
          D.map(function (F) {
            return se(F, 0, Math.min(Math.abs(A) / 2, Math.abs(k) / 2))
          })
      )
      break
    case G.PATH:
      var B = t.parsedStyle.path.absolutePath
      n = q([], N(B), !1)
      break
  }
  if (n.length) return rN(n, t, e)
}
var G2 = function (t) {
    if (t === '' || (Array.isArray(t) && t.length === 0))
      return {
        absolutePath: [],
        hasArc: !1,
        segments: [],
        polygons: [],
        polylines: [],
        curve: null,
        totalLength: 0,
        rect: { x: 0, y: 0, width: 0, height: 0 }
      }
    var e
    try {
      e = el(t)
    } catch {
      ;(e = el('')), console.error('[g]: Invalid SVG Path definition: '.concat(t))
    }
    ZL(e)
    var n = QL(e),
      r = JL(e),
      i = r.polygons,
      a = r.polylines,
      o = eN(e),
      s = tN(o, 0),
      c = s.x,
      l = s.y,
      u = s.width,
      f = s.height
    return {
      absolutePath: e,
      hasArc: n,
      segments: o,
      polygons: i,
      polylines: a,
      totalLength: 0,
      rect: {
        x: Number.isFinite(c) ? c : 0,
        y: Number.isFinite(l) ? l : 0,
        width: Number.isFinite(u) ? u : 0,
        height: Number.isFinite(f) ? f : 0
      }
    }
  },
  sN = $e(G2)
function Ch(t) {
  return ne(t) ? sN(t) : G2(t)
}
function cN(t, e, n) {
  var r = t.curve,
    i = e.curve
  ;(!r || r.length === 0) && ((r = nh(t.absolutePath, !1)), (t.curve = r)),
    (!i || i.length === 0) && ((i = nh(e.absolutePath, !1)), (e.curve = i))
  var a = [r, i]
  r.length !== i.length && (a = _b(r, i))
  var o = mv(a[0]) !== mv(a[1]) ? KA(a[0]) : qA(a[0])
  return [
    o,
    ik(a[1], o),
    function (s) {
      return s
    }
  ]
}
function W2(t, e) {
  var n
  ne(t)
    ? (n = t.split(' ').map(function (u) {
        var f = N(u.split(','), 2),
          h = f[0],
          d = f[1]
        return [Number(h), Number(d)]
      }))
    : (n = t)
  var r = [],
    i = 0,
    a,
    o,
    s = QC(n)
  n.forEach(function (u, f) {
    n[f + 1] &&
      ((a = [0, 0]),
      (a[0] = i / s),
      (o = P2(u[0], u[1], n[f + 1][0], n[f + 1][1])),
      (i += o),
      (a[1] = i / s),
      r.push(a))
  })
  var c = Math.min.apply(
      Math,
      q(
        [],
        N(
          n.map(function (u) {
            return u[0]
          })
        ),
        !1
      )
    ),
    l = Math.min.apply(
      Math,
      q(
        [],
        N(
          n.map(function (u) {
            return u[1]
          })
        ),
        !1
      )
    )
  return (
    e && ((e.parsedStyle.defX = c), (e.parsedStyle.defY = l)),
    { points: n, totalLength: s, segments: r }
  )
}
function lN(t, e) {
  return [
    t.points,
    e.points,
    function (n) {
      return n
    }
  ]
}
var re = null
function Ue(t) {
  return function (e) {
    var n = 0
    return t.map(function (r) {
      return r === re ? e[n++] : r
    })
  }
}
function gi(t) {
  return t
}
var Lh = {
  matrix: ['NNNNNN', [re, re, 0, 0, re, re, 0, 0, 0, 0, 1, 0, re, re, 0, 1], gi],
  matrix3d: ['NNNNNNNNNNNNNNNN', gi],
  rotate: ['A'],
  rotatex: ['A'],
  rotatey: ['A'],
  rotatez: ['A'],
  rotate3d: ['NNNA'],
  perspective: ['L'],
  scale: ['Nn', Ue([re, re, new jt(1)]), gi],
  scalex: ['N', Ue([re, new jt(1), new jt(1)]), Ue([re, new jt(1)])],
  scaley: ['N', Ue([new jt(1), re, new jt(1)]), Ue([new jt(1), re])],
  scalez: ['N', Ue([new jt(1), new jt(1), re])],
  scale3d: ['NNN', gi],
  skew: ['Aa', null, gi],
  skewx: ['A', null, Ue([re, mr])],
  skewy: ['A', null, Ue([mr, re])],
  translate: ['Tt', Ue([re, re, Me]), gi],
  translatex: ['T', Ue([re, Me, Me]), Ue([re, Me])],
  translatey: ['T', Ue([Me, re, Me]), Ue([Me, re])],
  translatez: ['L', Ue([Me, Me, re])],
  translate3d: ['TTL', gi]
}
function fl(t) {
  if (((t = (t || 'none').toLowerCase().trim()), t === 'none')) return []
  for (var e = /\s*(\w+)\(([^)]*)\)/g, n = [], r, i = 0; (r = e.exec(t)); ) {
    if (r.index !== i) return []
    i = r.index + r[0].length
    var a = r[1],
      o = Lh[a]
    if (!o) return []
    var s = r[2].split(','),
      c = o[0]
    if (c.length < s.length) return []
    for (var l = [], u = 0; u < c.length; u++) {
      var f = s[u],
        h = c[u],
        d = void 0
      if (
        (f
          ? (d = {
              A: function (p) {
                return p.trim() === '0' ? mr : j2(p)
              },
              N: Di,
              T: Ra,
              L: XL
            }[h.toUpperCase()](f))
          : (d = { a: mr, n: l[0], t: Me }[h]),
        d === void 0)
      )
        return []
      l.push(d)
    }
    if ((n.push({ t: a, d: l }), e.lastIndex === t.length)) return n
  }
  return []
}
function uN(t) {
  var e, n, r, i
  switch (t.t) {
    case 'rotatex':
      return (
        (i = Jt(un(t.d[0]))),
        [1, 0, 0, 0, 0, Math.cos(i), Math.sin(i), 0, 0, -Math.sin(i), Math.cos(i), 0, 0, 0, 0, 1]
      )
    case 'rotatey':
      return (
        (i = Jt(un(t.d[0]))),
        [Math.cos(i), 0, -Math.sin(i), 0, 0, 1, 0, 0, Math.sin(i), 0, Math.cos(i), 0, 0, 0, 0, 1]
      )
    case 'rotate':
    case 'rotatez':
      return (
        (i = Jt(un(t.d[0]))),
        [Math.cos(i), Math.sin(i), 0, 0, -Math.sin(i), Math.cos(i), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
      )
    case 'rotate3d':
      ;(e = t.d[0].value), (n = t.d[1].value), (r = t.d[2].value), (i = Jt(un(t.d[3])))
      var a = e * e + n * n + r * r
      if (a === 0) (e = 1), (n = 0), (r = 0)
      else if (a !== 1) {
        var o = Math.sqrt(a)
        ;(e /= o), (n /= o), (r /= o)
      }
      var s = Math.sin(i / 2),
        c = s * Math.cos(i / 2),
        l = s * s
      return [
        1 - 2 * (n * n + r * r) * l,
        2 * (e * n * l + r * c),
        2 * (e * r * l - n * c),
        0,
        2 * (e * n * l - r * c),
        1 - 2 * (e * e + r * r) * l,
        2 * (n * r * l + e * c),
        0,
        2 * (e * r * l + n * c),
        2 * (n * r * l - e * c),
        1 - 2 * (e * e + n * n) * l,
        0,
        0,
        0,
        0,
        1
      ]
    case 'scale':
      return [t.d[0].value, 0, 0, 0, 0, t.d[1].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    case 'scalex':
      return [t.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    case 'scaley':
      return [1, 0, 0, 0, 0, t.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    case 'scalez':
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, t.d[0].value, 0, 0, 0, 0, 1]
    case 'scale3d':
      return [t.d[0].value, 0, 0, 0, 0, t.d[1].value, 0, 0, 0, 0, t.d[2].value, 0, 0, 0, 0, 1]
    case 'skew':
      var u = Jt(un(t.d[0])),
        f = Jt(un(t.d[1]))
      return [1, Math.tan(f), 0, 0, Math.tan(u), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    case 'skewx':
      return (i = Jt(un(t.d[0]))), [1, 0, 0, 0, Math.tan(i), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    case 'skewy':
      return (i = Jt(un(t.d[0]))), [1, Math.tan(i), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    case 'translate':
      return (
        (e = ln(t.d[0], 0, null) || 0),
        (n = ln(t.d[1], 0, null) || 0),
        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, n, 0, 1]
      )
    case 'translatex':
      return (e = ln(t.d[0], 0, null) || 0), [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, 0, 0, 1]
    case 'translatey':
      return (n = ln(t.d[0], 0, null) || 0), [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, n, 0, 1]
    case 'translatez':
      return (r = ln(t.d[0], 0, null) || 0), [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, r, 1]
    case 'translate3d':
      return (
        (e = ln(t.d[0], 0, null) || 0),
        (n = ln(t.d[1], 0, null) || 0),
        (r = ln(t.d[2], 0, null) || 0),
        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, n, r, 1]
      )
    case 'perspective':
      var h = ln(t.d[0], 0, null) || 0,
        d = h ? -1 / h : 0
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, d, 0, 0, 0, 1]
    case 'matrix':
      return [
        t.d[0].value,
        t.d[1].value,
        0,
        0,
        t.d[2].value,
        t.d[3].value,
        0,
        0,
        0,
        0,
        1,
        0,
        t.d[4].value,
        t.d[5].value,
        0,
        1
      ]
    case 'matrix3d':
      return t.d.map(function (p) {
        return p.value
      })
  }
}
function fN(t, e) {
  return [
    t[0] * e[0] + t[4] * e[1] + t[8] * e[2] + t[12] * e[3],
    t[1] * e[0] + t[5] * e[1] + t[9] * e[2] + t[13] * e[3],
    t[2] * e[0] + t[6] * e[1] + t[10] * e[2] + t[14] * e[3],
    t[3] * e[0] + t[7] * e[1] + t[11] * e[2] + t[15] * e[3],
    t[0] * e[4] + t[4] * e[5] + t[8] * e[6] + t[12] * e[7],
    t[1] * e[4] + t[5] * e[5] + t[9] * e[6] + t[13] * e[7],
    t[2] * e[4] + t[6] * e[5] + t[10] * e[6] + t[14] * e[7],
    t[3] * e[4] + t[7] * e[5] + t[11] * e[6] + t[15] * e[7],
    t[0] * e[8] + t[4] * e[9] + t[8] * e[10] + t[12] * e[11],
    t[1] * e[8] + t[5] * e[9] + t[9] * e[10] + t[13] * e[11],
    t[2] * e[8] + t[6] * e[9] + t[10] * e[10] + t[14] * e[11],
    t[3] * e[8] + t[7] * e[9] + t[11] * e[10] + t[15] * e[11],
    t[0] * e[12] + t[4] * e[13] + t[8] * e[14] + t[12] * e[15],
    t[1] * e[12] + t[5] * e[13] + t[9] * e[14] + t[13] * e[15],
    t[2] * e[12] + t[6] * e[13] + t[10] * e[14] + t[14] * e[15],
    t[3] * e[12] + t[7] * e[13] + t[11] * e[14] + t[15] * e[15]
  ]
}
function hN(t) {
  return t.length === 0 ? [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] : t.map(uN).reduce(fN)
}
function ug(t) {
  var e = [0, 0, 0],
    n = [1, 1, 1],
    r = [0, 0, 0],
    i = [0, 0, 0, 1],
    a = [0, 0, 0, 1]
  return hL(hN(t), e, n, r, i, a), [[e, n, r, a, i]]
}
var dN = (function () {
  function t(r, i) {
    for (
      var a = [
          [0, 0, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        o = 0;
      o < 4;
      o++
    )
      for (var s = 0; s < 4; s++) for (var c = 0; c < 4; c++) a[o][s] += i[o][c] * r[c][s]
    return a
  }
  function e(r) {
    return (
      r[0][2] == 0 &&
      r[0][3] == 0 &&
      r[1][2] == 0 &&
      r[1][3] == 0 &&
      r[2][0] == 0 &&
      r[2][1] == 0 &&
      r[2][2] == 1 &&
      r[2][3] == 0 &&
      r[3][2] == 0 &&
      r[3][3] == 1
    )
  }
  function n(r, i, a, o, s) {
    for (
      var c = [
          [1, 0, 0, 0],
          [0, 1, 0, 0],
          [0, 0, 1, 0],
          [0, 0, 0, 1]
        ],
        l = 0;
      l < 4;
      l++
    )
      c[l][3] = s[l]
    for (var l = 0; l < 3; l++) for (var u = 0; u < 3; u++) c[3][l] += r[u] * c[u][l]
    var f = o[0],
      h = o[1],
      d = o[2],
      p = o[3],
      v = [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
      ]
    ;(v[0][0] = 1 - 2 * (h * h + d * d)),
      (v[0][1] = 2 * (f * h - d * p)),
      (v[0][2] = 2 * (f * d + h * p)),
      (v[1][0] = 2 * (f * h + d * p)),
      (v[1][1] = 1 - 2 * (f * f + d * d)),
      (v[1][2] = 2 * (h * d - f * p)),
      (v[2][0] = 2 * (f * d - h * p)),
      (v[2][1] = 2 * (h * d + f * p)),
      (v[2][2] = 1 - 2 * (f * f + h * h)),
      (c = t(c, v))
    var g = [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ]
    a[2] && ((g[2][1] = a[2]), (c = t(c, g))),
      a[1] && ((g[2][1] = 0), (g[2][0] = a[0]), (c = t(c, g))),
      a[0] && ((g[2][0] = 0), (g[1][0] = a[0]), (c = t(c, g)))
    for (var l = 0; l < 3; l++) for (var u = 0; u < 3; u++) c[l][u] *= i[l]
    return e(c)
      ? [c[0][0], c[0][1], c[1][0], c[1][1], c[3][0], c[3][1]]
      : c[0].concat(c[1], c[2], c[3])
  }
  return n
})()
function pN(t) {
  return t.toFixed(6).replace('.000000', '')
}
function of(t, e) {
  var n, r
  return (
    t.decompositionPair !== e && ((t.decompositionPair = e), (n = ug(t))),
    e.decompositionPair !== t && ((e.decompositionPair = t), (r = ug(e))),
    n[0] === null || r[0] === null
      ? [
          [!1],
          [!0],
          function (i) {
            return i ? e[0].d : t[0].d
          }
        ]
      : (n[0].push(0),
        r[0].push(1),
        [
          n,
          r,
          function (i) {
            var a = gN(n[0][3], r[0][3], i[5]),
              o = dN(i[0], i[1], i[2], a, i[4]),
              s = o.map(pN).join(',')
            return s
          }
        ])
  )
}
function vN(t, e) {
  for (var n = 0, r = 0; r < t.length; r++) n += t[r] * e[r]
  return n
}
function gN(t, e, n) {
  var r = vN(t, e)
  r = se(r, -1, 1)
  var i = []
  if (r === 1) i = t
  else
    for (var a = Math.acos(r), o = (Math.sin(n * a) * 1) / Math.sqrt(1 - r * r), s = 0; s < 4; s++)
      i.push(t[s] * (Math.cos(n * a) - r * o) + e[s] * o)
  return i
}
function sf(t) {
  return t.replace(/[xy]/, '')
}
function cf(t) {
  return t.replace(/(x|y|z|3d)?$/, '3d')
}
var yN = function (t, e) {
  return (
    (t === 'perspective' && e === 'perspective') ||
    ((t === 'matrix' || t === 'matrix3d') && (e === 'matrix' || e === 'matrix3d'))
  )
}
function mN(t, e, n) {
  var r = !1
  if (!t.length || !e.length) {
    t.length || ((r = !0), (t = e), (e = []))
    for (
      var i = function (O) {
          var S = t[O],
            _ = S.t,
            M = S.d,
            E = _.substring(0, 5) === 'scale' ? 1 : 0
          e.push({
            t: _,
            d: M.map(function (T) {
              return typeof T == 'number' ? ee(E) : ee(E, T.unit)
            })
          })
        },
        a = 0;
      a < t.length;
      a++
    )
      i(a)
  }
  var o = [],
    s = [],
    c = []
  if (t.length !== e.length) {
    var l = of(t, e)
    ;(o = [l[0]]), (s = [l[1]]), (c = [['matrix', [l[2]]]])
  } else
    for (var a = 0; a < t.length; a++) {
      var u = t[a].t,
        f = e[a].t,
        h = t[a].d,
        d = e[a].d,
        p = Lh[u],
        v = Lh[f],
        g = void 0
      if (yN(u, f)) {
        var l = of([t[a]], [e[a]])
        o.push(l[0]), s.push(l[1]), c.push(['matrix', [l[2]]])
        continue
      } else if (u === f) g = u
      else if (p[2] && v[2] && sf(u) === sf(f)) (g = sf(u)), (h = p[2](h)), (d = v[2](d))
      else if (p[1] && v[1] && cf(u) === cf(f)) (g = cf(u)), (h = p[1](h)), (d = v[1](d))
      else {
        var l = of(t, e)
        ;(o = [l[0]]), (s = [l[1]]), (c = [['matrix', [l[2]]]])
        break
      }
      for (var y = [], m = [], b = [], x = 0; x < h.length; x++) {
        var l = UL(h[x], d[x], n, !1, x)
        ;(y[x] = l[0]), (m[x] = l[1]), b.push(l[2])
      }
      o.push(y), s.push(m), c.push([g, b])
    }
  if (r) {
    var w = o
    ;(o = s), (s = w)
  }
  return [
    o,
    s,
    function (O) {
      return O.map(function (S, _) {
        var M = S.map(function (E, T) {
          return c[_][1][T](E)
        }).join(',')
        return (
          c[_][0] === 'matrix' && M.split(',').length === 16 && (c[_][0] = 'matrix3d'),
          c[_][0] === 'matrix3d' && M.split(',').length === 6 && (c[_][0] = 'matrix'),
          c[_][0] + '(' + M + ')'
        )
      }).join(' ')
    }
  ]
}
var Y2 = $e(function (t) {
  if (ne(t)) {
    if (t === 'text-anchor') return [ee(0, 'px'), ee(0, 'px')]
    var e = t.split(' ')
    return (
      e.length === 1 &&
        (e[0] === 'top' || e[0] === 'bottom'
          ? ((e[1] = e[0]), (e[0] = 'center'))
          : (e[1] = 'center')),
      e.length !== 2 ? null : [Ra(fg(e[0])), Ra(fg(e[1]))]
    )
  } else return [ee(t[0] || 0, 'px'), ee(t[1] || 0, 'px')]
})
function fg(t) {
  return t === 'center'
    ? '50%'
    : t === 'left' || t === 'top'
    ? '0'
    : t === 'right' || t === 'bottom'
    ? '100%'
    : t
}
var xp = [
    { n: 'display', k: ['none'] },
    { n: 'opacity', int: !0, inh: !0, d: '1', syntax: J.OPACITY_VALUE },
    { n: 'fillOpacity', int: !0, inh: !0, d: '1', syntax: J.OPACITY_VALUE },
    { n: 'strokeOpacity', int: !0, inh: !0, d: '1', syntax: J.OPACITY_VALUE },
    { n: 'fill', int: !0, k: ['none'], d: 'none', syntax: J.PAINT },
    { n: 'fillRule', k: ['nonzero', 'evenodd'], d: 'nonzero' },
    { n: 'stroke', int: !0, k: ['none'], d: 'none', syntax: J.PAINT, l: !0 },
    { n: 'shadowType', k: ['inner', 'outer', 'both'], d: 'outer', l: !0 },
    { n: 'shadowColor', int: !0, syntax: J.COLOR },
    { n: 'shadowOffsetX', int: !0, l: !0, d: '0', syntax: J.LENGTH_PERCENTAGE },
    { n: 'shadowOffsetY', int: !0, l: !0, d: '0', syntax: J.LENGTH_PERCENTAGE },
    { n: 'shadowBlur', int: !0, l: !0, d: '0', syntax: J.SHADOW_BLUR },
    {
      n: 'lineWidth',
      int: !0,
      inh: !0,
      d: '1',
      l: !0,
      a: ['strokeWidth'],
      syntax: J.LENGTH_PERCENTAGE
    },
    { n: 'increasedLineWidthForHitTesting', inh: !0, d: '0', l: !0, syntax: J.LENGTH_PERCENTAGE },
    {
      n: 'lineJoin',
      inh: !0,
      l: !0,
      a: ['strokeLinejoin'],
      k: ['miter', 'bevel', 'round'],
      d: 'miter'
    },
    {
      n: 'lineCap',
      inh: !0,
      l: !0,
      a: ['strokeLinecap'],
      k: ['butt', 'round', 'square'],
      d: 'butt'
    },
    {
      n: 'lineDash',
      int: !0,
      inh: !0,
      k: ['none'],
      a: ['strokeDasharray'],
      syntax: J.LENGTH_PERCENTAGE_12
    },
    {
      n: 'lineDashOffset',
      int: !0,
      inh: !0,
      d: '0',
      a: ['strokeDashoffset'],
      syntax: J.LENGTH_PERCENTAGE
    },
    { n: 'offsetPath', syntax: J.DEFINED_PATH },
    { n: 'offsetDistance', int: !0, syntax: J.OFFSET_DISTANCE },
    { n: 'dx', int: !0, l: !0, d: '0', syntax: J.LENGTH_PERCENTAGE },
    { n: 'dy', int: !0, l: !0, d: '0', syntax: J.LENGTH_PERCENTAGE },
    { n: 'zIndex', ind: !0, int: !0, d: '0', k: ['auto'], syntax: J.Z_INDEX },
    { n: 'visibility', k: ['visible', 'hidden'], ind: !0, inh: !0, int: !0, d: 'visible' },
    {
      n: 'pointerEvents',
      inh: !0,
      k: [
        'none',
        'auto',
        'stroke',
        'fill',
        'painted',
        'visible',
        'visiblestroke',
        'visiblefill',
        'visiblepainted',
        'all'
      ],
      d: 'auto'
    },
    { n: 'filter', ind: !0, l: !0, k: ['none'], d: 'none', syntax: J.FILTER },
    { n: 'clipPath', syntax: J.DEFINED_PATH },
    { n: 'textPath', syntax: J.DEFINED_PATH },
    { n: 'textPathSide', k: ['left', 'right'], d: 'left' },
    { n: 'textPathStartOffset', l: !0, d: '0', syntax: J.LENGTH_PERCENTAGE },
    { n: 'transform', p: 100, int: !0, k: ['none'], d: 'none', syntax: J.TRANSFORM },
    {
      n: 'transformOrigin',
      p: 100,
      d: function (t) {
        return t === G.CIRCLE || t === G.ELLIPSE
          ? 'center'
          : t === G.TEXT
          ? 'text-anchor'
          : 'left top'
      },
      l: !0,
      syntax: J.TRANSFORM_ORIGIN
    },
    {
      n: 'anchor',
      p: 99,
      d: function (t) {
        return t === G.CIRCLE || t === G.ELLIPSE ? '0.5 0.5' : '0 0'
      },
      l: !0,
      syntax: J.LENGTH_PERCENTAGE_12
    },
    { n: 'cx', int: !0, d: '0', syntax: J.COORDINATE },
    { n: 'cy', int: !0, d: '0', syntax: J.COORDINATE },
    { n: 'cz', int: !0, d: '0', syntax: J.COORDINATE },
    { n: 'r', int: !0, l: !0, d: '0', syntax: J.LENGTH_PERCENTAGE },
    { n: 'rx', int: !0, l: !0, d: '0', syntax: J.LENGTH_PERCENTAGE },
    { n: 'ry', int: !0, l: !0, d: '0', syntax: J.LENGTH_PERCENTAGE },
    { n: 'x', int: !0, d: '0', syntax: J.COORDINATE },
    { n: 'y', int: !0, d: '0', syntax: J.COORDINATE },
    { n: 'z', int: !0, d: '0', syntax: J.COORDINATE },
    {
      n: 'width',
      int: !0,
      l: !0,
      k: ['auto', 'fit-content', 'min-content', 'max-content'],
      d: '0',
      syntax: J.LENGTH_PERCENTAGE
    },
    {
      n: 'height',
      int: !0,
      l: !0,
      k: ['auto', 'fit-content', 'min-content', 'max-content'],
      d: '0',
      syntax: J.LENGTH_PERCENTAGE
    },
    { n: 'radius', int: !0, l: !0, d: '0', syntax: J.LENGTH_PERCENTAGE_14 },
    { n: 'x1', int: !0, l: !0, syntax: J.COORDINATE },
    { n: 'y1', int: !0, l: !0, syntax: J.COORDINATE },
    { n: 'z1', int: !0, l: !0, syntax: J.COORDINATE },
    { n: 'x2', int: !0, l: !0, syntax: J.COORDINATE },
    { n: 'y2', int: !0, l: !0, syntax: J.COORDINATE },
    { n: 'z2', int: !0, l: !0, syntax: J.COORDINATE },
    { n: 'path', int: !0, l: !0, d: '', a: ['d'], syntax: J.PATH, p: 50 },
    { n: 'points', int: !0, l: !0, syntax: J.LIST_OF_POINTS, p: 50 },
    { n: 'text', l: !0, d: '', syntax: J.TEXT, p: 50 },
    {
      n: 'textTransform',
      l: !0,
      inh: !0,
      k: ['capitalize', 'uppercase', 'lowercase', 'none'],
      d: 'none',
      syntax: J.TEXT_TRANSFORM,
      p: 51
    },
    { n: 'font', l: !0 },
    { n: 'fontSize', int: !0, inh: !0, d: '16px', l: !0, syntax: J.LENGTH_PERCENTAGE },
    { n: 'fontFamily', l: !0, inh: !0, d: 'sans-serif' },
    { n: 'fontStyle', l: !0, inh: !0, k: ['normal', 'italic', 'oblique'], d: 'normal' },
    { n: 'fontWeight', l: !0, inh: !0, k: ['normal', 'bold', 'bolder', 'lighter'], d: 'normal' },
    { n: 'fontVariant', l: !0, inh: !0, k: ['normal', 'small-caps'], d: 'normal' },
    { n: 'lineHeight', l: !0, syntax: J.LENGTH, int: !0, d: '0' },
    { n: 'letterSpacing', l: !0, syntax: J.LENGTH, int: !0, d: '0' },
    {
      n: 'miterLimit',
      l: !0,
      syntax: J.NUMBER,
      d: function (t) {
        return t === G.PATH || t === G.POLYGON || t === G.POLYLINE ? '4' : '10'
      }
    },
    { n: 'wordWrap', l: !0 },
    { n: 'wordWrapWidth', l: !0 },
    { n: 'maxLines', l: !0 },
    { n: 'textOverflow', l: !0, d: 'clip' },
    { n: 'leading', l: !0 },
    {
      n: 'textBaseline',
      l: !0,
      inh: !0,
      k: ['top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom'],
      d: 'alphabetic'
    },
    {
      n: 'textAlign',
      l: !0,
      inh: !0,
      k: ['start', 'center', 'middle', 'end', 'left', 'right'],
      d: 'start'
    },
    { n: 'markerStart', syntax: J.MARKER },
    { n: 'markerEnd', syntax: J.MARKER },
    { n: 'markerMid', syntax: J.MARKER },
    { n: 'markerStartOffset', syntax: J.LENGTH, l: !0, int: !0, d: '0' },
    { n: 'markerEndOffset', syntax: J.LENGTH, l: !0, int: !0, d: '0' }
  ],
  hg = xp
    .filter(function (t) {
      return !!t.l
    })
    .map(function (t) {
      return t.n
    }),
  Lr = {},
  aa = new WeakMap(),
  bN = function (t, e) {
    var n = aa.get(t)
    return !n || n.length === 0 ? !0 : n.includes(e)
  },
  xN = (function () {
    function t(e) {
      var n = this
      ;(this.runtime = e),
        xp.forEach(function (r) {
          n.registerMetadata(r)
        })
    }
    return (
      (t.prototype.registerMetadata = function (e) {
        q([e.n], N(e.a || []), !1).forEach(function (n) {
          Lr[n] = e
        })
      }),
      (t.prototype.unregisterMetadata = function (e) {
        delete Lr[e]
      }),
      (t.prototype.getPropertySyntax = function (e) {
        return this.runtime.CSSPropertySyntaxFactory[e]
      }),
      (t.prototype.processProperties = function (e, n, r) {
        var i = this
        if (
          (r === void 0 &&
            (r = {
              skipUpdateAttribute: !1,
              skipParse: !1,
              forceUpdateGeometry: !1,
              usedAttributes: []
            }),
          !this.runtime.enableCSSParsing)
        ) {
          Object.assign(e.attributes, n)
          var a = Object.keys(n),
            o = e.parsedStyle.clipPath,
            s = e.parsedStyle.offsetPath
          e.parsedStyle = Object.assign(e.parsedStyle, n)
          var c = !!r.forceUpdateGeometry
          if (!c) {
            for (var l = 0; l < hg.length; l++)
              if (hg[l] in n) {
                c = !0
                break
              }
          }
          n.fill && (e.parsedStyle.fill = Or(n.fill)),
            n.stroke && (e.parsedStyle.stroke = Or(n.stroke)),
            n.shadowColor && (e.parsedStyle.shadowColor = Or(n.shadowColor)),
            n.filter && (e.parsedStyle.filter = $2(n.filter)),
            nt(n.radius) || (e.parsedStyle.radius = af(n.radius, 4)),
            nt(n.lineDash) || (e.parsedStyle.lineDash = af(n.lineDash, 2)),
            n.points && (e.parsedStyle.points = W2(n.points, e)),
            n.path === '' && (e.parsedStyle.path = z({}, R2)),
            n.path &&
              ((e.parsedStyle.path = Ch(n.path)),
              (e.parsedStyle.defX = e.parsedStyle.path.rect.x),
              (e.parsedStyle.defY = e.parsedStyle.path.rect.y)),
            n.textTransform &&
              this.runtime.CSSPropertySyntaxFactory['<text-transform>'].calculator(
                null,
                null,
                { value: n.textTransform },
                e,
                null
              ),
            n.clipPath &&
              this.runtime.CSSPropertySyntaxFactory['<defined-path>'].calculator(
                'clipPath',
                o,
                n.clipPath,
                e,
                this.runtime
              ),
            n.offsetPath &&
              this.runtime.CSSPropertySyntaxFactory['<defined-path>'].calculator(
                'offsetPath',
                s,
                n.offsetPath,
                e,
                this.runtime
              ),
            n.anchor && (e.parsedStyle.anchor = af(n.anchor, 2)),
            n.transform && (e.parsedStyle.transform = fl(n.transform)),
            n.transformOrigin && (e.parsedStyle.transformOrigin = Y2(n.transformOrigin)),
            n.markerStart &&
              (e.parsedStyle.markerStart = this.runtime.CSSPropertySyntaxFactory[
                '<marker>'
              ].calculator(null, n.markerStart, n.markerStart, null, null)),
            n.markerEnd &&
              (e.parsedStyle.markerEnd = this.runtime.CSSPropertySyntaxFactory[
                '<marker>'
              ].calculator(null, n.markerEnd, n.markerEnd, null, null)),
            n.markerMid &&
              (e.parsedStyle.markerMid = this.runtime.CSSPropertySyntaxFactory[
                '<marker>'
              ].calculator('', n.markerMid, n.markerMid, null, null)),
            (((e.nodeName === G.CIRCLE || e.nodeName === G.ELLIPSE) && (!nt(n.cx) || !nt(n.cy))) ||
              ((e.nodeName === G.RECT ||
                e.nodeName === G.IMAGE ||
                e.nodeName === G.GROUP ||
                e.nodeName === G.HTML ||
                e.nodeName === G.TEXT ||
                e.nodeName === G.MESH) &&
                (!nt(n.x) || !nt(n.y) || !nt(n.z))) ||
              (e.nodeName === G.LINE &&
                (!nt(n.x1) || !nt(n.y1) || !nt(n.z1) || !nt(n.x2) || !nt(n.y2) || !nt(n.z2)))) &&
              this.runtime.CSSPropertySyntaxFactory['<coordinate>'].postProcessor(e, a),
            nt(n.zIndex) || this.runtime.CSSPropertySyntaxFactory['<z-index>'].postProcessor(e, a),
            n.path && this.runtime.CSSPropertySyntaxFactory['<path>'].postProcessor(e, a),
            n.points &&
              this.runtime.CSSPropertySyntaxFactory['<list-of-points>'].postProcessor(e, a),
            nt(n.offsetDistance) ||
              this.runtime.CSSPropertySyntaxFactory['<offset-distance>'].postProcessor(e, a),
            n.transform && this.runtime.CSSPropertySyntaxFactory['<transform>'].postProcessor(e, a),
            c && this.updateGeometry(e)
          return
        }
        var u = r.skipUpdateAttribute,
          f = r.skipParse,
          h = r.forceUpdateGeometry,
          d = r.usedAttributes,
          p = h,
          v = Object.keys(n)
        v.forEach(function (g) {
          var y
          u || (e.attributes[g] = n[g]),
            !p && !((y = Lr[g]) === null || y === void 0) && y.l && (p = !0)
        }),
          f ||
            v.forEach(function (g) {
              e.computedStyle[g] = i.parseProperty(g, e.attributes[g], e)
            }),
          d != null && d.length && (v = Array.from(new Set(v.concat(d)))),
          v.forEach(function (g) {
            g in e.computedStyle && (e.parsedStyle[g] = i.computeProperty(g, e.computedStyle[g], e))
          }),
          p && this.updateGeometry(e),
          v.forEach(function (g) {
            g in e.parsedStyle && i.postProcessProperty(g, e, v)
          }),
          this.runtime.enableCSSParsing &&
            e.children.length &&
            v.forEach(function (g) {
              g in e.parsedStyle &&
                i.isPropertyInheritable(g) &&
                e.children.forEach(function (y) {
                  y.internalSetAttribute(g, null, { skipUpdateAttribute: !0, skipParse: !0 })
                })
            })
      }),
      (t.prototype.parseProperty = function (e, n, r) {
        var i = Lr[e],
          a = n
        if (
          ((n === '' || nt(n)) && (n = 'unset'),
          n === 'unset' || n === 'initial' || n === 'inherit')
        )
          a = Eh(n)
        else if (i) {
          var o = i.k,
            s = i.syntax,
            c = s && this.getPropertySyntax(s)
          o && o.indexOf(n) > -1 ? (a = Eh(n)) : c && c.parser && (a = c.parser(n, r))
        }
        return a
      }),
      (t.prototype.computeProperty = function (e, n, r) {
        var i = Lr[e],
          a = r.id === 'g-root',
          o = n
        if (i) {
          var s = i.syntax,
            c = i.inh,
            l = i.d
          if (n instanceof en) {
            var u = n.value
            if ((u === 'unset' && (c && !a ? (u = 'inherit') : (u = 'initial')), u === 'initial'))
              nt(l) || (n = this.parseProperty(e, ha(l) ? l(r.nodeName) : l, r))
            else if (u === 'inherit') {
              var f = this.tryToResolveProperty(r, e, { inherited: !0 })
              if (nt(f)) {
                this.addUnresolveProperty(r, e)
                return
              } else return f
            }
          }
          var h = s && this.getPropertySyntax(s)
          if (h && h.calculator) {
            var d = r.parsedStyle[e]
            o = h.calculator(e, d, n, r, this.runtime)
          } else n instanceof en ? (o = n.value) : (o = n)
        }
        return o
      }),
      (t.prototype.postProcessProperty = function (e, n, r) {
        var i = Lr[e]
        if (i && i.syntax) {
          var a = i.syntax && this.getPropertySyntax(i.syntax),
            o = a
          o && o.postProcessor && o.postProcessor(n, r)
        }
      }),
      (t.prototype.addUnresolveProperty = function (e, n) {
        var r = aa.get(e)
        r || (aa.set(e, []), (r = aa.get(e))), r.indexOf(n) === -1 && r.push(n)
      }),
      (t.prototype.tryToResolveProperty = function (e, n, r) {
        r === void 0 && (r = {})
        var i = r.inherited
        if (i && e.parentElement && bN(e.parentElement, n)) {
          var a = e.parentElement.parsedStyle[n]
          return a === 'unset' || a === 'initial' || a === 'inherit' ? void 0 : a
        }
      }),
      (t.prototype.recalc = function (e) {
        var n = aa.get(e)
        if (n && n.length) {
          var r = {}
          n.forEach(function (i) {
            r[i] = e.attributes[i]
          }),
            this.processProperties(e, r),
            aa.delete(e)
        }
      }),
      (t.prototype.updateGeometry = function (e) {
        var n = e.nodeName,
          r = this.runtime.geometryUpdaterFactory[n]
        if (r) {
          var i = e.geometry
          i.contentBounds || (i.contentBounds = new me()),
            i.renderBounds || (i.renderBounds = new me())
          var a = e.parsedStyle,
            o = r.update(a, e),
            s = o.width,
            c = o.height,
            l = o.depth,
            u = l === void 0 ? 0 : l,
            f = o.offsetX,
            h = f === void 0 ? 0 : f,
            d = o.offsetY,
            p = d === void 0 ? 0 : d,
            v = o.offsetZ,
            g = v === void 0 ? 0 : v,
            y = [Math.abs(s) / 2, Math.abs(c) / 2, u / 2],
            m = a,
            b = m.stroke,
            x = m.lineWidth,
            w = m.increasedLineWidthForHitTesting,
            O = m.shadowType,
            S = m.shadowColor,
            _ = m.filter,
            M = _ === void 0 ? [] : _,
            E = m.transformOrigin,
            T = a.anchor
          n === G.TEXT ? delete a.anchor : n === G.MESH && (a.anchor[2] = 0.5)
          var C = [
            ((1 - ((T && T[0]) || 0) * 2) * s) / 2 + h,
            ((1 - ((T && T[1]) || 0) * 2) * c) / 2 + p,
            (1 - ((T && T[2]) || 0) * 2) * y[2] + g
          ]
          i.contentBounds.update(C, y)
          var A = n === G.POLYLINE || n === G.POLYGON || n === G.PATH ? Math.SQRT2 : 0.5,
            P = b && !b.isNone
          if (P) {
            var k = ((x || 0) + (w || 0)) * A
            ;(y[0] += k), (y[1] += k)
          }
          if ((i.renderBounds.update(C, y), S && O && O !== 'inner')) {
            var L = i.renderBounds,
              R = L.min,
              j = L.max,
              I = a,
              D = I.shadowBlur,
              $ = I.shadowOffsetX,
              B = I.shadowOffsetY,
              F = D || 0,
              W = $ || 0,
              U = B || 0,
              K = R[0] - F + W,
              V = j[0] + F + W,
              H = R[1] - F + U,
              Q = j[1] + F + U
            ;(R[0] = Math.min(R[0], K)),
              (j[0] = Math.max(j[0], V)),
              (R[1] = Math.min(R[1], H)),
              (j[1] = Math.max(j[1], Q)),
              i.renderBounds.setMinMax(R, j)
          }
          M.forEach(function (ht) {
            var Ot = ht.name,
              Mt = ht.params
            if (Ot === 'blur') {
              var Yt = Mt[0].value
              i.renderBounds.update(
                i.renderBounds.center,
                Bc(i.renderBounds.halfExtents, i.renderBounds.halfExtents, [Yt, Yt, 0])
              )
            } else if (Ot === 'drop-shadow') {
              var le = Mt[0].value,
                Ve = Mt[1].value,
                lr = Mt[2].value,
                pi = i.renderBounds,
                Fe = pi.min,
                xn = pi.max,
                Pt = Fe[0] - lr + le,
                Et = xn[0] + lr + le,
                Ht = Fe[1] - lr + Ve,
                At = xn[1] + lr + Ve
              ;(Fe[0] = Math.min(Fe[0], Pt)),
                (xn[0] = Math.max(xn[0], Et)),
                (Fe[1] = Math.min(Fe[1], Ht)),
                (xn[1] = Math.max(xn[1], At)),
                i.renderBounds.setMinMax(Fe, xn)
            }
          }),
            (T = a.anchor)
          var tt = s < 0,
            it = c < 0,
            ut = (tt ? -1 : 1) * (E ? ln(E[0], 0, e) : 0),
            st = (it ? -1 : 1) * (E ? ln(E[1], 1, e) : 0)
          ;(ut = ut - (tt ? -1 : 1) * ((T && T[0]) || 0) * i.contentBounds.halfExtents[0] * 2),
            (st = st - (it ? -1 : 1) * ((T && T[1]) || 0) * i.contentBounds.halfExtents[1] * 2),
            e.setOrigin(ut, st),
            this.runtime.sceneGraphService.dirtifyToRoot(e)
        }
      }),
      (t.prototype.isPropertyInheritable = function (e) {
        var n = Lr[e]
        return n ? n.inh : !1
      }),
      t
    )
  })(),
  wN = (function () {
    function t() {
      ;(this.parser = j2), (this.parserWithCSSDisabled = null), (this.mixer = mp)
    }
    return (
      (t.prototype.calculator = function (e, n, r, i) {
        return un(r)
      }),
      t
    )
  })(),
  ON = (function () {
    function t() {}
    return (
      (t.prototype.calculator = function (e, n, r, i, a) {
        return (
          r instanceof en && (r = null),
          a.sceneGraphService.updateDisplayObjectDependency(e, n, r, i),
          e === 'clipPath' &&
            i.forEach(function (o) {
              o.childNodes.length === 0 && a.sceneGraphService.dirtifyToRoot(o)
            }),
          r
        )
      }),
      t
    )
  })(),
  SN = (function () {
    function t() {
      ;(this.parser = Or), (this.parserWithCSSDisabled = Or), (this.mixer = VL)
    }
    return (
      (t.prototype.calculator = function (e, n, r, i) {
        return r instanceof en ? (r.value === 'none' ? Th : N2) : r
      }),
      t
    )
  })(),
  _N = (function () {
    function t() {
      this.parser = $2
    }
    return (
      (t.prototype.calculator = function (e, n, r) {
        return r instanceof en ? [] : r
      }),
      t
    )
  })()
function dg(t) {
  var e = t.parsedStyle.fontSize
  return nt(e) ? null : e
}
var wp = (function () {
    function t() {
      ;(this.parser = Ra), (this.parserWithCSSDisabled = null), (this.mixer = mp)
    }
    return (
      (t.prototype.calculator = function (e, n, r, i, a) {
        var o
        if (ve(r)) return r
        if (jt.isRelativeUnit(r.unit)) {
          var s = a.styleValueRegistry
          if (r.unit === Z.kPercentage) return 0
          if (r.unit === Z.kEms) {
            if (i.parentNode) {
              var c = dg(i.parentNode)
              if (c) return (c *= r.value), c
              s.addUnresolveProperty(i, e)
            } else s.addUnresolveProperty(i, e)
            return 0
          } else if (r.unit === Z.kRems) {
            if (
              !((o = i == null ? void 0 : i.ownerDocument) === null || o === void 0) &&
              o.documentElement
            ) {
              var c = dg(i.ownerDocument.documentElement)
              if (c) return (c *= r.value), c
              s.addUnresolveProperty(i, e)
            } else s.addUnresolveProperty(i, e)
            return 0
          }
        } else return r.value
      }),
      t
    )
  })(),
  MN = (function () {
    function t() {
      this.mixer = F2
    }
    return (
      (t.prototype.parser = function (e) {
        var n = D2(ve(e) ? [e] : e),
          r
        return n.length === 1 ? (r = [n[0], n[0]]) : (r = [n[0], n[1]]), r
      }),
      (t.prototype.calculator = function (e, n, r) {
        return r.map(function (i) {
          return i.value
        })
      }),
      t
    )
  })(),
  EN = (function () {
    function t() {
      this.mixer = F2
    }
    return (
      (t.prototype.parser = function (e) {
        var n = D2(ve(e) ? [e] : e),
          r
        return (
          n.length === 1
            ? (r = [n[0], n[0], n[0], n[0]])
            : n.length === 2
            ? (r = [n[0], n[1], n[0], n[1]])
            : n.length === 3
            ? (r = [n[0], n[1], n[2], n[1]])
            : (r = [n[0], n[1], n[2], n[3]]),
          r
        )
      }),
      (t.prototype.calculator = function (e, n, r) {
        return r.map(function (i) {
          return i.value
        })
      }),
      t
    )
  })(),
  ho = Nt()
function Op(t, e) {
  var n = e.parsedStyle.defX || 0,
    r = e.parsedStyle.defY || 0
  return (
    e.resetLocalTransform(),
    e.setLocalPosition(n, r),
    t.forEach(function (i) {
      var a = i.t,
        o = i.d
      if (a === 'scale') {
        var s = (o == null
          ? void 0
          : o.map(function (m) {
              return m.value
            })) || [1, 1]
        e.scaleLocal(s[0], s[1], 1)
      } else if (a === 'scalex') {
        var s = (o == null
          ? void 0
          : o.map(function (b) {
              return b.value
            })) || [1]
        e.scaleLocal(s[0], 1, 1)
      } else if (a === 'scaley') {
        var s = (o == null
          ? void 0
          : o.map(function (b) {
              return b.value
            })) || [1]
        e.scaleLocal(1, s[0], 1)
      } else if (a === 'scalez') {
        var s = (o == null
          ? void 0
          : o.map(function (b) {
              return b.value
            })) || [1]
        e.scaleLocal(1, 1, s[0])
      } else if (a === 'scale3d') {
        var s = (o == null
          ? void 0
          : o.map(function (b) {
              return b.value
            })) || [1, 1, 1]
        e.scaleLocal(s[0], s[1], s[2])
      } else if (a === 'translate') {
        var c = o || [Me, Me]
        e.translateLocal(c[0].value, c[1].value, 0)
      } else if (a === 'translatex') {
        var c = o || [Me]
        e.translateLocal(c[0].value, 0, 0)
      } else if (a === 'translatey') {
        var c = o || [Me]
        e.translateLocal(0, c[0].value, 0)
      } else if (a === 'translatez') {
        var c = o || [Me]
        e.translateLocal(0, 0, c[0].value)
      } else if (a === 'translate3d') {
        var c = o || [Me, Me, Me]
        e.translateLocal(c[0].value, c[1].value, c[2].value)
      } else if (a === 'rotate') {
        var l = o || [mr]
        e.rotateLocal(0, 0, un(l[0]))
      } else if (a === 'rotatex') {
        var l = o || [mr]
        e.rotateLocal(un(l[0]), 0, 0)
      } else if (a === 'rotatey') {
        var l = o || [mr]
        e.rotateLocal(0, un(l[0]), 0)
      } else if (a === 'rotatez') {
        var l = o || [mr]
        e.rotateLocal(0, 0, un(l[0]))
      } else if (a !== 'rotate3d')
        if (a === 'skew') {
          var u = (o == null
            ? void 0
            : o.map(function (m) {
                return m.value
              })) || [0, 0]
          e.setLocalSkew(Jt(u[0]), Jt(u[1]))
        } else if (a === 'skewx') {
          var u = (o == null
            ? void 0
            : o.map(function (b) {
                return b.value
              })) || [0]
          e.setLocalSkew(Jt(u[0]), e.getLocalSkew()[1])
        } else if (a === 'skewy') {
          var u = (o == null
            ? void 0
            : o.map(function (b) {
                return b.value
              })) || [0]
          e.setLocalSkew(e.getLocalSkew()[0], Jt(u[0]))
        } else if (a === 'matrix') {
          var f = N(
              o.map(function (m) {
                return m.value
              }),
              6
            ),
            h = f[0],
            d = f[1],
            p = f[2],
            v = f[3],
            g = f[4],
            y = f[5]
          e.setLocalTransform(Qf(ho, h, d, 0, 0, p, v, 0, 0, 0, 0, 1, 0, g + n, y + r, 0, 1))
        } else
          a === 'matrix3d' &&
            (Qf.apply(
              mA,
              q(
                [ho],
                N(
                  o.map(function (m) {
                    return m.value
                  })
                ),
                !1
              )
            ),
            (ho[12] += n),
            (ho[13] += r),
            e.setLocalTransform(ho))
    }),
    e.getLocalTransform()
  )
}
var TN = (function (t) {
    rt(e, t)
    function e() {
      return (t !== null && t.apply(this, arguments)) || this
    }
    return (
      (e.prototype.postProcessor = function (n, r) {
        var i, a, o
        switch (n.nodeName) {
          case G.CIRCLE:
          case G.ELLIPSE:
            var s = n.parsedStyle,
              c = s.cx,
              l = s.cy,
              u = s.cz
            nt(c) || (i = c), nt(l) || (a = l), nt(u) || (o = u)
            break
          case G.LINE:
            var f = n.parsedStyle,
              h = f.x1,
              d = f.x2,
              p = f.y1,
              v = f.y2,
              g = Math.min(h, d),
              y = Math.min(p, v)
            ;(i = g), (a = y), (o = 0)
            break
          case G.RECT:
          case G.IMAGE:
          case G.GROUP:
          case G.HTML:
          case G.TEXT:
          case G.MESH:
            nt(n.parsedStyle.x) || (i = n.parsedStyle.x),
              nt(n.parsedStyle.y) || (a = n.parsedStyle.y),
              nt(n.parsedStyle.z) || (o = n.parsedStyle.z)
            break
        }
        n.nodeName !== G.PATH &&
          n.nodeName !== G.POLYLINE &&
          n.nodeName !== G.POLYGON &&
          ((n.parsedStyle.defX = i || 0), (n.parsedStyle.defY = a || 0))
        var m = !nt(i) || !nt(a) || !nt(o)
        if (m && r.indexOf('transform') === -1) {
          var b = n.parsedStyle.transform
          if (b && b.length) Op(b, n)
          else {
            var x = N(n.getLocalPosition(), 3),
              w = x[0],
              O = x[1],
              S = x[2]
            n.setLocalPosition(nt(i) ? w : i, nt(a) ? O : a, nt(o) ? S : o)
          }
        }
      }),
      e
    )
  })(wp),
  PN = (function () {
    function t() {}
    return (
      (t.prototype.calculator = function (e, n, r, i) {
        r instanceof en && (r = null)
        var a = r == null ? void 0 : r.cloneNode(!0)
        return a && (a.style.isMarker = !0), a
      }),
      t
    )
  })(),
  AN = (function () {
    function t() {
      ;(this.mixer = mp), (this.parser = Di), (this.parserWithCSSDisabled = null)
    }
    return (
      (t.prototype.calculator = function (e, n, r) {
        return r.value
      }),
      t
    )
  })(),
  kN = (function () {
    function t() {
      ;(this.parser = Di), (this.parserWithCSSDisabled = null), (this.mixer = bp(0, 1))
    }
    return (
      (t.prototype.calculator = function (e, n, r) {
        return r.value
      }),
      (t.prototype.postProcessor = function (e) {
        var n = e.parsedStyle,
          r = n.offsetPath,
          i = n.offsetDistance
        if (r) {
          var a = r.nodeName
          if (a === G.LINE || a === G.PATH || a === G.POLYLINE) {
            var o = r.getPoint(i)
            o &&
              ((e.parsedStyle.defX = o.x), (e.parsedStyle.defY = o.y), e.setLocalPosition(o.x, o.y))
          }
        }
      }),
      t
    )
  })(),
  CN = (function () {
    function t() {
      ;(this.parser = Di), (this.parserWithCSSDisabled = null), (this.mixer = bp(0, 1))
    }
    return (
      (t.prototype.calculator = function (e, n, r) {
        return r.value
      }),
      t
    )
  })(),
  LN = (function () {
    function t() {
      ;(this.parser = Ch), (this.parserWithCSSDisabled = Ch), (this.mixer = cN)
    }
    return (
      (t.prototype.calculator = function (e, n, r) {
        return r instanceof en && r.value === 'unset'
          ? {
              absolutePath: [],
              hasArc: !1,
              segments: [],
              polygons: [],
              polylines: [],
              curve: null,
              totalLength: 0,
              rect: new ji(0, 0, 0, 0)
            }
          : r
      }),
      (t.prototype.postProcessor = function (e, n) {
        if (
          ((e.parsedStyle.defX = e.parsedStyle.path.rect.x),
          (e.parsedStyle.defY = e.parsedStyle.path.rect.y),
          e.nodeName === G.PATH && n.indexOf('transform') === -1)
        ) {
          var r = e.parsedStyle,
            i = r.defX,
            a = i === void 0 ? 0 : i,
            o = r.defY,
            s = o === void 0 ? 0 : o
          e.setLocalPosition(a, s)
        }
      }),
      t
    )
  })(),
  NN = (function () {
    function t() {
      ;(this.parser = W2), (this.mixer = lN)
    }
    return (
      (t.prototype.postProcessor = function (e, n) {
        if (
          (e.nodeName === G.POLYGON || e.nodeName === G.POLYLINE) &&
          n.indexOf('transform') === -1
        ) {
          var r = e.parsedStyle,
            i = r.defX,
            a = r.defY
          e.setLocalPosition(i, a)
        }
      }),
      t
    )
  })(),
  RN = (function (t) {
    rt(e, t)
    function e() {
      var n = (t !== null && t.apply(this, arguments)) || this
      return (n.mixer = bp(0, 1 / 0)), n
    }
    return e
  })(wp),
  IN = (function () {
    function t() {}
    return (
      (t.prototype.calculator = function (e, n, r, i) {
        return r instanceof en ? (r.value === 'unset' ? '' : r.value) : ''.concat(r)
      }),
      (t.prototype.postProcessor = function (e) {
        e.nodeValue = ''.concat(e.parsedStyle.text) || ''
      }),
      t
    )
  })(),
  jN = (function () {
    function t() {}
    return (
      (t.prototype.calculator = function (e, n, r, i) {
        var a = i.getAttribute('text')
        if (a) {
          var o = a
          r.value === 'capitalize'
            ? (o = a.charAt(0).toUpperCase() + a.slice(1))
            : r.value === 'lowercase'
            ? (o = a.toLowerCase())
            : r.value === 'uppercase' && (o = a.toUpperCase()),
            (i.parsedStyle.text = o)
        }
        return r.value
      }),
      t
    )
  })(),
  lf = {},
  DN = 0
function $N(t, e) {
  if (t) {
    var n = typeof t == 'string' ? t : t.id || DN++
    lf[n] && lf[n].destroy(), (lf[n] = e)
  }
}
var Ls = typeof window < 'u' && typeof window.document < 'u'
function BN(t) {
  return !!t.getAttribute
}
function FN(t, e) {
  for (var n = 0, r = t.length; n < r; ) {
    var i = (n + r) >>> 1
    H2(t[i], e) < 0 ? (n = i + 1) : (r = i)
  }
  return n
}
function H2(t, e) {
  var n = Number(t.parsedStyle.zIndex),
    r = Number(e.parsedStyle.zIndex)
  if (n === r) {
    var i = t.parentNode
    if (i) {
      var a = i.childNodes || []
      return a.indexOf(t) - a.indexOf(e)
    }
  }
  return n - r
}
function V2(t) {
  var e,
    n = t
  do {
    var r = (e = n.parsedStyle) === null || e === void 0 ? void 0 : e.clipPath
    if (r) return n
    n = n.parentElement
  } while (n !== null)
  return null
}
var pg = 'px'
function zN(t, e, n) {
  Ls && t.style && ((t.style.width = e + pg), (t.style.height = n + pg))
}
function X2(t, e) {
  if (Ls) return document.defaultView.getComputedStyle(t, null).getPropertyValue(e)
}
function GN(t) {
  var e = X2(t, 'width')
  return e === 'auto' ? t.offsetWidth : parseFloat(e)
}
function WN(t) {
  var e = X2(t, 'height')
  return e === 'auto' ? t.offsetHeight : parseFloat(e)
}
var YN = 1,
  HN = {
    touchstart: 'pointerdown',
    touchend: 'pointerup',
    touchendoutside: 'pointerupoutside',
    touchmove: 'pointermove',
    touchcancel: 'pointercancel'
  },
  Nh = typeof performance == 'object' && performance.now ? performance : Date
function Vi(t, e, n) {
  var r = !1,
    i = !1,
    a = !!e && !e.isNone,
    o = !!n && !n.isNone
  return (
    t === 'visiblepainted' || t === 'painted' || t === 'auto'
      ? ((r = a), (i = o))
      : t === 'visiblefill' || t === 'fill'
      ? (r = !0)
      : t === 'visiblestroke' || t === 'stroke'
      ? (i = !0)
      : (t === 'visible' || t === 'all') && ((r = !0), (i = !0)),
    [r, i]
  )
}
var VN = 1,
  XN = function () {
    return VN++
  },
  ir =
    typeof self == 'object' && self.self == self
      ? self
      : typeof global == 'object' && global.global == global
      ? global
      : {},
  UN = Date.now(),
  qN = function () {
    return ir.performance && typeof ir.performance.now == 'function'
      ? ir.performance.now()
      : Date.now() - UN
  },
  bo = {},
  vg = Date.now(),
  KN = function (t) {
    if (typeof t != 'function') throw new TypeError(t + ' is not a function')
    var e = Date.now(),
      n = e - vg,
      r = n > 16 ? 0 : 16 - n,
      i = XN()
    return (
      (bo[i] = t),
      Object.keys(bo).length > 1 ||
        setTimeout(function () {
          vg = e
          var a = bo
          ;(bo = {}),
            Object.keys(a).forEach(function (o) {
              return a[o](qN())
            })
        }, r),
      i
    )
  },
  ZN = function (t) {
    delete bo[t]
  },
  QN = ['', 'webkit', 'moz', 'ms', 'o'],
  U2 = function (t) {
    return typeof t != 'string'
      ? KN
      : t === ''
      ? ir.requestAnimationFrame
      : ir[t + 'RequestAnimationFrame']
  },
  JN = function (t) {
    return typeof t != 'string'
      ? ZN
      : t === ''
      ? ir.cancelAnimationFrame
      : ir[t + 'CancelAnimationFrame'] || ir[t + 'CancelRequestAnimationFrame']
  },
  t4 = function (t, e) {
    for (var n = 0; t[n] !== void 0; ) {
      if (e(t[n])) return t[n]
      n = n + 1
    }
  },
  q2 = t4(QN, function (t) {
    return !!U2(t)
  }),
  K2 = U2(q2),
  Z2 = JN(q2)
ir.requestAnimationFrame = K2
ir.cancelAnimationFrame = Z2
var e4 = (function () {
    function t() {
      this.callbacks = []
    }
    return (
      (t.prototype.getCallbacksNum = function () {
        return this.callbacks.length
      }),
      (t.prototype.tapPromise = function (e, n) {
        this.callbacks.push(n)
      }),
      (t.prototype.promise = function () {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n]
        return Promise.all(
          this.callbacks.map(function (r) {
            return r.apply(void 0, q([], N(e), !1))
          })
        )
      }),
      t
    )
  })(),
  n4 = (function () {
    function t() {
      this.callbacks = []
    }
    return (
      (t.prototype.tapPromise = function (e, n) {
        this.callbacks.push(n)
      }),
      (t.prototype.promise = function () {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n]
        return Ea(this, void 0, void 0, function () {
          var r, i, a, o
          return Ta(this, function (s) {
            switch (s.label) {
              case 0:
                return this.callbacks.length
                  ? [4, (o = this.callbacks)[0].apply(o, q([], N(e), !1))]
                  : [3, 6]
              case 1:
                ;(r = s.sent()), (i = 0), (s.label = 2)
              case 2:
                return i < this.callbacks.length - 1 ? ((a = this.callbacks[i]), [4, a(r)]) : [3, 5]
              case 3:
                ;(r = s.sent()), (s.label = 4)
              case 4:
                return i++, [3, 2]
              case 5:
                return [2, r]
              case 6:
                return [2, null]
            }
          })
        })
      }),
      t
    )
  })(),
  ze = (function () {
    function t() {
      this.callbacks = []
    }
    return (
      (t.prototype.tap = function (e, n) {
        this.callbacks.push(n)
      }),
      (t.prototype.call = function () {
        var e = arguments
        this.callbacks.forEach(function (n) {
          n.apply(void 0, e)
        })
      }),
      t
    )
  })(),
  uf = (function () {
    function t() {
      this.callbacks = []
    }
    return (
      (t.prototype.tap = function (e, n) {
        this.callbacks.push(n)
      }),
      (t.prototype.call = function () {
        if (this.callbacks.length) {
          for (
            var e = arguments, n = this.callbacks[0].apply(void 0, e), r = 0;
            r < this.callbacks.length - 1;
            r++
          ) {
            var i = this.callbacks[r]
            n = i(n)
          }
          return n
        }
        return null
      }),
      t
    )
  })(),
  r4 = ['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy', 'system-ui'],
  i4 = /([\"\'])[^\'\"]+\1/
function a4(t) {
  for (
    var e = t.fontSize,
      n = t.fontFamily,
      r = t.fontStyle,
      i = t.fontVariant,
      a = t.fontWeight,
      o = (ve(e) && ''.concat(e, 'px')) || '16px',
      s = n.split(','),
      c = s.length - 1;
    c >= 0;
    c--
  ) {
    var l = s[c].trim()
    !i4.test(l) && r4.indexOf(l) < 0 && (l = '"'.concat(l, '"')), (s[c] = l)
  }
  return ''.concat(r, ' ').concat(i, ' ').concat(a, ' ').concat(o, ' ').concat(s.join(','))
}
var o4 = (function () {
    function t() {
      ;(this.parser = fl), (this.parserWithCSSDisabled = fl), (this.mixer = mN)
    }
    return (
      (t.prototype.calculator = function (e, n, r, i) {
        return r instanceof en ? [] : r
      }),
      (t.prototype.postProcessor = function (e) {
        var n = e.parsedStyle.transform
        Op(n, e)
      }),
      t
    )
  })(),
  s4 = (function () {
    function t() {
      this.parser = Y2
    }
    return t
  })(),
  c4 = (function () {
    function t() {
      this.parser = Di
    }
    return (
      (t.prototype.calculator = function (e, n, r, i) {
        return r.value
      }),
      (t.prototype.postProcessor = function (e) {
        if (e.parentNode) {
          var n = e.parentNode,
            r = n.renderable,
            i = n.sortable
          r && (r.dirty = !0), i && ((i.dirty = !0), (i.dirtyReason = Na.Z_INDEX_CHANGED))
        }
      }),
      t
    )
  })(),
  l4 = (function () {
    function t() {}
    return (
      (t.prototype.update = function (e, n) {
        var r = e.r,
          i = r * 2,
          a = r * 2
        return { width: i, height: a }
      }),
      t
    )
  })(),
  u4 = (function () {
    function t() {}
    return (
      (t.prototype.update = function (e, n) {
        var r = e.rx,
          i = e.ry,
          a = r * 2,
          o = i * 2
        return { width: a, height: o }
      }),
      t
    )
  })(),
  f4 = (function () {
    function t() {}
    return (
      (t.prototype.update = function (e) {
        var n = e.x1,
          r = e.y1,
          i = e.x2,
          a = e.y2,
          o = Math.min(n, i),
          s = Math.max(n, i),
          c = Math.min(r, a),
          l = Math.max(r, a),
          u = s - o,
          f = l - c
        return { width: u, height: f }
      }),
      t
    )
  })(),
  h4 = (function () {
    function t() {}
    return (
      (t.prototype.update = function (e) {
        var n = e.path,
          r = n.rect,
          i = r.width,
          a = r.height
        return { width: i, height: a }
      }),
      t
    )
  })(),
  d4 = (function () {
    function t() {}
    return (
      (t.prototype.update = function (e) {
        if (e.points && bn(e.points.points)) {
          var n = e.points.points,
            r = Math.min.apply(
              Math,
              q(
                [],
                N(
                  n.map(function (l) {
                    return l[0]
                  })
                ),
                !1
              )
            ),
            i = Math.max.apply(
              Math,
              q(
                [],
                N(
                  n.map(function (l) {
                    return l[0]
                  })
                ),
                !1
              )
            ),
            a = Math.min.apply(
              Math,
              q(
                [],
                N(
                  n.map(function (l) {
                    return l[1]
                  })
                ),
                !1
              )
            ),
            o = Math.max.apply(
              Math,
              q(
                [],
                N(
                  n.map(function (l) {
                    return l[1]
                  })
                ),
                !1
              )
            ),
            s = i - r,
            c = o - a
          return { width: s, height: c }
        }
        return { width: 0, height: 0 }
      }),
      t
    )
  })(),
  p4 = (function () {
    function t() {}
    return (
      (t.prototype.update = function (e, n) {
        var r = e.img,
          i = e.width,
          a = i === void 0 ? 0 : i,
          o = e.height,
          s = o === void 0 ? 0 : o,
          c = a,
          l = s
        return (
          r &&
            !ne(r) &&
            (c || ((c = r.width), (e.width = c)), l || ((l = r.height), (e.height = l))),
          { width: c, height: l }
        )
      }),
      t
    )
  })(),
  v4 = (function () {
    function t(e) {
      this.globalRuntime = e
    }
    return (
      (t.prototype.isReadyToMeasure = function (e, n) {
        var r = e.text,
          i = e.textAlign,
          a = e.textBaseline,
          o = e.fontSize,
          s = e.fontStyle,
          c = e.fontWeight,
          l = e.fontVariant,
          u = e.lineWidth
        return r && o && s && c && l && i && a && !nt(u)
      }),
      (t.prototype.update = function (e, n) {
        var r,
          i,
          a = e.text,
          o = e.textAlign,
          s = e.lineWidth,
          c = e.textBaseline,
          l = e.dx,
          u = e.dy
        if (!this.isReadyToMeasure(e, n))
          return (
            (e.metrics = {
              font: '',
              width: 0,
              height: 0,
              lines: [],
              lineWidths: [],
              lineHeight: 0,
              maxLineWidth: 0,
              fontProperties: { ascent: 0, descent: 0, fontSize: 0 },
              lineMetrics: []
            }),
            { width: 0, height: 0, x: 0, y: 0, offsetX: 0, offsetY: 0 }
          )
        var f = (
            ((i =
              (r = n == null ? void 0 : n.ownerDocument) === null || r === void 0
                ? void 0
                : r.defaultView) === null || i === void 0
              ? void 0
              : i.getConfig()) || {}
          ).offscreenCanvas,
          h = this.globalRuntime.textService.measureText(a, e, f)
        e.metrics = h
        var d = h.width,
          p = h.height,
          v = h.lineHeight,
          g = h.fontProperties,
          y = [d / 2, p / 2, 0],
          m = [0, 1],
          b = 0
        o === 'center' || o === 'middle'
          ? ((b = s / 2), (m = [0.5, 1]))
          : (o === 'right' || o === 'end') && ((b = s), (m = [1, 1]))
        var x = 0
        return (
          c === 'middle'
            ? (x = y[1])
            : c === 'top' || c === 'hanging'
            ? (x = y[1] * 2)
            : c === 'alphabetic'
            ? (x = this.globalRuntime.enableCSSParsing ? v - g.ascent : 0)
            : (c === 'bottom' || c === 'ideographic') && (x = 0),
          l && (b += l),
          u && (x += u),
          (e.anchor = [m[0], m[1], 0]),
          { width: y[0] * 2, height: y[1] * 2, offsetX: b, offsetY: x }
        )
      }),
      t
    )
  })()
function g4(t) {
  return !!t.type
}
var hu = (function () {
    function t(e) {
      ;(this.eventPhase = t.prototype.NONE),
        (this.bubbles = !0),
        (this.cancelBubble = !0),
        (this.cancelable = !1),
        (this.defaultPrevented = !1),
        (this.propagationStopped = !1),
        (this.propagationImmediatelyStopped = !1),
        (this.layer = new Ee()),
        (this.page = new Ee()),
        (this.canvas = new Ee()),
        (this.viewport = new Ee()),
        (this.composed = !1),
        (this.NONE = 0),
        (this.CAPTURING_PHASE = 1),
        (this.AT_TARGET = 2),
        (this.BUBBLING_PHASE = 3),
        (this.manager = e)
    }
    return (
      Object.defineProperty(t.prototype, 'name', {
        get: function () {
          return this.type
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'layerX', {
        get: function () {
          return this.layer.x
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'layerY', {
        get: function () {
          return this.layer.y
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'pageX', {
        get: function () {
          return this.page.x
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'pageY', {
        get: function () {
          return this.page.y
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'x', {
        get: function () {
          return this.canvas.x
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'y', {
        get: function () {
          return this.canvas.y
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'canvasX', {
        get: function () {
          return this.canvas.x
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'canvasY', {
        get: function () {
          return this.canvas.y
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'viewportX', {
        get: function () {
          return this.viewport.x
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'viewportY', {
        get: function () {
          return this.viewport.y
        },
        enumerable: !1,
        configurable: !0
      }),
      (t.prototype.composedPath = function () {
        return (
          this.manager &&
            (!this.path || this.path[0] !== this.target) &&
            (this.path = this.target ? this.manager.propagationPath(this.target) : []),
          this.path
        )
      }),
      Object.defineProperty(t.prototype, 'propagationPath', {
        get: function () {
          return this.composedPath()
        },
        enumerable: !1,
        configurable: !0
      }),
      (t.prototype.preventDefault = function () {
        this.nativeEvent instanceof Event &&
          this.nativeEvent.cancelable &&
          this.nativeEvent.preventDefault(),
          (this.defaultPrevented = !0)
      }),
      (t.prototype.stopImmediatePropagation = function () {
        this.propagationImmediatelyStopped = !0
      }),
      (t.prototype.stopPropagation = function () {
        this.propagationStopped = !0
      }),
      (t.prototype.initEvent = function () {}),
      (t.prototype.initUIEvent = function () {}),
      (t.prototype.clone = function () {
        throw new Error(It)
      }),
      t
    )
  })(),
  Q2 = (function (t) {
    rt(e, t)
    function e() {
      var n = (t !== null && t.apply(this, arguments)) || this
      return (
        (n.client = new Ee()),
        (n.movement = new Ee()),
        (n.offset = new Ee()),
        (n.global = new Ee()),
        (n.screen = new Ee()),
        n
      )
    }
    return (
      Object.defineProperty(e.prototype, 'clientX', {
        get: function () {
          return this.client.x
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'clientY', {
        get: function () {
          return this.client.y
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'movementX', {
        get: function () {
          return this.movement.x
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'movementY', {
        get: function () {
          return this.movement.y
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'offsetX', {
        get: function () {
          return this.offset.x
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'offsetY', {
        get: function () {
          return this.offset.y
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'globalX', {
        get: function () {
          return this.global.x
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'globalY', {
        get: function () {
          return this.global.y
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'screenX', {
        get: function () {
          return this.screen.x
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'screenY', {
        get: function () {
          return this.screen.y
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.getModifierState = function (n) {
        return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(n)
      }),
      (e.prototype.initMouseEvent = function () {
        throw new Error(It)
      }),
      e
    )
  })(hu),
  Rh = (function (t) {
    rt(e, t)
    function e() {
      var n = (t !== null && t.apply(this, arguments)) || this
      return (n.width = 0), (n.height = 0), (n.isPrimary = !1), n
    }
    return (
      (e.prototype.getCoalescedEvents = function () {
        return this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove'
          ? [this]
          : []
      }),
      (e.prototype.getPredictedEvents = function () {
        throw new Error('getPredictedEvents is not supported!')
      }),
      (e.prototype.clone = function () {
        return this.manager.clonePointerEvent(this)
      }),
      e
    )
  })(Q2),
  Ih = (function (t) {
    rt(e, t)
    function e() {
      return (t !== null && t.apply(this, arguments)) || this
    }
    return (
      (e.prototype.clone = function () {
        return this.manager.cloneWheelEvent(this)
      }),
      e
    )
  })(Q2),
  Bt = (function (t) {
    rt(e, t)
    function e(n, r) {
      var i = t.call(this, null) || this
      return (i.type = n), (i.detail = r), Object.assign(i, r), i
    }
    return e
  })(hu),
  gg = ':',
  J2 = (function () {
    function t() {
      this.emitter = new vp()
    }
    return (
      (t.prototype.on = function (e, n, r) {
        return this.addEventListener(e, n, r), this
      }),
      (t.prototype.addEventListener = function (e, n, r) {
        var i = (fv(r) && r) || (Ei(r) && r.capture),
          a = Ei(r) && r.once,
          o = ha(n) ? void 0 : n,
          s = !1,
          c = ''
        if (e.indexOf(gg) > -1) {
          var l = N(e.split(gg), 2),
            u = l[0],
            f = l[1]
          ;(e = f), (c = u), (s = !0)
        }
        if (((e = i ? ''.concat(e, 'capture') : e), (n = ha(n) ? n : n.handleEvent), s)) {
          var h = n
          n = function () {
            for (var d, p = [], v = 0; v < arguments.length; v++) p[v] = arguments[v]
            ;((d = p[0].target) === null || d === void 0 ? void 0 : d.name) === c &&
              h.apply(void 0, q([], N(p), !1))
          }
        }
        return a ? this.emitter.once(e, n, o) : this.emitter.on(e, n, o), this
      }),
      (t.prototype.off = function (e, n, r) {
        return e ? this.removeEventListener(e, n, r) : this.removeAllEventListeners(), this
      }),
      (t.prototype.removeAllEventListeners = function () {
        this.emitter.removeAllListeners()
      }),
      (t.prototype.removeEventListener = function (e, n, r) {
        var i = (fv(r) && r) || (Ei(r) && r.capture),
          a = ha(n) ? void 0 : n
        return (
          (e = i ? ''.concat(e, 'capture') : e),
          (n = ha(n) ? n : n == null ? void 0 : n.handleEvent),
          this.emitter.off(e, n, a),
          this
        )
      }),
      (t.prototype.emit = function (e, n) {
        this.dispatchEvent(new Bt(e, n))
      }),
      (t.prototype.dispatchEvent = function (e, n) {
        var r, i
        if ((n === void 0 && (n = !1), !g4(e)))
          throw new Error(
            'DisplayObject cannot propagate events outside of the Federated Events API'
          )
        var a
        if (
          (this.document
            ? (a = this)
            : this.defaultView
            ? (a = this.defaultView)
            : (a = (r = this.ownerDocument) === null || r === void 0 ? void 0 : r.defaultView),
          a)
        ) {
          if (((e.manager = a.getEventService() || null), !e.manager)) return !1
          ;(e.defaultPrevented = !1),
            (e.path = []),
            n || (e.target = this),
            (i = e.manager) === null || i === void 0 || i.dispatchEvent(e, e.type, n)
        }
        return !e.defaultPrevented
      }),
      t
    )
  })(),
  Se = (function (t) {
    rt(e, t)
    function e() {
      var n = (t !== null && t.apply(this, arguments)) || this
      return (
        (n.shadow = !1),
        (n.ownerDocument = null),
        (n.isConnected = !1),
        (n.baseURI = ''),
        (n.childNodes = []),
        (n.nodeType = 0),
        (n.nodeName = ''),
        (n.nodeValue = null),
        (n.parentNode = null),
        n
      )
    }
    return (
      (e.isNode = function (n) {
        return !!n.childNodes
      }),
      Object.defineProperty(e.prototype, 'textContent', {
        get: function () {
          var n,
            r,
            i = ''
          this.nodeName === G.TEXT && (i += this.style.text)
          try {
            for (var a = hn(this.childNodes), o = a.next(); !o.done; o = a.next()) {
              var s = o.value
              s.nodeName === G.TEXT ? (i += s.nodeValue) : (i += s.textContent)
            }
          } catch (c) {
            n = { error: c }
          } finally {
            try {
              o && !o.done && (r = a.return) && r.call(a)
            } finally {
              if (n) throw n.error
            }
          }
          return i
        },
        set: function (n) {
          var r = this
          this.childNodes.slice().forEach(function (i) {
            r.removeChild(i)
          }),
            this.nodeName === G.TEXT && (this.style.text = ''.concat(n))
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.getRootNode = function (n) {
        return (
          n === void 0 && (n = {}),
          this.parentNode
            ? this.parentNode.getRootNode(n)
            : n.composed && this.host
            ? this.host.getRootNode(n)
            : this
        )
      }),
      (e.prototype.hasChildNodes = function () {
        return this.childNodes.length > 0
      }),
      (e.prototype.isDefaultNamespace = function (n) {
        throw new Error(It)
      }),
      (e.prototype.lookupNamespaceURI = function (n) {
        throw new Error(It)
      }),
      (e.prototype.lookupPrefix = function (n) {
        throw new Error(It)
      }),
      (e.prototype.normalize = function () {
        throw new Error(It)
      }),
      (e.prototype.isEqualNode = function (n) {
        return this === n
      }),
      (e.prototype.isSameNode = function (n) {
        return this.isEqualNode(n)
      }),
      Object.defineProperty(e.prototype, 'parent', {
        get: function () {
          return this.parentNode
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'parentElement', {
        get: function () {
          return null
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'nextSibling', {
        get: function () {
          return null
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'previousSibling', {
        get: function () {
          return null
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'firstChild', {
        get: function () {
          return this.childNodes.length > 0 ? this.childNodes[0] : null
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'lastChild', {
        get: function () {
          return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.compareDocumentPosition = function (n) {
        var r
        if (n === this) return 0
        for (
          var i = n, a = this, o = [i], s = [a];
          (r = i.parentNode) !== null && r !== void 0 ? r : a.parentNode;

        )
          (i = i.parentNode ? (o.push(i.parentNode), i.parentNode) : i),
            (a = a.parentNode ? (s.push(a.parentNode), a.parentNode) : a)
        if (i !== a)
          return (
            e.DOCUMENT_POSITION_DISCONNECTED |
            e.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |
            e.DOCUMENT_POSITION_PRECEDING
          )
        var c = o.length > s.length ? o : s,
          l = c === o ? s : o
        if (c[c.length - l.length] === l[0])
          return c === o
            ? e.DOCUMENT_POSITION_CONTAINED_BY | e.DOCUMENT_POSITION_FOLLOWING
            : e.DOCUMENT_POSITION_CONTAINS | e.DOCUMENT_POSITION_PRECEDING
        for (var u = c.length - l.length, f = l.length - 1; f >= 0; f--) {
          var h = l[f],
            d = c[u + f]
          if (d !== h) {
            var p = h.parentNode.childNodes
            return p.indexOf(h) < p.indexOf(d)
              ? l === o
                ? e.DOCUMENT_POSITION_PRECEDING
                : e.DOCUMENT_POSITION_FOLLOWING
              : c === o
              ? e.DOCUMENT_POSITION_PRECEDING
              : e.DOCUMENT_POSITION_FOLLOWING
          }
        }
        return e.DOCUMENT_POSITION_FOLLOWING
      }),
      (e.prototype.contain = function (n) {
        return this.contains(n)
      }),
      (e.prototype.contains = function (n) {
        for (var r = n; r && this !== r; ) r = r.parentNode
        return !!r
      }),
      (e.prototype.getAncestor = function (n) {
        for (var r = this; n > 0 && r; ) (r = r.parentNode), n--
        return r
      }),
      (e.prototype.forEach = function (n, r) {
        r === void 0 && (r = !1),
          n(this) ||
            (r ? this.childNodes.slice() : this.childNodes).forEach(function (i) {
              i.forEach(n)
            })
      }),
      (e.DOCUMENT_POSITION_DISCONNECTED = 1),
      (e.DOCUMENT_POSITION_PRECEDING = 2),
      (e.DOCUMENT_POSITION_FOLLOWING = 4),
      (e.DOCUMENT_POSITION_CONTAINS = 8),
      (e.DOCUMENT_POSITION_CONTAINED_BY = 16),
      (e.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32),
      e
    )
  })(J2),
  y4 = 2048,
  m4 = (function () {
    function t(e, n) {
      var r = this
      ;(this.globalRuntime = e),
        (this.context = n),
        (this.emitter = new vp()),
        (this.cursor = 'default'),
        (this.mappingTable = {}),
        (this.mappingState = { trackingData: {} }),
        (this.eventPool = new Map()),
        (this.tmpMatrix = Nt()),
        (this.tmpVec3 = yt()),
        (this.onPointerDown = function (i) {
          var a = r.createPointerEvent(i)
          if ((r.dispatchEvent(a, 'pointerdown'), a.pointerType === 'touch'))
            r.dispatchEvent(a, 'touchstart')
          else if (a.pointerType === 'mouse' || a.pointerType === 'pen') {
            var o = a.button === 2
            r.dispatchEvent(a, o ? 'rightdown' : 'mousedown')
          }
          var s = r.trackingData(i.pointerId)
          ;(s.pressTargetsByButton[i.button] = a.composedPath()), r.freeEvent(a)
        }),
        (this.onPointerUp = function (i) {
          var a,
            o = Nh.now(),
            s = r.createPointerEvent(
              i,
              void 0,
              void 0,
              r.context.config.alwaysTriggerPointerEventOnCanvas ? r.rootTarget : void 0
            )
          if ((r.dispatchEvent(s, 'pointerup'), s.pointerType === 'touch'))
            r.dispatchEvent(s, 'touchend')
          else if (s.pointerType === 'mouse' || s.pointerType === 'pen') {
            var c = s.button === 2
            r.dispatchEvent(s, c ? 'rightup' : 'mouseup')
          }
          var l = r.trackingData(i.pointerId),
            u = r.findMountedTarget(l.pressTargetsByButton[i.button]),
            f = u
          if (u && !s.composedPath().includes(u)) {
            for (var h = u; h && !s.composedPath().includes(h); ) {
              if (
                ((s.currentTarget = h),
                r.notifyTarget(s, 'pointerupoutside'),
                s.pointerType === 'touch')
              )
                r.notifyTarget(s, 'touchendoutside')
              else if (s.pointerType === 'mouse' || s.pointerType === 'pen') {
                var c = s.button === 2
                r.notifyTarget(s, c ? 'rightupoutside' : 'mouseupoutside')
              }
              Se.isNode(h) && (h = h.parentNode)
            }
            delete l.pressTargetsByButton[i.button], (f = h)
          }
          if (f) {
            var d = r.clonePointerEvent(s, 'click')
            ;(d.target = f),
              (d.path = []),
              l.clicksByButton[i.button] ||
                (l.clicksByButton[i.button] = { clickCount: 0, target: d.target, timeStamp: o })
            var p = l.clicksByButton[i.button]
            p.target === d.target && o - p.timeStamp < 200 ? ++p.clickCount : (p.clickCount = 1),
              (p.target = d.target),
              (p.timeStamp = o),
              (d.detail = p.clickCount),
              (!((a = s.detail) === null || a === void 0) && a.preventClick) ||
                (!r.context.config.useNativeClickEvent &&
                  (d.pointerType === 'mouse' || d.pointerType === 'touch') &&
                  r.dispatchEvent(d, 'click'),
                r.dispatchEvent(d, 'pointertap')),
              r.freeEvent(d)
          }
          r.freeEvent(s)
        }),
        (this.onPointerMove = function (i) {
          var a = r.createPointerEvent(
              i,
              void 0,
              void 0,
              r.context.config.alwaysTriggerPointerEventOnCanvas ? r.rootTarget : void 0
            ),
            o = a.pointerType === 'mouse' || a.pointerType === 'pen',
            s = r.trackingData(i.pointerId),
            c = r.findMountedTarget(s.overTargets)
          if (s.overTargets && c !== a.target) {
            var l = i.type === 'mousemove' ? 'mouseout' : 'pointerout',
              u = r.createPointerEvent(i, l, c || void 0)
            if (
              (r.dispatchEvent(u, 'pointerout'),
              o && r.dispatchEvent(u, 'mouseout'),
              !a.composedPath().includes(c))
            ) {
              var f = r.createPointerEvent(i, 'pointerleave', c || void 0)
              for (f.eventPhase = f.AT_TARGET; f.target && !a.composedPath().includes(f.target); )
                (f.currentTarget = f.target),
                  r.notifyTarget(f),
                  o && r.notifyTarget(f, 'mouseleave'),
                  Se.isNode(f.target) && (f.target = f.target.parentNode)
              r.freeEvent(f)
            }
            r.freeEvent(u)
          }
          if (c !== a.target) {
            var h = i.type === 'mousemove' ? 'mouseover' : 'pointerover',
              d = r.clonePointerEvent(a, h)
            r.dispatchEvent(d, 'pointerover'), o && r.dispatchEvent(d, 'mouseover')
            for (
              var p = c && Se.isNode(c) && c.parentNode;
              p && p !== (Se.isNode(r.rootTarget) && r.rootTarget.parentNode) && p !== a.target;

            )
              p = p.parentNode
            var v = !p || p === (Se.isNode(r.rootTarget) && r.rootTarget.parentNode)
            if (v) {
              var g = r.clonePointerEvent(a, 'pointerenter')
              for (
                g.eventPhase = g.AT_TARGET;
                g.target &&
                g.target !== c &&
                g.target !== (Se.isNode(r.rootTarget) && r.rootTarget.parentNode);

              )
                (g.currentTarget = g.target),
                  r.notifyTarget(g),
                  o && r.notifyTarget(g, 'mouseenter'),
                  Se.isNode(g.target) && (g.target = g.target.parentNode)
              r.freeEvent(g)
            }
            r.freeEvent(d)
          }
          r.dispatchEvent(a, 'pointermove'),
            a.pointerType === 'touch' && r.dispatchEvent(a, 'touchmove'),
            o && (r.dispatchEvent(a, 'mousemove'), (r.cursor = r.getCursor(a.target))),
            (s.overTargets = a.composedPath()),
            r.freeEvent(a)
        }),
        (this.onPointerOut = function (i) {
          var a = r.trackingData(i.pointerId)
          if (a.overTargets) {
            var o = i.pointerType === 'mouse' || i.pointerType === 'pen',
              s = r.findMountedTarget(a.overTargets),
              c = r.createPointerEvent(i, 'pointerout', s || void 0)
            r.dispatchEvent(c), o && r.dispatchEvent(c, 'mouseout')
            var l = r.createPointerEvent(i, 'pointerleave', s || void 0)
            for (
              l.eventPhase = l.AT_TARGET;
              l.target && l.target !== (Se.isNode(r.rootTarget) && r.rootTarget.parentNode);

            )
              (l.currentTarget = l.target),
                r.notifyTarget(l),
                o && r.notifyTarget(l, 'mouseleave'),
                Se.isNode(l.target) && (l.target = l.target.parentNode)
            ;(a.overTargets = null), r.freeEvent(c), r.freeEvent(l)
          }
          r.cursor = null
        }),
        (this.onPointerOver = function (i) {
          var a = r.trackingData(i.pointerId),
            o = r.createPointerEvent(i),
            s = o.pointerType === 'mouse' || o.pointerType === 'pen'
          r.dispatchEvent(o, 'pointerover'),
            s && r.dispatchEvent(o, 'mouseover'),
            o.pointerType === 'mouse' && (r.cursor = r.getCursor(o.target))
          var c = r.clonePointerEvent(o, 'pointerenter')
          for (
            c.eventPhase = c.AT_TARGET;
            c.target && c.target !== (Se.isNode(r.rootTarget) && r.rootTarget.parentNode);

          )
            (c.currentTarget = c.target),
              r.notifyTarget(c),
              s && r.notifyTarget(c, 'mouseenter'),
              Se.isNode(c.target) && (c.target = c.target.parentNode)
          ;(a.overTargets = o.composedPath()), r.freeEvent(o), r.freeEvent(c)
        }),
        (this.onPointerUpOutside = function (i) {
          var a = r.trackingData(i.pointerId),
            o = r.findMountedTarget(a.pressTargetsByButton[i.button]),
            s = r.createPointerEvent(i)
          if (o) {
            for (var c = o; c; )
              (s.currentTarget = c),
                r.notifyTarget(s, 'pointerupoutside'),
                s.pointerType === 'touch' ||
                  ((s.pointerType === 'mouse' || s.pointerType === 'pen') &&
                    r.notifyTarget(s, s.button === 2 ? 'rightupoutside' : 'mouseupoutside')),
                Se.isNode(c) && (c = c.parentNode)
            delete a.pressTargetsByButton[i.button]
          }
          r.freeEvent(s)
        }),
        (this.onWheel = function (i) {
          var a = r.createWheelEvent(i)
          r.dispatchEvent(a), r.freeEvent(a)
        }),
        (this.onClick = function (i) {
          if (r.context.config.useNativeClickEvent) {
            var a = r.createPointerEvent(i)
            r.dispatchEvent(a), r.freeEvent(a)
          }
        }),
        (this.onPointerCancel = function (i) {
          var a = r.createPointerEvent(
            i,
            void 0,
            void 0,
            r.context.config.alwaysTriggerPointerEventOnCanvas ? r.rootTarget : void 0
          )
          r.dispatchEvent(a), r.freeEvent(a)
        })
    }
    return (
      (t.prototype.init = function () {
        ;(this.rootTarget = this.context.renderingContext.root.parentNode),
          this.addEventMapping('pointerdown', this.onPointerDown),
          this.addEventMapping('pointerup', this.onPointerUp),
          this.addEventMapping('pointermove', this.onPointerMove),
          this.addEventMapping('pointerout', this.onPointerOut),
          this.addEventMapping('pointerleave', this.onPointerOut),
          this.addEventMapping('pointercancel', this.onPointerCancel),
          this.addEventMapping('pointerover', this.onPointerOver),
          this.addEventMapping('pointerupoutside', this.onPointerUpOutside),
          this.addEventMapping('wheel', this.onWheel),
          this.addEventMapping('click', this.onClick)
      }),
      (t.prototype.destroy = function () {
        this.emitter.removeAllListeners(),
          (this.mappingTable = {}),
          (this.mappingState = {}),
          this.eventPool.clear()
      }),
      (t.prototype.client2Viewport = function (e) {
        var n = this.context.contextService.getBoundingClientRect()
        return new Ee(
          e.x - ((n == null ? void 0 : n.left) || 0),
          e.y - ((n == null ? void 0 : n.top) || 0)
        )
      }),
      (t.prototype.viewport2Client = function (e) {
        var n = this.context.contextService.getBoundingClientRect()
        return new Ee(
          e.x + ((n == null ? void 0 : n.left) || 0),
          e.y + ((n == null ? void 0 : n.top) || 0)
        )
      }),
      (t.prototype.viewport2Canvas = function (e) {
        var n = e.x,
          r = e.y,
          i = this.rootTarget.defaultView,
          a = i.getCamera(),
          o = this.context.config,
          s = o.width,
          c = o.height,
          l = a.getPerspectiveInverse(),
          u = a.getWorldTransform(),
          f = Re(this.tmpMatrix, u, l),
          h = $n(this.tmpVec3, (n / s) * 2 - 1, (1 - r / c) * 2 - 1, 0)
        return be(h, h, f), new Ee(h[0], h[1])
      }),
      (t.prototype.canvas2Viewport = function (e) {
        var n = this.rootTarget.defaultView,
          r = n.getCamera(),
          i = r.getPerspective(),
          a = r.getViewTransform(),
          o = Re(this.tmpMatrix, i, a),
          s = $n(this.tmpVec3, e.x, e.y, 0)
        be(this.tmpVec3, this.tmpVec3, o)
        var c = this.context.config,
          l = c.width,
          u = c.height
        return new Ee(((s[0] + 1) / 2) * l, (1 - (s[1] + 1) / 2) * u)
      }),
      (t.prototype.setPickHandler = function (e) {
        this.pickHandler = e
      }),
      (t.prototype.addEventMapping = function (e, n) {
        this.mappingTable[e] || (this.mappingTable[e] = []),
          this.mappingTable[e].push({ fn: n, priority: 0 }),
          this.mappingTable[e].sort(function (r, i) {
            return r.priority - i.priority
          })
      }),
      (t.prototype.mapEvent = function (e) {
        if (this.rootTarget) {
          var n = this.mappingTable[e.type]
          if (n) for (var r = 0, i = n.length; r < i; r++) n[r].fn(e)
          else console.warn('[EventService]: Event mapping not defined for '.concat(e.type))
        }
      }),
      (t.prototype.dispatchEvent = function (e, n, r) {
        if (!r)
          (e.propagationStopped = !1), (e.propagationImmediatelyStopped = !1), this.propagate(e, n)
        else {
          e.eventPhase = e.AT_TARGET
          var i = this.rootTarget.defaultView || null
          ;(e.currentTarget = i), this.notifyListeners(e, n)
        }
        this.emitter.emit(n || e.type, e)
      }),
      (t.prototype.propagate = function (e, n) {
        if (e.target) {
          var r = e.composedPath()
          e.eventPhase = e.CAPTURING_PHASE
          for (var i = r.length - 1; i >= 1; i--)
            if (
              ((e.currentTarget = r[i]),
              this.notifyTarget(e, n),
              e.propagationStopped || e.propagationImmediatelyStopped)
            )
              return
          if (
            ((e.eventPhase = e.AT_TARGET),
            (e.currentTarget = e.target),
            this.notifyTarget(e, n),
            !(e.propagationStopped || e.propagationImmediatelyStopped))
          ) {
            var a = r.indexOf(e.currentTarget)
            e.eventPhase = e.BUBBLING_PHASE
            for (var i = a + 1; i < r.length; i++)
              if (
                ((e.currentTarget = r[i]),
                this.notifyTarget(e, n),
                e.propagationStopped || e.propagationImmediatelyStopped)
              )
                return
          }
        }
      }),
      (t.prototype.propagationPath = function (e) {
        var n = [e],
          r = this.rootTarget.defaultView || null
        if (r && r === e) return n.unshift(r.document), n
        for (var i = 0; i < y4 && e !== this.rootTarget; i++)
          Se.isNode(e) && e.parentNode && (n.push(e.parentNode), (e = e.parentNode))
        return r && n.push(r), n
      }),
      (t.prototype.hitTest = function (e) {
        var n = e.viewportX,
          r = e.viewportY,
          i = this.context.config,
          a = i.width,
          o = i.height,
          s = i.disableHitTesting
        return n < 0 || r < 0 || n > a || r > o
          ? null
          : (!s && this.pickHandler(e)) || this.rootTarget || null
      }),
      (t.prototype.isNativeEventFromCanvas = function (e) {
        var n,
          r = this.context.contextService.getDomElement(),
          i = (n = e.nativeEvent) === null || n === void 0 ? void 0 : n.target
        if (i) {
          if (i === r) return !0
          if (r && r.contains) return r.contains(i)
        }
        return e.nativeEvent.composedPath ? e.nativeEvent.composedPath().indexOf(r) > -1 : !1
      }),
      (t.prototype.getExistedHTML = function (e) {
        var n, r
        if (e.nativeEvent.composedPath)
          try {
            for (var i = hn(e.nativeEvent.composedPath()), a = i.next(); !a.done; a = i.next()) {
              var o = a.value,
                s = this.globalRuntime.nativeHTMLMap.get(o)
              if (s) return s
            }
          } catch (c) {
            n = { error: c }
          } finally {
            try {
              a && !a.done && (r = i.return) && r.call(i)
            } finally {
              if (n) throw n.error
            }
          }
        return null
      }),
      (t.prototype.pickTarget = function (e) {
        return this.hitTest({
          clientX: e.clientX,
          clientY: e.clientY,
          viewportX: e.viewportX,
          viewportY: e.viewportY,
          x: e.canvasX,
          y: e.canvasY
        })
      }),
      (t.prototype.createPointerEvent = function (e, n, r, i) {
        var a = this.allocateEvent(Rh)
        this.copyPointerData(e, a),
          this.copyMouseData(e, a),
          this.copyData(e, a),
          (a.nativeEvent = e.nativeEvent),
          (a.originalEvent = e)
        var o = this.getExistedHTML(a)
        return (
          (a.target = r ?? (o || (this.isNativeEventFromCanvas(a) && this.pickTarget(a)) || i)),
          typeof n == 'string' && (a.type = n),
          a
        )
      }),
      (t.prototype.createWheelEvent = function (e) {
        var n = this.allocateEvent(Ih)
        this.copyWheelData(e, n),
          this.copyMouseData(e, n),
          this.copyData(e, n),
          (n.nativeEvent = e.nativeEvent),
          (n.originalEvent = e)
        var r = this.getExistedHTML(n)
        return (n.target = r || (this.isNativeEventFromCanvas(n) && this.pickTarget(n))), n
      }),
      (t.prototype.trackingData = function (e) {
        return (
          this.mappingState.trackingData[e] ||
            (this.mappingState.trackingData[e] = {
              pressTargetsByButton: {},
              clicksByButton: {},
              overTarget: null
            }),
          this.mappingState.trackingData[e]
        )
      }),
      (t.prototype.cloneWheelEvent = function (e) {
        var n = this.allocateEvent(Ih)
        return (
          (n.nativeEvent = e.nativeEvent),
          (n.originalEvent = e.originalEvent),
          this.copyWheelData(e, n),
          this.copyMouseData(e, n),
          this.copyData(e, n),
          (n.target = e.target),
          (n.path = e.composedPath().slice()),
          (n.type = e.type),
          n
        )
      }),
      (t.prototype.clonePointerEvent = function (e, n) {
        var r = this.allocateEvent(Rh)
        return (
          (r.nativeEvent = e.nativeEvent),
          (r.originalEvent = e.originalEvent),
          this.copyPointerData(e, r),
          this.copyMouseData(e, r),
          this.copyData(e, r),
          (r.target = e.target),
          (r.path = e.composedPath().slice()),
          (r.type = n ?? r.type),
          r
        )
      }),
      (t.prototype.copyPointerData = function (e, n) {
        ;(n.pointerId = e.pointerId),
          (n.width = e.width),
          (n.height = e.height),
          (n.isPrimary = e.isPrimary),
          (n.pointerType = e.pointerType),
          (n.pressure = e.pressure),
          (n.tangentialPressure = e.tangentialPressure),
          (n.tiltX = e.tiltX),
          (n.tiltY = e.tiltY),
          (n.twist = e.twist)
      }),
      (t.prototype.copyMouseData = function (e, n) {
        ;(n.altKey = e.altKey),
          (n.button = e.button),
          (n.buttons = e.buttons),
          (n.ctrlKey = e.ctrlKey),
          (n.metaKey = e.metaKey),
          (n.shiftKey = e.shiftKey),
          n.client.copyFrom(e.client),
          n.movement.copyFrom(e.movement),
          n.canvas.copyFrom(e.canvas),
          n.screen.copyFrom(e.screen),
          n.global.copyFrom(e.global),
          n.offset.copyFrom(e.offset)
      }),
      (t.prototype.copyWheelData = function (e, n) {
        ;(n.deltaMode = e.deltaMode),
          (n.deltaX = e.deltaX),
          (n.deltaY = e.deltaY),
          (n.deltaZ = e.deltaZ)
      }),
      (t.prototype.copyData = function (e, n) {
        ;(n.isTrusted = e.isTrusted),
          (n.timeStamp = Nh.now()),
          (n.type = e.type),
          (n.detail = e.detail),
          (n.view = e.view),
          n.page.copyFrom(e.page),
          n.viewport.copyFrom(e.viewport)
      }),
      (t.prototype.allocateEvent = function (e) {
        this.eventPool.has(e) || this.eventPool.set(e, [])
        var n = this.eventPool.get(e).pop() || new e(this)
        return (
          (n.eventPhase = n.NONE), (n.currentTarget = null), (n.path = []), (n.target = null), n
        )
      }),
      (t.prototype.freeEvent = function (e) {
        if (e.manager !== this)
          throw new Error('It is illegal to free an event not managed by this EventBoundary!')
        var n = e.constructor
        this.eventPool.has(n) || this.eventPool.set(n, []), this.eventPool.get(n).push(e)
      }),
      (t.prototype.notifyTarget = function (e, n) {
        n = n ?? e.type
        var r =
          e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET
            ? ''.concat(n, 'capture')
            : n
        this.notifyListeners(e, r), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, n)
      }),
      (t.prototype.notifyListeners = function (e, n) {
        var r = e.currentTarget.emitter,
          i = r._events[n]
        if (i)
          if ('fn' in i)
            i.once && r.removeListener(n, i.fn, void 0, !0),
              i.fn.call(e.currentTarget || i.context, e)
          else
            for (var a = 0; a < i.length && !e.propagationImmediatelyStopped; a++)
              i[a].once && r.removeListener(n, i[a].fn, void 0, !0),
                i[a].fn.call(e.currentTarget || i[a].context, e)
      }),
      (t.prototype.findMountedTarget = function (e) {
        if (!e) return null
        for (var n = e[e.length - 1], r = e.length - 2; r >= 0; r--) {
          var i = e[r]
          if (i === this.rootTarget || (Se.isNode(i) && i.parentNode === n)) n = e[r]
          else break
        }
        return n
      }),
      (t.prototype.getCursor = function (e) {
        for (var n = e; n; ) {
          var r = BN(n) && n.getAttribute('cursor')
          if (r) return r
          n = Se.isNode(n) && n.parentNode
        }
      }),
      t
    )
  })(),
  b4 = (function () {
    function t() {}
    return (
      (t.prototype.getOrCreateCanvas = function (e, n) {
        if (this.canvas) return this.canvas
        if (e || Y.offscreenCanvas)
          (this.canvas = e || Y.offscreenCanvas), (this.context = this.canvas.getContext('2d', n))
        else
          try {
            ;(this.canvas = new window.OffscreenCanvas(0, 0)),
              (this.context = this.canvas.getContext('2d', n)),
              (!this.context || !this.context.measureText) &&
                ((this.canvas = document.createElement('canvas')),
                (this.context = this.canvas.getContext('2d')))
          } catch {
            ;(this.canvas = document.createElement('canvas')),
              (this.context = this.canvas.getContext('2d', n))
          }
        return (this.canvas.width = 10), (this.canvas.height = 10), this.canvas
      }),
      (t.prototype.getOrCreateContext = function (e, n) {
        return this.context ? this.context : (this.getOrCreateCanvas(e, n), this.context)
      }),
      t
    )
  })(),
  Vr
;(function (t) {
  ;(t[(t.CAMERA_CHANGED = 0)] = 'CAMERA_CHANGED'),
    (t[(t.DISPLAY_OBJECT_CHANGED = 1)] = 'DISPLAY_OBJECT_CHANGED'),
    (t[(t.NONE = 2)] = 'NONE')
})(Vr || (Vr = {}))
var x4 = (function () {
    function t(e, n) {
      ;(this.globalRuntime = e),
        (this.context = n),
        (this.inited = !1),
        (this.stats = { total: 0, rendered: 0 }),
        (this.zIndexCounter = 0),
        (this.hooks = {
          init: new ze(),
          initAsync: new e4(),
          dirtycheck: new uf(),
          cull: new uf(),
          beginFrame: new ze(),
          beforeRender: new ze(),
          render: new ze(),
          afterRender: new ze(),
          endFrame: new ze(),
          destroy: new ze(),
          pick: new n4(),
          pickSync: new uf(),
          pointerDown: new ze(),
          pointerUp: new ze(),
          pointerMove: new ze(),
          pointerOut: new ze(),
          pointerOver: new ze(),
          pointerWheel: new ze(),
          pointerCancel: new ze(),
          click: new ze()
        })
    }
    return (
      (t.prototype.init = function (e) {
        var n = this,
          r = z(z({}, this.globalRuntime), this.context)
        this.context.renderingPlugins.forEach(function (i) {
          i.apply(r, n.globalRuntime)
        }),
          this.hooks.init.call(),
          this.hooks.initAsync.getCallbacksNum() === 0
            ? ((this.inited = !0), e())
            : this.hooks.initAsync.promise().then(function () {
                ;(n.inited = !0), e()
              })
      }),
      (t.prototype.getStats = function () {
        return this.stats
      }),
      (t.prototype.disableDirtyRectangleRendering = function () {
        var e = this.context.config.renderer,
          n = e.getConfig().enableDirtyRectangleRendering
        return !n || this.context.renderingContext.renderReasons.has(Vr.CAMERA_CHANGED)
      }),
      (t.prototype.render = function (e, n) {
        var r = this
        ;(this.stats.total = 0), (this.stats.rendered = 0), (this.zIndexCounter = 0)
        var i = this.context.renderingContext
        if (
          (this.globalRuntime.sceneGraphService.syncHierarchy(i.root),
          this.globalRuntime.sceneGraphService.triggerPendingEvents(),
          i.renderReasons.size && this.inited)
        ) {
          i.dirtyRectangleRenderingDisabled = this.disableDirtyRectangleRendering()
          var a = i.renderReasons.size === 1 && i.renderReasons.has(Vr.CAMERA_CHANGED),
            o = !e.disableRenderHooks || !(e.disableRenderHooks && a)
          o && this.renderDisplayObject(i.root, e, i),
            this.hooks.beginFrame.call(),
            o &&
              i.renderListCurrentFrame.forEach(function (s) {
                r.hooks.beforeRender.call(s), r.hooks.render.call(s), r.hooks.afterRender.call(s)
              }),
            this.hooks.endFrame.call(),
            (i.renderListCurrentFrame = []),
            i.renderReasons.clear(),
            n()
        }
      }),
      (t.prototype.renderDisplayObject = function (e, n, r) {
        var i = this,
          a = n.renderer.getConfig(),
          o = a.enableDirtyCheck,
          s = a.enableCulling
        this.globalRuntime.enableCSSParsing && this.globalRuntime.styleValueRegistry.recalc(e)
        var c = e.renderable,
          l = o ? (c.dirty || r.dirtyRectangleRenderingDisabled ? e : null) : e
        if (l) {
          var u = s ? this.hooks.cull.call(l, this.context.camera) : l
          u && (this.stats.rendered++, r.renderListCurrentFrame.push(u))
        }
        ;(e.renderable.dirty = !1),
          (e.sortable.renderOrder = this.zIndexCounter++),
          this.stats.total++
        var f = e.sortable
        f.dirty &&
          (this.sort(e, f), (f.dirty = !1), (f.dirtyChildren = []), (f.dirtyReason = void 0)),
          (f.sorted || e.childNodes).forEach(function (h) {
            i.renderDisplayObject(h, n, r)
          })
      }),
      (t.prototype.sort = function (e, n) {
        n.sorted && n.dirtyReason !== Na.Z_INDEX_CHANGED
          ? n.dirtyChildren.forEach(function (r) {
              var i = e.childNodes.indexOf(r)
              if (i === -1) {
                var a = n.sorted.indexOf(r)
                a >= 0 && n.sorted.splice(a, 1)
              } else if (n.sorted.length === 0) n.sorted.push(r)
              else {
                var o = FN(n.sorted, r)
                n.sorted.splice(o, 0, r)
              }
            })
          : (n.sorted = e.childNodes.slice().sort(H2))
      }),
      (t.prototype.destroy = function () {
        ;(this.inited = !1),
          this.hooks.destroy.call(),
          this.globalRuntime.sceneGraphService.clearPendingEvents()
      }),
      (t.prototype.dirtify = function () {
        this.context.renderingContext.renderReasons.add(Vr.DISPLAY_OBJECT_CHANGED)
      }),
      t
    )
  })(),
  w4 = /\[\s*(.*)=(.*)\s*\]/,
  O4 = (function () {
    function t() {}
    return (
      (t.prototype.selectOne = function (e, n) {
        var r = this
        if (e.startsWith('.'))
          return n.find(function (s) {
            return ((s == null ? void 0 : s.classList) || []).indexOf(r.getIdOrClassname(e)) > -1
          })
        if (e.startsWith('#'))
          return n.find(function (s) {
            return s.id === r.getIdOrClassname(e)
          })
        if (e.startsWith('[')) {
          var i = this.getAttribute(e),
            a = i.name,
            o = i.value
          return a
            ? n.find(function (s) {
                return n !== s && (a === 'name' ? s.name === o : r.attributeToString(s, a) === o)
              })
            : null
        } else
          return n.find(function (s) {
            return n !== s && s.nodeName === e
          })
      }),
      (t.prototype.selectAll = function (e, n) {
        var r = this
        if (e.startsWith('.'))
          return n.findAll(function (s) {
            return (
              n !== s &&
              ((s == null ? void 0 : s.classList) || []).indexOf(r.getIdOrClassname(e)) > -1
            )
          })
        if (e.startsWith('#'))
          return n.findAll(function (s) {
            return n !== s && s.id === r.getIdOrClassname(e)
          })
        if (e.startsWith('[')) {
          var i = this.getAttribute(e),
            a = i.name,
            o = i.value
          return a
            ? n.findAll(function (s) {
                return n !== s && (a === 'name' ? s.name === o : r.attributeToString(s, a) === o)
              })
            : []
        } else
          return n.findAll(function (s) {
            return n !== s && s.nodeName === e
          })
      }),
      (t.prototype.is = function (e, n) {
        if (e.startsWith('.')) return n.className === this.getIdOrClassname(e)
        if (e.startsWith('#')) return n.id === this.getIdOrClassname(e)
        if (e.startsWith('[')) {
          var r = this.getAttribute(e),
            i = r.name,
            a = r.value
          return i === 'name' ? n.name === a : this.attributeToString(n, i) === a
        } else return n.nodeName === e
      }),
      (t.prototype.getIdOrClassname = function (e) {
        return e.substring(1)
      }),
      (t.prototype.getAttribute = function (e) {
        var n = e.match(w4),
          r = '',
          i = ''
        return (
          n && n.length > 2 && ((r = n[1].replace(/"/g, '')), (i = n[2].replace(/"/g, ''))),
          { name: r, value: i }
        )
      }),
      (t.prototype.attributeToString = function (e, n) {
        if (!e.getAttribute) return ''
        var r = e.getAttribute(n)
        return nt(r) ? '' : r.toString ? r.toString() : ''
      }),
      t
    )
  })(),
  $i = (function (t) {
    rt(e, t)
    function e(n, r, i, a, o, s, c, l) {
      var u = t.call(this, null) || this
      return (
        (u.relatedNode = r),
        (u.prevValue = i),
        (u.newValue = a),
        (u.attrName = o),
        (u.attrChange = s),
        (u.prevParsedValue = c),
        (u.newParsedValue = l),
        (u.type = n),
        u
      )
    }
    return (e.ADDITION = 2), (e.MODIFICATION = 1), (e.REMOVAL = 3), e
  })(hu),
  dt
;(function (t) {
  ;(t.REPARENT = 'reparent'),
    (t.DESTROY = 'destroy'),
    (t.ATTR_MODIFIED = 'DOMAttrModified'),
    (t.INSERTED = 'DOMNodeInserted'),
    (t.REMOVED = 'removed'),
    (t.MOUNTED = 'DOMNodeInsertedIntoDocument'),
    (t.UNMOUNTED = 'DOMNodeRemovedFromDocument'),
    (t.BOUNDS_CHANGED = 'bounds-changed'),
    (t.CULLED = 'culled')
})(dt || (dt = {}))
function yg(t) {
  var e = t.renderable
  e && ((e.renderBoundsDirty = !0), (e.boundsDirty = !0))
}
var S4 = new $i(dt.REPARENT, null, '', '', '', 0, '', ''),
  _4 = (function () {
    function t(e) {
      var n = this
      ;(this.runtime = e),
        (this.pendingEvents = []),
        (this.boundsChangedEvent = new Bt(dt.BOUNDS_CHANGED)),
        (this.rotate = (function () {
          var r = pe()
          return function (i, a, o, s) {
            o === void 0 && (o = 0),
              s === void 0 && (s = 0),
              typeof a == 'number' && (a = St(a, o, s))
            var c = i.transformable
            if (i.parentNode === null || !i.parentNode.transformable) n.rotateLocal(i, a)
            else {
              var l = pe()
              Vs(l, a[0], a[1], a[2])
              var u = n.getRotation(i),
                f = n.getRotation(i.parentNode)
              Xs(r, f),
                Yu(r, r),
                Wr(l, r, l),
                Wr(c.localRotation, l, u),
                tl(c.localRotation, c.localRotation),
                n.dirtifyLocal(i, c)
            }
          }
        })()),
        (this.rotateLocal = (function () {
          var r = pe()
          return function (i, a, o, s) {
            o === void 0 && (o = 0),
              s === void 0 && (s = 0),
              typeof a == 'number' && (a = St(a, o, s))
            var c = i.transformable
            Vs(r, a[0], a[1], a[2]), pv(c.localRotation, c.localRotation, r), n.dirtifyLocal(i, c)
          }
        })()),
        (this.setEulerAngles = (function () {
          var r = pe()
          return function (i, a, o, s) {
            o === void 0 && (o = 0),
              s === void 0 && (s = 0),
              typeof a == 'number' && (a = St(a, o, s))
            var c = i.transformable
            if (i.parentNode === null || !i.parentNode.transformable) n.setLocalEulerAngles(i, a)
            else {
              Vs(c.localRotation, a[0], a[1], a[2])
              var l = n.getRotation(i.parentNode)
              Xs(r, Yu(pe(), l)), pv(c.localRotation, c.localRotation, r), n.dirtifyLocal(i, c)
            }
          }
        })()),
        (this.translateLocal = (function () {
          return function (r, i, a, o) {
            a === void 0 && (a = 0),
              o === void 0 && (o = 0),
              typeof i == 'number' && (i = St(i, a, o))
            var s = r.transformable
            co(i, yt()) ||
              (wA(i, i, s.localRotation),
              va(s.localPosition, s.localPosition, i),
              n.dirtifyLocal(r, s))
          }
        })()),
        (this.setPosition = (function () {
          var r = Nt(),
            i = yt()
          return function (a, o) {
            var s = a.transformable
            if (((i[0] = o[0]), (i[1] = o[1]), (i[2] = o[2] || 0), !co(n.getPosition(a), i))) {
              if ((Qe(s.position, i), a.parentNode === null || !a.parentNode.transformable))
                Qe(s.localPosition, i)
              else {
                var c = a.parentNode.transformable
                Li(r, c.worldTransform), zn(r, r), be(s.localPosition, i, r)
              }
              n.dirtifyLocal(a, s)
            }
          }
        })()),
        (this.setLocalPosition = (function () {
          var r = yt()
          return function (i, a) {
            var o = i.transformable
            ;(r[0] = a[0]),
              (r[1] = a[1]),
              (r[2] = a[2] || 0),
              !co(o.localPosition, r) && (Qe(o.localPosition, r), n.dirtifyLocal(i, o))
          }
        })()),
        (this.translate = (function () {
          var r = yt(),
            i = yt(),
            a = yt()
          return function (o, s, c, l) {
            c === void 0 && (c = 0),
              l === void 0 && (l = 0),
              typeof s == 'number' && (s = $n(i, s, c, l)),
              !co(s, r) && (va(a, n.getPosition(o), s), n.setPosition(o, a))
          }
        })()),
        (this.setRotation = function () {
          var r = pe()
          return function (i, a, o, s, c) {
            var l = i.transformable
            if (
              (typeof a == 'number' && (a = Hu(a, o, s, c)),
              i.parentNode === null || !i.parentNode.transformable)
            )
              n.setLocalRotation(i, a)
            else {
              var u = n.getRotation(i.parentNode)
              Xs(r, u),
                Yu(r, r),
                Wr(l.localRotation, r, a),
                tl(l.localRotation, l.localRotation),
                n.dirtifyLocal(i, l)
            }
          }
        }),
        (this.displayObjectDependencyMap = new WeakMap()),
        (this.calcLocalTransform = (function () {
          var r = Nt(),
            i = yt(),
            a = Hu(0, 0, 0, 1)
          return function (o) {
            var s = o.localSkew[0] !== 0 || o.localSkew[1] !== 0
            if (s) {
              if (
                (Ro(o.localTransform, o.localRotation, o.localPosition, St(1, 1, 1), o.origin),
                o.localSkew[0] !== 0 || o.localSkew[1] !== 0)
              ) {
                var c = ws(r)
                ;(c[4] = Math.tan(o.localSkew[0])),
                  (c[1] = Math.tan(o.localSkew[1])),
                  Re(o.localTransform, o.localTransform, c)
              }
              var l = Ro(r, a, i, o.localScale, o.origin)
              Re(o.localTransform, o.localTransform, l)
            } else Ro(o.localTransform, o.localRotation, o.localPosition, o.localScale, o.origin)
          }
        })())
    }
    return (
      (t.prototype.matches = function (e, n) {
        return this.runtime.sceneGraphSelector.is(e, n)
      }),
      (t.prototype.querySelector = function (e, n) {
        return this.runtime.sceneGraphSelector.selectOne(e, n)
      }),
      (t.prototype.querySelectorAll = function (e, n) {
        return this.runtime.sceneGraphSelector.selectAll(e, n)
      }),
      (t.prototype.attach = function (e, n, r) {
        var i,
          a,
          o = !1
        e.parentNode && ((o = e.parentNode !== n), this.detach(e)),
          (e.parentNode = n),
          nt(r) ? e.parentNode.childNodes.push(e) : e.parentNode.childNodes.splice(r, 0, e)
        var s = n.sortable
        ;((!((i = s == null ? void 0 : s.sorted) === null || i === void 0) && i.length) ||
          (!((a = e.style) === null || a === void 0) && a.zIndex)) &&
          (s.dirtyChildren.indexOf(e) === -1 && s.dirtyChildren.push(e),
          (s.dirty = !0),
          (s.dirtyReason = Na.ADDED))
        var c = e.transformable
        c && this.dirtifyWorld(e, c),
          c.frozen && this.unfreezeParentToRoot(e),
          o && e.dispatchEvent(S4)
      }),
      (t.prototype.detach = function (e) {
        var n, r
        if (e.parentNode) {
          var i = e.transformable,
            a = e.parentNode.sortable
          ;((!((n = a == null ? void 0 : a.sorted) === null || n === void 0) && n.length) ||
            (!((r = e.style) === null || r === void 0) && r.zIndex)) &&
            (a.dirtyChildren.indexOf(e) === -1 && a.dirtyChildren.push(e),
            (a.dirty = !0),
            (a.dirtyReason = Na.REMOVED))
          var o = e.parentNode.childNodes.indexOf(e)
          o > -1 && e.parentNode.childNodes.splice(o, 1),
            i && this.dirtifyWorld(e, i),
            (e.parentNode = null)
        }
      }),
      (t.prototype.getOrigin = function (e) {
        return e.transformable.origin
      }),
      (t.prototype.setOrigin = function (e, n, r, i) {
        r === void 0 && (r = 0), i === void 0 && (i = 0), typeof n == 'number' && (n = [n, r, i])
        var a = e.transformable
        if (!(n[0] === a.origin[0] && n[1] === a.origin[1] && n[2] === a.origin[2])) {
          var o = a.origin
          ;(o[0] = n[0]), (o[1] = n[1]), (o[2] = n[2] || 0), this.dirtifyLocal(e, a)
        }
      }),
      (t.prototype.setLocalEulerAngles = function (e, n, r, i) {
        r === void 0 && (r = 0), i === void 0 && (i = 0), typeof n == 'number' && (n = St(n, r, i))
        var a = e.transformable
        Vs(a.localRotation, n[0], n[1], n[2]), this.dirtifyLocal(e, a)
      }),
      (t.prototype.scaleLocal = function (e, n) {
        var r = e.transformable
        bA(r.localScale, r.localScale, St(n[0], n[1], n[2] || 1)), this.dirtifyLocal(e, r)
      }),
      (t.prototype.setLocalScale = function (e, n) {
        var r = e.transformable,
          i = St(n[0], n[1], n[2] || r.localScale[2])
        co(i, r.localScale) || (Qe(r.localScale, i), this.dirtifyLocal(e, r))
      }),
      (t.prototype.setLocalRotation = function (e, n, r, i, a) {
        typeof n == 'number' && (n = Hu(n, r, i, a))
        var o = e.transformable
        Xs(o.localRotation, n), this.dirtifyLocal(e, o)
      }),
      (t.prototype.setLocalSkew = function (e, n, r) {
        typeof n == 'number' && (n = TA(n, r))
        var i = e.transformable
        PA(i.localSkew, n), this.dirtifyLocal(e, i)
      }),
      (t.prototype.dirtifyLocal = function (e, n) {
        n.localDirtyFlag || ((n.localDirtyFlag = !0), n.dirtyFlag || this.dirtifyWorld(e, n))
      }),
      (t.prototype.dirtifyWorld = function (e, n) {
        n.dirtyFlag || this.unfreezeParentToRoot(e),
          this.dirtifyWorldInternal(e, n),
          this.dirtifyToRoot(e, !0)
      }),
      (t.prototype.triggerPendingEvents = function () {
        var e = this,
          n = new Set(),
          r = function (i, a) {
            i.isConnected &&
              !n.has(i.entity) &&
              ((e.boundsChangedEvent.detail = a),
              (e.boundsChangedEvent.target = i),
              i.isMutationObserved
                ? i.dispatchEvent(e.boundsChangedEvent)
                : i.ownerDocument.defaultView.dispatchEvent(e.boundsChangedEvent, !0),
              n.add(i.entity))
          }
        this.pendingEvents.forEach(function (i) {
          var a = N(i, 2),
            o = a[0],
            s = a[1]
          s.affectChildren
            ? o.forEach(function (c) {
                r(c, s)
              })
            : r(o, s)
        }),
          this.clearPendingEvents(),
          n.clear()
      }),
      (t.prototype.clearPendingEvents = function () {
        this.pendingEvents = []
      }),
      (t.prototype.dirtifyToRoot = function (e, n) {
        n === void 0 && (n = !1)
        var r = e
        for (r.renderable && (r.renderable.dirty = !0); r; ) yg(r), (r = r.parentNode)
        n &&
          e.forEach(function (i) {
            yg(i)
          }),
          this.informDependentDisplayObjects(e),
          this.pendingEvents.push([e, { affectChildren: n }])
      }),
      (t.prototype.updateDisplayObjectDependency = function (e, n, r, i) {
        if (n && n !== r) {
          var a = this.displayObjectDependencyMap.get(n)
          if (a && a[e]) {
            var o = a[e].indexOf(i)
            a[e].splice(o, 1)
          }
        }
        if (r) {
          var s = this.displayObjectDependencyMap.get(r)
          s ||
            (this.displayObjectDependencyMap.set(r, {}),
            (s = this.displayObjectDependencyMap.get(r))),
            s[e] || (s[e] = []),
            s[e].push(i)
        }
      }),
      (t.prototype.informDependentDisplayObjects = function (e) {
        var n = this,
          r = this.displayObjectDependencyMap.get(e)
        r &&
          Object.keys(r).forEach(function (i) {
            r[i].forEach(function (a) {
              n.dirtifyToRoot(a, !0),
                a.dispatchEvent(new $i(dt.ATTR_MODIFIED, a, n, n, i, $i.MODIFICATION, n, n)),
                a.isCustomElement &&
                  a.isConnected &&
                  a.attributeChangedCallback &&
                  a.attributeChangedCallback(i, n, n)
            })
          })
      }),
      (t.prototype.getPosition = function (e) {
        var n = e.transformable
        return Qc(n.position, this.getWorldTransform(e, n))
      }),
      (t.prototype.getRotation = function (e) {
        var n = e.transformable
        return Jc(n.rotation, this.getWorldTransform(e, n))
      }),
      (t.prototype.getScale = function (e) {
        var n = e.transformable
        return Ma(n.scaling, this.getWorldTransform(e, n))
      }),
      (t.prototype.getWorldTransform = function (e, n) {
        return (
          n === void 0 && (n = e.transformable),
          (!n.localDirtyFlag && !n.dirtyFlag) ||
            (e.parentNode && e.parentNode.transformable && this.getWorldTransform(e.parentNode),
            this.sync(e, n)),
          n.worldTransform
        )
      }),
      (t.prototype.getLocalPosition = function (e) {
        return e.transformable.localPosition
      }),
      (t.prototype.getLocalRotation = function (e) {
        return e.transformable.localRotation
      }),
      (t.prototype.getLocalScale = function (e) {
        return e.transformable.localScale
      }),
      (t.prototype.getLocalSkew = function (e) {
        return e.transformable.localSkew
      }),
      (t.prototype.getLocalTransform = function (e) {
        var n = e.transformable
        return (
          n.localDirtyFlag && (this.calcLocalTransform(n), (n.localDirtyFlag = !1)),
          n.localTransform
        )
      }),
      (t.prototype.setLocalTransform = function (e, n) {
        var r = Qc(yt(), n),
          i = Jc(pe(), n),
          a = Ma(yt(), n)
        this.setLocalScale(e, a), this.setLocalPosition(e, r), this.setLocalRotation(e, i)
      }),
      (t.prototype.resetLocalTransform = function (e) {
        this.setLocalScale(e, [1, 1, 1]),
          this.setLocalPosition(e, [0, 0, 0]),
          this.setLocalEulerAngles(e, [0, 0, 0]),
          this.setLocalSkew(e, [0, 0])
      }),
      (t.prototype.getTransformedGeometryBounds = function (e, n, r) {
        n === void 0 && (n = !1)
        var i = this.getGeometryBounds(e, n)
        if (me.isEmpty(i)) return null
        var a = r || new me()
        return a.setFromTransformedAABB(i, this.getWorldTransform(e)), a
      }),
      (t.prototype.getGeometryBounds = function (e, n) {
        n === void 0 && (n = !1)
        var r = e.geometry,
          i = n ? r.renderBounds : r.contentBounds || null
        return i || new me()
      }),
      (t.prototype.getBounds = function (e, n) {
        var r = this
        n === void 0 && (n = !1)
        var i = e.renderable
        if (!i.boundsDirty && !n && i.bounds) return i.bounds
        if (!i.renderBoundsDirty && n && i.renderBounds) return i.renderBounds
        var a = n ? i.renderBounds : i.bounds,
          o = this.getTransformedGeometryBounds(e, n, a),
          s = e.childNodes
        if (
          (s.forEach(function (u) {
            var f = r.getBounds(u, n)
            f && (o ? o.add(f) : ((o = a || new me()), o.update(f.center, f.halfExtents)))
          }),
          n)
        ) {
          var c = V2(e)
          if (c) {
            var l = c.parsedStyle.clipPath.getBounds(n)
            o ? l && (o = l.intersection(o)) : (o = l)
          }
        }
        return (
          o || (o = new me()),
          o && (n ? (i.renderBounds = o) : (i.bounds = o)),
          n ? (i.renderBoundsDirty = !1) : (i.boundsDirty = !1),
          o
        )
      }),
      (t.prototype.getLocalBounds = function (e) {
        if (e.parentNode) {
          var n = Nt()
          e.parentNode.transformable && (n = zn(Nt(), this.getWorldTransform(e.parentNode)))
          var r = this.getBounds(e)
          if (!me.isEmpty(r)) {
            var i = new me()
            return i.setFromTransformedAABB(r, n), i
          }
        }
        return this.getBounds(e)
      }),
      (t.prototype.getBoundingClientRect = function (e) {
        var n,
          r,
          i,
          a = this.getGeometryBounds(e)
        me.isEmpty(a) || ((i = new me()), i.setFromTransformedAABB(a, this.getWorldTransform(e)))
        var o =
          (r = (n = e.ownerDocument) === null || n === void 0 ? void 0 : n.defaultView) === null ||
          r === void 0
            ? void 0
            : r.getContextService().getBoundingClientRect()
        if (i) {
          var s = N(i.getMin(), 2),
            c = s[0],
            l = s[1],
            u = N(i.getMax(), 2),
            f = u[0],
            h = u[1]
          return new ji(
            c + ((o == null ? void 0 : o.left) || 0),
            l + ((o == null ? void 0 : o.top) || 0),
            f - c,
            h - l
          )
        }
        return new ji((o == null ? void 0 : o.left) || 0, (o == null ? void 0 : o.top) || 0, 0, 0)
      }),
      (t.prototype.dirtifyWorldInternal = function (e, n) {
        var r = this
        if (!n.dirtyFlag) {
          ;(n.dirtyFlag = !0),
            (n.frozen = !1),
            e.childNodes.forEach(function (a) {
              var o = a.transformable
              o.dirtyFlag || r.dirtifyWorldInternal(a, o)
            })
          var i = e.renderable
          i && ((i.renderBoundsDirty = !0), (i.boundsDirty = !0), (i.dirty = !0))
        }
      }),
      (t.prototype.syncHierarchy = function (e) {
        var n = e.transformable
        if (!n.frozen) {
          ;(n.frozen = !0), (n.localDirtyFlag || n.dirtyFlag) && this.sync(e, n)
          for (var r = e.childNodes, i = 0; i < r.length; i++) this.syncHierarchy(r[i])
        }
      }),
      (t.prototype.sync = function (e, n) {
        if (
          (n.localDirtyFlag && (this.calcLocalTransform(n), (n.localDirtyFlag = !1)), n.dirtyFlag)
        ) {
          var r = e.parentNode,
            i = r && r.transformable
          r === null || !i
            ? Li(n.worldTransform, n.localTransform)
            : Re(n.worldTransform, i.worldTransform, n.localTransform),
            (n.dirtyFlag = !1)
        }
      }),
      (t.prototype.unfreezeParentToRoot = function (e) {
        for (var n = e.parentNode; n; ) {
          var r = n.transformable
          r && (r.frozen = !1), (n = n.parentNode)
        }
      }),
      t
    )
  })(),
  yi = {
    MetricsString: '|ÉqÅ',
    BaselineSymbol: 'M',
    BaselineMultiplier: 1.4,
    HeightMultiplier: 2,
    Newlines: [10, 13],
    BreakingSpaces: [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288]
  },
  mg = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/,
  M4 = /[!%),.:;?\]}¢°·'""†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？！］｝～]/,
  E4 = /[$(£¥·'"〈《「『【〔〖〝﹙﹛＄（．［｛￡￥]/,
  T4 =
    /[!),.:;?\]}¢·–—'"•"、。〆〞〕〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘﹚﹜！），．：；？︶︸︺︼︾﹀﹂﹗］｜｝､]/,
  P4 = /[([{£¥'"‵〈《「『〔〝︴﹙﹛（｛︵︷︹︻︽︿﹁﹃﹏]/,
  A4 =
    /[)\]｝〕〉》」』】〙〗〟'"｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、:;,。.]/,
  k4 = /[([｛〔〈《「『【〘〖〝'"｟«—...‥〳〴〵]/,
  C4 = /[!%),.:;?\]}¢°'"†‡℃〆〈《「『〕！％），．：；？］｝]/,
  L4 = /[$([{£¥'"々〇〉》」〔＄（［｛｠￥￦#]/,
  N4 = new RegExp(
    ''.concat(M4.source, '|').concat(T4.source, '|').concat(A4.source, '|').concat(C4.source)
  ),
  R4 = new RegExp(
    ''.concat(E4.source, '|').concat(P4.source, '|').concat(k4.source, '|').concat(L4.source)
  ),
  I4 = (function () {
    function t(e) {
      var n = this
      ;(this.runtime = e),
        (this.fontMetricsCache = {}),
        (this.shouldBreakByKinsokuShorui = function (r, i) {
          return n.isBreakingSpace(i) ? !1 : !!(r && (R4.exec(i) || N4.exec(r)))
        }),
        (this.trimByKinsokuShorui = function (r) {
          var i = q([], N(r), !1),
            a = i[i.length - 2]
          if (!a) return r
          var o = a[a.length - 1]
          return (i[i.length - 2] = a.slice(0, -1)), (i[i.length - 1] = o + i[i.length - 1]), i
        })
    }
    return (
      (t.prototype.measureFont = function (e, n) {
        if (this.fontMetricsCache[e]) return this.fontMetricsCache[e]
        var r = { ascent: 0, descent: 0, fontSize: 0 },
          i = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(n),
          a = this.runtime.offscreenCanvasCreator.getOrCreateContext(n, { willReadFrequently: !0 })
        a.font = e
        var o = yi.MetricsString + yi.BaselineSymbol,
          s = Math.ceil(a.measureText(o).width),
          c = Math.ceil(a.measureText(yi.BaselineSymbol).width),
          l = yi.HeightMultiplier * c
        ;(c = (c * yi.BaselineMultiplier) | 0),
          (i.width = s),
          (i.height = l),
          (a.fillStyle = '#f00'),
          a.fillRect(0, 0, s, l),
          (a.font = e),
          (a.textBaseline = 'alphabetic'),
          (a.fillStyle = '#000'),
          a.fillText(o, 0, c)
        var u = a.getImageData(0, 0, s || 1, l || 1).data,
          f = u.length,
          h = s * 4,
          d = 0,
          p = 0,
          v = !1
        for (d = 0; d < c; ++d) {
          for (var g = 0; g < h; g += 4)
            if (u[p + g] !== 255) {
              v = !0
              break
            }
          if (!v) p += h
          else break
        }
        for (r.ascent = c - d, p = f - h, v = !1, d = l; d > c; --d) {
          for (var g = 0; g < h; g += 4)
            if (u[p + g] !== 255) {
              v = !0
              break
            }
          if (!v) p -= h
          else break
        }
        return (
          (r.descent = d - c),
          (r.fontSize = r.ascent + r.descent),
          (this.fontMetricsCache[e] = r),
          r
        )
      }),
      (t.prototype.measureText = function (e, n, r) {
        var i = n.fontSize,
          a = n.wordWrap,
          o = n.lineHeight,
          s = n.lineWidth,
          c = n.textBaseline,
          l = n.textAlign,
          u = n.letterSpacing,
          f = n.textPath
        n.textPathSide, n.textPathStartOffset
        var h = n.leading,
          d = h === void 0 ? 0 : h,
          p = a4(n),
          v = this.measureFont(p, r)
        v.fontSize === 0 && ((v.fontSize = i), (v.ascent = i))
        var g = this.runtime.offscreenCanvasCreator.getOrCreateContext(r)
        ;(g.font = p), (n.isOverflowing = !1)
        var y = a ? this.wordWrap(e, n, r) : e,
          m = y.split(/(?:\r\n|\r|\n)/),
          b = new Array(m.length),
          x = 0
        if (f) {
          f.getTotalLength()
          for (var w = 0; w < m.length; w++)
            var O = g.measureText(m[w]).width + (m[w].length - 1) * u
        } else {
          for (var w = 0; w < m.length; w++) {
            var S = g.measureText(m[w]).width + (m[w].length - 1) * u
            ;(b[w] = S), (x = Math.max(x, S))
          }
          var O = x + s,
            _ = o || v.fontSize + s,
            M = Math.max(_, v.fontSize + s) + (m.length - 1) * (_ + d)
          _ += d
          var E = 0
          return (
            c === 'middle'
              ? (E = -M / 2)
              : c === 'bottom' || c === 'alphabetic' || c === 'ideographic'
              ? (E = -M)
              : (c === 'top' || c === 'hanging') && (E = 0),
            {
              font: p,
              width: O,
              height: M,
              lines: m,
              lineWidths: b,
              lineHeight: _,
              maxLineWidth: x,
              fontProperties: v,
              lineMetrics: b.map(function (C, A) {
                var P = 0
                return (
                  l === 'center' || l === 'middle'
                    ? (P -= C / 2)
                    : (l === 'right' || l === 'end') && (P -= C),
                  new ji(P - s / 2, E + A * _, C + s, _)
                )
              })
            }
          )
        }
      }),
      (t.prototype.setGraphemeOnPath = function () {}),
      (t.prototype.wordWrap = function (e, n, r) {
        var i = this,
          a = n.wordWrapWidth,
          o = a === void 0 ? 0 : a,
          s = n.letterSpacing,
          c = n.maxLines,
          l = c === void 0 ? 1 / 0 : c,
          u = n.textOverflow,
          f = this.runtime.offscreenCanvasCreator.getOrCreateContext(r),
          h = o + s,
          d = ''
        u === 'ellipsis' ? (d = '...') : u && u !== 'clip' && (d = u)
        for (
          var p = [],
            v = 0,
            g = 0,
            y = {},
            m = function (k) {
              return i.getFromCache(k, s, y, f)
            },
            b = Array.from(d).reduce(function (k, L) {
              return k + m(L)
            }, 0),
            x = Array.from(e),
            w = 0;
          w < x.length;
          w++
        ) {
          var O = x[w],
            S = e[w - 1],
            _ = e[w + 1],
            M = m(O)
          if (this.isNewline(O)) {
            if ((v++, v >= l)) {
              n.isOverflowing = !0
              break
            }
            ;(g = 0), (p[v] = '')
            continue
          }
          if (g > 0 && g + M > h) {
            if (v + 1 >= l) {
              if (((n.isOverflowing = !0), b > 0 && b <= h)) {
                for (var E = p[v].length, T = 0, C = E, A = 0; A < E; A++) {
                  var P = m(p[v][A])
                  if (T + P + b > h) {
                    C = A
                    break
                  }
                  T += P
                }
                p[v] = (p[v] || '').slice(0, C) + d
              }
              break
            }
            if ((v++, (g = 0), (p[v] = ''), this.isBreakingSpace(O))) continue
            this.canBreakInLastChar(O) ||
              ((p = this.trimToBreakable(p)), (g = this.sumTextWidthByCache(p[v] || '', y))),
              this.shouldBreakByKinsokuShorui(O, _) &&
                ((p = this.trimByKinsokuShorui(p)), (g += m(S || '')))
          }
          ;(g += M), (p[v] = (p[v] || '') + O)
        }
        return p.join(`
`)
      }),
      (t.prototype.isBreakingSpace = function (e) {
        return typeof e != 'string' ? !1 : yi.BreakingSpaces.indexOf(e.charCodeAt(0)) >= 0
      }),
      (t.prototype.isNewline = function (e) {
        return typeof e != 'string' ? !1 : yi.Newlines.indexOf(e.charCodeAt(0)) >= 0
      }),
      (t.prototype.trimToBreakable = function (e) {
        var n = q([], N(e), !1),
          r = n[n.length - 2],
          i = this.findBreakableIndex(r)
        if (i === -1 || !r) return n
        var a = r.slice(i, i + 1),
          o = this.isBreakingSpace(a),
          s = i + 1,
          c = i + (o ? 0 : 1)
        return (n[n.length - 1] += r.slice(s, r.length)), (n[n.length - 2] = r.slice(0, c)), n
      }),
      (t.prototype.canBreakInLastChar = function (e) {
        return !(e && mg.test(e))
      }),
      (t.prototype.sumTextWidthByCache = function (e, n) {
        return e.split('').reduce(function (r, i) {
          if (!n[i]) throw Error('cannot count the word without cache')
          return r + n[i]
        }, 0)
      }),
      (t.prototype.findBreakableIndex = function (e) {
        for (var n = e.length - 1; n >= 0; n--) if (!mg.test(e[n])) return n
        return -1
      }),
      (t.prototype.getFromCache = function (e, n, r, i) {
        var a = r[e]
        if (typeof a != 'number') {
          var o = e.length * n
          ;(a = i.measureText(e).width + o), (r[e] = a)
        }
        return a
      }),
      t
    )
  })(),
  Y = {},
  j4 = (function () {
    var t,
      e = new p4(),
      n = new d4()
    return (
      (t = {}),
      (t[G.CIRCLE] = new l4()),
      (t[G.ELLIPSE] = new u4()),
      (t[G.RECT] = e),
      (t[G.IMAGE] = e),
      (t[G.GROUP] = e),
      (t[G.LINE] = new f4()),
      (t[G.TEXT] = new v4(Y)),
      (t[G.POLYLINE] = n),
      (t[G.POLYGON] = n),
      (t[G.PATH] = new h4()),
      (t[G.HTML] = null),
      (t[G.MESH] = null),
      t
    )
  })(),
  D4 = (function () {
    var t,
      e = new SN(),
      n = new wp()
    return (
      (t = {}),
      (t[J.PERCENTAGE] = null),
      (t[J.NUMBER] = new AN()),
      (t[J.ANGLE] = new wN()),
      (t[J.DEFINED_PATH] = new ON()),
      (t[J.PAINT] = e),
      (t[J.COLOR] = e),
      (t[J.FILTER] = new _N()),
      (t[J.LENGTH] = n),
      (t[J.LENGTH_PERCENTAGE] = n),
      (t[J.LENGTH_PERCENTAGE_12] = new MN()),
      (t[J.LENGTH_PERCENTAGE_14] = new EN()),
      (t[J.COORDINATE] = new TN()),
      (t[J.OFFSET_DISTANCE] = new kN()),
      (t[J.OPACITY_VALUE] = new CN()),
      (t[J.PATH] = new LN()),
      (t[J.LIST_OF_POINTS] = new NN()),
      (t[J.SHADOW_BLUR] = new RN()),
      (t[J.TEXT] = new IN()),
      (t[J.TEXT_TRANSFORM] = new jN()),
      (t[J.TRANSFORM] = new o4()),
      (t[J.TRANSFORM_ORIGIN] = new s4()),
      (t[J.Z_INDEX] = new c4()),
      (t[J.MARKER] = new PN()),
      t
    )
  })(),
  $4 = function () {
    return typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
      ? self
      : typeof window < 'u'
      ? window
      : typeof global < 'u'
      ? global
      : {}
  }
Y.CameraContribution = L2
Y.AnimationTimeline = null
Y.EasingFunction = null
Y.offscreenCanvasCreator = new b4()
Y.nativeHTMLMap = new WeakMap()
Y.sceneGraphSelector = new O4()
Y.sceneGraphService = new _4(Y)
Y.textService = new I4(Y)
Y.geometryUpdaterFactory = j4
Y.CSSPropertySyntaxFactory = D4
Y.styleValueRegistry = new xN(Y)
Y.layoutRegistry = null
Y.globalThis = $4()
Y.enableCSSParsing = !0
Y.enableDataset = !1
Y.enableStyleSyntax = !0
var B4 = 0,
  bg = new $i(dt.INSERTED, null, '', '', '', 0, '', ''),
  xg = new $i(dt.REMOVED, null, '', '', '', 0, '', ''),
  F4 = new Bt(dt.DESTROY),
  z4 = (function (t) {
    rt(e, t)
    function e() {
      var n = (t !== null && t.apply(this, arguments)) || this
      return (
        (n.entity = B4++),
        (n.renderable = {
          bounds: void 0,
          boundsDirty: !0,
          renderBounds: void 0,
          renderBoundsDirty: !0,
          dirtyRenderBounds: void 0,
          dirty: !1
        }),
        (n.cullable = { strategy: Ph.Standard, visibilityPlaneMask: -1, visible: !0, enable: !0 }),
        (n.transformable = {
          dirtyFlag: !1,
          localDirtyFlag: !1,
          frozen: !1,
          localPosition: [0, 0, 0],
          localRotation: [0, 0, 0, 1],
          localScale: [1, 1, 1],
          localTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
          localSkew: [0, 0],
          position: [0, 0, 0],
          rotation: [0, 0, 0, 1],
          scaling: [1, 1, 1],
          worldTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
          origin: [0, 0, 0]
        }),
        (n.sortable = {
          dirty: !1,
          sorted: void 0,
          renderOrder: 0,
          dirtyChildren: [],
          dirtyReason: void 0
        }),
        (n.geometry = { contentBounds: void 0, renderBounds: void 0 }),
        (n.rBushNode = { aabb: void 0 }),
        (n.namespaceURI = 'g'),
        (n.scrollLeft = 0),
        (n.scrollTop = 0),
        (n.clientTop = 0),
        (n.clientLeft = 0),
        (n.destroyed = !1),
        (n.style = {}),
        (n.computedStyle = Y.enableCSSParsing
          ? {
              anchor: zt,
              opacity: zt,
              fillOpacity: zt,
              strokeOpacity: zt,
              fill: zt,
              stroke: zt,
              transform: zt,
              transformOrigin: zt,
              visibility: zt,
              pointerEvents: zt,
              lineWidth: zt,
              lineCap: zt,
              lineJoin: zt,
              increasedLineWidthForHitTesting: zt,
              fontSize: zt,
              fontFamily: zt,
              fontStyle: zt,
              fontWeight: zt,
              fontVariant: zt,
              textAlign: zt,
              textBaseline: zt,
              textTransform: zt,
              zIndex: zt,
              filter: zt,
              shadowType: zt
            }
          : null),
        (n.parsedStyle = {}),
        (n.attributes = {}),
        n
      )
    }
    return (
      Object.defineProperty(e.prototype, 'className', {
        get: function () {
          return this.getAttribute('class') || ''
        },
        set: function (n) {
          this.setAttribute('class', n)
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'classList', {
        get: function () {
          return this.className.split(' ').filter(function (n) {
            return n !== ''
          })
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'tagName', {
        get: function () {
          return this.nodeName
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'children', {
        get: function () {
          return this.childNodes
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'childElementCount', {
        get: function () {
          return this.childNodes.length
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'firstElementChild', {
        get: function () {
          return this.firstChild
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'lastElementChild', {
        get: function () {
          return this.lastChild
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'parentElement', {
        get: function () {
          return this.parentNode
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'nextSibling', {
        get: function () {
          if (this.parentNode) {
            var n = this.parentNode.childNodes.indexOf(this)
            return this.parentNode.childNodes[n + 1] || null
          }
          return null
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'previousSibling', {
        get: function () {
          if (this.parentNode) {
            var n = this.parentNode.childNodes.indexOf(this)
            return this.parentNode.childNodes[n - 1] || null
          }
          return null
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.cloneNode = function (n) {
        throw new Error(It)
      }),
      (e.prototype.appendChild = function (n, r) {
        var i
        if (n.destroyed) throw new Error(yL)
        return (
          Y.sceneGraphService.attach(n, this, r),
          !((i = this.ownerDocument) === null || i === void 0) &&
            i.defaultView &&
            this.ownerDocument.defaultView.mountChildren(n),
          (bg.relatedNode = this),
          n.dispatchEvent(bg),
          n
        )
      }),
      (e.prototype.insertBefore = function (n, r) {
        if (!r) this.appendChild(n)
        else {
          n.parentElement && n.parentElement.removeChild(n)
          var i = this.childNodes.indexOf(r)
          i === -1 ? this.appendChild(n) : this.appendChild(n, i)
        }
        return n
      }),
      (e.prototype.replaceChild = function (n, r) {
        var i = this.childNodes.indexOf(r)
        return this.removeChild(r), this.appendChild(n, i), r
      }),
      (e.prototype.removeChild = function (n) {
        var r
        return (
          (xg.relatedNode = this),
          n.dispatchEvent(xg),
          !((r = n.ownerDocument) === null || r === void 0) &&
            r.defaultView &&
            n.ownerDocument.defaultView.unmountChildren(n),
          Y.sceneGraphService.detach(n),
          n
        )
      }),
      (e.prototype.removeChildren = function () {
        for (var n = this.childNodes.length - 1; n >= 0; n--) {
          var r = this.childNodes[n]
          this.removeChild(r)
        }
      }),
      (e.prototype.destroyChildren = function () {
        for (var n = this.childNodes.length - 1; n >= 0; n--) {
          var r = this.childNodes[n]
          r.childNodes.length && r.destroyChildren(), r.destroy()
        }
      }),
      (e.prototype.matches = function (n) {
        return Y.sceneGraphService.matches(n, this)
      }),
      (e.prototype.getElementById = function (n) {
        return Y.sceneGraphService.querySelector('#'.concat(n), this)
      }),
      (e.prototype.getElementsByName = function (n) {
        return Y.sceneGraphService.querySelectorAll('[name="'.concat(n, '"]'), this)
      }),
      (e.prototype.getElementsByClassName = function (n) {
        return Y.sceneGraphService.querySelectorAll('.'.concat(n), this)
      }),
      (e.prototype.getElementsByTagName = function (n) {
        return Y.sceneGraphService.querySelectorAll(n, this)
      }),
      (e.prototype.querySelector = function (n) {
        return Y.sceneGraphService.querySelector(n, this)
      }),
      (e.prototype.querySelectorAll = function (n) {
        return Y.sceneGraphService.querySelectorAll(n, this)
      }),
      (e.prototype.closest = function (n) {
        var r = this
        do {
          if (Y.sceneGraphService.matches(n, r)) return r
          r = r.parentElement
        } while (r !== null)
        return null
      }),
      (e.prototype.find = function (n) {
        var r = this,
          i = null
        return (
          this.forEach(function (a) {
            return a !== r && n(a) ? ((i = a), !0) : !1
          }),
          i
        )
      }),
      (e.prototype.findAll = function (n) {
        var r = this,
          i = []
        return (
          this.forEach(function (a) {
            a !== r && n(a) && i.push(a)
          }),
          i
        )
      }),
      (e.prototype.after = function () {
        for (var n = this, r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i]
        if (this.parentNode) {
          var a = this.parentNode.childNodes.indexOf(this)
          r.forEach(function (o, s) {
            var c
            return (c = n.parentNode) === null || c === void 0
              ? void 0
              : c.appendChild(o, a + s + 1)
          })
        }
      }),
      (e.prototype.before = function () {
        for (var n, r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i]
        if (this.parentNode) {
          var a = this.parentNode.childNodes.indexOf(this),
            o = N(r),
            s = o[0],
            c = o.slice(1)
          this.parentNode.appendChild(s, a), (n = s).after.apply(n, q([], N(c), !1))
        }
      }),
      (e.prototype.replaceWith = function () {
        for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r]
        this.after.apply(this, q([], N(n), !1)), this.remove()
      }),
      (e.prototype.append = function () {
        for (var n = this, r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i]
        r.forEach(function (a) {
          return n.appendChild(a)
        })
      }),
      (e.prototype.prepend = function () {
        for (var n = this, r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i]
        r.forEach(function (a, o) {
          return n.appendChild(a, o)
        })
      }),
      (e.prototype.replaceChildren = function () {
        for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r]
        for (; this.childNodes.length && this.firstChild; ) this.removeChild(this.firstChild)
        this.append.apply(this, q([], N(n), !1))
      }),
      (e.prototype.remove = function () {
        return this.parentNode ? this.parentNode.removeChild(this) : this
      }),
      (e.prototype.destroy = function () {
        this.dispatchEvent(F4),
          this.remove(),
          this.emitter.removeAllListeners(),
          (this.destroyed = !0)
      }),
      (e.prototype.getGeometryBounds = function () {
        return Y.sceneGraphService.getGeometryBounds(this)
      }),
      (e.prototype.getRenderBounds = function () {
        return Y.sceneGraphService.getBounds(this, !0)
      }),
      (e.prototype.getBounds = function () {
        return Y.sceneGraphService.getBounds(this)
      }),
      (e.prototype.getLocalBounds = function () {
        return Y.sceneGraphService.getLocalBounds(this)
      }),
      (e.prototype.getBoundingClientRect = function () {
        return Y.sceneGraphService.getBoundingClientRect(this)
      }),
      (e.prototype.getClientRects = function () {
        return [this.getBoundingClientRect()]
      }),
      (e.prototype.computedStyleMap = function () {
        return new Map(Object.entries(this.computedStyle))
      }),
      (e.prototype.getAttributeNames = function () {
        return Object.keys(this.attributes)
      }),
      (e.prototype.getAttribute = function (n) {
        if (EL(n)) return Y.enableCSSParsing ? null : void 0
        var r = this.attributes[n]
        if (r === void 0) {
          var i = _h(n)
          return (r = this.attributes[i]), Y.enableCSSParsing && nt(r) ? null : r
        } else return r
      }),
      (e.prototype.hasAttribute = function (n) {
        return this.getAttributeNames().includes(n)
      }),
      (e.prototype.hasAttributes = function () {
        return !!this.getAttributeNames().length
      }),
      (e.prototype.removeAttribute = function (n) {
        this.setAttribute(n, null), delete this.attributes[n]
      }),
      (e.prototype.setAttribute = function (n, r, i) {
        this.attributes[n] = r
      }),
      (e.prototype.getAttributeNS = function (n, r) {
        throw new Error(It)
      }),
      (e.prototype.getAttributeNode = function (n) {
        throw new Error(It)
      }),
      (e.prototype.getAttributeNodeNS = function (n, r) {
        throw new Error(It)
      }),
      (e.prototype.hasAttributeNS = function (n, r) {
        throw new Error(It)
      }),
      (e.prototype.removeAttributeNS = function (n, r) {
        throw new Error(It)
      }),
      (e.prototype.removeAttributeNode = function (n) {
        throw new Error(It)
      }),
      (e.prototype.setAttributeNS = function (n, r, i) {
        throw new Error(It)
      }),
      (e.prototype.setAttributeNode = function (n) {
        throw new Error(It)
      }),
      (e.prototype.setAttributeNodeNS = function (n) {
        throw new Error(It)
      }),
      (e.prototype.toggleAttribute = function (n, r) {
        throw new Error(It)
      }),
      e
    )
  })(Se)
function _t(t) {
  return !!(t != null && t.nodeName)
}
var ur = new $i(dt.ATTR_MODIFIED, null, null, null, null, $i.MODIFICATION, null, null),
  G4 = {
    anchor: '',
    opacity: '',
    fillOpacity: '',
    strokeOpacity: '',
    fill: '',
    stroke: '',
    transform: '',
    transformOrigin: '',
    visibility: '',
    pointerEvents: '',
    lineWidth: '',
    lineCap: '',
    lineJoin: '',
    increasedLineWidthForHitTesting: '',
    fontSize: '',
    fontFamily: '',
    fontStyle: '',
    fontWeight: '',
    fontVariant: '',
    textAlign: '',
    textBaseline: '',
    textTransform: '',
    zIndex: '',
    filter: '',
    shadowType: ''
  },
  tw = {
    anchor: [0, 0],
    fill: Th,
    stroke: Th,
    transform: [],
    zIndex: 0,
    filter: [],
    shadowType: 'outer',
    miterLimit: 10
  },
  W4 = z(z({}, tw), {
    opacity: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    visibility: 'visible',
    pointerEvents: 'auto',
    lineWidth: 1,
    lineCap: 'butt',
    lineJoin: 'miter',
    increasedLineWidthForHitTesting: 0,
    fillRule: 'nonzero'
  }),
  Y4 = [
    'opacity',
    'fillOpacity',
    'strokeOpacity',
    'transformOrigin',
    'visibility',
    'pointerEvents',
    'lineWidth',
    'lineCap',
    'lineJoin',
    'increasedLineWidthForHitTesting'
  ],
  H4 = q(
    q([], N(Y4), !1),
    [
      'fontSize',
      'fontFamily',
      'fontStyle',
      'fontWeight',
      'fontVariant',
      'textAlign',
      'textBaseline',
      'textTransform'
    ],
    !1
  ),
  wg = 'data-',
  Be = (function (t) {
    rt(e, t)
    function e(n) {
      var r,
        i = t.call(this) || this
      ;(i.isCustomElement = !1),
        (i.isMutationObserved = !1),
        (i.activeAnimations = []),
        (i.getClip = function () {
          return this.style.clipPath || null
        }),
        (i.config = n),
        (i.config.interactive =
          (r = i.config.capture) !== null && r !== void 0 ? r : i.config.interactive),
        (i.id = i.config.id || ''),
        (i.name = i.config.name || ''),
        (i.config.className || i.config.class) &&
          (i.className = i.config.className || i.config.class),
        (i.nodeName = i.config.type || G.GROUP),
        (i.config.style = i.config.style || i.config.attrs || {}),
        Object.assign(i.config.style, i.config.attrs),
        i.config.visible != null &&
          (i.config.style.visibility = i.config.visible === !1 ? 'hidden' : 'visible'),
        i.config.interactive != null &&
          (i.config.style.pointerEvents = i.config.interactive === !1 ? 'none' : 'auto'),
        Object.assign(i.parsedStyle, Y.enableCSSParsing ? tw : W4, i.config.initialParsedStyle),
        Y.enableCSSParsing && Object.assign(i.attributes, G4),
        i.initAttributes(i.config.style)
      var a = Y.globalThis.Proxy ? Y.globalThis.Proxy : function () {}
      return (
        Y.enableDataset &&
          (i.dataset = new a(
            {},
            {
              get: function (o, s) {
                var c = ''.concat(wg).concat(rg(s))
                return o[c] !== void 0 ? o[c] : i.getAttribute(c)
              },
              set: function (o, s, c) {
                return i.setAttribute(''.concat(wg).concat(rg(s)), c), !0
              }
            }
          )),
        Y.enableStyleSyntax &&
          (i.style = new a(
            {
              setProperty: function (o, s) {
                i.setAttribute(o, s)
              },
              getPropertyValue: function (o) {
                return i.getAttribute(o)
              },
              removeProperty: function (o) {
                i.removeAttribute(o)
              },
              item: function () {
                return ''
              }
            },
            {
              get: function (o, s) {
                return o[s] !== void 0 ? o[s] : i.getAttribute(s)
              },
              set: function (o, s, c) {
                return i.setAttribute(s, c), !0
              }
            }
          )),
        i
      )
    }
    return (
      (e.prototype.destroy = function () {
        t.prototype.destroy.call(this),
          this.getAnimations().forEach(function (n) {
            n.cancel()
          })
      }),
      (e.prototype.cloneNode = function (n, r) {
        var i = z({}, this.attributes)
        for (var a in i) {
          var o = i[a]
          _t(o) &&
            a !== 'clipPath' &&
            a !== 'offsetPath' &&
            a !== 'textPath' &&
            (i[a] = o.cloneNode(n)),
            r && (i[a] = r(a, o))
        }
        var s = new this.constructor({
          id: this.id,
          name: this.name,
          className: this.name,
          interactive: this.interactive,
          style: i
        })
        return (
          s.setLocalTransform(this.getLocalTransform()),
          n &&
            this.children.forEach(function (c) {
              if (!c.style.isMarker) {
                var l = c.cloneNode(n)
                s.appendChild(l)
              }
            }),
          s
        )
      }),
      (e.prototype.initAttributes = function (n) {
        n === void 0 && (n = {})
        var r = this.renderable,
          i = { forceUpdateGeometry: !0 }
        Y.enableCSSParsing && (i.usedAttributes = H4)
        var a = {}
        for (var o in n) {
          var s = _h(o)
          a[s] = n[o]
        }
        Y.styleValueRegistry.processProperties(this, a, i), (r.dirty = !0)
      }),
      (e.prototype.setAttribute = function (n, r, i) {
        i === void 0 && (i = !1)
        var a = _h(n)
        Qt(r) ||
          ((i || r !== this.attributes[a]) &&
            (this.internalSetAttribute(a, r), t.prototype.setAttribute.call(this, a, r)))
      }),
      (e.prototype.internalSetAttribute = function (n, r, i) {
        var a
        i === void 0 && (i = {})
        var o = this.renderable,
          s = this.attributes[n],
          c = this.parsedStyle[n]
        Y.styleValueRegistry.processProperties(this, ((a = {}), (a[n] = r), a), i), (o.dirty = !0)
        var l = this.parsedStyle[n]
        this.isConnected &&
          ((ur.relatedNode = this),
          (ur.prevValue = s),
          (ur.newValue = r),
          (ur.attrName = n),
          (ur.prevParsedValue = c),
          (ur.newParsedValue = l),
          this.isMutationObserved
            ? this.dispatchEvent(ur)
            : ((ur.target = this), this.ownerDocument.defaultView.dispatchEvent(ur, !0))),
          ((this.isCustomElement && this.isConnected) || !this.isCustomElement) &&
            this.attributeChangedCallback &&
            this.attributeChangedCallback(n, s, r, c, l)
      }),
      (e.prototype.getBBox = function () {
        var n = this.getBounds(),
          r = N(n.getMin(), 2),
          i = r[0],
          a = r[1],
          o = N(n.getMax(), 2),
          s = o[0],
          c = o[1]
        return new ji(i, a, s - i, c - a)
      }),
      (e.prototype.setOrigin = function (n, r, i) {
        return (
          r === void 0 && (r = 0),
          i === void 0 && (i = 0),
          Y.sceneGraphService.setOrigin(this, Ge(n, r, i)),
          this
        )
      }),
      (e.prototype.getOrigin = function () {
        return Y.sceneGraphService.getOrigin(this)
      }),
      (e.prototype.setPosition = function (n, r, i) {
        return (
          r === void 0 && (r = 0),
          i === void 0 && (i = 0),
          Y.sceneGraphService.setPosition(this, Ge(n, r, i)),
          this
        )
      }),
      (e.prototype.setLocalPosition = function (n, r, i) {
        return (
          r === void 0 && (r = 0),
          i === void 0 && (i = 0),
          Y.sceneGraphService.setLocalPosition(this, Ge(n, r, i)),
          this
        )
      }),
      (e.prototype.translate = function (n, r, i) {
        return (
          r === void 0 && (r = 0),
          i === void 0 && (i = 0),
          Y.sceneGraphService.translate(this, Ge(n, r, i)),
          this
        )
      }),
      (e.prototype.translateLocal = function (n, r, i) {
        return (
          r === void 0 && (r = 0),
          i === void 0 && (i = 0),
          Y.sceneGraphService.translateLocal(this, Ge(n, r, i)),
          this
        )
      }),
      (e.prototype.getPosition = function () {
        return Y.sceneGraphService.getPosition(this)
      }),
      (e.prototype.getLocalPosition = function () {
        return Y.sceneGraphService.getLocalPosition(this)
      }),
      (e.prototype.scale = function (n, r, i) {
        return this.scaleLocal(n, r, i)
      }),
      (e.prototype.scaleLocal = function (n, r, i) {
        return (
          typeof n == 'number' && ((r = r || n), (i = i || n), (n = Ge(n, r, i))),
          Y.sceneGraphService.scaleLocal(this, n),
          this
        )
      }),
      (e.prototype.setLocalScale = function (n, r, i) {
        return (
          typeof n == 'number' && ((r = r || n), (i = i || n), (n = Ge(n, r, i))),
          Y.sceneGraphService.setLocalScale(this, n),
          this
        )
      }),
      (e.prototype.getLocalScale = function () {
        return Y.sceneGraphService.getLocalScale(this)
      }),
      (e.prototype.getScale = function () {
        return Y.sceneGraphService.getScale(this)
      }),
      (e.prototype.getEulerAngles = function () {
        var n = N(ef(yt(), Y.sceneGraphService.getWorldTransform(this)), 3),
          r = n[2]
        return Mn(r)
      }),
      (e.prototype.getLocalEulerAngles = function () {
        var n = N(ef(yt(), Y.sceneGraphService.getLocalRotation(this)), 3),
          r = n[2]
        return Mn(r)
      }),
      (e.prototype.setEulerAngles = function (n) {
        return Y.sceneGraphService.setEulerAngles(this, 0, 0, n), this
      }),
      (e.prototype.setLocalEulerAngles = function (n) {
        return Y.sceneGraphService.setLocalEulerAngles(this, 0, 0, n), this
      }),
      (e.prototype.rotateLocal = function (n, r, i) {
        return (
          nt(r) && nt(i)
            ? Y.sceneGraphService.rotateLocal(this, 0, 0, n)
            : Y.sceneGraphService.rotateLocal(this, n, r, i),
          this
        )
      }),
      (e.prototype.rotate = function (n, r, i) {
        return (
          nt(r) && nt(i)
            ? Y.sceneGraphService.rotate(this, 0, 0, n)
            : Y.sceneGraphService.rotate(this, n, r, i),
          this
        )
      }),
      (e.prototype.setRotation = function (n, r, i, a) {
        return Y.sceneGraphService.setRotation(this, n, r, i, a), this
      }),
      (e.prototype.setLocalRotation = function (n, r, i, a) {
        return Y.sceneGraphService.setLocalRotation(this, n, r, i, a), this
      }),
      (e.prototype.setLocalSkew = function (n, r) {
        return Y.sceneGraphService.setLocalSkew(this, n, r), this
      }),
      (e.prototype.getRotation = function () {
        return Y.sceneGraphService.getRotation(this)
      }),
      (e.prototype.getLocalRotation = function () {
        return Y.sceneGraphService.getLocalRotation(this)
      }),
      (e.prototype.getLocalSkew = function () {
        return Y.sceneGraphService.getLocalSkew(this)
      }),
      (e.prototype.getLocalTransform = function () {
        return Y.sceneGraphService.getLocalTransform(this)
      }),
      (e.prototype.getWorldTransform = function () {
        return Y.sceneGraphService.getWorldTransform(this)
      }),
      (e.prototype.setLocalTransform = function (n) {
        return Y.sceneGraphService.setLocalTransform(this, n), this
      }),
      (e.prototype.resetLocalTransform = function () {
        Y.sceneGraphService.resetLocalTransform(this)
      }),
      (e.prototype.getAnimations = function () {
        return this.activeAnimations
      }),
      (e.prototype.animate = function (n, r) {
        var i,
          a = (i = this.ownerDocument) === null || i === void 0 ? void 0 : i.timeline
        return a ? a.play(this, n, r) : null
      }),
      (e.prototype.isVisible = function () {
        var n
        return (
          ((n = this.parsedStyle) === null || n === void 0 ? void 0 : n.visibility) === 'visible'
        )
      }),
      Object.defineProperty(e.prototype, 'interactive', {
        get: function () {
          return this.isInteractive()
        },
        set: function (n) {
          this.style.pointerEvents = n ? 'auto' : 'none'
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.isInteractive = function () {
        var n
        return (
          ((n = this.parsedStyle) === null || n === void 0 ? void 0 : n.pointerEvents) !== 'none'
        )
      }),
      (e.prototype.isCulled = function () {
        return !!(this.cullable && this.cullable.enable && !this.cullable.visible)
      }),
      (e.prototype.toFront = function () {
        return (
          this.parentNode &&
            (this.style.zIndex =
              Math.max.apply(
                Math,
                q(
                  [],
                  N(
                    this.parentNode.children.map(function (n) {
                      return Number(n.style.zIndex)
                    })
                  ),
                  !1
                )
              ) + 1),
          this
        )
      }),
      (e.prototype.toBack = function () {
        return (
          this.parentNode &&
            (this.style.zIndex =
              Math.min.apply(
                Math,
                q(
                  [],
                  N(
                    this.parentNode.children.map(function (n) {
                      return Number(n.style.zIndex)
                    })
                  ),
                  !1
                )
              ) - 1),
          this
        )
      }),
      (e.prototype.getConfig = function () {
        return this.config
      }),
      (e.prototype.attr = function () {
        for (var n = this, r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i]
        var a = N(r, 2),
          o = a[0],
          s = a[1]
        return o
          ? Ei(o)
            ? (Object.keys(o).forEach(function (c) {
                n.setAttribute(c, o[c])
              }),
              this)
            : r.length === 2
            ? (this.setAttribute(o, s), this)
            : this.attributes[o]
          : this.attributes
      }),
      (e.prototype.getMatrix = function (n) {
        var r = n || this.getWorldTransform(),
          i = N(Qc(yt(), r), 2),
          a = i[0],
          o = i[1],
          s = N(Ma(yt(), r), 2),
          c = s[0],
          l = s[1],
          u = Jc(pe(), r),
          f = N(ef(yt(), u), 3),
          h = f[0],
          d = f[2]
        return uL(h || d, a, o, c, l)
      }),
      (e.prototype.getLocalMatrix = function () {
        return this.getMatrix(this.getLocalTransform())
      }),
      (e.prototype.setMatrix = function (n) {
        var r = N(Qv(n), 5),
          i = r[0],
          a = r[1],
          o = r[2],
          s = r[3],
          c = r[4]
        this.setEulerAngles(c).setPosition(i, a).setLocalScale(o, s)
      }),
      (e.prototype.setLocalMatrix = function (n) {
        var r = N(Qv(n), 5),
          i = r[0],
          a = r[1],
          o = r[2],
          s = r[3],
          c = r[4]
        this.setLocalEulerAngles(c).setLocalPosition(i, a).setLocalScale(o, s)
      }),
      (e.prototype.show = function () {
        Y.enableCSSParsing
          ? (this.style.visibility = 'visible')
          : this.forEach(function (n) {
              n.style.visibility = 'visible'
            })
      }),
      (e.prototype.hide = function () {
        Y.enableCSSParsing
          ? (this.style.visibility = 'hidden')
          : this.forEach(function (n) {
              n.style.visibility = 'hidden'
            })
      }),
      (e.prototype.getCount = function () {
        return this.childElementCount
      }),
      (e.prototype.getParent = function () {
        return this.parentElement
      }),
      (e.prototype.getChildren = function () {
        return this.children
      }),
      (e.prototype.getFirst = function () {
        return this.firstElementChild
      }),
      (e.prototype.getLast = function () {
        return this.lastElementChild
      }),
      (e.prototype.getChildByIndex = function (n) {
        return this.children[n] || null
      }),
      (e.prototype.add = function (n, r) {
        return this.appendChild(n, r)
      }),
      (e.prototype.setClip = function (n) {
        this.style.clipPath = n
      }),
      (e.prototype.set = function (n, r) {
        this.config[n] = r
      }),
      (e.prototype.get = function (n) {
        return this.config[n]
      }),
      (e.prototype.moveTo = function (n, r, i) {
        return r === void 0 && (r = 0), i === void 0 && (i = 0), this.setPosition(n, r, i), this
      }),
      (e.prototype.move = function (n, r, i) {
        return r === void 0 && (r = 0), i === void 0 && (i = 0), this.setPosition(n, r, i), this
      }),
      (e.prototype.setZIndex = function (n) {
        return (this.style.zIndex = n), this
      }),
      e
    )
  })(z4),
  V4 = {
    number: function (t) {
      return new jt(t)
    },
    percent: function (t) {
      return new jt(t, '%')
    },
    px: function (t) {
      return new jt(t, 'px')
    },
    em: function (t) {
      return new jt(t, 'em')
    },
    rem: function (t) {
      return new jt(t, 'rem')
    },
    deg: function (t) {
      return new jt(t, 'deg')
    },
    grad: function (t) {
      return new jt(t, 'grad')
    },
    rad: function (t) {
      return new jt(t, 'rad')
    },
    turn: function (t) {
      return new jt(t, 'turn')
    },
    s: function (t) {
      return new jt(t, 's')
    },
    ms: function (t) {
      return new jt(t, 'ms')
    },
    registerProperty: function (t) {
      var e = t.name,
        n = t.inherits,
        r = t.interpolable,
        i = t.initialValue,
        a = t.syntax
      Y.styleValueRegistry.registerMetadata({ n: e, inh: n, int: r, d: i, syntax: a })
    },
    registerLayout: function (t, e) {
      Y.layoutRegistry.registerLayout(t, e)
    }
  },
  Ns = (function (t) {
    rt(e, t)
    function e(n) {
      n === void 0 && (n = {})
      var r = n.style,
        i = Dt(n, ['style'])
      return (
        t.call(
          this,
          z(
            {
              type: G.CIRCLE,
              style: Y.enableCSSParsing ? z({ cx: '', cy: '', r: '' }, r) : z({}, r),
              initialParsedStyle: {
                anchor: [0.5, 0.5],
                transformOrigin: Y.enableCSSParsing ? null : [cl, cl]
              }
            },
            i
          )
        ) || this
      )
    }
    return e
  })(Be),
  Sp = (function (t) {
    rt(e, t)
    function e(n) {
      var r = this
      n === void 0 && (n = {})
      var i = n.style,
        a = Dt(n, ['style'])
      return (
        (r =
          t.call(this, z({ style: Y.enableCSSParsing ? z({ x: '', y: '' }, i) : z({}, i) }, a)) ||
          this),
        (r.isCustomElement = !0),
        r
      )
    }
    return e
  })(Be),
  _p = (function (t) {
    rt(e, t)
    function e(n) {
      n === void 0 && (n = {})
      var r = n.style,
        i = Dt(n, ['style'])
      return (
        t.call(
          this,
          z(
            {
              type: G.ELLIPSE,
              style: Y.enableCSSParsing ? z({ cx: '', cy: '', rx: '', ry: '' }, r) : z({}, r),
              initialParsedStyle: {
                anchor: [0.5, 0.5],
                transformOrigin: Y.enableCSSParsing ? null : [cl, cl]
              }
            },
            i
          )
        ) || this
      )
    }
    return e
  })(Be),
  je = (function (t) {
    rt(e, t)
    function e(n) {
      n === void 0 && (n = {})
      var r = n.style,
        i = Dt(n, ['style'])
      return (
        t.call(
          this,
          z(
            {
              type: G.GROUP,
              style: Y.enableCSSParsing ? z({ x: '', y: '', width: '', height: '' }, r) : z({}, r)
            },
            i
          )
        ) || this
      )
    }
    return e
  })(Be),
  du = (function (t) {
    rt(e, t)
    function e(n) {
      var r = this
      n === void 0 && (n = {})
      var i = n.style,
        a = Dt(n, ['style'])
      return (
        (r =
          t.call(
            this,
            z(
              {
                type: G.HTML,
                style: Y.enableCSSParsing
                  ? z({ x: '', y: '', width: 'auto', height: 'auto', innerHTML: '' }, i)
                  : z({}, i)
              },
              a
            )
          ) || this),
        (r.cullable.enable = !1),
        r
      )
    }
    return (
      (e.prototype.getDomElement = function () {
        return this.parsedStyle.$el
      }),
      (e.prototype.getBoundingClientRect = function () {
        if (this.parsedStyle.$el) return this.parsedStyle.$el.getBoundingClientRect()
        var n = this.parsedStyle,
          r = n.x,
          i = n.y,
          a = n.width,
          o = n.height
        return new ji(r, i, a, o)
      }),
      (e.prototype.getClientRects = function () {
        return [this.getBoundingClientRect()]
      }),
      (e.prototype.getBounds = function () {
        var n,
          r,
          i = this.getBoundingClientRect(),
          a =
            (r = (n = this.ownerDocument) === null || n === void 0 ? void 0 : n.defaultView) ===
              null || r === void 0
              ? void 0
              : r.getContextService().getBoundingClientRect(),
          o = new me(),
          s = i.left - ((a == null ? void 0 : a.left) || 0),
          c = i.top - ((a == null ? void 0 : a.top) || 0)
        return o.setMinMax([s, c, 0], [s + i.width, c + i.height, 0]), o
      }),
      (e.prototype.getLocalBounds = function () {
        if (this.parentNode) {
          var n = zn(Nt(), this.parentNode.getWorldTransform()),
            r = this.getBounds()
          if (!me.isEmpty(r)) {
            var i = new me()
            return i.setFromTransformedAABB(r, n), i
          }
        }
        return this.getBounds()
      }),
      e
    )
  })(Be),
  Mp = (function (t) {
    rt(e, t)
    function e(n) {
      n === void 0 && (n = {})
      var r = n.style,
        i = Dt(n, ['style'])
      return (
        t.call(
          this,
          z(
            {
              type: G.IMAGE,
              style: Y.enableCSSParsing
                ? z({ x: '', y: '', img: '', width: '', height: '' }, r)
                : z({}, r)
            },
            i
          )
        ) || this
      )
    }
    return e
  })(Be),
  Rs = (function (t) {
    rt(e, t)
    function e(n) {
      var r = this
      n === void 0 && (n = {})
      var i = n.style,
        a = Dt(n, ['style'])
      ;(r =
        t.call(
          this,
          z(
            {
              type: G.LINE,
              style: z({ x1: 0, y1: 0, x2: 0, y2: 0, z1: 0, z2: 0, isBillboard: !1 }, i)
            },
            a
          )
        ) || this),
        (r.markerStartAngle = 0),
        (r.markerEndAngle = 0)
      var o = r.parsedStyle,
        s = o.markerStart,
        c = o.markerEnd
      return (
        s && _t(s) && ((r.markerStartAngle = s.getLocalEulerAngles()), r.appendChild(s)),
        c && _t(c) && ((r.markerEndAngle = c.getLocalEulerAngles()), r.appendChild(c)),
        r.transformMarker(!0),
        r.transformMarker(!1),
        r
      )
    }
    return (
      (e.prototype.attributeChangedCallback = function (n, r, i, a, o) {
        n === 'x1' ||
        n === 'y1' ||
        n === 'x2' ||
        n === 'y2' ||
        n === 'markerStartOffset' ||
        n === 'markerEndOffset'
          ? (this.transformMarker(!0), this.transformMarker(!1))
          : n === 'markerStart'
          ? (a && _t(a) && ((this.markerStartAngle = 0), a.remove()),
            o &&
              _t(o) &&
              ((this.markerStartAngle = o.getLocalEulerAngles()),
              this.appendChild(o),
              this.transformMarker(!0)))
          : n === 'markerEnd' &&
            (a && _t(a) && ((this.markerEndAngle = 0), a.remove()),
            o &&
              _t(o) &&
              ((this.markerEndAngle = o.getLocalEulerAngles()),
              this.appendChild(o),
              this.transformMarker(!1)))
      }),
      (e.prototype.transformMarker = function (n) {
        var r = this.parsedStyle,
          i = r.markerStart,
          a = r.markerEnd,
          o = r.markerStartOffset,
          s = r.markerEndOffset,
          c = r.x1,
          l = r.x2,
          u = r.y1,
          f = r.y2,
          h = r.defX,
          d = r.defY,
          p = n ? i : a
        if (!(!p || !_t(p))) {
          var v = 0,
            g,
            y,
            m,
            b,
            x,
            w
          n
            ? ((m = c - h),
              (b = u - d),
              (g = l - c),
              (y = f - u),
              (x = o || 0),
              (w = this.markerStartAngle))
            : ((m = l - h),
              (b = f - d),
              (g = c - l),
              (y = u - f),
              (x = s || 0),
              (w = this.markerEndAngle)),
            (v = Math.atan2(y, g)),
            p.setLocalEulerAngles((v * 180) / Math.PI + w),
            p.setLocalPosition(m + Math.cos(v) * x, b + Math.sin(v) * x)
        }
      }),
      (e.prototype.getPoint = function (n, r) {
        r === void 0 && (r = !1)
        var i = this.parsedStyle,
          a = i.x1,
          o = i.y1,
          s = i.x2,
          c = i.y2,
          l = i.defX,
          u = i.defY,
          f = A2(a, o, s, c, n),
          h = f.x,
          d = f.y,
          p = be(yt(), St(h - l, d - u, 0), r ? this.getWorldTransform() : this.getLocalTransform())
        return new Ee(p[0], p[1])
      }),
      (e.prototype.getPointAtLength = function (n, r) {
        return r === void 0 && (r = !1), this.getPoint(n / this.getTotalLength(), r)
      }),
      (e.prototype.getTotalLength = function () {
        var n = this.parsedStyle,
          r = n.x1,
          i = n.y1,
          a = n.x2,
          o = n.y2
        return P2(r, i, a, o)
      }),
      e
    )
  })(Be),
  rn = (function (t) {
    rt(e, t)
    function e(n) {
      var r = this
      n === void 0 && (n = {})
      var i = n.style,
        a = Dt(n, ['style'])
      ;(r =
        t.call(
          this,
          z(
            {
              type: G.PATH,
              style: Y.enableCSSParsing ? z({ path: '', miterLimit: '' }, i) : z({}, i),
              initialParsedStyle: Y.enableCSSParsing ? null : { miterLimit: 4, path: z({}, R2) }
            },
            a
          )
        ) || this),
        (r.markerStartAngle = 0),
        (r.markerEndAngle = 0),
        (r.markerMidList = [])
      var o = r.parsedStyle,
        s = o.markerStart,
        c = o.markerEnd,
        l = o.markerMid
      return (
        s && _t(s) && ((r.markerStartAngle = s.getLocalEulerAngles()), r.appendChild(s)),
        l && _t(l) && r.placeMarkerMid(l),
        c && _t(c) && ((r.markerEndAngle = c.getLocalEulerAngles()), r.appendChild(c)),
        r.transformMarker(!0),
        r.transformMarker(!1),
        r
      )
    }
    return (
      (e.prototype.attributeChangedCallback = function (n, r, i, a, o) {
        n === 'path'
          ? (this.transformMarker(!0),
            this.transformMarker(!1),
            this.placeMarkerMid(this.parsedStyle.markerMid))
          : n === 'markerStartOffset' || n === 'markerEndOffset'
          ? (this.transformMarker(!0), this.transformMarker(!1))
          : n === 'markerStart'
          ? (a && _t(a) && ((this.markerStartAngle = 0), a.remove()),
            o &&
              _t(o) &&
              ((this.markerStartAngle = o.getLocalEulerAngles()),
              this.appendChild(o),
              this.transformMarker(!0)))
          : n === 'markerEnd'
          ? (a && _t(a) && ((this.markerEndAngle = 0), a.remove()),
            o &&
              _t(o) &&
              ((this.markerEndAngle = o.getLocalEulerAngles()),
              this.appendChild(o),
              this.transformMarker(!1)))
          : n === 'markerMid' && this.placeMarkerMid(o)
      }),
      (e.prototype.transformMarker = function (n) {
        var r = this.parsedStyle,
          i = r.markerStart,
          a = r.markerEnd,
          o = r.markerStartOffset,
          s = r.markerEndOffset,
          c = r.defX,
          l = r.defY,
          u = n ? i : a
        if (!(!u || !_t(u))) {
          var f = 0,
            h,
            d,
            p,
            v,
            g,
            y
          if (n) {
            var m = N(this.getStartTangent(), 2),
              b = m[0],
              x = m[1]
            ;(p = x[0] - c),
              (v = x[1] - l),
              (h = b[0] - x[0]),
              (d = b[1] - x[1]),
              (g = o || 0),
              (y = this.markerStartAngle)
          } else {
            var w = N(this.getEndTangent(), 2),
              b = w[0],
              x = w[1]
            ;(p = x[0] - c),
              (v = x[1] - l),
              (h = b[0] - x[0]),
              (d = b[1] - x[1]),
              (g = s || 0),
              (y = this.markerEndAngle)
          }
          ;(f = Math.atan2(d, h)),
            u.setLocalEulerAngles((f * 180) / Math.PI + y),
            u.setLocalPosition(p + Math.cos(f) * g, v + Math.sin(f) * g)
        }
      }),
      (e.prototype.placeMarkerMid = function (n) {
        var r = this.parsedStyle,
          i = r.path.segments,
          a = r.defX,
          o = r.defY
        if (
          (this.markerMidList.forEach(function (h) {
            h.remove()
          }),
          n && _t(n))
        )
          for (var s = 1; s < i.length - 1; s++) {
            var c = N(i[s].currentPoint, 2),
              l = c[0],
              u = c[1],
              f = s === 1 ? n : n.cloneNode(!0)
            this.markerMidList.push(f), this.appendChild(f), f.setLocalPosition(l - a, u - o)
          }
      }),
      (e.prototype.getTotalLength = function () {
        return Ah(this)
      }),
      (e.prototype.getPointAtLength = function (n, r) {
        r === void 0 && (r = !1)
        var i = this.parsedStyle,
          a = i.defX,
          o = i.defY,
          s = i.path.absolutePath,
          c = sk(s, n),
          l = c.x,
          u = c.y,
          f = be(yt(), St(l - a, u - o, 0), r ? this.getWorldTransform() : this.getLocalTransform())
        return new Ee(f[0], f[1])
      }),
      (e.prototype.getPoint = function (n, r) {
        return r === void 0 && (r = !1), this.getPointAtLength(n * Ah(this), r)
      }),
      (e.prototype.getStartTangent = function () {
        var n = this.parsedStyle.path.segments,
          r = []
        if (n.length > 1) {
          var i = n[0].currentPoint,
            a = n[1].currentPoint,
            o = n[1].startTangent
          ;(r = []),
            o
              ? (r.push([i[0] - o[0], i[1] - o[1]]), r.push([i[0], i[1]]))
              : (r.push([a[0], a[1]]), r.push([i[0], i[1]]))
        }
        return r
      }),
      (e.prototype.getEndTangent = function () {
        var n = this.parsedStyle.path.segments,
          r = n.length,
          i = []
        if (r > 1) {
          var a = n[r - 2].currentPoint,
            o = n[r - 1].currentPoint,
            s = n[r - 1].endTangent
          ;(i = []),
            s
              ? (i.push([o[0] - s[0], o[1] - s[1]]), i.push([o[0], o[1]]))
              : (i.push([a[0], a[1]]), i.push([o[0], o[1]]))
        }
        return i
      }),
      e
    )
  })(Be),
  pu = (function (t) {
    rt(e, t)
    function e(n) {
      var r = this
      n === void 0 && (n = {})
      var i = n.style,
        a = Dt(n, ['style'])
      ;(r =
        t.call(
          this,
          z(
            {
              type: G.POLYGON,
              style: Y.enableCSSParsing
                ? z({ points: '', miterLimit: '', isClosed: !0 }, i)
                : z({}, i),
              initialParsedStyle: Y.enableCSSParsing
                ? null
                : {
                    points: { points: [], totalLength: 0, segments: [] },
                    miterLimit: 4,
                    isClosed: !0
                  }
            },
            a
          )
        ) || this),
        (r.markerStartAngle = 0),
        (r.markerEndAngle = 0),
        (r.markerMidList = [])
      var o = r.parsedStyle,
        s = o.markerStart,
        c = o.markerEnd,
        l = o.markerMid
      return (
        s && _t(s) && ((r.markerStartAngle = s.getLocalEulerAngles()), r.appendChild(s)),
        l && _t(l) && r.placeMarkerMid(l),
        c && _t(c) && ((r.markerEndAngle = c.getLocalEulerAngles()), r.appendChild(c)),
        r.transformMarker(!0),
        r.transformMarker(!1),
        r
      )
    }
    return (
      (e.prototype.attributeChangedCallback = function (n, r, i, a, o) {
        n === 'points'
          ? (this.transformMarker(!0),
            this.transformMarker(!1),
            this.placeMarkerMid(this.parsedStyle.markerMid))
          : n === 'markerStartOffset' || n === 'markerEndOffset'
          ? (this.transformMarker(!0), this.transformMarker(!1))
          : n === 'markerStart'
          ? (a && _t(a) && ((this.markerStartAngle = 0), a.remove()),
            o &&
              _t(o) &&
              ((this.markerStartAngle = o.getLocalEulerAngles()),
              this.appendChild(o),
              this.transformMarker(!0)))
          : n === 'markerEnd'
          ? (a && _t(a) && ((this.markerEndAngle = 0), a.remove()),
            o &&
              _t(o) &&
              ((this.markerEndAngle = o.getLocalEulerAngles()),
              this.appendChild(o),
              this.transformMarker(!1)))
          : n === 'markerMid' && this.placeMarkerMid(o)
      }),
      (e.prototype.transformMarker = function (n) {
        var r = this.parsedStyle,
          i = r.markerStart,
          a = r.markerEnd,
          o = r.markerStartOffset,
          s = r.markerEndOffset,
          c = r.points,
          l = r.defX,
          u = r.defY,
          f = (c || {}).points,
          h = n ? i : a
        if (!(!h || !_t(h) || !f)) {
          var d = 0,
            p,
            v,
            g,
            y,
            m,
            b
          if (((g = f[0][0] - l), (y = f[0][1] - u), n))
            (p = f[1][0] - f[0][0]),
              (v = f[1][1] - f[0][1]),
              (m = o || 0),
              (b = this.markerStartAngle)
          else {
            var x = f.length
            this.parsedStyle.isClosed
              ? ((p = f[x - 1][0] - f[0][0]), (v = f[x - 1][1] - f[0][1]))
              : ((g = f[x - 1][0] - l),
                (y = f[x - 1][1] - u),
                (p = f[x - 2][0] - f[x - 1][0]),
                (v = f[x - 2][1] - f[x - 1][1])),
              (m = s || 0),
              (b = this.markerEndAngle)
          }
          ;(d = Math.atan2(v, p)),
            h.setLocalEulerAngles((d * 180) / Math.PI + b),
            h.setLocalPosition(g + Math.cos(d) * m, y + Math.sin(d) * m)
        }
      }),
      (e.prototype.placeMarkerMid = function (n) {
        var r = this.parsedStyle,
          i = r.points,
          a = r.defX,
          o = r.defY,
          s = (i || {}).points
        if (
          (this.markerMidList.forEach(function (h) {
            h.remove()
          }),
          (this.markerMidList = []),
          n && _t(n) && s)
        )
          for (var c = 1; c < (this.parsedStyle.isClosed ? s.length : s.length - 1); c++) {
            var l = s[c][0] - a,
              u = s[c][1] - o,
              f = c === 1 ? n : n.cloneNode(!0)
            this.markerMidList.push(f), this.appendChild(f), f.setLocalPosition(l, u)
          }
      }),
      e
    )
  })(Be),
  Ep = (function (t) {
    rt(e, t)
    function e(n) {
      n === void 0 && (n = {})
      var r = n.style,
        i = Dt(n, ['style'])
      return (
        t.call(
          this,
          z(
            {
              type: G.POLYLINE,
              style: Y.enableCSSParsing
                ? z({ points: '', miterLimit: '', isClosed: !1 }, r)
                : z({}, r),
              initialParsedStyle: Y.enableCSSParsing
                ? null
                : {
                    points: { points: [], totalLength: 0, segments: [] },
                    miterLimit: 4,
                    isClosed: !1
                  }
            },
            i
          )
        ) || this
      )
    }
    return (
      (e.prototype.getTotalLength = function () {
        return this.parsedStyle.points.totalLength
      }),
      (e.prototype.getPointAtLength = function (n, r) {
        return r === void 0 && (r = !1), this.getPoint(n / this.getTotalLength(), r)
      }),
      (e.prototype.getPoint = function (n, r) {
        r === void 0 && (r = !1)
        var i = this.parsedStyle,
          a = i.defX,
          o = i.defY,
          s = i.points,
          c = s.points,
          l = s.segments,
          u = 0,
          f = 0
        l.forEach(function (g, y) {
          n >= g[0] && n <= g[1] && ((u = (n - g[0]) / (g[1] - g[0])), (f = y))
        })
        var h = A2(c[f][0], c[f][1], c[f + 1][0], c[f + 1][1], u),
          d = h.x,
          p = h.y,
          v = be(yt(), St(d - a, p - o, 0), r ? this.getWorldTransform() : this.getLocalTransform())
        return new Ee(v[0], v[1])
      }),
      (e.prototype.getStartTangent = function () {
        var n = this.parsedStyle.points.points,
          r = []
        return r.push([n[1][0], n[1][1]]), r.push([n[0][0], n[0][1]]), r
      }),
      (e.prototype.getEndTangent = function () {
        var n = this.parsedStyle.points.points,
          r = n.length - 1,
          i = []
        return i.push([n[r - 1][0], n[r - 1][1]]), i.push([n[r][0], n[r][1]]), i
      }),
      e
    )
  })(pu),
  Xi = (function (t) {
    rt(e, t)
    function e(n) {
      n === void 0 && (n = {})
      var r = n.style,
        i = Dt(n, ['style'])
      return (
        t.call(
          this,
          z(
            {
              type: G.RECT,
              style: Y.enableCSSParsing
                ? z({ x: '', y: '', width: '', height: '', radius: '' }, r)
                : z({}, r)
            },
            i
          )
        ) || this
      )
    }
    return e
  })(Be),
  Za = (function (t) {
    rt(e, t)
    function e(n) {
      n === void 0 && (n = {})
      var r = n.style,
        i = Dt(n, ['style'])
      return (
        t.call(
          this,
          z(
            {
              type: G.TEXT,
              style: Y.enableCSSParsing
                ? z(
                    {
                      x: '',
                      y: '',
                      text: '',
                      fontSize: '',
                      fontFamily: '',
                      fontStyle: '',
                      fontWeight: '',
                      fontVariant: '',
                      textAlign: '',
                      textBaseline: '',
                      textTransform: '',
                      fill: 'black',
                      letterSpacing: '',
                      lineHeight: '',
                      miterLimit: '',
                      wordWrap: !1,
                      wordWrapWidth: 0,
                      leading: 0,
                      dx: '',
                      dy: ''
                    },
                    r
                  )
                : z({ fill: 'black' }, r),
              initialParsedStyle: Y.enableCSSParsing
                ? {}
                : {
                    x: 0,
                    y: 0,
                    fontSize: 16,
                    fontFamily: 'sans-serif',
                    fontStyle: 'normal',
                    fontWeight: 'normal',
                    fontVariant: 'normal',
                    lineHeight: 0,
                    letterSpacing: 0,
                    textBaseline: 'alphabetic',
                    textAlign: 'start',
                    wordWrap: !1,
                    wordWrapWidth: 0,
                    leading: 0,
                    dx: 0,
                    dy: 0
                  }
            },
            i
          )
        ) || this
      )
    }
    return (
      (e.prototype.getComputedTextLength = function () {
        var n
        return (
          ((n = this.parsedStyle.metrics) === null || n === void 0 ? void 0 : n.maxLineWidth) || 0
        )
      }),
      (e.prototype.getLineBoundingRects = function () {
        var n
        return (
          ((n = this.parsedStyle.metrics) === null || n === void 0 ? void 0 : n.lineMetrics) || []
        )
      }),
      (e.prototype.isOverflowing = function () {
        return !!this.parsedStyle.isOverflowing
      }),
      e
    )
  })(Be),
  X4 = (function () {
    function t() {
      ;(this.registry = {}),
        this.define(G.CIRCLE, Ns),
        this.define(G.ELLIPSE, _p),
        this.define(G.RECT, Xi),
        this.define(G.IMAGE, Mp),
        this.define(G.LINE, Rs),
        this.define(G.GROUP, je),
        this.define(G.PATH, rn),
        this.define(G.POLYGON, pu),
        this.define(G.POLYLINE, Ep),
        this.define(G.TEXT, Za),
        this.define(G.HTML, du)
    }
    return (
      (t.prototype.define = function (e, n) {
        this.registry[e] = n
      }),
      (t.prototype.get = function (e) {
        return this.registry[e]
      }),
      t
    )
  })(),
  U4 = (function (t) {
    rt(e, t)
    function e() {
      var n = t.call(this) || this
      ;(n.defaultView = null), (n.ownerDocument = null), (n.nodeName = 'document')
      try {
        n.timeline = new Y.AnimationTimeline(n)
      } catch {}
      var r = {}
      return (
        xp.forEach(function (i) {
          var a = i.n,
            o = i.inh,
            s = i.d
          o && s && (r[a] = ha(s) ? s(G.GROUP) : s)
        }),
        (n.documentElement = new je({ id: 'g-root', style: r })),
        (n.documentElement.ownerDocument = n),
        (n.documentElement.parentNode = n),
        (n.childNodes = [n.documentElement]),
        n
      )
    }
    return (
      Object.defineProperty(e.prototype, 'children', {
        get: function () {
          return this.childNodes
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'childElementCount', {
        get: function () {
          return this.childNodes.length
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'firstElementChild', {
        get: function () {
          return this.firstChild
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'lastElementChild', {
        get: function () {
          return this.lastChild
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.createElement = function (n, r) {
        if (n === 'svg') return this.documentElement
        var i = this.defaultView.customElements.get(n)
        i || (console.warn('Unsupported tagName: ', n), (i = n === 'tspan' ? Za : je))
        var a = new i(r)
        return (a.ownerDocument = this), a
      }),
      (e.prototype.createElementNS = function (n, r, i) {
        return this.createElement(r, i)
      }),
      (e.prototype.cloneNode = function (n) {
        throw new Error(It)
      }),
      (e.prototype.destroy = function () {
        try {
          this.documentElement.destroyChildren(), this.timeline.destroy()
        } catch {}
      }),
      (e.prototype.elementsFromBBox = function (n, r, i, a) {
        var o = this.defaultView.context.rBushRoot,
          s = o.search({ minX: n, minY: r, maxX: i, maxY: a }),
          c = []
        return (
          s.forEach(function (l) {
            var u = l.displayObject,
              f = u.parsedStyle.pointerEvents,
              h = ['auto', 'visiblepainted', 'visiblefill', 'visiblestroke', 'visible'].includes(f)
            ;(!h || (h && u.isVisible())) && !u.isCulled() && u.isInteractive() && c.push(u)
          }),
          c.sort(function (l, u) {
            return u.sortable.renderOrder - l.sortable.renderOrder
          }),
          c
        )
      }),
      (e.prototype.elementFromPointSync = function (n, r) {
        var i = this.defaultView.canvas2Viewport({ x: n, y: r }),
          a = i.x,
          o = i.y,
          s = this.defaultView.getConfig(),
          c = s.width,
          l = s.height
        if (a < 0 || o < 0 || a > c || o > l) return null
        var u = this.defaultView.viewport2Client({ x: a, y: o }),
          f = u.x,
          h = u.y,
          d = this.defaultView
            .getRenderingService()
            .hooks.pickSync.call({
              topmost: !0,
              position: { x: n, y: r, viewportX: a, viewportY: o, clientX: f, clientY: h },
              picked: []
            }).picked
        return (d && d[0]) || this.documentElement
      }),
      (e.prototype.elementFromPoint = function (n, r) {
        return Ea(this, void 0, void 0, function () {
          var i, a, o, s, c, l, u, f, h, d
          return Ta(this, function (p) {
            switch (p.label) {
              case 0:
                return (
                  (i = this.defaultView.canvas2Viewport({ x: n, y: r })),
                  (a = i.x),
                  (o = i.y),
                  (s = this.defaultView.getConfig()),
                  (c = s.width),
                  (l = s.height),
                  a < 0 || o < 0 || a > c || o > l
                    ? [2, null]
                    : ((u = this.defaultView.viewport2Client({ x: a, y: o })),
                      (f = u.x),
                      (h = u.y),
                      [
                        4,
                        this.defaultView
                          .getRenderingService()
                          .hooks.pick.promise({
                            topmost: !0,
                            position: {
                              x: n,
                              y: r,
                              viewportX: a,
                              viewportY: o,
                              clientX: f,
                              clientY: h
                            },
                            picked: []
                          })
                      ])
                )
              case 1:
                return (d = p.sent().picked), [2, (d && d[0]) || this.documentElement]
            }
          })
        })
      }),
      (e.prototype.elementsFromPointSync = function (n, r) {
        var i = this.defaultView.canvas2Viewport({ x: n, y: r }),
          a = i.x,
          o = i.y,
          s = this.defaultView.getConfig(),
          c = s.width,
          l = s.height
        if (a < 0 || o < 0 || a > c || o > l) return []
        var u = this.defaultView.viewport2Client({ x: a, y: o }),
          f = u.x,
          h = u.y,
          d = this.defaultView
            .getRenderingService()
            .hooks.pickSync.call({
              topmost: !1,
              position: { x: n, y: r, viewportX: a, viewportY: o, clientX: f, clientY: h },
              picked: []
            }).picked
        return d[d.length - 1] !== this.documentElement && d.push(this.documentElement), d
      }),
      (e.prototype.elementsFromPoint = function (n, r) {
        return Ea(this, void 0, void 0, function () {
          var i, a, o, s, c, l, u, f, h, d
          return Ta(this, function (p) {
            switch (p.label) {
              case 0:
                return (
                  (i = this.defaultView.canvas2Viewport({ x: n, y: r })),
                  (a = i.x),
                  (o = i.y),
                  (s = this.defaultView.getConfig()),
                  (c = s.width),
                  (l = s.height),
                  a < 0 || o < 0 || a > c || o > l
                    ? [2, []]
                    : ((u = this.defaultView.viewport2Client({ x: a, y: o })),
                      (f = u.x),
                      (h = u.y),
                      [
                        4,
                        this.defaultView
                          .getRenderingService()
                          .hooks.pick.promise({
                            topmost: !1,
                            position: {
                              x: n,
                              y: r,
                              viewportX: a,
                              viewportY: o,
                              clientX: f,
                              clientY: h
                            },
                            picked: []
                          })
                      ])
                )
              case 1:
                return (
                  (d = p.sent().picked),
                  d[d.length - 1] !== this.documentElement && d.push(this.documentElement),
                  [2, d]
                )
            }
          })
        })
      }),
      (e.prototype.appendChild = function (n, r) {
        throw new Error(Ji)
      }),
      (e.prototype.insertBefore = function (n, r) {
        throw new Error(Ji)
      }),
      (e.prototype.removeChild = function (n, r) {
        throw new Error(Ji)
      }),
      (e.prototype.replaceChild = function (n, r, i) {
        throw new Error(Ji)
      }),
      (e.prototype.append = function () {
        throw new Error(Ji)
      }),
      (e.prototype.prepend = function () {
        throw new Error(Ji)
      }),
      (e.prototype.getElementById = function (n) {
        return this.documentElement.getElementById(n)
      }),
      (e.prototype.getElementsByName = function (n) {
        return this.documentElement.getElementsByName(n)
      }),
      (e.prototype.getElementsByTagName = function (n) {
        return this.documentElement.getElementsByTagName(n)
      }),
      (e.prototype.getElementsByClassName = function (n) {
        return this.documentElement.getElementsByClassName(n)
      }),
      (e.prototype.querySelector = function (n) {
        return this.documentElement.querySelector(n)
      }),
      (e.prototype.querySelectorAll = function (n) {
        return this.documentElement.querySelectorAll(n)
      }),
      (e.prototype.find = function (n) {
        return this.documentElement.find(n)
      }),
      (e.prototype.findAll = function (n) {
        return this.documentElement.findAll(n)
      }),
      e
    )
  })(Se),
  q4 = (function () {
    function t(e) {
      this.strategies = e
    }
    return (
      (t.prototype.apply = function (e) {
        var n = e.camera,
          r = e.renderingService,
          i = e.renderingContext,
          a = this.strategies
        r.hooks.cull.tap(t.tag, function (o) {
          if (o) {
            var s = o.cullable
            return (
              a.length === 0
                ? (s.visible = i.unculledEntities.indexOf(o.entity) > -1)
                : (s.visible = a.every(function (c) {
                    return c.isVisible(n, o)
                  })),
              !o.isCulled() && o.isVisible() ? o : (o.dispatchEvent(new Bt(dt.CULLED)), null)
            )
          }
          return o
        }),
          r.hooks.afterRender.tap(t.tag, function (o) {
            o.cullable.visibilityPlaneMask = -1
          })
      }),
      (t.tag = 'Culling'),
      t
    )
  })(),
  K4 = (function () {
    function t() {
      var e = this
      ;(this.autoPreventDefault = !1),
        (this.rootPointerEvent = new Rh(null)),
        (this.rootWheelEvent = new Ih(null)),
        (this.onPointerMove = function (n) {
          var r,
            i,
            a,
            o,
            s =
              (o =
                (a = e.context.renderingContext.root) === null || a === void 0
                  ? void 0
                  : a.ownerDocument) === null || o === void 0
                ? void 0
                : o.defaultView
          if (!(s.supportsTouchEvents && n.pointerType === 'touch')) {
            var c = e.normalizeToPointerEvent(n, s)
            try {
              for (var l = hn(c), u = l.next(); !u.done; u = l.next()) {
                var f = u.value,
                  h = e.bootstrapEvent(e.rootPointerEvent, f, s, n)
                e.context.eventService.mapEvent(h)
              }
            } catch (d) {
              r = { error: d }
            } finally {
              try {
                u && !u.done && (i = l.return) && i.call(l)
              } finally {
                if (r) throw r.error
              }
            }
            e.setCursor(e.context.eventService.cursor)
          }
        }),
        (this.onClick = function (n) {
          var r,
            i,
            a,
            o,
            s =
              (o =
                (a = e.context.renderingContext.root) === null || a === void 0
                  ? void 0
                  : a.ownerDocument) === null || o === void 0
                ? void 0
                : o.defaultView,
            c = e.normalizeToPointerEvent(n, s)
          try {
            for (var l = hn(c), u = l.next(); !u.done; u = l.next()) {
              var f = u.value,
                h = e.bootstrapEvent(e.rootPointerEvent, f, s, n)
              e.context.eventService.mapEvent(h)
            }
          } catch (d) {
            r = { error: d }
          } finally {
            try {
              u && !u.done && (i = l.return) && i.call(l)
            } finally {
              if (r) throw r.error
            }
          }
          e.setCursor(e.context.eventService.cursor)
        })
    }
    return (
      (t.prototype.apply = function (e) {
        var n = this
        this.context = e
        var r = e.renderingService,
          i = this.context.renderingContext.root.ownerDocument.defaultView
        this.context.eventService.setPickHandler(function (a) {
          var o = n.context.renderingService.hooks.pickSync.call({
            position: a,
            picked: [],
            topmost: !0
          }).picked
          return o[0] || null
        }),
          r.hooks.pointerWheel.tap(t.tag, function (a) {
            var o = n.normalizeWheelEvent(a)
            n.context.eventService.mapEvent(o)
          }),
          r.hooks.pointerDown.tap(t.tag, function (a) {
            var o, s
            if (!(i.supportsTouchEvents && a.pointerType === 'touch')) {
              var c = n.normalizeToPointerEvent(a, i)
              if (n.autoPreventDefault && c[0].isNormalized) {
                var l = a.cancelable || !('cancelable' in a)
                l && a.preventDefault()
              }
              try {
                for (var u = hn(c), f = u.next(); !f.done; f = u.next()) {
                  var h = f.value,
                    d = n.bootstrapEvent(n.rootPointerEvent, h, i, a)
                  n.context.eventService.mapEvent(d)
                }
              } catch (p) {
                o = { error: p }
              } finally {
                try {
                  f && !f.done && (s = u.return) && s.call(u)
                } finally {
                  if (o) throw o.error
                }
              }
              n.setCursor(n.context.eventService.cursor)
            }
          }),
          r.hooks.pointerUp.tap(t.tag, function (a) {
            var o, s
            if (!(i.supportsTouchEvents && a.pointerType === 'touch')) {
              var c = n.context.contextService.getDomElement(),
                l = 'outside'
              try {
                l =
                  c && a.target && a.target !== c && c.contains && !c.contains(a.target)
                    ? 'outside'
                    : ''
              } catch {}
              var u = n.normalizeToPointerEvent(a, i)
              try {
                for (var f = hn(u), h = f.next(); !h.done; h = f.next()) {
                  var d = h.value,
                    p = n.bootstrapEvent(n.rootPointerEvent, d, i, a)
                  ;(p.type += l), n.context.eventService.mapEvent(p)
                }
              } catch (v) {
                o = { error: v }
              } finally {
                try {
                  h && !h.done && (s = f.return) && s.call(f)
                } finally {
                  if (o) throw o.error
                }
              }
              n.setCursor(n.context.eventService.cursor)
            }
          }),
          r.hooks.pointerMove.tap(t.tag, this.onPointerMove),
          r.hooks.pointerOver.tap(t.tag, this.onPointerMove),
          r.hooks.pointerOut.tap(t.tag, this.onPointerMove),
          r.hooks.click.tap(t.tag, this.onClick),
          r.hooks.pointerCancel.tap(t.tag, function (a) {
            var o,
              s,
              c = n.normalizeToPointerEvent(a, i)
            try {
              for (var l = hn(c), u = l.next(); !u.done; u = l.next()) {
                var f = u.value,
                  h = n.bootstrapEvent(n.rootPointerEvent, f, i, a)
                n.context.eventService.mapEvent(h)
              }
            } catch (d) {
              o = { error: d }
            } finally {
              try {
                u && !u.done && (s = l.return) && s.call(l)
              } finally {
                if (o) throw o.error
              }
            }
            n.setCursor(n.context.eventService.cursor)
          })
      }),
      (t.prototype.getViewportXY = function (e) {
        var n,
          r,
          i = e.offsetX,
          a = e.offsetY,
          o = e.clientX,
          s = e.clientY
        if (this.context.config.supportsCSSTransform && !nt(i) && !nt(a)) (n = i), (r = a)
        else {
          var c = this.context.eventService.client2Viewport(new Ee(o, s))
          ;(n = c.x), (r = c.y)
        }
        return { x: n, y: r }
      }),
      (t.prototype.bootstrapEvent = function (e, n, r, i) {
        ;(e.view = r),
          (e.originalEvent = null),
          (e.nativeEvent = i),
          (e.pointerId = n.pointerId),
          (e.width = n.width),
          (e.height = n.height),
          (e.isPrimary = n.isPrimary),
          (e.pointerType = n.pointerType),
          (e.pressure = n.pressure),
          (e.tangentialPressure = n.tangentialPressure),
          (e.tiltX = n.tiltX),
          (e.tiltY = n.tiltY),
          (e.twist = n.twist),
          this.transferMouseData(e, n)
        var a = this.getViewportXY(n),
          o = a.x,
          s = a.y
        ;(e.viewport.x = o), (e.viewport.y = s)
        var c = this.context.eventService.viewport2Canvas(e.viewport),
          l = c.x,
          u = c.y
        return (
          (e.canvas.x = l),
          (e.canvas.y = u),
          e.global.copyFrom(e.canvas),
          e.offset.copyFrom(e.canvas),
          (e.isTrusted = i.isTrusted),
          e.type === 'pointerleave' && (e.type = 'pointerout'),
          e.type.startsWith('mouse') && (e.type = e.type.replace('mouse', 'pointer')),
          e.type.startsWith('touch') && (e.type = HN[e.type] || e.type),
          e
        )
      }),
      (t.prototype.normalizeWheelEvent = function (e) {
        var n = this.rootWheelEvent
        this.transferMouseData(n, e),
          (n.deltaMode = e.deltaMode),
          (n.deltaX = e.deltaX),
          (n.deltaY = e.deltaY),
          (n.deltaZ = e.deltaZ)
        var r = this.getViewportXY(e),
          i = r.x,
          a = r.y
        ;(n.viewport.x = i), (n.viewport.y = a)
        var o = this.context.eventService.viewport2Canvas(n.viewport),
          s = o.x,
          c = o.y
        return (
          (n.canvas.x = s),
          (n.canvas.y = c),
          n.global.copyFrom(n.canvas),
          n.offset.copyFrom(n.canvas),
          (n.nativeEvent = e),
          (n.type = e.type),
          n
        )
      }),
      (t.prototype.transferMouseData = function (e, n) {
        ;(e.isTrusted = n.isTrusted),
          (e.srcElement = n.srcElement),
          (e.timeStamp = Nh.now()),
          (e.type = n.type),
          (e.altKey = n.altKey),
          (e.metaKey = n.metaKey),
          (e.shiftKey = n.shiftKey),
          (e.ctrlKey = n.ctrlKey),
          (e.button = n.button),
          (e.buttons = n.buttons),
          (e.client.x = n.clientX),
          (e.client.y = n.clientY),
          (e.movement.x = n.movementX),
          (e.movement.y = n.movementY),
          (e.page.x = n.pageX),
          (e.page.y = n.pageY),
          (e.screen.x = n.screenX),
          (e.screen.y = n.screenY),
          (e.relatedTarget = null)
      }),
      (t.prototype.setCursor = function (e) {
        this.context.contextService.applyCursorStyle(e || this.context.config.cursor || 'default')
      }),
      (t.prototype.normalizeToPointerEvent = function (e, n) {
        var r = []
        if (n.isTouchEvent(e))
          for (var i = 0; i < e.changedTouches.length; i++) {
            var a = e.changedTouches[i]
            Qt(a.button) && (a.button = 0),
              Qt(a.buttons) && (a.buttons = 1),
              Qt(a.isPrimary) && (a.isPrimary = e.touches.length === 1 && e.type === 'touchstart'),
              Qt(a.width) && (a.width = a.radiusX || 1),
              Qt(a.height) && (a.height = a.radiusY || 1),
              Qt(a.tiltX) && (a.tiltX = 0),
              Qt(a.tiltY) && (a.tiltY = 0),
              Qt(a.pointerType) && (a.pointerType = 'touch'),
              Qt(a.pointerId) && (a.pointerId = a.identifier || 0),
              Qt(a.pressure) && (a.pressure = a.force || 0.5),
              Qt(a.twist) && (a.twist = 0),
              Qt(a.tangentialPressure) && (a.tangentialPressure = 0),
              (a.isNormalized = !0),
              (a.type = e.type),
              r.push(a)
          }
        else if (n.isMouseEvent(e)) {
          var o = e
          Qt(o.isPrimary) && (o.isPrimary = !0),
            Qt(o.width) && (o.width = 1),
            Qt(o.height) && (o.height = 1),
            Qt(o.tiltX) && (o.tiltX = 0),
            Qt(o.tiltY) && (o.tiltY = 0),
            Qt(o.pointerType) && (o.pointerType = 'mouse'),
            Qt(o.pointerId) && (o.pointerId = YN),
            Qt(o.pressure) && (o.pressure = 0.5),
            Qt(o.twist) && (o.twist = 0),
            Qt(o.tangentialPressure) && (o.tangentialPressure = 0),
            (o.isNormalized = !0),
            r.push(o)
        } else r.push(e)
        return r
      }),
      (t.tag = 'Event'),
      t
    )
  })(),
  Z4 = [
    G.CIRCLE,
    G.ELLIPSE,
    G.IMAGE,
    G.RECT,
    G.LINE,
    G.POLYLINE,
    G.POLYGON,
    G.TEXT,
    G.PATH,
    G.HTML
  ],
  Q4 = (function () {
    function t() {}
    return (
      (t.prototype.isVisible = function (e, n) {
        var r,
          i,
          a = n.cullable
        if (!a.enable) return !0
        var o = n.getRenderBounds()
        if (me.isEmpty(o)) return !1
        var s = e.getFrustum(),
          c =
            (i = (r = n.parentNode) === null || r === void 0 ? void 0 : r.cullable) === null ||
            i === void 0
              ? void 0
              : i.visibilityPlaneMask
        return (
          (a.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(
            n,
            o,
            c || Rr.INDETERMINATE,
            s.planes
          )),
          (a.visible = a.visibilityPlaneMask !== Rr.OUTSIDE),
          a.visible
        )
      }),
      (t.prototype.computeVisibilityWithPlaneMask = function (e, n, r, i) {
        if (r === Rr.OUTSIDE || r === Rr.INSIDE) return r
        for (var a = Rr.INSIDE, o = Z4.indexOf(e.nodeName) > -1, s = 0, c = i.length; s < c; ++s) {
          var l = 1 << s
          if (r & l && !(o && (s === 4 || s === 5))) {
            var u = i[s],
              f = u.normal,
              h = u.distance
            if (Jn(f, n.getPositiveFarPoint(i[s])) + h < 0) return Rr.OUTSIDE
            Jn(f, n.getNegativeFarPoint(i[s])) + h < 0 && (a |= l)
          }
        }
        return a
      }),
      t
    )
  })(),
  J4 = (function () {
    function t() {
      this.toSync = new Set()
    }
    return (
      (t.prototype.apply = function (e) {
        var n = this,
          r = e.renderingService,
          i = e.renderingContext,
          a = e.rBushRoot,
          o = i.root.ownerDocument.defaultView
        this.rBush = a
        var s = function (f) {
            var h = f.target
            ;(h.renderable.dirty = !0), r.dirtify()
          },
          c = function (f) {
            var h = f.detail.affectChildren,
              d = f.target
            h &&
              d.forEach(function (v) {
                n.toSync.add(v)
              })
            for (var p = d; p; ) p.renderable && n.toSync.add(p), (p = p.parentElement)
            r.dirtify()
          },
          l = function (f) {
            var h = f.target
            Y.enableCSSParsing && Y.styleValueRegistry.recalc(h),
              Y.sceneGraphService.dirtifyToRoot(h),
              r.dirtify()
          },
          u = function (f) {
            var h = f.target,
              d = h.rBushNode
            d.aabb && n.rBush.remove(d.aabb),
              n.toSync.delete(h),
              Y.sceneGraphService.dirtifyToRoot(h),
              r.dirtify()
          }
        r.hooks.init.tap(t.tag, function () {
          o.addEventListener(dt.MOUNTED, l),
            o.addEventListener(dt.UNMOUNTED, u),
            o.addEventListener(dt.ATTR_MODIFIED, s),
            o.addEventListener(dt.BOUNDS_CHANGED, c)
        }),
          r.hooks.destroy.tap(t.tag, function () {
            o.removeEventListener(dt.MOUNTED, l),
              o.removeEventListener(dt.UNMOUNTED, u),
              o.removeEventListener(dt.ATTR_MODIFIED, s),
              o.removeEventListener(dt.BOUNDS_CHANGED, c),
              n.toSync.clear()
          }),
          r.hooks.endFrame.tap(t.tag, function () {
            n.syncRTree()
          })
      }),
      (t.prototype.syncRTree = function () {
        var e = this,
          n = []
        Array.from(this.toSync)
          .filter(function (r) {
            return r.isConnected
          })
          .forEach(function (r) {
            var i = r.rBushNode
            i && i.aabb && e.rBush.remove(i.aabb)
            var a = r.getRenderBounds()
            if (a) {
              var o = N(a.getMin(), 2),
                s = o[0],
                c = o[1],
                l = N(a.getMax(), 2),
                u = l[0],
                f = l[1]
              i.aabb || (i.aabb = {}),
                (i.aabb.displayObject = r),
                (i.aabb.minX = s),
                (i.aabb.minY = c),
                (i.aabb.maxX = u),
                (i.aabb.maxY = f)
            }
            i.aabb &&
              !isNaN(i.aabb.maxX) &&
              !isNaN(i.aabb.maxX) &&
              !isNaN(i.aabb.minX) &&
              !isNaN(i.aabb.minY) &&
              n.push(i.aabb)
          }),
          this.rBush.load(n),
          (n.length = 0),
          this.toSync.clear()
      }),
      (t.tag = 'Prepare'),
      t
    )
  })(),
  Je
;(function (t) {
  ;(t.READY = 'ready'),
    (t.BEFORE_RENDER = 'beforerender'),
    (t.RERENDER = 'rerender'),
    (t.AFTER_RENDER = 'afterrender'),
    (t.BEFORE_DESTROY = 'beforedestroy'),
    (t.AFTER_DESTROY = 'afterdestroy'),
    (t.RESIZE = 'resize'),
    (t.DIRTY_RECTANGLE = 'dirtyrectangle'),
    (t.RENDERER_CHANGED = 'rendererchanged')
})(Je || (Je = {}))
var Og = 500,
  tR = 0.1,
  eR = 1e3,
  ff = new Bt(dt.MOUNTED),
  hf = new Bt(dt.UNMOUNTED),
  nR = new Bt(Je.BEFORE_RENDER),
  rR = new Bt(Je.RERENDER),
  iR = new Bt(Je.AFTER_RENDER),
  ew = (function (t) {
    rt(e, t)
    function e(n) {
      var r = t.call(this) || this
      ;(r.Element = Be),
        (r.inited = !1),
        (r.context = {}),
        (r.document = new U4()),
        (r.document.defaultView = r),
        (r.customElements = new X4())
      var i = n.container,
        a = n.canvas,
        o = n.offscreenCanvas,
        s = n.width,
        c = n.height,
        l = n.devicePixelRatio,
        u = n.renderer,
        f = n.background,
        h = n.cursor,
        d = n.document,
        p = n.requestAnimationFrame,
        v = n.cancelAnimationFrame,
        g = n.createImage,
        y = n.supportsPointerEvents,
        m = n.supportsTouchEvents,
        b = n.supportsCSSTransform,
        x = n.supportsMutipleCanvasesInOneContainer,
        w = n.useNativeClickEvent,
        O = n.alwaysTriggerPointerEventOnCanvas,
        S = n.isTouchEvent,
        _ = n.isMouseEvent
      x || $N(i, r)
      var M = s,
        E = c,
        T = l
      return (
        a &&
          ((T = l || (Ls && window.devicePixelRatio) || 1),
          (T = T >= 1 ? Math.ceil(T) : 1),
          (M = s || GN(a) || a.width / T),
          (E = c || WN(a) || a.height / T)),
        o && (Y.offscreenCanvas = o),
        (r.devicePixelRatio = T),
        (r.requestAnimationFrame = p ?? K2.bind(Y.globalThis)),
        (r.cancelAnimationFrame = v ?? Z2.bind(Y.globalThis)),
        (r.supportsTouchEvents = m ?? 'ontouchstart' in Y.globalThis),
        (r.supportsPointerEvents = y ?? !!Y.globalThis.PointerEvent),
        (r.isTouchEvent =
          S ??
          function (C) {
            return r.supportsTouchEvents && C instanceof Y.globalThis.TouchEvent
          }),
        (r.isMouseEvent =
          _ ??
          function (C) {
            return (
              !Y.globalThis.MouseEvent ||
              (C instanceof Y.globalThis.MouseEvent &&
                (!r.supportsPointerEvents || !(C instanceof Y.globalThis.PointerEvent)))
            )
          }),
        r.initRenderingContext({
          container: i,
          canvas: a,
          width: M,
          height: E,
          renderer: u,
          offscreenCanvas: o,
          devicePixelRatio: T,
          cursor: h || 'default',
          background: f || 'transparent',
          createImage: g,
          document: d,
          supportsCSSTransform: b,
          useNativeClickEvent: w,
          alwaysTriggerPointerEventOnCanvas: O
        }),
        r.initDefaultCamera(M, E, u.clipSpaceNearZ),
        r.initRenderer(u, !0),
        r
      )
    }
    return (
      (e.prototype.initRenderingContext = function (n) {
        ;(this.context.config = n),
          (this.context.renderingContext = {
            root: this.document.documentElement,
            renderListCurrentFrame: [],
            unculledEntities: [],
            renderReasons: new Set(),
            force: !1,
            dirty: !1
          })
      }),
      (e.prototype.initDefaultCamera = function (n, r, i) {
        var a = this,
          o = new Y.CameraContribution()
        ;(o.clipSpaceNearZ = i),
          o
            .setType(kt.EXPLORING, ns.DEFAULT)
            .setPosition(n / 2, r / 2, Og)
            .setFocalPoint(n / 2, r / 2, 0)
            .setOrthographic(n / -2, n / 2, r / 2, r / -2, tR, eR),
          (o.canvas = this),
          o.eventEmitter.on(C2.UPDATED, function () {
            a.context.renderingContext.renderReasons.add(Vr.CAMERA_CHANGED)
          }),
          (this.context.camera = o)
      }),
      (e.prototype.getConfig = function () {
        return this.context.config
      }),
      (e.prototype.getRoot = function () {
        return this.document.documentElement
      }),
      (e.prototype.getCamera = function () {
        return this.context.camera
      }),
      (e.prototype.getContextService = function () {
        return this.context.contextService
      }),
      (e.prototype.getEventService = function () {
        return this.context.eventService
      }),
      (e.prototype.getRenderingService = function () {
        return this.context.renderingService
      }),
      (e.prototype.getRenderingContext = function () {
        return this.context.renderingContext
      }),
      (e.prototype.getStats = function () {
        return this.getRenderingService().getStats()
      }),
      Object.defineProperty(e.prototype, 'ready', {
        get: function () {
          var n = this
          return (
            this.readyPromise ||
              ((this.readyPromise = new Promise(function (r) {
                n.resolveReadyPromise = function () {
                  r(n)
                }
              })),
              this.inited && this.resolveReadyPromise()),
            this.readyPromise
          )
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.destroy = function (n, r) {
        if (
          (n === void 0 && (n = !0),
          r === void 0 && (r = !1),
          r || this.dispatchEvent(new Bt(Je.BEFORE_DESTROY)),
          this.frameId)
        ) {
          var i = this.getConfig().cancelAnimationFrame || cancelAnimationFrame
          i(this.frameId)
        }
        var a = this.getRoot()
        this.unmountChildren(a),
          n && (this.document.destroy(), this.getEventService().destroy()),
          this.getRenderingService().destroy(),
          this.getContextService().destroy(),
          n &&
            this.context.rBushRoot &&
            (this.context.rBushRoot.clear(),
            (this.context.rBushRoot = null),
            (this.context.renderingContext.root = null)),
          r || this.dispatchEvent(new Bt(Je.AFTER_DESTROY))
      }),
      (e.prototype.changeSize = function (n, r) {
        this.resize(n, r)
      }),
      (e.prototype.resize = function (n, r) {
        var i = this.context.config
        ;(i.width = n), (i.height = r), this.getContextService().resize(n, r)
        var a = this.context.camera,
          o = a.getProjectionMode()
        a.setPosition(n / 2, r / 2, Og).setFocalPoint(n / 2, r / 2, 0),
          o === qe.ORTHOGRAPHIC
            ? a.setOrthographic(n / -2, n / 2, r / 2, r / -2, a.getNear(), a.getFar())
            : a.setAspect(n / r),
          this.dispatchEvent(new Bt(Je.RESIZE, { width: n, height: r }))
      }),
      (e.prototype.appendChild = function (n, r) {
        return this.document.documentElement.appendChild(n, r)
      }),
      (e.prototype.insertBefore = function (n, r) {
        return this.document.documentElement.insertBefore(n, r)
      }),
      (e.prototype.removeChild = function (n) {
        return this.document.documentElement.removeChild(n)
      }),
      (e.prototype.removeChildren = function () {
        this.document.documentElement.removeChildren()
      }),
      (e.prototype.destroyChildren = function () {
        this.document.documentElement.destroyChildren()
      }),
      (e.prototype.render = function () {
        var n = this
        this.dispatchEvent(nR)
        var r = this.getRenderingService()
        r.render(this.getConfig(), function () {
          n.dispatchEvent(rR)
        }),
          this.dispatchEvent(iR)
      }),
      (e.prototype.run = function () {
        var n = this,
          r = function () {
            n.render(), (n.frameId = n.requestAnimationFrame(r))
          }
        r()
      }),
      (e.prototype.initRenderer = function (n, r) {
        var i = this
        if ((r === void 0 && (r = !1), !n)) throw new Error('Renderer is required.')
        ;(this.inited = !1),
          (this.readyPromise = void 0),
          (this.context.rBushRoot = new rL()),
          (this.context.renderingPlugins = []),
          this.context.renderingPlugins.push(new K4(), new J4(), new q4([new Q4()])),
          this.loadRendererContainerModule(n),
          (this.context.contextService = new this.context.ContextService(
            z(z({}, Y), this.context)
          )),
          (this.context.renderingService = new x4(Y, this.context)),
          (this.context.eventService = new m4(Y, this.context)),
          this.context.eventService.init(),
          this.context.contextService.init
            ? (this.context.contextService.init(), this.initRenderingService(n, r, !0))
            : this.context.contextService.initAsync().then(function () {
                i.initRenderingService(n, r)
              })
      }),
      (e.prototype.initRenderingService = function (n, r, i) {
        var a = this
        r === void 0 && (r = !1),
          i === void 0 && (i = !1),
          this.context.renderingService.init(function () {
            ;(a.inited = !0),
              r
                ? (i
                    ? a.requestAnimationFrame(function () {
                        a.dispatchEvent(new Bt(Je.READY))
                      })
                    : a.dispatchEvent(new Bt(Je.READY)),
                  a.readyPromise && a.resolveReadyPromise())
                : a.dispatchEvent(new Bt(Je.RENDERER_CHANGED)),
              r ||
                a.getRoot().forEach(function (o) {
                  var s = o.renderable
                  s && ((s.renderBoundsDirty = !0), (s.boundsDirty = !0), (s.dirty = !0))
                }),
              a.mountChildren(a.getRoot()),
              n.getConfig().enableAutoRendering && a.run()
          })
      }),
      (e.prototype.loadRendererContainerModule = function (n) {
        var r = this,
          i = n.getPlugins()
        i.forEach(function (a) {
          ;(a.context = r.context), a.init(Y)
        })
      }),
      (e.prototype.setRenderer = function (n) {
        var r = this.getConfig()
        if (r.renderer !== n) {
          var i = r.renderer
          ;(r.renderer = n),
            this.destroy(!1, !0),
            q([], N(i == null ? void 0 : i.getPlugins()), !1)
              .reverse()
              .forEach(function (a) {
                a.destroy(Y)
              }),
            this.initRenderer(n)
        }
      }),
      (e.prototype.setCursor = function (n) {
        var r = this.getConfig()
        ;(r.cursor = n), this.getContextService().applyCursorStyle(n)
      }),
      (e.prototype.unmountChildren = function (n) {
        var r = this
        n.childNodes.forEach(function (i) {
          r.unmountChildren(i)
        }),
          this.inited &&
            (n.isMutationObserved
              ? n.dispatchEvent(hf)
              : ((hf.target = n), this.dispatchEvent(hf, !0)),
            n !== this.document.documentElement && (n.ownerDocument = null),
            (n.isConnected = !1)),
          n.isCustomElement && n.disconnectedCallback && n.disconnectedCallback()
      }),
      (e.prototype.mountChildren = function (n) {
        var r = this
        this.inited
          ? n.isConnected ||
            ((n.ownerDocument = this.document),
            (n.isConnected = !0),
            n.isMutationObserved
              ? n.dispatchEvent(ff)
              : ((ff.target = n), this.dispatchEvent(ff, !0)))
          : console.warn(
              "[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.",
              'appended child: ',
              n.nodeName
            ),
          n.childNodes.forEach(function (i) {
            r.mountChildren(i)
          }),
          n.isCustomElement && n.connectedCallback && n.connectedCallback()
      }),
      (e.prototype.client2Viewport = function (n) {
        return this.getEventService().client2Viewport(n)
      }),
      (e.prototype.viewport2Client = function (n) {
        return this.getEventService().viewport2Client(n)
      }),
      (e.prototype.viewport2Canvas = function (n) {
        return this.getEventService().viewport2Canvas(n)
      }),
      (e.prototype.canvas2Viewport = function (n) {
        return this.getEventService().canvas2Viewport(n)
      }),
      (e.prototype.getPointByClient = function (n, r) {
        return this.client2Viewport({ x: n, y: r })
      }),
      (e.prototype.getClientByPoint = function (n, r) {
        return this.viewport2Client({ x: n, y: r })
      }),
      e
    )
  })(J2),
  aR = (function (t) {
    rt(e, t)
    function e() {
      var n = (t !== null && t.apply(this, arguments)) || this
      return (n.landmarks = []), n
    }
    return (
      (e.prototype.rotate = function (n, r, i) {
        if (
          ((this.relElevation = ba(r)),
          (this.relAzimuth = ba(n)),
          (this.relRoll = ba(i)),
          (this.elevation += this.relElevation),
          (this.azimuth += this.relAzimuth),
          (this.roll += this.relRoll),
          this.type === kt.EXPLORING)
        ) {
          var a = Br(pe(), [1, 0, 0], Jt((this.rotateWorld ? 1 : -1) * this.relElevation)),
            o = Br(pe(), [0, 1, 0], Jt((this.rotateWorld ? 1 : -1) * this.relAzimuth)),
            s = Br(pe(), [0, 0, 1], Jt(this.relRoll)),
            c = Wr(pe(), o, a)
          c = Wr(pe(), c, s)
          var l = zd(Nt(), c)
          Gr(this.matrix, this.matrix, [0, 0, -this.distance]),
            Re(this.matrix, this.matrix, l),
            Gr(this.matrix, this.matrix, [0, 0, this.distance])
        } else {
          if (Math.abs(this.elevation) > 90) return this
          this.computeMatrix()
        }
        return (
          this._getAxes(),
          this.type === kt.ORBITING || this.type === kt.EXPLORING
            ? this._getPosition()
            : this.type === kt.TRACKING && this._getFocalPoint(),
          this._update(),
          this
        )
      }),
      (e.prototype.pan = function (n, r) {
        var i = Ge(n, r, 0),
          a = dr(this.position)
        return (
          va(a, a, Jf(yt(), this.right, i[0])),
          va(a, a, Jf(yt(), this.up, i[1])),
          this._setPosition(a),
          this.triggerUpdate(),
          this
        )
      }),
      (e.prototype.dolly = function (n) {
        var r = this.forward,
          i = dr(this.position),
          a = n * this.dollyingStep,
          o = this.distance + n * this.dollyingStep
        return (
          (a = Math.max(Math.min(o, this.maxDistance), this.minDistance) - this.distance),
          (i[0] += a * r[0]),
          (i[1] += a * r[1]),
          (i[2] += a * r[2]),
          this._setPosition(i),
          this.type === kt.ORBITING || this.type === kt.EXPLORING
            ? this._getDistance()
            : this.type === kt.TRACKING && va(this.focalPoint, i, this.distanceVector),
          this.triggerUpdate(),
          this
        )
      }),
      (e.prototype.cancelLandmarkAnimation = function () {
        this.landmarkAnimationID !== void 0 &&
          this.canvas.cancelAnimationFrame(this.landmarkAnimationID)
      }),
      (e.prototype.createLandmark = function (n, r) {
        var i, a, o, s
        r === void 0 && (r = {})
        var c = r.position,
          l = c === void 0 ? this.position : c,
          u = r.focalPoint,
          f = u === void 0 ? this.focalPoint : u,
          h = r.roll,
          d = r.zoom,
          p = new Y.CameraContribution()
        p.setType(this.type, void 0),
          p.setPosition(
            l[0],
            (i = l[1]) !== null && i !== void 0 ? i : this.position[1],
            (a = l[2]) !== null && a !== void 0 ? a : this.position[2]
          ),
          p.setFocalPoint(
            f[0],
            (o = f[1]) !== null && o !== void 0 ? o : this.focalPoint[1],
            (s = f[2]) !== null && s !== void 0 ? s : this.focalPoint[2]
          ),
          p.setRoll(h ?? this.roll),
          p.setZoom(d ?? this.zoom)
        var v = {
          name: n,
          matrix: $d(p.getWorldTransform()),
          right: dr(p.right),
          up: dr(p.up),
          forward: dr(p.forward),
          position: dr(p.getPosition()),
          focalPoint: dr(p.getFocalPoint()),
          distanceVector: dr(p.getDistanceVector()),
          distance: p.getDistance(),
          dollyingStep: p.getDollyingStep(),
          azimuth: p.getAzimuth(),
          elevation: p.getElevation(),
          roll: p.getRoll(),
          relAzimuth: p.relAzimuth,
          relElevation: p.relElevation,
          relRoll: p.relRoll,
          zoom: p.getZoom()
        }
        return this.landmarks.push(v), v
      }),
      (e.prototype.gotoLandmark = function (n, r) {
        var i = this
        r === void 0 && (r = {})
        var a = ne(n)
          ? this.landmarks.find(function (E) {
              return E.name === n
            })
          : n
        if (a) {
          var o = ve(r) ? { duration: r } : r,
            s = o.easing,
            c = s === void 0 ? 'linear' : s,
            l = o.duration,
            u = l === void 0 ? 100 : l,
            f = o.easingFunction,
            h = f === void 0 ? void 0 : f,
            d = o.onfinish,
            p = d === void 0 ? void 0 : d,
            v = o.onframe,
            g = v === void 0 ? void 0 : v,
            y = 0.01
          if (u === 0) {
            this.syncFromLandmark(a), p && p()
            return
          }
          this.cancelLandmarkAnimation()
          var m = a.position,
            b = a.focalPoint,
            x = a.zoom,
            w = a.roll,
            O = h || Y.EasingFunction(c),
            S,
            _ = function () {
              i.setFocalPoint(b),
                i.setPosition(m),
                i.setRoll(w),
                i.setZoom(x),
                i.computeMatrix(),
                i.triggerUpdate(),
                p && p()
            },
            M = function (E) {
              S === void 0 && (S = E)
              var T = E - S
              if (T > u) {
                _()
                return
              }
              var C = O(T / u),
                A = yt(),
                P = yt(),
                k = 1,
                L = 0
              th(A, i.focalPoint, b, C),
                th(P, i.position, m, C),
                (L = i.roll * (1 - C) + w * C),
                (k = i.zoom * (1 - C) + x * C),
                i.setFocalPoint(A),
                i.setPosition(P),
                i.setRoll(L),
                i.setZoom(k)
              var R = dv(A, b) + dv(P, m)
              if (R <= y && x == null && w == null) {
                _()
                return
              }
              i.computeMatrix(),
                i.triggerUpdate(),
                T < u && (g && g(C), (i.landmarkAnimationID = i.canvas.requestAnimationFrame(M)))
            }
          this.canvas.requestAnimationFrame(M)
        }
      }),
      (e.prototype.syncFromLandmark = function (n) {
        ;(this.matrix = Li(this.matrix, n.matrix)),
          (this.right = Qe(this.right, n.right)),
          (this.up = Qe(this.up, n.up)),
          (this.forward = Qe(this.forward, n.forward)),
          (this.position = Qe(this.position, n.position)),
          (this.focalPoint = Qe(this.focalPoint, n.focalPoint)),
          (this.distanceVector = Qe(this.distanceVector, n.distanceVector)),
          (this.azimuth = n.azimuth),
          (this.elevation = n.elevation),
          (this.roll = n.roll),
          (this.relAzimuth = n.relAzimuth),
          (this.relElevation = n.relElevation),
          (this.relRoll = n.relRoll),
          (this.dollyingStep = n.dollyingStep),
          (this.distance = n.distance),
          (this.zoom = n.zoom)
      }),
      e
    )
  })(L2)
Y.CameraContribution = aR
var df = (function (t) {
    rt(e, t)
    function e(n, r, i, a) {
      var o = t.call(this, n) || this
      return (
        (o.currentTime = i),
        (o.timelineTime = a),
        (o.target = r),
        (o.type = 'finish'),
        (o.bubbles = !1),
        (o.currentTarget = r),
        (o.defaultPrevented = !1),
        (o.eventPhase = o.AT_TARGET),
        (o.timeStamp = Date.now()),
        (o.currentTime = i),
        (o.timelineTime = a),
        o
      )
    }
    return e
  })(hu),
  oR = 0,
  sR = (function () {
    function t(e, n) {
      var r
      ;(this.currentTimePending = !1),
        (this._idle = !0),
        (this._paused = !1),
        (this._finishedFlag = !0),
        (this._currentTime = 0),
        (this._playbackRate = 1),
        (this._inTimeline = !0),
        (this.effect = e),
        (e.animation = this),
        (this.timeline = n),
        (this.id = ''.concat(oR++)),
        (this._inEffect = !!this.effect.update(0)),
        (this._totalDuration = Number(
          (r = this.effect) === null || r === void 0 ? void 0 : r.getComputedTiming().endTime
        )),
        (this._holdTime = 0),
        (this._paused = !1),
        (this.oldPlayState = 'idle'),
        this.updatePromises()
    }
    return (
      Object.defineProperty(t.prototype, 'pending', {
        get: function () {
          return (
            (this._startTime === null && !this._paused && this.playbackRate !== 0) ||
            this.currentTimePending
          )
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'playState', {
        get: function () {
          return this._idle
            ? 'idle'
            : this._isFinished
            ? 'finished'
            : this._paused
            ? 'paused'
            : 'running'
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'ready', {
        get: function () {
          var e = this
          return (
            this.readyPromise ||
              (this.timeline.animationsWithPromises.indexOf(this) === -1 &&
                this.timeline.animationsWithPromises.push(this),
              (this.readyPromise = new Promise(function (n, r) {
                ;(e.resolveReadyPromise = function () {
                  n(e)
                }),
                  (e.rejectReadyPromise = function () {
                    r(new Error())
                  })
              })),
              this.pending || this.resolveReadyPromise()),
            this.readyPromise
          )
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'finished', {
        get: function () {
          var e = this
          return (
            this.finishedPromise ||
              (this.timeline.animationsWithPromises.indexOf(this) === -1 &&
                this.timeline.animationsWithPromises.push(this),
              (this.finishedPromise = new Promise(function (n, r) {
                ;(e.resolveFinishedPromise = function () {
                  n(e)
                }),
                  (e.rejectFinishedPromise = function () {
                    r(new Error())
                  })
              })),
              this.playState === 'finished' && this.resolveFinishedPromise()),
            this.finishedPromise
          )
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'currentTime', {
        get: function () {
          return (
            this.updatePromises(), this._idle || this.currentTimePending ? null : this._currentTime
          )
        },
        set: function (e) {
          var n
          ;(e = Number(e)),
            !isNaN(e) &&
              (this.timeline.restart(),
              !this._paused &&
                this._startTime !== null &&
                (this._startTime =
                  Number((n = this.timeline) === null || n === void 0 ? void 0 : n.currentTime) -
                  e / this.playbackRate),
              (this.currentTimePending = !1),
              this._currentTime !== e &&
                (this._idle && ((this._idle = !1), (this._paused = !0)),
                this.tickCurrentTime(e, !0),
                this.timeline.applyDirtiedAnimation(this)))
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'startTime', {
        get: function () {
          return this._startTime
        },
        set: function (e) {
          if (e !== null) {
            if ((this.updatePromises(), (e = Number(e)), isNaN(e) || this._paused || this._idle))
              return
            ;(this._startTime = e),
              this.tickCurrentTime(
                (Number(this.timeline.currentTime) - this._startTime) * this.playbackRate
              ),
              this.timeline.applyDirtiedAnimation(this),
              this.updatePromises()
          }
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'playbackRate', {
        get: function () {
          return this._playbackRate
        },
        set: function (e) {
          if (e !== this._playbackRate) {
            this.updatePromises()
            var n = this.currentTime
            ;(this._playbackRate = e),
              (this.startTime = null),
              this.playState !== 'paused' &&
                this.playState !== 'idle' &&
                ((this._finishedFlag = !1),
                (this._idle = !1),
                this.ensureAlive(),
                this.timeline.applyDirtiedAnimation(this)),
              n !== null && (this.currentTime = n),
              this.updatePromises()
          }
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, '_isFinished', {
        get: function () {
          return (
            !this._idle &&
            ((this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration) ||
              (this._playbackRate < 0 && Number(this._currentTime) <= 0))
          )
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, 'totalDuration', {
        get: function () {
          return this._totalDuration
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(t.prototype, '_needsTick', {
        get: function () {
          return this.pending || this.playState === 'running' || !this._finishedFlag
        },
        enumerable: !1,
        configurable: !0
      }),
      (t.prototype.updatePromises = function () {
        var e = this.oldPlayState,
          n = this.pending ? 'pending' : this.playState
        return (
          this.readyPromise &&
            n !== e &&
            (n === 'idle'
              ? (this.rejectReadyPromise(), (this.readyPromise = void 0))
              : e === 'pending'
              ? this.resolveReadyPromise()
              : n === 'pending' && (this.readyPromise = void 0)),
          this.finishedPromise &&
            n !== e &&
            (n === 'idle'
              ? (this.rejectFinishedPromise(), (this.finishedPromise = void 0))
              : n === 'finished'
              ? this.resolveFinishedPromise()
              : e === 'finished' && (this.finishedPromise = void 0)),
          (this.oldPlayState = n),
          this.readyPromise || this.finishedPromise
        )
      }),
      (t.prototype.play = function () {
        this.updatePromises(),
          (this._paused = !1),
          (this._isFinished || this._idle) && (this.rewind(), (this._startTime = null)),
          (this._finishedFlag = !1),
          (this._idle = !1),
          this.ensureAlive(),
          this.timeline.applyDirtiedAnimation(this),
          this.timeline.animations.indexOf(this) === -1 && this.timeline.animations.push(this),
          this.updatePromises()
      }),
      (t.prototype.pause = function () {
        this.updatePromises(),
          this.currentTime && (this._holdTime = this.currentTime),
          !this._isFinished && !this._paused && !this._idle
            ? (this.currentTimePending = !0)
            : this._idle && (this.rewind(), (this._idle = !1)),
          (this._startTime = null),
          (this._paused = !0),
          this.updatePromises()
      }),
      (t.prototype.finish = function () {
        this.updatePromises(),
          !this._idle &&
            ((this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0),
            (this._startTime = this._totalDuration - this.currentTime),
            (this.currentTimePending = !1),
            this.timeline.applyDirtiedAnimation(this),
            this.updatePromises())
      }),
      (t.prototype.cancel = function () {
        var e = this
        if (
          (this.updatePromises(),
          !!this._inEffect &&
            ((this._inEffect = !1),
            (this._idle = !0),
            (this._paused = !1),
            (this._finishedFlag = !0),
            (this._currentTime = 0),
            (this._startTime = null),
            this.effect.update(null),
            this.timeline.applyDirtiedAnimation(this),
            this.updatePromises(),
            this.oncancel))
        ) {
          var n = new df(null, this, this.currentTime, null)
          setTimeout(function () {
            e.oncancel(n)
          })
        }
      }),
      (t.prototype.reverse = function () {
        this.updatePromises()
        var e = this.currentTime
        ;(this.playbackRate *= -1),
          this.play(),
          e !== null && (this.currentTime = e),
          this.updatePromises()
      }),
      (t.prototype.updatePlaybackRate = function (e) {
        this.playbackRate = e
      }),
      (t.prototype.targetAnimations = function () {
        var e,
          n = (e = this.effect) === null || e === void 0 ? void 0 : e.target
        return n.getAnimations()
      }),
      (t.prototype.markTarget = function () {
        var e = this.targetAnimations()
        e.indexOf(this) === -1 && e.push(this)
      }),
      (t.prototype.unmarkTarget = function () {
        var e = this.targetAnimations(),
          n = e.indexOf(this)
        n !== -1 && e.splice(n, 1)
      }),
      (t.prototype.tick = function (e, n) {
        !this._idle &&
          !this._paused &&
          (this._startTime === null
            ? n && (this.startTime = e - this._currentTime / this.playbackRate)
            : this._isFinished || this.tickCurrentTime((e - this._startTime) * this.playbackRate)),
          n && ((this.currentTimePending = !1), this.fireEvents(e))
      }),
      (t.prototype.rewind = function () {
        if (this.playbackRate >= 0) this.currentTime = 0
        else if (this._totalDuration < 1 / 0) this.currentTime = this._totalDuration
        else
          throw new Error(
            'Unable to rewind negative playback rate animation with infinite duration'
          )
      }),
      (t.prototype.persist = function () {
        throw new Error(It)
      }),
      (t.prototype.addEventListener = function (e, n, r) {
        throw new Error(It)
      }),
      (t.prototype.removeEventListener = function (e, n, r) {
        throw new Error(It)
      }),
      (t.prototype.dispatchEvent = function (e) {
        throw new Error(It)
      }),
      (t.prototype.commitStyles = function () {
        throw new Error(It)
      }),
      (t.prototype.ensureAlive = function () {
        var e, n
        this.playbackRate < 0 && this.currentTime === 0
          ? (this._inEffect = !!(!((e = this.effect) === null || e === void 0) && e.update(-1)))
          : (this._inEffect = !!(
              !((n = this.effect) === null || n === void 0) && n.update(this.currentTime)
            )),
          !this._inTimeline &&
            (this._inEffect || !this._finishedFlag) &&
            ((this._inTimeline = !0), this.timeline.animations.push(this))
      }),
      (t.prototype.tickCurrentTime = function (e, n) {
        e !== this._currentTime &&
          ((this._currentTime = e),
          this._isFinished &&
            !n &&
            (this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0),
          this.ensureAlive())
      }),
      (t.prototype.fireEvents = function (e) {
        var n = this
        if (this._isFinished) {
          if (!this._finishedFlag) {
            if (this.onfinish) {
              var r = new df(null, this, this.currentTime, e)
              setTimeout(function () {
                n.onfinish && n.onfinish(r)
              })
            }
            this._finishedFlag = !0
          }
        } else {
          if (this.onframe && this.playState === 'running') {
            var i = new df(null, this, this.currentTime, e)
            this.onframe(i)
          }
          this._finishedFlag = !1
        }
      }),
      t
    )
  })(),
  cR = 4,
  lR = 0.001,
  uR = 1e-7,
  fR = 10,
  xo = 11,
  rc = 1 / (xo - 1),
  hR = typeof Float32Array == 'function',
  nw = function (t, e) {
    return 1 - 3 * e + 3 * t
  },
  rw = function (t, e) {
    return 3 * e - 6 * t
  },
  iw = function (t) {
    return 3 * t
  },
  hl = function (t, e, n) {
    return ((nw(e, n) * t + rw(e, n)) * t + iw(e)) * t
  },
  aw = function (t, e, n) {
    return 3 * nw(e, n) * t * t + 2 * rw(e, n) * t + iw(e)
  },
  dR = function (t, e, n, r, i) {
    var a,
      o,
      s = 0
    do (o = e + (n - e) / 2), (a = hl(o, r, i) - t), a > 0 ? (n = o) : (e = o)
    while (Math.abs(a) > uR && ++s < fR)
    return o
  },
  pR = function (t, e, n, r) {
    for (var i = 0; i < cR; ++i) {
      var a = aw(e, n, r)
      if (a === 0) return e
      var o = hl(e, n, r) - t
      e -= o / a
    }
    return e
  },
  Tp = function (t, e, n, r) {
    if (!(0 <= t && t <= 1 && 0 <= n && n <= 1))
      throw new Error('bezier x values must be in [0, 1] range')
    if (t === e && n === r)
      return function (s) {
        return s
      }
    for (var i = hR ? new Float32Array(xo) : new Array(xo), a = 0; a < xo; ++a)
      i[a] = hl(a * rc, t, n)
    var o = function (s) {
      for (var c = 0, l = 1, u = xo - 1; l !== u && i[l] <= s; ++l) c += rc
      --l
      var f = (s - i[l]) / (i[l + 1] - i[l]),
        h = c + f * rc,
        d = aw(h, t, n)
      return d >= lR ? pR(s, h, t, n) : d === 0 ? h : dR(s, c, c + rc, t, n)
    }
    return function (s) {
      return s === 0 || s === 1 ? s : hl(o(s), e, r)
    }
  },
  vR = function (t) {
    return (
      (t = t.replace(/([A-Z])/g, function (e) {
        return '-'.concat(e.toLowerCase())
      })),
      t.charAt(0) === '-' ? t.substring(1) : t
    )
  },
  ic = function (t) {
    return Math.pow(t, 2)
  },
  ac = function (t) {
    return Math.pow(t, 3)
  },
  oc = function (t) {
    return Math.pow(t, 4)
  },
  sc = function (t) {
    return Math.pow(t, 5)
  },
  cc = function (t) {
    return Math.pow(t, 6)
  },
  lc = function (t) {
    return 1 - Math.cos((t * Math.PI) / 2)
  },
  uc = function (t) {
    return 1 - Math.sqrt(1 - t * t)
  },
  fc = function (t) {
    return t * t * (3 * t - 2)
  },
  hc = function (t) {
    for (var e, n = 4; t < ((e = Math.pow(2, --n)) - 1) / 11; );
    return 1 / Math.pow(4, 3 - n) - 7.5625 * Math.pow((e * 3 - 2) / 22 - t, 2)
  },
  dc = function (t, e) {
    e === void 0 && (e = [])
    var n = N(e, 2),
      r = n[0],
      i = r === void 0 ? 1 : r,
      a = n[1],
      o = a === void 0 ? 0.5 : a,
      s = se(Number(i), 1, 10),
      c = se(Number(o), 0.1, 2)
    return t === 0 || t === 1
      ? t
      : -s *
          Math.pow(2, 10 * (t - 1)) *
          Math.sin(((t - 1 - (c / (Math.PI * 2)) * Math.asin(1 / s)) * (Math.PI * 2)) / c)
  },
  po = function (t, e, n) {
    e === void 0 && (e = [])
    var r = N(e, 4),
      i = r[0],
      a = i === void 0 ? 1 : i,
      o = r[1],
      s = o === void 0 ? 100 : o,
      c = r[2],
      l = c === void 0 ? 10 : c,
      u = r[3],
      f = u === void 0 ? 0 : u
    ;(a = se(a, 0.1, 1e3)), (s = se(s, 0.1, 1e3)), (l = se(l, 0.1, 1e3)), (f = se(f, 0.1, 1e3))
    var h = Math.sqrt(s / a),
      d = l / (2 * Math.sqrt(s * a)),
      p = d < 1 ? h * Math.sqrt(1 - d * d) : 0,
      v = 1,
      g = d < 1 ? (d * h + -f) / p : -f + h,
      y = n ? (n * t) / 1e3 : t
    return (
      d < 1
        ? (y = Math.exp(-y * d * h) * (v * Math.cos(p * y) + g * Math.sin(p * y)))
        : (y = (v + g * y) * Math.exp(-y * h)),
      t === 0 || t === 1 ? t : 1 - y
    )
  },
  pf = function (t, e) {
    e === void 0 && (e = [])
    var n = N(e, 2),
      r = n[0],
      i = r === void 0 ? 10 : r,
      a = n[1],
      o = a == 'start' ? Math.ceil : Math.floor
    return o(se(t, 0, 1) * i) / i
  },
  Sg = function (t, e) {
    e === void 0 && (e = [])
    var n = N(e, 4),
      r = n[0],
      i = n[1],
      a = n[2],
      o = n[3]
    return Tp(r, i, a, o)(t)
  },
  pc = Tp(0.42, 0, 1, 1),
  wn = function (t) {
    return function (e, n, r) {
      return n === void 0 && (n = []), 1 - t(1 - e, n, r)
    }
  },
  On = function (t) {
    return function (e, n, r) {
      return n === void 0 && (n = []), e < 0.5 ? t(e * 2, n, r) / 2 : 1 - t(e * -2 + 2, n, r) / 2
    }
  },
  Sn = function (t) {
    return function (e, n, r) {
      return (
        n === void 0 && (n = []),
        e < 0.5 ? (1 - t(1 - e * 2, n, r)) / 2 : (t(e * 2 - 1, n, r) + 1) / 2
      )
    }
  },
  _g = {
    steps: pf,
    'step-start': function (t) {
      return pf(t, [1, 'start'])
    },
    'step-end': function (t) {
      return pf(t, [1, 'end'])
    },
    linear: function (t) {
      return t
    },
    'cubic-bezier': Sg,
    ease: function (t) {
      return Sg(t, [0.25, 0.1, 0.25, 1])
    },
    in: pc,
    out: wn(pc),
    'in-out': On(pc),
    'out-in': Sn(pc),
    'in-quad': ic,
    'out-quad': wn(ic),
    'in-out-quad': On(ic),
    'out-in-quad': Sn(ic),
    'in-cubic': ac,
    'out-cubic': wn(ac),
    'in-out-cubic': On(ac),
    'out-in-cubic': Sn(ac),
    'in-quart': oc,
    'out-quart': wn(oc),
    'in-out-quart': On(oc),
    'out-in-quart': Sn(oc),
    'in-quint': sc,
    'out-quint': wn(sc),
    'in-out-quint': On(sc),
    'out-in-quint': Sn(sc),
    'in-expo': cc,
    'out-expo': wn(cc),
    'in-out-expo': On(cc),
    'out-in-expo': Sn(cc),
    'in-sine': lc,
    'out-sine': wn(lc),
    'in-out-sine': On(lc),
    'out-in-sine': Sn(lc),
    'in-circ': uc,
    'out-circ': wn(uc),
    'in-out-circ': On(uc),
    'out-in-circ': Sn(uc),
    'in-back': fc,
    'out-back': wn(fc),
    'in-out-back': On(fc),
    'out-in-back': Sn(fc),
    'in-bounce': hc,
    'out-bounce': wn(hc),
    'in-out-bounce': On(hc),
    'out-in-bounce': Sn(hc),
    'in-elastic': dc,
    'out-elastic': wn(dc),
    'in-out-elastic': On(dc),
    'out-in-elastic': Sn(dc),
    spring: po,
    'spring-in': po,
    'spring-out': wn(po),
    'spring-in-out': On(po),
    'spring-out-in': Sn(po)
  },
  gR = function (t) {
    return vR(t)
      .replace(/^ease-/, '')
      .replace(/(\(|\s).+/, '')
      .toLowerCase()
      .trim()
  },
  yR = function (t) {
    return _g[gR(t)] || _g.linear
  },
  mR = function (t) {
    return t
  },
  bR = 1,
  xR = 0.5,
  Mg = 0
function Eg(t, e) {
  return function (n) {
    if (n >= 1) return 1
    var r = 1 / t
    return (n += e * r), n - (n % r)
  }
}
var vc = '\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*',
  wR = new RegExp('cubic-bezier\\(' + vc + ',' + vc + ',' + vc + ',' + vc + '\\)'),
  OR = /steps\(\s*(\d+)\s*\)/,
  SR = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/
function Pp(t) {
  var e = wR.exec(t)
  if (e) return Tp.apply(void 0, q([], N(e.slice(1).map(Number)), !1))
  var n = OR.exec(t)
  if (n) return Eg(Number(n[1]), Mg)
  var r = SR.exec(t)
  return r ? Eg(Number(r[1]), { start: bR, middle: xR, end: Mg }[r[2]]) : yR(t)
}
function _R(t) {
  return Math.abs(MR(t) / (t.playbackRate || 1))
}
function MR(t) {
  var e
  return t.duration === 0 || t.iterations === 0
    ? 0
    : (t.duration === 'auto' ? 0 : Number(t.duration)) *
        ((e = t.iterations) !== null && e !== void 0 ? e : 1)
}
var ow = 0,
  Ap = 1,
  vu = 2,
  sw = 3
function ER(t, e, n) {
  if (e === null) return ow
  var r = n.endTime
  return e < Math.min(n.delay, r) ? Ap : e >= Math.min(n.delay + t + n.endDelay, r) ? vu : sw
}
function TR(t, e, n, r, i) {
  switch (r) {
    case Ap:
      return e === 'backwards' || e === 'both' ? 0 : null
    case sw:
      return n - i
    case vu:
      return e === 'forwards' || e === 'both' ? t : null
    case ow:
      return null
  }
}
function PR(t, e, n, r, i) {
  var a = i
  return t === 0 ? e !== Ap && (a += n) : (a += r / t), a
}
function AR(t, e, n, r, i, a) {
  var o = t === 1 / 0 ? e % 1 : t % 1
  return o === 0 && n === vu && r !== 0 && (i !== 0 || a === 0) && (o = 1), o
}
function kR(t, e, n, r) {
  return t === vu && e === 1 / 0 ? 1 / 0 : n === 1 ? Math.floor(r) - 1 : Math.floor(r)
}
function CR(t, e, n) {
  var r = t
  if (t !== 'normal' && t !== 'reverse') {
    var i = e
    t === 'alternate-reverse' && (i += 1),
      (r = 'normal'),
      i !== 1 / 0 && i % 2 !== 0 && (r = 'reverse')
  }
  return r === 'normal' ? n : 1 - n
}
function LR(t, e, n) {
  var r = ER(t, e, n),
    i = TR(t, n.fill, e, r, n.delay)
  if (i === null) return null
  var a = n.duration === 'auto' ? 0 : n.duration,
    o = PR(a, r, n.iterations, i, n.iterationStart),
    s = AR(o, n.iterationStart, r, n.iterations, i, a),
    c = kR(r, n.iterations, s, o),
    l = CR(n.direction, c, s)
  return (n.currentIteration = c), (n.progress = l), n.easingFunction(l)
}
function NR(t, e, n) {
  var r = RR(t, e),
    i = IR(r, n)
  return function (a, o) {
    if (o !== null)
      i.filter(function (c) {
        return o >= c.applyFrom && o < c.applyTo
      }).forEach(function (c) {
        var l = o - c.startOffset,
          u = c.endOffset - c.startOffset,
          f = u === 0 ? 0 : c.easingFunction(l / u)
        a.setAttribute(c.property, c.interpolation(f))
      })
    else for (var s in r) cw(s) && a.setAttribute(s, null)
  }
}
function cw(t) {
  return t !== 'offset' && t !== 'easing' && t !== 'composite' && t !== 'computedOffset'
}
function RR(t, e) {
  for (var n = {}, r = 0; r < t.length; r++)
    for (var i in t[r])
      if (cw(i)) {
        var a = {
          offset: t[r].offset,
          computedOffset: t[r].computedOffset,
          easing: t[r].easing,
          easingFunction: Pp(t[r].easing) || e.easingFunction,
          value: t[r][i]
        }
        ;(n[i] = n[i] || []), n[i].push(a)
      }
  return n
}
function IR(t, e) {
  var n = []
  for (var r in t)
    for (var i = t[r], a = 0; a < i.length - 1; a++) {
      var o = a,
        s = a + 1,
        c = i[o].computedOffset,
        l = i[s].computedOffset,
        u = c,
        f = l
      a === 0 && ((u = -1 / 0), l === 0 && (s = o)),
        a === i.length - 2 && ((f = 1 / 0), c === 1 && (o = s)),
        n.push({
          applyFrom: u,
          applyTo: f,
          startOffset: i[o].computedOffset,
          endOffset: i[s].computedOffset,
          easingFunction: i[o].easingFunction,
          property: r,
          interpolation: jR(r, i[o].value, i[s].value, e)
        })
    }
  return (
    n.sort(function (h, d) {
      return h.startOffset - d.startOffset
    }),
    n
  )
}
var Tg = function (t, e, n) {
  return function (r) {
    var i = lw(t, e, r)
    return !Y.enableCSSParsing && ve(i) ? i : n(i)
  }
}
function jR(t, e, n, r) {
  var i = Lr[t]
  if (i && i.syntax && i.int) {
    var a = Y.styleValueRegistry.getPropertySyntax(i.syntax)
    if (a) {
      var o = void 0,
        s = void 0
      if (Y.enableCSSParsing) {
        var c = Y.styleValueRegistry.parseProperty(t, e, r),
          l = Y.styleValueRegistry.parseProperty(t, n, r)
        ;(o = Y.styleValueRegistry.computeProperty(t, c, r)),
          (s = Y.styleValueRegistry.computeProperty(t, l, r))
      } else {
        var u = a.parserWithCSSDisabled
        ;(o = u ? u(e, r) : e), (s = u ? u(n, r) : n)
      }
      var f = a.mixer(o, s, r)
      if (f) {
        var h = Tg.apply(void 0, q([], N(f), !1))
        return function (d) {
          return d === 0 ? e : d === 1 ? n : h(d)
        }
      }
    }
  }
  return Tg(!1, !0, function (d) {
    return d ? n : e
  })
}
function lw(t, e, n) {
  if (typeof t == 'number' && typeof e == 'number') return t * (1 - n) + e * n
  if (
    (typeof t == 'boolean' && typeof e == 'boolean') ||
    (typeof t == 'string' && typeof e == 'string')
  )
    return n < 0.5 ? t : e
  if (Array.isArray(t) && Array.isArray(e)) {
    for (var r = t.length, i = e.length, a = Math.max(r, i), o = [], s = 0; s < a; s++)
      o.push(lw(t[s < r ? s : r - 1], e[s < i ? s : i - 1], n))
    return o
  }
  throw new Error('Mismatched interpolation arguments ' + t + ':' + e)
}
var DR = (function () {
  function t() {
    ;(this.delay = 0),
      (this.direction = 'normal'),
      (this.duration = 'auto'),
      (this._easing = 'linear'),
      (this.easingFunction = mR),
      (this.endDelay = 0),
      (this.fill = 'auto'),
      (this.iterationStart = 0),
      (this.iterations = 1),
      (this.currentIteration = null),
      (this.progress = null)
  }
  return (
    Object.defineProperty(t.prototype, 'easing', {
      get: function () {
        return this._easing
      },
      set: function (e) {
        ;(this.easingFunction = Pp(e)), (this._easing = e)
      },
      enumerable: !1,
      configurable: !0
    }),
    t
  )
})()
function $R(t) {
  var e = []
  for (var n in t)
    if (!(n in ['easing', 'offset', 'composite'])) {
      var r = t[n]
      Array.isArray(r) || (r = [r])
      for (var i = r.length, a = 0; a < i; a++) {
        if (!e[a]) {
          var o = {}
          'offset' in t && (o.offset = Number(t.offset)),
            'easing' in t && (o.easing = t.easing),
            'composite' in t && (o.composite = t.composite),
            (e[a] = o)
        }
        r[a] !== void 0 && r[a] !== null && (e[a][n] = r[a])
      }
    }
  return (
    e.sort(function (s, c) {
      return (s.computedOffset || 0) - (c.computedOffset || 0)
    }),
    e
  )
}
function Pg(t, e) {
  if (t === null) return []
  Array.isArray(t) || (t = $R(t))
  for (
    var n = t.map(function (c) {
        var l = {}
        e != null && e.composite && (l.composite = 'auto')
        for (var u in c) {
          var f = c[u]
          if (u === 'offset') {
            if (f !== null) {
              if (((f = Number(f)), !isFinite(f)))
                throw new Error('Keyframe offsets must be numbers.')
              if (f < 0 || f > 1) throw new Error('Keyframe offsets must be between 0 and 1.')
              l.computedOffset = f
            }
          } else if (
            u === 'composite' &&
            ['replace', 'add', 'accumulate', 'auto'].indexOf(f) === -1
          )
            throw new Error(''.concat(f, ' compositing is not supported'))
          l[u] = f
        }
        return (
          l.offset === void 0 && (l.offset = null),
          l.easing === void 0 && (l.easing = (e == null ? void 0 : e.easing) || 'linear'),
          l.composite === void 0 && (l.composite = 'auto'),
          l
        )
      }),
      r = !0,
      i = -1 / 0,
      a = 0;
    a < n.length;
    a++
  ) {
    var o = n[a].offset
    if (nt(o)) r = !1
    else {
      if (o < i)
        throw new TypeError('Keyframes are not loosely sorted by offset. Sort or specify offsets.')
      i = o
    }
  }
  n = n.filter(function (c) {
    return Number(c.offset) >= 0 && Number(c.offset) <= 1
  })
  function s() {
    var c,
      l,
      u = n.length
    ;(n[u - 1].computedOffset = Number((c = n[u - 1].offset) !== null && c !== void 0 ? c : 1)),
      u > 1 && (n[0].computedOffset = Number((l = n[0].offset) !== null && l !== void 0 ? l : 0))
    for (var f = 0, h = Number(n[0].computedOffset), d = 1; d < u; d++) {
      var p = n[d].computedOffset
      if (!nt(p) && !nt(h)) {
        for (var v = 1; v < d - f; v++)
          n[f + v].computedOffset = h + ((Number(p) - h) * v) / (d - f)
        ;(f = d), (h = Number(p))
      }
    }
  }
  return r || s(), n
}
var BR = 'backwards|forwards|both|none'.split('|'),
  FR = 'reverse|alternate|alternate-reverse'.split('|')
function zR(t, e) {
  var n = new DR()
  return (
    e && ((n.fill = 'both'), (n.duration = 'auto')),
    typeof t == 'number' && !isNaN(t)
      ? (n.duration = t)
      : t !== void 0 &&
        Object.keys(t).forEach(function (r) {
          if (t[r] !== void 0 && t[r] !== null && t[r] !== 'auto') {
            if (
              ((typeof n[r] == 'number' || r === 'duration') &&
                (typeof t[r] != 'number' || isNaN(t[r]))) ||
              (r === 'fill' && BR.indexOf(t[r]) === -1) ||
              (r === 'direction' && FR.indexOf(t[r]) === -1)
            )
              return
            n[r] = t[r]
          }
        }),
    n
  )
}
function GR(t, e) {
  return (t = WR(t ?? { duration: 'auto' })), zR(t, e)
}
function WR(t) {
  return typeof t == 'number' && (isNaN(t) ? (t = { duration: 'auto' }) : (t = { duration: t })), t
}
var YR = (function () {
  function t(e, n, r) {
    var i = this
    ;(this.composite = 'replace'),
      (this.iterationComposite = 'replace'),
      (this.target = e),
      (this.timing = GR(r, !1)),
      (this.timing.effect = this),
      (this.timing.activeDuration = _R(this.timing)),
      (this.timing.endTime = Math.max(
        0,
        this.timing.delay + this.timing.activeDuration + this.timing.endDelay
      )),
      (this.normalizedKeyframes = Pg(n, this.timing)),
      (this.interpolations = NR(this.normalizedKeyframes, this.timing, this.target))
    var a = Y.globalThis.Proxy
    this.computedTiming = a
      ? new a(this.timing, {
          get: function (o, s) {
            return s === 'duration'
              ? o.duration === 'auto'
                ? 0
                : o.duration
              : s === 'fill'
              ? o.fill === 'auto'
                ? 'none'
                : o.fill
              : s === 'localTime'
              ? (i.animation && i.animation.currentTime) || null
              : s === 'currentIteration'
              ? !i.animation || i.animation.playState !== 'running'
                ? null
                : o.currentIteration || 0
              : s === 'progress'
              ? !i.animation || i.animation.playState !== 'running'
                ? null
                : o.progress || 0
              : o[s]
          },
          set: function () {
            return !0
          }
        })
      : this.timing
  }
  return (
    (t.prototype.applyInterpolations = function () {
      this.interpolations(this.target, Number(this.timeFraction))
    }),
    (t.prototype.update = function (e) {
      return e === null
        ? !1
        : ((this.timeFraction = LR(this.timing.activeDuration, e, this.timing)),
          this.timeFraction !== null)
    }),
    (t.prototype.getKeyframes = function () {
      return this.normalizedKeyframes
    }),
    (t.prototype.setKeyframes = function (e) {
      this.normalizedKeyframes = Pg(e)
    }),
    (t.prototype.getComputedTiming = function () {
      return this.computedTiming
    }),
    (t.prototype.getTiming = function () {
      return this.timing
    }),
    (t.prototype.updateTiming = function (e) {
      var n = this
      Object.keys(e || {}).forEach(function (r) {
        n.timing[r] = e[r]
      })
    }),
    t
  )
})()
function Ag(t, e) {
  return Number(t.id) - Number(e.id)
}
var HR = (function () {
  function t(e) {
    var n = this
    ;(this.document = e),
      (this.animations = []),
      (this.ticking = !1),
      (this.timelineTicking = !1),
      (this.hasRestartedThisFrame = !1),
      (this.animationsWithPromises = []),
      (this.inTick = !1),
      (this.pendingEffects = []),
      (this.currentTime = null),
      (this.rafId = 0),
      (this.rafCallbacks = []),
      (this.webAnimationsNextTick = function (r) {
        ;(n.currentTime = r),
          n.discardAnimations(),
          n.animations.length === 0
            ? (n.timelineTicking = !1)
            : n.requestAnimationFrame(n.webAnimationsNextTick)
      }),
      (this.processRafCallbacks = function (r) {
        var i = n.rafCallbacks
        ;(n.rafCallbacks = []),
          r < Number(n.currentTime) && (r = Number(n.currentTime)),
          n.animations.sort(Ag),
          (n.animations = n.tick(r, !0, n.animations)[0]),
          i.forEach(function (a) {
            a[1](r)
          }),
          n.applyPendingEffects()
      })
  }
  return (
    (t.prototype.getAnimations = function () {
      return this.discardAnimations(), this.animations.slice()
    }),
    (t.prototype.isTicking = function () {
      return this.inTick
    }),
    (t.prototype.play = function (e, n, r) {
      var i = new YR(e, n, r),
        a = new sR(i, this)
      return (
        this.animations.push(a),
        this.restartWebAnimationsNextTick(),
        a.updatePromises(),
        a.play(),
        a.updatePromises(),
        a
      )
    }),
    (t.prototype.applyDirtiedAnimation = function (e) {
      var n = this
      if (!this.inTick) {
        e.markTarget()
        var r = e.targetAnimations()
        r.sort(Ag)
        var i = this.tick(Number(this.currentTime), !1, r.slice())[1]
        i.forEach(function (a) {
          var o = n.animations.indexOf(a)
          o !== -1 && n.animations.splice(o, 1)
        }),
          this.applyPendingEffects()
      }
    }),
    (t.prototype.restart = function () {
      return (
        this.ticking ||
          ((this.ticking = !0),
          this.requestAnimationFrame(function () {}),
          (this.hasRestartedThisFrame = !0)),
        this.hasRestartedThisFrame
      )
    }),
    (t.prototype.destroy = function () {
      this.document.defaultView.cancelAnimationFrame(this.frameId)
    }),
    (t.prototype.applyPendingEffects = function () {
      this.pendingEffects.forEach(function (e) {
        e == null || e.applyInterpolations()
      }),
        (this.pendingEffects = [])
    }),
    (t.prototype.updateAnimationsPromises = function () {
      this.animationsWithPromises = this.animationsWithPromises.filter(function (e) {
        return e.updatePromises()
      })
    }),
    (t.prototype.discardAnimations = function () {
      this.updateAnimationsPromises(),
        (this.animations = this.animations.filter(function (e) {
          return e.playState !== 'finished' && e.playState !== 'idle'
        }))
    }),
    (t.prototype.restartWebAnimationsNextTick = function () {
      this.timelineTicking ||
        ((this.timelineTicking = !0), this.requestAnimationFrame(this.webAnimationsNextTick))
    }),
    (t.prototype.rAF = function (e) {
      var n = this.rafId++
      return (
        this.rafCallbacks.length === 0 &&
          (this.frameId = this.document.defaultView.requestAnimationFrame(
            this.processRafCallbacks
          )),
        this.rafCallbacks.push([n, e]),
        n
      )
    }),
    (t.prototype.requestAnimationFrame = function (e) {
      var n = this
      return this.rAF(function (r) {
        n.updateAnimationsPromises(), e(r), n.updateAnimationsPromises()
      })
    }),
    (t.prototype.tick = function (e, n, r) {
      var i,
        a,
        o = this
      ;(this.inTick = !0),
        (this.hasRestartedThisFrame = !1),
        (this.currentTime = e),
        (this.ticking = !1)
      var s = [],
        c = [],
        l = [],
        u = []
      return (
        r.forEach(function (f) {
          f.tick(e, n),
            f._inEffect ? (c.push(f.effect), f.markTarget()) : (s.push(f.effect), f.unmarkTarget()),
            f._needsTick && (o.ticking = !0)
          var h = f._inEffect || f._needsTick
          ;(f._inTimeline = h), h ? l.push(f) : u.push(f)
        }),
        (i = this.pendingEffects).push.apply(i, q([], N(s), !1)),
        (a = this.pendingEffects).push.apply(a, q([], N(c), !1)),
        this.ticking && this.requestAnimationFrame(function () {}),
        (this.inTick = !1),
        [l, u]
      )
    }),
    t
  )
})()
Y.EasingFunction = Pp
Y.AnimationTimeline = HR
function ot(t) {
  return new dl([t], null, t, t.ownerDocument)
}
let dl = class Pe {
  constructor(
    e = null,
    n = null,
    r = null,
    i = null,
    a = [null, null, null, null, null],
    o = [],
    s = []
  ) {
    ;(this._elements = Array.from(e)),
      (this._data = n),
      (this._parent = r),
      (this._document = i),
      (this._enter = a[0]),
      (this._update = a[1]),
      (this._exit = a[2]),
      (this._merge = a[3]),
      (this._split = a[4]),
      (this._transitions = o),
      (this._facetElements = s)
  }
  selectAll(e) {
    const n = typeof e == 'string' ? this._parent.querySelectorAll(e) : e
    return new Pe(n, null, this._elements[0], this._document)
  }
  selectFacetAll(e) {
    const n = typeof e == 'string' ? this._parent.querySelectorAll(e) : e
    return new Pe(this._elements, null, this._parent, this._document, void 0, void 0, n)
  }
  select(e) {
    const n = typeof e == 'string' ? this._parent.querySelectorAll(e)[0] || null : e
    return new Pe([n], null, n, this._document)
  }
  append(e) {
    const n = typeof e == 'function' ? e : () => this.createElement(e),
      r = []
    if (this._data !== null) {
      for (let i = 0; i < this._data.length; i++) {
        const a = this._data[i],
          [o, s] = Array.isArray(a) ? a : [a, null],
          c = n(o, i)
        ;(c.__data__ = o),
          s !== null && (c.__fromElements__ = s),
          this._parent.appendChild(c),
          r.push(c)
      }
      return new Pe(r, null, this._parent, this._document)
    } else {
      for (let i = 0; i < this._elements.length; i++) {
        const a = this._elements[i],
          o = a.__data__,
          s = n(o, i)
        a.appendChild(s), r.push(s)
      }
      return new Pe(r, null, r[0], this._document)
    }
  }
  maybeAppend(e, n, r) {
    const i = this._elements[0],
      a = i.getElementById(e)
    if (a) return new Pe([a], null, this._parent, this._document)
    const o = typeof n == 'string' ? this.createElement(n) : n()
    return (
      (o.id = e),
      r && (o.className = r),
      i.appendChild(o),
      new Pe([o], null, this._parent, this._document)
    )
  }
  data(e, n = (i) => i, r = () => null) {
    const i = [],
      a = [],
      o = new Set(this._elements),
      s = [],
      c = new Set(),
      l = new Map(this._elements.map((d, p) => [n(d.__data__, p), d])),
      u = new Map(this._facetElements.map((d, p) => [n(d.__data__, p), d])),
      f = qt(this._elements, (d) => r(d.__data__))
    for (let d = 0; d < e.length; d++) {
      const p = e[d],
        v = n(p, d),
        g = r(p, d)
      if (l.has(v)) {
        const y = l.get(v)
        ;(y.__data__ = p), (y.__facet__ = !1), a.push(y), o.delete(y), l.delete(v)
      } else if (u.has(v)) {
        const y = u.get(v)
        ;(y.__data__ = p), (y.__facet__ = !0), a.push(y), u.delete(v)
      } else if (f.has(v)) {
        const y = f.get(v)
        s.push([p, y])
        for (const m of y) o.delete(m)
        f.delete(v)
      } else if (l.has(g)) {
        const y = l.get(g)
        y.__toData__ ? y.__toData__.push(p) : (y.__toData__ = [p]), c.add(y), o.delete(y)
      } else i.push(p)
    }
    const h = [
      new Pe([], i, this._parent, this._document),
      new Pe(a, null, this._parent, this._document),
      new Pe(o, null, this._parent, this._document),
      new Pe([], s, this._parent, this._document),
      new Pe(c, null, this._parent, this._document)
    ]
    return new Pe(this._elements, null, this._parent, this._document, h)
  }
  merge(e) {
    const n = [...this._elements, ...e._elements],
      r = [...this._transitions, ...e._transitions]
    return new Pe(n, null, this._parent, this._document, void 0, r)
  }
  createElement(e) {
    if (this._document) return this._document.createElement(e, {})
    const n = Pe.registry[e]
    return n ? new n() : ql(`Unknown node type: ${e}`)
  }
  join(e = (o) => o, n = (o) => o, r = (o) => o.remove(), i = (o) => o, a = (o) => o.remove()) {
    const o = e(this._enter),
      s = n(this._update),
      c = r(this._exit),
      l = i(this._merge),
      u = a(this._split)
    return s.merge(o).merge(c).merge(l).merge(u)
  }
  remove() {
    for (let e = 0; e < this._elements.length; e++) {
      const n = this._transitions[e]
      if (n) {
        const r = Array.isArray(n) ? n : [n]
        Promise.all(r.map((i) => i.finished)).then(() => {
          this._elements[e].remove()
        })
      } else this._elements[e].remove()
    }
    return new Pe([], null, this._parent, this._document, void 0, this._transitions)
  }
  each(e) {
    for (let n = 0; n < this._elements.length; n++) {
      const r = this._elements[n],
        i = r.__data__
      e(i, n, r)
    }
    return this
  }
  attr(e, n) {
    const r = typeof n != 'function' ? () => n : n
    return this.each(function (i, a, o) {
      n !== void 0 && (o[e] = r(i, a, o))
    })
  }
  style(e, n) {
    const r = typeof n != 'function' ? () => n : n
    return this.each(function (i, a, o) {
      n !== void 0 && (o.style[e] = r(i, a, o))
    })
  }
  transition(e) {
    const n = typeof e != 'function' ? () => e : e,
      { _transitions: r } = this
    return this.each(function (i, a, o) {
      r[a] = n(i, a, o)
    })
  }
  on(e, n) {
    return (
      this.each(function (r, i, a) {
        a.addEventListener(e, n)
      }),
      this
    )
  }
  call(e, ...n) {
    return e(this, ...n), this
  }
  node() {
    return this._elements[0]
  }
  nodes() {
    return this._elements
  }
  transitions() {
    return this._transitions
  }
  parent() {
    return this._parent
  }
}
dl.registry = {
  g: je,
  rect: Xi,
  circle: Ns,
  path: rn,
  text: Za,
  ellipse: _p,
  image: Mp,
  line: Rs,
  polygon: pu,
  polyline: Ep,
  html: du
}
function kg(t, e, n) {
  return Math.max(e, Math.min(t, n))
}
function at(t, e) {
  for (const [n, r] of Object.entries(e)) t.style(n, r)
}
function VR(t, e) {
  return (
    e.forEach((n, r) => (r === 0 ? t.moveTo(n[0], n[1]) : t.lineTo(n[0], n[1]))), t.closePath(), t
  )
}
function XR(t, e, n) {
  const { arrowSize: r } = n,
    i = typeof r == 'string' ? (+parseFloat(r) / 100) * Ut(t, e) : r,
    a = Math.PI / 6,
    o = Math.atan2(e[1] - t[1], e[0] - t[0]),
    s = Math.PI / 2 - o - a,
    c = [e[0] - i * Math.sin(s), e[1] - i * Math.cos(s)],
    l = o - a,
    u = [e[0] - i * Math.cos(l), e[1] - i * Math.sin(l)]
  return [c, u]
}
function is(t, e, n, r, i) {
  const a = kn(oe(r, e)) + Math.PI,
    o = kn(oe(r, n)) + Math.PI
  return t.arc(r[0], r[1], i, a, o, o - a < 0), t
}
function uw(t, e, n, r = 'y', i = 'between') {
  const a = r === 'y' || r === !0 ? n : e,
    o = r === 'y' || r === !0 ? 90 : 0,
    s = Yi(a),
    [c, l] = br(s, (p) => a[p]),
    u = new Ft({ domain: [c, l], range: [0, 100] }),
    f = (p) => u.map(a[p]),
    h = {
      between: (p) => `${t[p]} ${f(p)}%`,
      start: (p) => (p === 0 ? `${t[p]} ${f(p)}%` : `${t[p - 1]} ${f(p)}%, ${t[p]} ${f(p)}%`),
      end: (p) =>
        p === t.length - 1 ? `${t[p]} ${f(p)}%` : `${t[p]} ${f(p)}%, ${t[p + 1]} ${f(p)}%`
    },
    d = s
      .sort((p, v) => f(p) - f(v))
      .map(h[i] || h.between)
      .join(',')
  return `linear-gradient(${o}deg, ${d})`
}
function gu(t) {
  const [e, n, r, i] = t
  return [i, e, n, r]
}
function Qa(t, e, n) {
  const [r, i, , a] = ce(t) ? gu(e) : e,
    [o, s] = n,
    c = t.getCenter(),
    l = Ca(oe(r, c)),
    u = Ca(oe(i, c)),
    f = u === l && o !== s ? u + Math.PI * 2 : u
  return {
    startAngle: l,
    endAngle: f - l >= 0 ? f : Math.PI * 2 + f,
    innerRadius: Ut(a, c),
    outerRadius: Ut(r, c)
  }
}
function fw(t) {
  const { colorAttribute: e, opacityAttribute: n = e } = t
  return `${n}Opacity`
}
function hw(t, e) {
  if (!Zt(t)) return ''
  const n = t.getCenter(),
    { transform: r } = e
  return `translate(${n[0]}, ${n[1]}) ${r || ''}`
}
function dw(t) {
  if (t.length === 1) return t[0]
  const [[e, n, r = 0], [i, a, o = 0]] = t
  return [(e + i) / 2, (n + a) / 2, (r + o) / 2]
}
var Fc =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function pw(t, e, n, r, i = {}) {
  const {
      inset: a = 0,
      radius: o = 0,
      insetLeft: s = a,
      insetTop: c = a,
      insetRight: l = a,
      insetBottom: u = a,
      radiusBottomLeft: f = o,
      radiusBottomRight: h = o,
      radiusTopLeft: d = o,
      radiusTopRight: p = o,
      minWidth: v = -1 / 0,
      maxWidth: g = 1 / 0
    } = i,
    y = Fc(i, [
      'inset',
      'radius',
      'insetLeft',
      'insetTop',
      'insetRight',
      'insetBottom',
      'radiusBottomLeft',
      'radiusBottomRight',
      'radiusTopLeft',
      'radiusTopRight',
      'minWidth',
      'maxWidth'
    ])
  if (!Zt(r) && !w2(r)) {
    const S = !!ce(r),
      [_, , M] = S ? gu(e) : e,
      [E, T] = _,
      [C, A] = oe(M, _),
      P = C > 0 ? E : E + C,
      k = A > 0 ? T : T + A,
      L = Math.abs(C),
      R = Math.abs(A),
      j = P + s,
      I = k + c,
      D = L - (s + l),
      $ = R - (c + u),
      B = S ? D : kg(D, v, g),
      F = S ? kg($, v, g) : $,
      W = j - (B - D) / 2,
      U = I - (F - $) / 2
    return ot(t.createElement('rect', {}))
      .style('x', W)
      .style('y', U)
      .style('width', B)
      .style('height', F)
      .style('radius', [d, p, h, f])
      .call(at, y)
      .node()
  }
  const { y: m, y1: b } = n,
    x = r.getCenter(),
    w = Qa(r, e, [m, b]),
    O = lp()
      .cornerRadius(o)
      .padAngle((a * Math.PI) / 180)
  return ot(t.createElement('path', {}))
    .style('path', O(w))
    .style('transform', `translate(${x[0]}, ${x[1]})`)
    .style('radius', o)
    .style('inset', a)
    .call(at, y)
    .node()
}
const Is = (t, e) => {
  const { colorAttribute: n, opacityAttribute: r = 'fill', first: i = !0, last: a = !0 } = t,
    o = Fc(t, ['colorAttribute', 'opacityAttribute', 'first', 'last']),
    { coordinate: s, document: c } = e
  return (l, u, f) => {
    const { color: h, radius: d = 0 } = f,
      p = Fc(f, ['color', 'radius']),
      v = p.lineWidth || 1,
      {
        stroke: g,
        radius: y = d,
        radiusTopLeft: m = y,
        radiusTopRight: b = y,
        radiusBottomRight: x = y,
        radiusBottomLeft: w = y,
        innerRadius: O = 0,
        innerRadiusTopLeft: S = O,
        innerRadiusTopRight: _ = O,
        innerRadiusBottomRight: M = O,
        innerRadiusBottomLeft: E = O,
        lineWidth: T = n === 'stroke' || g ? v : 0,
        inset: C = 0,
        insetLeft: A = C,
        insetRight: P = C,
        insetBottom: k = C,
        insetTop: L = C,
        minWidth: R,
        maxWidth: j
      } = o,
      I = Fc(o, [
        'stroke',
        'radius',
        'radiusTopLeft',
        'radiusTopRight',
        'radiusBottomRight',
        'radiusBottomLeft',
        'innerRadius',
        'innerRadiusTopLeft',
        'innerRadiusTopRight',
        'innerRadiusBottomRight',
        'innerRadiusBottomLeft',
        'lineWidth',
        'inset',
        'insetLeft',
        'insetRight',
        'insetBottom',
        'insetTop',
        'minWidth',
        'maxWidth'
      ]),
      { color: D = h, opacity: $ } = u,
      B = [i ? m : S, i ? b : _, a ? x : M, a ? w : E],
      F = ['radiusTopLeft', 'radiusTopRight', 'radiusBottomRight', 'radiusBottomLeft']
    ce(s) && F.push(F.shift())
    const W = Object.assign(
      Object.assign({ radius: y }, Object.fromEntries(F.map((U, K) => [U, B[K]]))),
      {
        inset: C,
        insetLeft: A,
        insetRight: P,
        insetBottom: k,
        insetTop: L,
        minWidth: R,
        maxWidth: j
      }
    )
    return ot(pw(c, l, u, s, W))
      .call(at, p)
      .style('fill', 'transparent')
      .style(n, D)
      .style(fw(t), $)
      .style('lineWidth', T)
      .style('stroke', g === void 0 ? D : g)
      .call(at, I)
      .node()
  }
}
Is.props = {
  defaultEnterAnimation: 'scaleInY',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
const Ui = (t, e) => Is(Object.assign({ colorAttribute: 'fill' }, t), e)
Ui.props = Object.assign(Object.assign({}, Is.props), { defaultMarker: 'square' })
const yu = (t, e) => Is(Object.assign({ colorAttribute: 'stroke' }, t), e)
yu.props = Object.assign(Object.assign({}, Is.props), { defaultMarker: 'hollowSquare' })
var Cg =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function UR(t, e, n) {
  const [r, i, a, o] = t
  if (ce(n)) {
    const l = [e ? e[0][0] : i[0], i[1]],
      u = [e ? e[3][0] : a[0], a[1]]
    return [r, l, u, o]
  }
  const s = [i[0], e ? e[0][1] : i[1]],
    c = [a[0], e ? e[3][1] : a[1]]
  return [r, s, c, o]
}
const kp = (t, e) => {
  const { adjustPoints: n = UR } = t,
    r = Cg(t, ['adjustPoints']),
    { coordinate: i, document: a } = e
  return (o, s, c, l) => {
    const { index: u } = s,
      { color: f } = c,
      h = Cg(c, ['color']),
      d = l[u + 1],
      p = n(o, d, i),
      v = !!ce(i),
      [g, y, m, b] = v ? gu(p) : p,
      { color: x = f, opacity: w } = s,
      O = Kr().curve(dp)([g, y, m, b])
    return ot(a.createElement('path', {}))
      .call(at, h)
      .style('path', O)
      .style('fill', x)
      .style('fillOpacity', w)
      .call(at, r)
      .node()
  }
}
kp.props = { defaultMarker: 'square' }
function qR(t, e, n) {
  const [r, i, a, o] = t
  if (ce(n)) {
    const l = [e ? e[0][0] : (i[0] + a[0]) / 2, i[1]],
      u = [e ? e[3][0] : (i[0] + a[0]) / 2, a[1]]
    return [r, l, u, o]
  }
  const s = [i[0], e ? e[0][1] : (i[1] + a[1]) / 2],
    c = [a[0], e ? e[3][1] : (i[1] + a[1]) / 2]
  return [r, s, c, o]
}
const vw = (t, e) => kp(Object.assign({ adjustPoints: qR }, t), e)
vw.props = { defaultMarker: 'square' }
function Ia(t) {
  const e = typeof t == 'function' ? t : t.render
  return class extends Sp {
    connectedCallback() {
      this.draw()
    }
    attributeChangedCallback() {
      this.draw()
    }
    draw() {
      e(this)
    }
  }
}
var Lg =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const KR = Ia((t) => {
  const { d1: e, d2: n, style1: r, style2: i } = t.attributes,
    a = t.ownerDocument
  ot(t)
    .maybeAppend('line', () => a.createElement('path', {}))
    .style('d', e)
    .call(at, r),
    ot(t)
      .maybeAppend('line1', () => a.createElement('path', {}))
      .style('d', n)
      .call(at, i)
})
function ZR(t, e) {
  const n = [],
    r = []
  let i = !1,
    a = null
  for (const o of t)
    !e(o[0]) || !e(o[1]) ? (i = !0) : (n.push(o), i && ((i = !1), r.push([a, o])), (a = o))
  return [n, r]
}
const Rn = (t, e) => {
  const {
      curve: n,
      gradient: r = !1,
      gradientColor: i = 'between',
      defined: a = (u) => !Number.isNaN(u) && u !== void 0 && u !== null,
      connect: o = !1
    } = t,
    s = Lg(t, ['curve', 'gradient', 'gradientColor', 'defined', 'connect']),
    { coordinate: c, document: l } = e
  return (u, f, h) => {
    const { color: d, lineWidth: p } = h,
      v = Lg(h, ['color', 'lineWidth']),
      { color: g = d, size: y = p, seriesColor: m, seriesX: b, seriesY: x } = f,
      w = r && m ? uw(m, b, x, r, i) : g,
      O = hw(c, f),
      S = Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(Object.assign({}, v), w && { stroke: w }),
            y && { lineWidth: y }
          ),
          O && { transform: O }
        ),
        s
      )
    let _
    if (Zt(c)) {
      const P = c.getCenter()
      _ = (k) =>
        _C()
          .angle((L, R) => Ca(oe(k[R], P)))
          .radius((L, R) => Ut(k[R], P))
          .defined(([L, R]) => a(L) && a(R))
          .curve(n)(k)
    } else
      _ = Kr()
        .x((P) => P[0])
        .y((P) => P[1])
        .defined(([P, k]) => a(P) && a(k))
        .curve(n)
    const [M, E] = ZR(u, a),
      T = et(S, 'connect'),
      C = !!E.length
    if (!C || (o && !Object.keys(T).length))
      return ot(l.createElement('path', {}))
        .style('d', _(M) || [])
        .call(at, S)
        .node()
    if (C && !o) return ot(l.createElement('path', {})).style('d', _(u)).call(at, S).node()
    const A = (P) => P.map(_).join(',')
    return ot(new KR())
      .style('style1', Object.assign(Object.assign({}, S), T))
      .style('style2', S)
      .style('d1', A(E))
      .style('d2', _(u))
      .node()
  }
}
Rn.props = {
  defaultMarker: 'smooth',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
const gw = (t, e) => {
  const { coordinate: n } = e
  return (...r) => {
    const i = Zt(n) ? dp : As
    return Rn(Object.assign({ curve: i }, t), e)(...r)
  }
}
gw.props = Object.assign(Object.assign({}, Rn.props), { defaultMarker: 'line' })
var QR =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const yw = (t, e) => {
  const { alpha: n = 0.5 } = t,
    r = QR(t, ['alpha']),
    { coordinate: i } = e
  return (...a) => {
    const o = Zt(i) ? g2 : p2
    return Rn(Object.assign({ curve: o.alpha(n) }, r), e)(...a)
  }
}
yw.props = Object.assign(Object.assign({}, Rn.props), { defaultMarker: 'smooth' })
const mw = (t, e) => Rn(Object.assign({ curve: x2 }, t), e)
mw.props = Object.assign(Object.assign({}, Rn.props), { defaultMarker: 'hv' })
const bw = (t, e) => Rn(Object.assign({ curve: b2 }, t), e)
bw.props = Object.assign(Object.assign({}, Rn.props), { defaultMarker: 'vh' })
const xw = (t, e) => Rn(Object.assign({ curve: m2 }, t), e)
xw.props = Object.assign(Object.assign({}, Rn.props), { defaultMarker: 'hvh' })
var JR =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function t6(t, e, n, r, i) {
  const a = oe(n, e),
    o = kn(a),
    s = o + Math.PI / 2,
    c = [(r / 2) * Math.cos(s), (r / 2) * Math.sin(s)],
    l = [(i / 2) * Math.cos(s), (i / 2) * Math.sin(s)],
    u = [(i / 2) * Math.cos(o), (i / 2) * Math.sin(o)],
    f = [(r / 2) * Math.cos(o), (r / 2) * Math.sin(o)],
    h = Zs(e, c),
    d = Zs(n, l),
    p = Zs(d, u),
    v = Zs(n, u),
    g = oe(v, l),
    y = oe(n, l),
    m = oe(e, c),
    b = oe(m, f),
    x = oe(e, f),
    w = oe(h, f)
  t.moveTo(...h),
    t.lineTo(...d),
    t.arcTo(...p, ...v, i / 2),
    t.arcTo(...g, ...y, i / 2),
    t.lineTo(...m),
    t.arcTo(...b, ...x, r / 2),
    t.arcTo(...w, ...h, r / 2),
    t.closePath()
}
const ww = (t, e) => {
  const { document: n } = e
  return (r, i, a) => {
    const { seriesSize: o, color: s } = i,
      { color: c } = a,
      l = JR(a, ['color']),
      u = Nn()
    for (let f = 0; f < r.length - 1; f++) {
      const h = r[f],
        d = r[f + 1],
        p = o[f],
        v = o[f + 1]
      ;[...h, ...d].every(Gt) && t6(u, h, d, p, v)
    }
    return ot(n.createElement('path', {}))
      .call(at, l)
      .style('fill', s || c)
      .style('d', u.toString())
      .call(at, t)
      .node()
  }
}
ww.props = Object.assign(Object.assign({}, Rn.props), { defaultMarker: 'line' })
var e6 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const Cp = (t, e, n) => [
  ['M', t - n, e],
  ['A', n, n, 0, 1, 0, t + n, e],
  ['A', n, n, 0, 1, 0, t - n, e],
  ['Z']
]
Cp.style = ['fill']
const Ow = Cp.bind(void 0)
Ow.style = ['stroke', 'lineWidth']
const mu = (t, e, n) => [
  ['M', t - n, e - n],
  ['L', t + n, e - n],
  ['L', t + n, e + n],
  ['L', t - n, e + n],
  ['Z']
]
mu.style = ['fill']
const Sw = mu.bind(void 0)
Sw.style = ['fill']
const _w = mu.bind(void 0)
_w.style = ['stroke', 'lineWidth']
const Lp = (t, e, n) => {
  const r = n * 0.618
  return [['M', t - r, e], ['L', t, e - n], ['L', t + r, e], ['L', t, e + n], ['Z']]
}
Lp.style = ['fill']
const Mw = Lp.bind(void 0)
Mw.style = ['stroke', 'lineWidth']
const Np = (t, e, n) => {
  const r = n * Math.sin(0.3333333333333333 * Math.PI)
  return [['M', t - n, e + r], ['L', t, e - r], ['L', t + n, e + r], ['Z']]
}
Np.style = ['fill']
const Ew = Np.bind(void 0)
Ew.style = ['stroke', 'lineWidth']
const Rp = (t, e, n) => {
  const r = n * Math.sin(0.3333333333333333 * Math.PI)
  return [['M', t - n, e - r], ['L', t + n, e - r], ['L', t, e + r], ['Z']]
}
Rp.style = ['fill']
const Tw = Rp.bind(void 0)
Tw.style = ['stroke', 'lineWidth']
const Ip = (t, e, n) => {
  const r = (n / 2) * Math.sqrt(3)
  return [
    ['M', t, e - n],
    ['L', t + r, e - n / 2],
    ['L', t + r, e + n / 2],
    ['L', t, e + n],
    ['L', t - r, e + n / 2],
    ['L', t - r, e - n / 2],
    ['Z']
  ]
}
Ip.style = ['fill']
const Pw = Ip.bind(void 0)
Pw.style = ['stroke', 'lineWidth']
const jp = (t, e, n) => {
  const r = n - 1.5
  return [['M', t - n, e - r], ['L', t + n, e + r], ['L', t + n, e - r], ['L', t - n, e + r], ['Z']]
}
jp.style = ['fill']
const Aw = jp.bind(void 0)
Aw.style = ['stroke', 'lineWidth']
const kw = (t, e, n) => [
  ['M', t, e + n],
  ['L', t, e - n]
]
kw.style = ['stroke', 'lineWidth']
const Cw = (t, e, n) => [
  ['M', t - n, e - n],
  ['L', t + n, e + n],
  ['M', t + n, e - n],
  ['L', t - n, e + n]
]
Cw.style = ['stroke', 'lineWidth']
const Lw = (t, e, n) => [
  ['M', t - n / 2, e - n],
  ['L', t + n / 2, e - n],
  ['M', t, e - n],
  ['L', t, e + n],
  ['M', t - n / 2, e + n],
  ['L', t + n / 2, e + n]
]
Lw.style = ['stroke', 'lineWidth']
const Nw = (t, e, n) => [
  ['M', t - n, e],
  ['L', t + n, e],
  ['M', t, e - n],
  ['L', t, e + n]
]
Nw.style = ['stroke', 'lineWidth']
const Rw = (t, e, n) => [
  ['M', t - n, e],
  ['L', t + n, e]
]
Rw.style = ['stroke', 'lineWidth']
const Dp = (t, e, n) => [
  ['M', t - n, e],
  ['L', t + n, e]
]
Dp.style = ['stroke', 'lineWidth']
const Iw = Dp.bind(void 0)
Iw.style = ['stroke', 'lineWidth']
const jw = (t, e, n) => [
  ['M', t - n, e],
  ['A', n / 2, n / 2, 0, 1, 1, t, e],
  ['A', n / 2, n / 2, 0, 1, 0, t + n, e]
]
jw.style = ['stroke', 'lineWidth']
const Dw = (t, e, n) => [
  ['M', t - n - 1, e - 2.5],
  ['L', t, e - 2.5],
  ['L', t, e + 2.5],
  ['L', t + n + 1, e + 2.5]
]
Dw.style = ['stroke', 'lineWidth']
const $w = (t, e, n) => [
  ['M', t - n - 1, e + 2.5],
  ['L', t, e + 2.5],
  ['L', t, e - 2.5],
  ['L', t + n + 1, e - 2.5]
]
$w.style = ['stroke', 'lineWidth']
const Bw = (t, e, n) => [
  ['M', t - (n + 1), e + 2.5],
  ['L', t - n / 2, e + 2.5],
  ['L', t - n / 2, e - 2.5],
  ['L', t + n / 2, e - 2.5],
  ['L', t + n / 2, e + 2.5],
  ['L', t + n + 1, e + 2.5]
]
Bw.style = ['stroke', 'lineWidth']
const Fw = (t, e, n) => [
  ['M', t - 5, e + 2.5],
  ['L', t - 5, e],
  ['L', t, e],
  ['L', t, e - 3],
  ['L', t, e + 3],
  ['L', t + 6.5, e + 3]
]
Fw.style = ['stroke', 'lineWidth']
const pl = new Map([
  ['bowtie', jp],
  ['cross', Cw],
  ['dash', Iw],
  ['diamond', Lp],
  ['dot', Dp],
  ['hexagon', Ip],
  ['hollowBowtie', Aw],
  ['hollowDiamond', Mw],
  ['hollowHexagon', Pw],
  ['hollowPoint', Ow],
  ['hollowSquare', _w],
  ['hollowTriangle', Ew],
  ['hollowTriangleDown', Tw],
  ['hv', Dw],
  ['hvh', Bw],
  ['hyphen', Rw],
  ['line', kw],
  ['plus', Nw],
  ['point', Cp],
  ['rect', Sw],
  ['smooth', jw],
  ['square', mu],
  ['tick', Lw],
  ['triangleDown', Rp],
  ['triangle', Np],
  ['vh', $w],
  ['vhv', Fw]
])
function n6(t, e) {
  var { d: n, fill: r, strokeWidth: i, path: a, stroke: o, lineWidth: s, color: c } = e,
    l = e6(e, ['d', 'fill', 'strokeWidth', 'path', 'stroke', 'lineWidth', 'color'])
  const u = pl.get(t) || pl.get('point')
  return (...f) =>
    new rn({
      style: Object.assign(Object.assign({}, l), {
        path: u(...f),
        stroke: u.style.includes('stroke') ? c || o : '',
        fill: u.style.includes('fill') ? c || r : '',
        lineWidth: u.style.includes('lineWidth') ? s || s || 2 : 0
      })
    })
}
var r6 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function i6(t, e, n, r) {
  if (e.length === 1) return
  const { size: i } = n
  if (t === 'fixed') return i
  if (t === 'normal' || O2(r)) {
    const [[a, o], [s, c]] = e,
      l = Math.abs((s - a) / 2),
      u = Math.abs((c - o) / 2)
    return Math.max(0, (l + u) / 2)
  }
  return i
}
const bt = (t, e) => {
  const { colorAttribute: n, symbol: r, mode: i = 'auto' } = t,
    a = r6(t, ['colorAttribute', 'symbol', 'mode']),
    o = pl.get(r) || pl.get('point'),
    { coordinate: s, document: c } = e
  return (l, u, f) => {
    const { lineWidth: h, color: d } = f,
      p = a.stroke ? h || 1 : h,
      { color: v = d, transform: g, opacity: y } = u,
      [m, b] = dw(l),
      w = i6(i, l, u, s) || a.r || f.r
    return ot(c.createElement('path', {}))
      .call(at, f)
      .style('fill', 'transparent')
      .style('d', o(m, b, w))
      .style('lineWidth', p)
      .style('transform', g)
      .style('stroke', v)
      .style(fw(t), y)
      .style(n, v)
      .call(at, a)
      .node()
  }
}
bt.props = {
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
const zw = (t, e) => bt(Object.assign({ colorAttribute: 'stroke', symbol: 'bowtie' }, t), e)
zw.props = Object.assign({ defaultMarker: 'hollowBowtie' }, bt.props)
const Gw = (t, e) => bt(Object.assign({ colorAttribute: 'stroke', symbol: 'diamond' }, t), e)
Gw.props = Object.assign({ defaultMarker: 'hollowDiamond' }, bt.props)
const Ww = (t, e) => bt(Object.assign({ colorAttribute: 'stroke', symbol: 'hexagon' }, t), e)
Ww.props = Object.assign({ defaultMarker: 'hollowHexagon' }, bt.props)
const Yw = (t, e) => bt(Object.assign({ colorAttribute: 'stroke', symbol: 'point' }, t), e)
Yw.props = Object.assign({ defaultMarker: 'hollowPoint' }, bt.props)
const Hw = (t, e) => bt(Object.assign({ colorAttribute: 'stroke', symbol: 'square' }, t), e)
Hw.props = Object.assign({ defaultMarker: 'hollowSquare' }, bt.props)
const Vw = (t, e) => bt(Object.assign({ colorAttribute: 'stroke', symbol: 'triangle' }, t), e)
Vw.props = Object.assign({ defaultMarker: 'hollowTriangle' }, bt.props)
const Xw = (t, e) => bt(Object.assign({ colorAttribute: 'stroke', symbol: 'triangle-down' }, t), e)
Xw.props = Object.assign({ defaultMarker: 'hollowTriangleDown' }, bt.props)
const Uw = (t, e) => bt(Object.assign({ colorAttribute: 'fill', symbol: 'bowtie' }, t), e)
Uw.props = Object.assign({ defaultMarker: 'bowtie' }, bt.props)
const qw = (t, e) => bt(Object.assign({ colorAttribute: 'stroke', symbol: 'cross' }, t), e)
qw.props = Object.assign({ defaultMarker: 'cross' }, bt.props)
const Kw = (t, e) => bt(Object.assign({ colorAttribute: 'fill', symbol: 'diamond' }, t), e)
Kw.props = Object.assign({ defaultMarker: 'diamond' }, bt.props)
const Zw = (t, e) => bt(Object.assign({ colorAttribute: 'fill', symbol: 'hexagon' }, t), e)
Zw.props = Object.assign({ defaultMarker: 'hexagon' }, bt.props)
const Qw = (t, e) => bt(Object.assign({ colorAttribute: 'stroke', symbol: 'hyphen' }, t), e)
Qw.props = Object.assign({ defaultMarker: 'hyphen' }, bt.props)
const Jw = (t, e) => bt(Object.assign({ colorAttribute: 'stroke', symbol: 'line' }, t), e)
Jw.props = Object.assign({ defaultMarker: 'line' }, bt.props)
const tO = (t, e) => bt(Object.assign({ colorAttribute: 'stroke', symbol: 'plus' }, t), e)
tO.props = Object.assign({ defaultMarker: 'plus' }, bt.props)
const eO = (t, e) => bt(Object.assign({ colorAttribute: 'fill', symbol: 'point' }, t), e)
eO.props = Object.assign({ defaultMarker: 'point' }, bt.props)
const nO = (t, e) => bt(Object.assign({ colorAttribute: 'fill', symbol: 'square' }, t), e)
nO.props = Object.assign({ defaultMarker: 'square' }, bt.props)
const rO = (t, e) => bt(Object.assign({ colorAttribute: 'stroke', symbol: 'tick' }, t), e)
rO.props = Object.assign({ defaultMarker: 'tick' }, bt.props)
const iO = (t, e) => bt(Object.assign({ colorAttribute: 'fill', symbol: 'triangle' }, t), e)
iO.props = Object.assign({ defaultMarker: 'triangle' }, bt.props)
const aO = (t, e) => bt(Object.assign({ colorAttribute: 'fill', symbol: 'triangle-down' }, t), e)
aO.props = Object.assign({ defaultMarker: 'triangleDown' }, bt.props)
var Ng =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const $p = (t, e) => {
  const { arrow: n = !0, arrowSize: r = '40%' } = t,
    i = Ng(t, ['arrow', 'arrowSize']),
    { document: a } = e
  return (o, s, c) => {
    const { defaultColor: l } = c,
      u = Ng(c, ['defaultColor']),
      { color: f = l, transform: h } = s,
      [d, p] = o,
      v = Nn()
    if ((v.moveTo(...d), v.lineTo(...p), n)) {
      const [g, y] = XR(d, p, { arrowSize: r })
      v.moveTo(...p), v.lineTo(...g), v.moveTo(...p), v.lineTo(...y)
    }
    return ot(a.createElement('path', {}))
      .call(at, u)
      .style('d', v.toString())
      .style('stroke', f)
      .style('transform', h)
      .call(at, i)
      .node()
  }
}
$p.props = {
  defaultMarker: 'line',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
function oO(t, e) {
  e(t),
    t.children &&
      t.children.forEach(function (n) {
        n && oO(n, e)
      })
}
function js(t) {
  bu(t, !0)
}
function si(t) {
  bu(t, !1)
}
function bu(t, e) {
  var n = e ? 'visible' : 'hidden'
  oO(t, function (r) {
    r.attr('visibility', n)
  })
}
var a6 = (function (t) {
  rt(e, t)
  function e() {
    for (var n = [], r = 0; r < arguments.length; r++) n[r] = arguments[r]
    var i = t.apply(this, q([], N(n), !1)) || this
    return (
      i.addEventListener(dt.INSERTED, function () {
        si(i)
      }),
      i
    )
  }
  return e
})(je)
function sO(t) {
  var e = t.appendChild(new a6({ class: 'offscreen' }))
  return si(e), e
}
function o6(t) {
  for (var e = t; e; ) {
    if (e.className === 'offscreen') return !0
    e = e.parent
  }
  return !1
}
var Bp = (function (t) {
  rt(e, t)
  function e(n) {
    n === void 0 && (n = {})
    var r = n.style,
      i = Dt(n, ['style'])
    return (
      t.call(
        this,
        z(
          {
            style: z(
              {
                text: '',
                fill: 'black',
                fontFamily: 'sans-serif',
                fontSize: 16,
                fontStyle: 'normal',
                fontVariant: 'normal',
                fontWeight: 'normal',
                lineWidth: 1,
                textAlign: 'start',
                textBaseline: 'middle'
              },
              r
            )
          },
          i
        )
      ) || this
    )
  }
  return (
    Object.defineProperty(e.prototype, 'offscreenGroup', {
      get: function () {
        return this._offscreen || (this._offscreen = sO(this)), this._offscreen
      },
      enumerable: !1,
      configurable: !0
    }),
    (e.prototype.disconnectedCallback = function () {
      var n
      ;(n = this._offscreen) === null || n === void 0 || n.destroy()
    }),
    e
  )
})(Za)
function ja(t) {
  return (t * Math.PI) / 180
}
function cO(t) {
  return Number(((t * 180) / Math.PI).toPrecision(5))
}
var te = (function () {
  function t(e, n, r, i) {
    e === void 0 && (e = 0),
      n === void 0 && (n = 0),
      r === void 0 && (r = 0),
      i === void 0 && (i = 0),
      (this.x = 0),
      (this.y = 0),
      (this.width = 0),
      (this.height = 0),
      (this.x = e),
      (this.y = n),
      (this.width = r),
      (this.height = i)
  }
  return (
    Object.defineProperty(t.prototype, 'bottom', {
      get: function () {
        return this.y + this.height
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(t.prototype, 'left', {
      get: function () {
        return this.x
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(t.prototype, 'right', {
      get: function () {
        return this.x + this.width
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(t.prototype, 'top', {
      get: function () {
        return this.y
      },
      enumerable: !1,
      configurable: !0
    }),
    (t.fromRect = function (e) {
      return new t(e.x, e.y, e.width, e.height)
    }),
    (t.prototype.toJSON = function () {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height,
        top: this.top,
        right: this.right,
        bottom: this.bottom,
        left: this.left
      }
    }),
    t
  )
})()
function Cn(t, e) {
  return mn(t) ? t.apply(void 0, q([], N(e), !1)) : t
}
var In = function (t, e) {
    var n = function (i) {
        return ''.concat(e, '-').concat(i)
      },
      r = Object.fromEntries(
        Object.entries(t).map(function (i) {
          var a = N(i, 2),
            o = a[0],
            s = a[1],
            c = n(s)
          return [
            o,
            {
              name: c,
              class: '.'.concat(c),
              id: '#'.concat(c),
              toString: function () {
                return c
              }
            }
          ]
        })
      )
    return Object.assign(r, { prefix: n }), r
  },
  s6 = 5,
  lO = function (t, e, n, r) {
    n === void 0 && (n = 0),
      r === void 0 && (r = s6),
      Object.entries(e).forEach(function (i) {
        var a = N(i, 2),
          o = a[0],
          s = a[1],
          c = t
        Object.prototype.hasOwnProperty.call(e, o) &&
          (s
            ? ki(s)
              ? (ki(t[o]) || (c[o] = {}), n < r ? lO(t[o], s, n + 1, r) : (c[o] = e[o]))
              : bn(s)
              ? ((c[o] = []), (c[o] = c[o].concat(s)))
              : (c[o] = s)
            : (c[o] = s))
      })
  },
  Tr = function (t) {
    for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n]
    for (var r = 0; r < e.length; r += 1) lO(t, e[r])
    return t
  },
  uO = function (t) {
    return t !== void 0 && t != null && !Number.isNaN(t)
  },
  gc,
  c6 = IP(
    function (t, e) {
      var n = ne(t) ? t : t.style.text.toString(),
        r = e || jh(t),
        i = r.fontSize,
        a = r.fontFamily,
        o = r.fontWeight,
        s = r.fontStyle,
        c = r.fontVariant
      return (
        gc || (gc = document.createElement('canvas').getContext('2d')),
        (gc.font = [s, c, o, ''.concat(i, 'px'), a].join(' ')),
        gc.measureText(n).width
      )
    },
    function (t, e) {
      return [ne(t) ? t : t.style.text.toString(), Object.values(e || jh(t)).join()].join('')
    },
    4096
  ),
  jh = function (t) {
    var e = t.style.fontFamily || 'sans-serif',
      n = t.style.fontWeight || 'normal',
      r = t.style.fontStyle || 'normal',
      i = t.style.fontVariant,
      a = t.style.fontSize
    return (
      (a = typeof a == 'object' ? a.value : a),
      { fontSize: a, fontFamily: e, fontWeight: n, fontStyle: r, fontVariant: i }
    )
  }
function fO(t) {
  return t.nodeName === 'text'
    ? t
    : t.nodeName === 'g' && t.children.length === 1 && t.children[0].nodeName === 'text'
    ? t.children[0]
    : null
}
function hO(t, e) {
  var n = fO(t)
  n && n.attr(e)
}
function Dh(t, e, n) {
  n === void 0 && (n = '...'),
    hO(t, { wordWrap: !0, wordWrapWidth: e, maxLines: 1, textOverflow: n })
}
function l6(t, e, n, r) {
  n === void 0 && (n = 2),
    r === void 0 && (r = 'top'),
    hO(t, { wordWrap: !0, wordWrapWidth: e, maxLines: n, textBaseline: r })
}
function vl(t) {
  var e = t.canvas,
    n = t.touches,
    r = t.offsetX,
    i = t.offsetY
  if (e) {
    var a = e.x,
      o = e.y
    return [a, o]
  }
  if (n) {
    var s = n[0],
      c = s.clientX,
      l = s.clientY
    return [c, l]
  }
  return r && i ? [r, i] : [0, 0]
}
function Bi(t) {
  return typeof t == 'function' ? t() : ne(t) || ve(t) ? new Bp({ style: { text: String(t) } }) : t
}
function u6(t, e) {
  return t.reduce(function (n, r) {
    return (n[r[e]] = n[r[e]] || []).push(r), n
  }, {})
}
function tn(t, e, n, r, i) {
  return (
    r === void 0 && (r = !0),
    i === void 0 &&
      (i = function (a) {
        a.node().removeChildren()
      }),
    t ? n(e) : (r && i(e), null)
  )
}
function Ae(t, e, n, r, i) {
  return (
    r === void 0 && (r = !0),
    i === void 0 && (i = !1),
    (r && t === e) || (i && t === n) ? !0 : t > e && t < n
  )
}
var f6 = function (t, e) {
  return function (n) {
    return t * (1 - n) + e * n
  }
}
function h6(t, e) {
  var n = e ? e.length : 0,
    r = t ? Math.min(n, t.length) : 0
  return function (i) {
    var a = new Array(r),
      o = new Array(n),
      s = 0
    for (s = 0; s < r; ++s) a[s] = Fp(t[s], e[s])
    for (; s < n; ++s) o[s] = e[s]
    for (s = 0; s < r; ++s) o[s] = a[s](i)
    return o
  }
}
function d6(t, e) {
  t === void 0 && (t = {}), e === void 0 && (e = {})
  var n = {},
    r = {}
  return (
    Object.entries(e).forEach(function (i) {
      var a = N(i, 2),
        o = a[0],
        s = a[1]
      o in t ? (n[o] = Fp(t[o], s)) : (r[o] = s)
    }),
    function (i) {
      return (
        Object.entries(n).forEach(function (a) {
          var o = N(a, 2),
            s = o[0],
            c = o[1]
          return (r[s] = c(i))
        }),
        r
      )
    }
  )
}
function Fp(t, e) {
  return typeof t == 'number' && typeof e == 'number'
    ? f6(t, e)
    : Array.isArray(t) && Array.isArray(e)
    ? h6(t, e)
    : typeof t == 'object' && typeof e == 'object'
    ? d6(t, e)
    : function (n) {
        return t
      }
}
function p6(t, e, n, r) {
  if (!r) return t.attr('__keyframe_data__', n), null
  var i = r.duration,
    a = i === void 0 ? 0 : i,
    o = Fp(e, n),
    s = Math.ceil(+a / 16),
    c = new Array(s).fill(0).map(function (l, u, f) {
      return { __keyframe_data__: o(u / (f.length - 1)) }
    })
  return t.animate(c, z({ fill: 'both' }, r))
}
function Rg(t) {
  for (var e = 1 / 0, n = 1 / 0, r = -1 / 0, i = -1 / 0, a = 0; a < t.length; a++) {
    var o = t[a],
      s = o.x,
      c = o.y,
      l = o.width,
      u = o.height,
      f = N([s + l, c + u], 2),
      h = f[0],
      d = f[1]
    s < e && (e = s), c < n && (n = c), h > r && (r = h), d > i && (i = d)
  }
  return new te(e, n, r - e, i - n)
}
var v6 = function (t, e, n) {
    var r = t.width,
      i = t.height,
      a = n.flexDirection,
      o = a === void 0 ? 'row' : a
    n.flexWrap
    var s = n.justifyContent,
      c = s === void 0 ? 'flex-start' : s
    n.alignContent
    var l = n.alignItems,
      u = l === void 0 ? 'flex-start' : l,
      f = o === 'row',
      h = o === 'row' || o === 'column',
      d = f ? (h ? [1, 0] : [-1, 0]) : h ? [0, 1] : [0, -1],
      p = N([0, 0], 2),
      v = p[0],
      g = p[1],
      y = e.map(function (_) {
        var M,
          E = _.width,
          T = _.height,
          C = N([v, g], 2),
          A = C[0],
          P = C[1]
        return (M = N([v + E * d[0], g + T * d[1]], 2)), (v = M[0]), (g = M[1]), new te(A, P, E, T)
      }),
      m = Rg(y),
      b = {
        'flex-start': 0,
        'flex-end': f ? r - m.width : i - m.height,
        center: f ? (r - m.width) / 2 : (i - m.height) / 2
      },
      x = y.map(function (_) {
        var M = _.x,
          E = _.y,
          T = te.fromRect(_)
        return (T.x = f ? M + b[c] : M), (T.y = f ? E : E + b[c]), T
      })
    Rg(x)
    var w = function (_) {
        var M = N(f ? ['height', i] : ['width', r], 2),
          E = M[0],
          T = M[1]
        switch (u) {
          case 'flex-start':
            return 0
          case 'flex-end':
            return T - _[E]
          case 'center':
            return T / 2 - _[E] / 2
          default:
            return 0
        }
      },
      O = x.map(function (_) {
        var M = _.x,
          E = _.y,
          T = te.fromRect(_)
        return (T.x = f ? M : M + w(T)), (T.y = f ? E + w(T) : E), T
      }),
      S = O.map(function (_) {
        var M,
          E,
          T = te.fromRect(_)
        return (
          (T.x += (M = t.x) !== null && M !== void 0 ? M : 0),
          (T.y += (E = t.y) !== null && E !== void 0 ? E : 0),
          T
        )
      })
    return S
  },
  g6 = function (t, e, n) {
    return []
  }
const y6 = function (t, e, n) {
  if (e.length === 0) return []
  var r = { flex: v6, grid: g6 },
    i = n.display in r ? r[n.display] : null
  return (i == null ? void 0 : i.call(null, t, e, n)) || []
}
function gr(t, e) {
  return [t[0] * e, t[1] * e]
}
function wo(t, e) {
  return [t[0] + e[0], t[1] + e[1]]
}
function vf(t, e) {
  return [t[0] - e[0], t[1] - e[1]]
}
function mi(t, e) {
  return [Math.min(t[0], e[0]), Math.min(t[1], e[1])]
}
function bi(t, e) {
  return [Math.max(t[0], e[0]), Math.max(t[1], e[1])]
}
function as(t, e) {
  return Math.sqrt(Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2))
}
function dO(t) {
  if (t[0] === 0 && t[1] === 0) return [0, 0]
  var e = Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2))
  return [t[0] / e, t[1] / e]
}
function m6(t, e) {
  return e ? [t[1], -t[0]] : [-t[1], t[0]]
}
function $h(t, e) {
  return +t.toPrecision(e)
}
function Ig(t, e) {
  var n = {},
    r = Array.isArray(e) ? e : [e]
  for (var i in t) r.includes(i) || (n[i] = t[i])
  return n
}
function b6(t, e, n, r) {
  var i,
    a = [],
    o = !!r,
    s,
    c,
    l = [1 / 0, 1 / 0],
    u = [-1 / 0, -1 / 0],
    f,
    h,
    d
  if (o) {
    ;(i = N(r, 2)), (l = i[0]), (u = i[1])
    for (var p = 0, v = t.length; p < v; p += 1) {
      var g = t[p]
      ;(l = mi(l, g)), (u = bi(u, g))
    }
  }
  for (var p = 0, y = t.length; p < y; p += 1) {
    var g = t[p]
    if (p === 0 && !n) d = g
    else if (p === y - 1 && !n) (h = g), a.push(d), a.push(h)
    else {
      var m = [p ? p - 1 : y - 1, p - 1][n ? 0 : 1]
      ;(s = t[m]), (c = t[n ? (p + 1) % y : p + 1])
      var b = [0, 0]
      ;(b = vf(c, s)), (b = gr(b, e))
      var x = as(g, s),
        w = as(g, c),
        O = x + w
      O !== 0 && ((x /= O), (w /= O))
      var S = gr(b, -x),
        _ = gr(b, w)
      ;(h = wo(g, S)),
        (f = wo(g, _)),
        (f = mi(f, bi(c, g))),
        (f = bi(f, mi(c, g))),
        (S = vf(f, g)),
        (S = gr(S, -x / w)),
        (h = wo(g, S)),
        (h = mi(h, bi(s, g))),
        (h = bi(h, mi(s, g))),
        (_ = vf(g, h)),
        (_ = gr(_, w / x)),
        (f = wo(g, _)),
        o && ((h = bi(h, l)), (h = mi(h, u)), (f = bi(f, l)), (f = mi(f, u))),
        a.push(d),
        a.push(h),
        (d = f)
    }
  }
  return n && a.push(a.shift()), a
}
function x6(t, e, n) {
  var r
  e === void 0 && (e = !1),
    n === void 0 &&
      (n = [
        [0, 0],
        [1, 1]
      ])
  for (var i = !!e, a = [], o = 0, s = t.length; o < s; o += 2) a.push([t[o], t[o + 1]])
  for (var c = b6(a, 0.4, i, n), l = a.length, u = [], f, h, d, o = 0; o < l - 1; o += 1)
    (f = c[o * 2]),
      (h = c[o * 2 + 1]),
      (d = a[o + 1]),
      u.push(['C', f[0], f[1], h[0], h[1], d[0], d[1]])
  return (
    i &&
      ((f = c[l]),
      (h = c[l + 1]),
      (r = N(a, 1)),
      (d = r[0]),
      u.push(['C', f[0], f[1], h[0], h[1], d[0], d[1]])),
    u
  )
}
var w6 = [
  '$el',
  'anchor',
  'cx',
  'cy',
  'd',
  'defX',
  'defY',
  'dx',
  'dy',
  'fill',
  'fillOpacity',
  'filter',
  'fontFamily',
  'fontSize',
  'fontStyle',
  'fontVariant',
  'fontWeight',
  'height',
  'img',
  'increasedLineWidthForHitTesting',
  'innerHTML',
  'isBillboard',
  'billboardRotation',
  'isSizeAttenuation',
  'isClosed',
  'isOverflowing',
  'leading',
  'letterSpacing',
  'lineDash',
  'lineHeight',
  'lineWidth',
  'markerEnd',
  'markerEndOffset',
  'markerMid',
  'markerStart',
  'markerStartOffset',
  'maxLines',
  'metrics',
  'miterLimit',
  'offsetX',
  'offsetY',
  'opacity',
  'path',
  'points',
  'r',
  'radius',
  'rx',
  'ry',
  'shadowColor',
  'src',
  'stroke',
  'strokeOpacity',
  'text',
  'textAlign',
  'textBaseline',
  'textDecorationColor',
  'textDecorationLine',
  'textDecorationStyle',
  'textOverflow',
  'textPath',
  'textPathSide',
  'textPathStartOffset',
  'transform',
  'transformOrigin',
  'visibility',
  'width',
  'wordWrap',
  'wordWrapWidth',
  'x',
  'x1',
  'x2',
  'y',
  'y1',
  'y2',
  'z1',
  'z2',
  'zIndex'
]
function O6(t) {
  return w6.includes(t)
}
function jg(t) {
  var e = {}
  for (var n in t) O6(n) && (e[n] = t[n])
  return e
}
function S6(t, e) {
  if (t.length <= e) return t
  for (var n = Math.floor(t.length / e), r = [], i = 0; i < t.length; i += n) r.push(t[i])
  return r
}
function zp(t, e, n) {
  n === void 0 && (n = !1)
  var r = t.getBBox(),
    i = r.width,
    a = r.height,
    o = e / Math.max(i, a)
  return n && t.scale(o), o
}
function _6(t, e) {
  var n = new Map()
  return (
    t.forEach(function (r) {
      var i = e(r)
      n.has(i) || n.set(i, []), n.get(i).push(r)
    }),
    n
  )
}
function M6(t) {
  throw new Error(t)
}
var E6 = (function () {
  function t(i, a, o, s, c, l, u) {
    i === void 0 && (i = null),
      a === void 0 && (a = null),
      o === void 0 && (o = null),
      s === void 0 && (s = null),
      c === void 0 && (c = [null, null, null, null, null]),
      l === void 0 && (l = []),
      u === void 0 && (u = []),
      e.add(this),
      (this._elements = Array.from(i)),
      (this._data = a),
      (this._parent = o),
      (this._document = s),
      (this._enter = c[0]),
      (this._update = c[1]),
      (this._exit = c[2]),
      (this._merge = c[3]),
      (this._split = c[4]),
      (this._transitions = l),
      (this._facetElements = u)
  }
  ;(t.prototype.selectAll = function (i) {
    var a = typeof i == 'string' ? this._parent.querySelectorAll(i) : i
    return new n(a, null, this._elements[0], this._document)
  }),
    (t.prototype.selectFacetAll = function (i) {
      var a = typeof i == 'string' ? this._parent.querySelectorAll(i) : i
      return new n(this._elements, null, this._parent, this._document, void 0, void 0, a)
    }),
    (t.prototype.select = function (i) {
      var a = typeof i == 'string' ? this._parent.querySelectorAll(i)[0] || null : i
      return new n([a], null, a, this._document)
    }),
    (t.prototype.append = function (i) {
      var a = this,
        o =
          typeof i == 'function'
            ? i
            : function () {
                return a.createElement(i)
              },
        s = []
      if (this._data !== null) {
        for (var c = 0; c < this._data.length; c++) {
          var l = this._data[c],
            u = N(Array.isArray(l) ? l : [l, null], 2),
            f = u[0],
            h = u[1],
            d = o(f, c)
          ;(d.__data__ = f),
            h !== null && (d.__fromElements__ = h),
            this._parent.appendChild(d),
            s.push(d)
        }
        return new n(s, null, this._parent, this._document)
      }
      for (var c = 0; c < this._elements.length; c++) {
        var p = this._elements[c],
          f = p.__data__,
          d = o(f, c)
        p.appendChild(d), s.push(d)
      }
      return new n(s, null, s[0], this._document)
    }),
    (t.prototype.maybeAppend = function (i, a) {
      var o = Vu(this, e, 'm', r).call(this, i[0] === '#' ? i : '#'.concat(i), a)
      return o.attr('id', i), o
    }),
    (t.prototype.maybeAppendByClassName = function (i, a) {
      var o = i.toString(),
        s = Vu(this, e, 'm', r).call(this, o[0] === '.' ? o : '.'.concat(o), a)
      return s.attr('className', o), s
    }),
    (t.prototype.maybeAppendByName = function (i, a) {
      var o = Vu(this, e, 'm', r).call(this, '[name="'.concat(i, '"]'), a)
      return o.attr('name', i), o
    }),
    (t.prototype.data = function (i, a, o) {
      var s, c
      a === void 0 &&
        (a = function (E) {
          return E
        }),
        o === void 0 &&
          (o = function () {
            return null
          })
      for (
        var l = [],
          u = [],
          f = new Set(this._elements),
          h = [],
          d = new Set(),
          p = new Map(
            this._elements.map(function (E, T) {
              return [a(E.__data__, T), E]
            })
          ),
          v = new Map(
            this._facetElements.map(function (E, T) {
              return [a(E.__data__, T), E]
            })
          ),
          g = _6(this._elements, function (E) {
            return o(E.__data__)
          }),
          y = 0;
        y < i.length;
        y++
      ) {
        var m = i[y],
          b = a(m, y),
          x = o(m, y)
        if (p.has(b)) {
          var w = p.get(b)
          ;(w.__data__ = m), (w.__facet__ = !1), u.push(w), f.delete(w), p.delete(b)
        } else if (v.has(b)) {
          var w = v.get(b)
          ;(w.__data__ = m), (w.__facet__ = !0), u.push(w), v.delete(b)
        } else if (g.has(b)) {
          var O = g.get(b)
          h.push([m, O])
          try {
            for (var S = ((s = void 0), hn(O)), _ = S.next(); !_.done; _ = S.next()) {
              var w = _.value
              f.delete(w)
            }
          } catch (E) {
            s = { error: E }
          } finally {
            try {
              _ && !_.done && (c = S.return) && c.call(S)
            } finally {
              if (s) throw s.error
            }
          }
          g.delete(b)
        } else if (p.has(x)) {
          var w = p.get(x)
          w.__toData__ ? w.__toData__.push(m) : (w.__toData__ = [m]), d.add(w), f.delete(w)
        } else l.push(m)
      }
      var M = [
        new n([], l, this._parent, this._document),
        new n(u, null, this._parent, this._document),
        new n(f, null, this._parent, this._document),
        new n([], h, this._parent, this._document),
        new n(d, null, this._parent, this._document)
      ]
      return new n(this._elements, null, this._parent, this._document, M)
    }),
    (t.prototype.merge = function (i) {
      var a = q(q([], N(this._elements), !1), N(i._elements), !1),
        o = q(q([], N(this._transitions), !1), N(i._transitions), !1)
      return new n(a, null, this._parent, this._document, void 0, o)
    }),
    (t.prototype.createElement = function (i) {
      if (this._document) return this._document.createElement(i, {})
      var a = n.registry[i]
      return a ? new a() : M6('Unknown node type: '.concat(i))
    }),
    (t.prototype.join = function (i, a, o, s, c) {
      i === void 0 &&
        (i = function (p) {
          return p
        }),
        a === void 0 &&
          (a = function (p) {
            return p
          }),
        o === void 0 &&
          (o = function (p) {
            return p.remove()
          }),
        s === void 0 &&
          (s = function (p) {
            return p
          }),
        c === void 0 &&
          (c = function (p) {
            return p.remove()
          })
      var l = i(this._enter),
        u = a(this._update),
        f = o(this._exit),
        h = s(this._merge),
        d = c(this._split)
      return u.merge(l).merge(f).merge(h).merge(d)
    }),
    (t.prototype.remove = function () {
      for (
        var i = function (s) {
            var c = a._elements[s],
              l = a._transitions[s]
            l
              ? l.then(function () {
                  return c.remove()
                })
              : c.remove()
          },
          a = this,
          o = 0;
        o < this._elements.length;
        o++
      )
        i(o)
      return new n([], null, this._parent, this._document, void 0, this._transitions)
    }),
    (t.prototype.each = function (i) {
      for (var a = 0; a < this._elements.length; a++) {
        var o = this._elements[a],
          s = o.__data__
        i.call(o, s, a)
      }
      return this
    }),
    (t.prototype.attr = function (i, a) {
      var o =
        typeof a != 'function'
          ? function () {
              return a
            }
          : a
      return this.each(function (s, c) {
        a !== void 0 && (this[i] = o.call(this, s, c))
      })
    }),
    (t.prototype.style = function (i, a, o) {
      o === void 0 && (o = !0)
      var s =
        typeof a != 'function' || !o
          ? function () {
              return a
            }
          : a
      return this.each(function (c, l) {
        a !== void 0 && (this.style[i] = s.call(this, c, l))
      })
    }),
    (t.prototype.styles = function (i, a) {
      return (
        i === void 0 && (i = {}),
        a === void 0 && (a = !0),
        this.each(function (o, s) {
          var c = this
          Object.entries(i).forEach(function (l) {
            var u = N(l, 2),
              f = u[0],
              h = u[1],
              d =
                typeof h != 'function' || !a
                  ? function () {
                      return h
                    }
                  : h
            h !== void 0 && c.attr(f, d.call(c, o, s))
          })
        })
      )
    }),
    (t.prototype.update = function (i, a) {
      a === void 0 && (a = !0)
      var o =
        typeof i != 'function' || !a
          ? function () {
              return i
            }
          : i
      return this.each(function (s, c) {
        i && this.update && this.update(o.call(this, s, c))
      })
    }),
    (t.prototype.maybeUpdate = function (i, a) {
      a === void 0 && (a = !0)
      var o =
        typeof i != 'function' || !a
          ? function () {
              return i
            }
          : i
      return this.each(function (s, c) {
        i && this.update && this.update(o.call(this, s, c))
      })
    }),
    (t.prototype.transition = function (i) {
      var a = this._transitions
      return this.each(function (o, s) {
        a[s] = i.call(this, o, s)
      })
    }),
    (t.prototype.on = function (i, a) {
      return (
        this.each(function () {
          this.addEventListener(i, a)
        }),
        this
      )
    }),
    (t.prototype.call = function (i) {
      for (var a = [], o = 1; o < arguments.length; o++) a[o - 1] = arguments[o]
      return i.call.apply(i, q([this._parent, this], N(a), !1)), this
    }),
    (t.prototype.node = function () {
      return this._elements[0]
    }),
    (t.prototype.nodes = function () {
      return this._elements
    }),
    (t.prototype.transitions = function () {
      return this._transitions.filter(function (i) {
        return !!i
      })
    }),
    (t.prototype.parent = function () {
      return this._parent
    })
  var e, n, r
  return (
    (n = t),
    (e = new WeakSet()),
    (r = function (a, o) {
      var s = this._elements[0],
        c = s.querySelector(a)
      if (c) return new n([c], null, this._parent, this._document)
      var l = typeof o == 'string' ? this.createElement(o) : o()
      return s.appendChild(l), new n([l], null, this._parent, this._document)
    }),
    (t.registry = {
      g: je,
      rect: Xi,
      circle: Ns,
      path: rn,
      text: Bp,
      ellipse: _p,
      image: Mp,
      line: Rs,
      polygon: pu,
      polyline: Ep,
      html: du
    }),
    t
  )
})()
function ft(t) {
  return new E6([t], null, t, t.ownerDocument)
}
function T6(t, e, n) {
  return t.querySelector(e) ? ft(t).select(e) : ft(t).append(n)
}
function ke(t) {
  if (ve(t)) return [t, t, t, t]
  if (bn(t)) {
    var e = t.length
    if (e === 1) return [t[0], t[0], t[0], t[0]]
    if (e === 2) return [t[0], t[1], t[0], t[1]]
    if (e === 3) return [t[0], t[1], t[2], t[1]]
    if (e === 4) return t
  }
  return [0, 0, 0, 0]
}
function Dg(t) {
  var e = t.getLocalBounds(),
    n = e.min,
    r = e.max,
    i = N([n, r], 2),
    a = N(i[0], 2),
    o = a[0],
    s = a[1],
    c = N(i[1], 2),
    l = c[0],
    u = c[1]
  return { x: o, y: s, width: l - o, height: u - s, left: o, bottom: u, top: s, right: l }
}
function P6(t, e) {
  var n = N(t, 2),
    r = n[0],
    i = n[1],
    a = N(e, 2),
    o = a[0],
    s = a[1]
  return r !== o && i === s
}
function A6(t, e) {
  var n,
    r,
    i = e.attributes
  try {
    for (var a = hn(Object.entries(i)), o = a.next(); !o.done; o = a.next()) {
      var s = N(o.value, 2),
        c = s[0],
        l = s[1]
      c !== 'id' && c !== 'className' && t.attr(c, l)
    }
  } catch (u) {
    n = { error: u }
  } finally {
    try {
      o && !o.done && (r = a.return) && r.call(a)
    } finally {
      if (n) throw n.error
    }
  }
}
function Gp(t) {
  return t.toString().charAt(0).toUpperCase() + t.toString().slice(1)
}
function k6(t) {
  return t.toString().charAt(0).toLowerCase() + t.toString().slice(1)
}
function C6(t, e) {
  return ''.concat(e).concat(Gp(t))
}
function $g(t, e, n) {
  var r
  n === void 0 && (n = !0)
  var i = e || ((r = t.match(/^([a-z][a-z0-9]+)/)) === null || r === void 0 ? void 0 : r[0]) || '',
    a = t.replace(new RegExp('^('.concat(i, ')')), '')
  return n ? k6(a) : a
}
function L6(t, e) {
  Object.entries(e).forEach(function (n) {
    var r = N(n, 2),
      i = r[0],
      a = r[1]
    q([t], N(t.querySelectorAll(i)), !1)
      .filter(function (o) {
        return o.matches(i)
      })
      .forEach(function (o) {
        if (o) {
          var s = o
          s.style.cssText += Object.entries(a).reduce(function (c, l) {
            return ''.concat(c).concat(l.join(':'), ';')
          }, '')
        }
      })
  })
}
var yc = function (t, e) {
  if (!(t != null && t.startsWith(e))) return !1
  var n = t[e.length]
  return n >= 'A' && n <= 'Z'
}
function vt(t, e, n) {
  n === void 0 && (n = !1)
  var r = {}
  return (
    Object.entries(t).forEach(function (i) {
      var a = N(i, 2),
        o = a[0],
        s = a[1]
      if (!(o === 'className' || o === 'class')) {
        if (yc(o, 'show') && yc($g(o, 'show'), e) !== n)
          o === C6(e, 'show') ? (r[o] = s) : (r[o.replace(new RegExp(Gp(e)), '')] = s)
        else if (!yc(o, 'show') && yc(o, e) !== n) {
          var c = $g(o, e)
          ;(c === 'filter' && typeof s == 'function') || (r[c] = s)
        }
      }
    }),
    r
  )
}
function Kn(t, e) {
  return Object.entries(t).reduce(function (n, r) {
    var i = N(r, 2),
      a = i[0],
      o = i[1]
    return (
      a.startsWith('show')
        ? (n['show'.concat(e).concat(a.slice(4))] = o)
        : (n[''.concat(e).concat(Gp(a))] = o),
      n
    )
  }, {})
}
function Pr(t, e) {
  e === void 0 && (e = ['x', 'y', 'class', 'className'])
  var n = [
      'transform',
      'transformOrigin',
      'anchor',
      'visibility',
      'pointerEvents',
      'zIndex',
      'cursor',
      'clipPath',
      'clipPathTargets',
      'offsetPath',
      'offsetPathTargets',
      'offsetDistance',
      'draggable',
      'droppable'
    ],
    r = {},
    i = {}
  return (
    Object.entries(t).forEach(function (a) {
      var o = N(a, 2),
        s = o[0],
        c = o[1]
      e.includes(s) || (n.indexOf(s) !== -1 ? (i[s] = c) : (r[s] = c))
    }),
    [r, i]
  )
}
function N6(t, e) {
  return (
    t === void 0 && (t = 0),
    e === void 0 && (e = !1),
    function (n, r, i) {
      var a = i.value,
        o
      typeof a == 'function' &&
        (i.value = function () {
          for (var s = [], c = 0; c < arguments.length; c++) s[c] = arguments[c]
          if (!o) {
            var l = this
            e && a.apply(l, s),
              (o = window.setTimeout(function () {
                a.apply(l, s), (o = null)
              }, t))
          }
        })
    }
  )
}
function R6(t, e, n) {
  var r = t.getBBox(),
    i = r.width,
    a = r.height,
    o = N(
      [e, n].map(function (l, u) {
        var f
        return l.includes('%')
          ? (parseFloat(
              ((f = l.match(/[+-]?([0-9]*[.])?[0-9]+/)) === null || f === void 0 ? void 0 : f[0]) ||
                '0'
            ) /
              100) *
              (u === 0 ? i : a)
          : l
      }),
      2
    ),
    s = o[0],
    c = o[1]
  return [s, c]
}
function gl(t, e) {
  if (e)
    try {
      var n = /translate\(([+-]*[\d]+[%]*),[ ]*([+-]*[\d]+[%]*)\)/g,
        r = e.replace(n, function (i, a, o) {
          return 'translate('.concat(R6(t, a, o), ')')
        })
      t.attr('transform', r)
    } catch {}
}
function I6(t) {
  var e
  return (
    ((e = t[0]) === null || e === void 0
      ? void 0
      : e.map(function (n, r) {
          return t.map(function (i) {
            return i[r]
          })
        })) || []
  )
}
function j6() {
  bu(this, this.attributes.visibility !== 'hidden')
}
var Te = (function (t) {
    rt(e, t)
    function e(n, r) {
      r === void 0 && (r = {})
      var i = t.call(this, Tr({}, { style: r }, n)) || this
      return (i.initialized = !1), (i._defaultOptions = r), i
    }
    return (
      Object.defineProperty(e.prototype, 'offscreenGroup', {
        get: function () {
          return this._offscreen || (this._offscreen = sO(this)), this._offscreen
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'defaultOptions', {
        get: function () {
          return this._defaultOptions
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.connectedCallback = function () {
        this.render(this.attributes, this),
          this.bindEvents(this.attributes, this),
          (this.initialized = !0)
      }),
      (e.prototype.disconnectedCallback = function () {
        var n
        ;(n = this._offscreen) === null || n === void 0 || n.destroy()
      }),
      (e.prototype.attributeChangedCallback = function (n) {
        n === 'visibility' && j6.call(this)
      }),
      (e.prototype.update = function (n, r) {
        var i
        return (
          this.attr(Tr({}, this.attributes, n || {})),
          (i = this.render) === null || i === void 0
            ? void 0
            : i.call(this, this.attributes, this, r)
        )
      }),
      (e.prototype.clear = function () {
        this.removeChildren()
      }),
      (e.prototype.bindEvents = function (n, r) {}),
      e
    )
  })(Sp),
  pO = function (t, e, n) {
    return [['M', t - n, e], ['A', n, n, 0, 1, 0, t + n, e], ['A', n, n, 0, 1, 0, t - n, e], ['Z']]
  },
  D6 = pO,
  $6 = function (t, e, n) {
    return [
      ['M', t - n, e - n],
      ['L', t + n, e - n],
      ['L', t + n, e + n],
      ['L', t - n, e + n],
      ['Z']
    ]
  },
  B6 = function (t, e, n) {
    return [['M', t - n, e], ['L', t, e - n], ['L', t + n, e], ['L', t, e + n], ['Z']]
  },
  F6 = function (t, e, n) {
    var r = n * Math.sin(0.3333333333333333 * Math.PI)
    return [['M', t - n, e + r], ['L', t, e - r], ['L', t + n, e + r], ['Z']]
  },
  z6 = function (t, e, n) {
    var r = n * Math.sin(0.3333333333333333 * Math.PI)
    return [['M', t - n, e - r], ['L', t + n, e - r], ['L', t, e + r], ['Z']]
  },
  G6 = function (t, e, n) {
    var r = (n / 2) * Math.sqrt(3)
    return [
      ['M', t, e - n],
      ['L', t + r, e - n / 2],
      ['L', t + r, e + n / 2],
      ['L', t, e + n],
      ['L', t - r, e + n / 2],
      ['L', t - r, e - n / 2],
      ['Z']
    ]
  },
  W6 = function (t, e, n) {
    var r = n - 1.5
    return [
      ['M', t - n, e - r],
      ['L', t + n, e + r],
      ['L', t + n, e - r],
      ['L', t - n, e + r],
      ['Z']
    ]
  },
  vO = function (t, e, n) {
    return [
      ['M', t, e + n],
      ['L', t, e - n]
    ]
  },
  Y6 = function (t, e, n) {
    return [
      ['M', t - n, e - n],
      ['L', t + n, e + n],
      ['M', t + n, e - n],
      ['L', t - n, e + n]
    ]
  },
  H6 = function (t, e, n) {
    return [
      ['M', t - n / 2, e - n],
      ['L', t + n / 2, e - n],
      ['M', t, e - n],
      ['L', t, e + n],
      ['M', t - n / 2, e + n],
      ['L', t + n / 2, e + n]
    ]
  },
  V6 = function (t, e, n) {
    return [
      ['M', t - n, e],
      ['L', t + n, e],
      ['M', t, e - n],
      ['L', t, e + n]
    ]
  },
  X6 = function (t, e, n) {
    return [
      ['M', t - n, e],
      ['L', t + n, e]
    ]
  },
  gO = function (t, e, n) {
    return [
      ['M', t - n, e],
      ['L', t + n, e]
    ]
  },
  U6 = gO,
  q6 = function (t, e, n) {
    return [
      ['M', t - n, e],
      ['A', n / 2, n / 2, 0, 1, 1, t, e],
      ['A', n / 2, n / 2, 0, 1, 0, t + n, e]
    ]
  },
  K6 = function (t, e, n) {
    return [
      ['M', t - n - 1, e - 2.5],
      ['L', t, e - 2.5],
      ['L', t, e + 2.5],
      ['L', t + n + 1, e + 2.5]
    ]
  },
  Z6 = function (t, e, n) {
    return [
      ['M', t - n - 1, e + 2.5],
      ['L', t, e + 2.5],
      ['L', t, e - 2.5],
      ['L', t + n + 1, e - 2.5]
    ]
  },
  Q6 = function (t, e, n) {
    return [
      ['M', t - (n + 1), e + 2.5],
      ['L', t - n / 2, e + 2.5],
      ['L', t - n / 2, e - 2.5],
      ['L', t + n / 2, e - 2.5],
      ['L', t + n / 2, e + 2.5],
      ['L', t + n + 1, e + 2.5]
    ]
  }
function J6(t, e) {
  return [
    ['M', t - 5, e + 2.5],
    ['L', t - 5, e],
    ['L', t, e],
    ['L', t, e - 3],
    ['L', t, e + 3],
    ['L', t + 6.5, e + 3]
  ]
}
var t8 = function (t, e, n) {
  return [['M', t - n, e - n], ['L', t + n, e], ['L', t - n, e + n], ['Z']]
}
function e8(t) {
  var e = 'default'
  if (Ei(t) && t instanceof Image) e = 'image'
  else if (mn(t)) e = 'symbol'
  else if (ne(t)) {
    var n = new RegExp('data:(image|text)')
    t.match(n)
      ? (e = 'base64')
      : /^(https?:\/\/(([a-zA-Z0-9]+-?)+[a-zA-Z0-9]+\.)+[a-zA-Z]+)(:\d+)?(\/.*)?(\?.*)?(#.*)?$/.test(
          t
        )
      ? (e = 'url')
      : (e = 'symbol')
  }
  return e
}
function n8(t) {
  var e = e8(t)
  return ['base64', 'url', 'image'].includes(e) ? 'image' : t && e === 'symbol' ? 'path' : null
}
var $t = (function (t) {
  rt(e, t)
  function e() {
    return (t !== null && t.apply(this, arguments)) || this
  }
  return (
    (e.prototype.render = function (n, r) {
      var i = n.symbol,
        a = n.size,
        o = a === void 0 ? 16 : a,
        s = Dt(n, ['symbol', 'size']),
        c = n8(i)
      tn(!!c, ft(r), function (l) {
        l.maybeAppendByClassName('marker', c)
          .attr('className', 'marker '.concat(c, '-marker'))
          .call(function (u) {
            if (c === 'image') {
              var f = o * 2
              u.styles({ img: i, width: f, height: f, x: -o, y: -o })
            } else {
              var f = o / 2,
                h = mn(i) ? i : e.getSymbol(i)
              u.styles(z({ path: h == null ? void 0 : h(0, 0, f) }, s))
            }
          })
      })
    }),
    (e.MARKER_SYMBOL_MAP = new Map()),
    (e.registerSymbol = function (n, r) {
      e.MARKER_SYMBOL_MAP.set(n, r)
    }),
    (e.getSymbol = function (n) {
      return e.MARKER_SYMBOL_MAP.get(n)
    }),
    e
  )
})(Te)
$t.registerSymbol('cross', Y6)
$t.registerSymbol('hyphen', X6)
$t.registerSymbol('line', vO)
$t.registerSymbol('plus', V6)
$t.registerSymbol('tick', H6)
$t.registerSymbol('circle', pO)
$t.registerSymbol('point', D6)
$t.registerSymbol('bowtie', W6)
$t.registerSymbol('hexagon', G6)
$t.registerSymbol('square', $6)
$t.registerSymbol('diamond', B6)
$t.registerSymbol('triangle', F6)
$t.registerSymbol('triangle-down', z6)
$t.registerSymbol('line', vO)
$t.registerSymbol('dot', gO)
$t.registerSymbol('dash', U6)
$t.registerSymbol('smooth', q6)
$t.registerSymbol('hv', K6)
$t.registerSymbol('vh', Z6)
$t.registerSymbol('hvh', Q6)
$t.registerSymbol('vhv', J6)
var r8 = (function (t) {
    rt(e, t)
    function e(n) {
      var r = this,
        i = n.style,
        a = Dt(n, ['style'])
      return (
        (r = t.call(this, X({}, { type: 'column' }, z({ style: i }, a))) || this),
        (r.columnsGroup = new je({ name: 'columns' })),
        r.appendChild(r.columnsGroup),
        r.render(),
        r
      )
    }
    return (
      (e.prototype.render = function () {
        var n = this.attributes.columns
        ft(this.columnsGroup)
          .selectAll('.column')
          .data(n.flat())
          .join(
            function (r) {
              return r
                .append('rect')
                .attr('className', 'column')
                .each(function (i) {
                  this.attr(i)
                })
            },
            function (r) {
              return r.each(function (i) {
                this.attr(i)
              })
            },
            function (r) {
              return r.remove()
            }
          )
      }),
      (e.prototype.update = function (n) {
        this.attr(Tr({}, this.attributes, n)), this.render()
      }),
      (e.prototype.clear = function () {
        this.removeChildren()
      }),
      e
    )
  })(Be),
  i8 = (function (t) {
    rt(e, t)
    function e(n) {
      var r = this,
        i = n.style,
        a = Dt(n, ['style'])
      return (
        (r = t.call(this, X({}, { type: 'lines' }, z({ style: i }, a))) || this),
        (r.linesGroup = r.appendChild(new je())),
        (r.areasGroup = r.appendChild(new je())),
        r.render(),
        r
      )
    }
    return (
      (e.prototype.render = function () {
        var n = this.attributes,
          r = n.lines,
          i = n.areas
        r && this.renderLines(r), i && this.renderAreas(i)
      }),
      (e.prototype.clear = function () {
        this.linesGroup.removeChildren(), this.areasGroup.removeChildren()
      }),
      (e.prototype.update = function (n) {
        this.attr(Tr({}, this.attributes, n)), this.render()
      }),
      (e.prototype.renderLines = function (n) {
        ft(this.linesGroup)
          .selectAll('.line')
          .data(n)
          .join(
            function (r) {
              return r
                .append('path')
                .attr('className', 'line')
                .each(function (i) {
                  this.attr(i)
                })
            },
            function (r) {
              return r.each(function (i) {
                this.attr(i)
              })
            },
            function (r) {
              return r.remove()
            }
          )
      }),
      (e.prototype.renderAreas = function (n) {
        ft(this.linesGroup)
          .selectAll('.area')
          .data(n)
          .join(
            function (r) {
              return r
                .append('path')
                .attr('className', 'area')
                .each(function (i) {
                  this.attr(i)
                })
            },
            function (r) {
              return r.each(function (i) {
                this.style(i)
              })
            },
            function (r) {
              return r.remove()
            }
          )
      }),
      e
    )
  })(Be)
function a8(t, e) {
  var n,
    r = e.x,
    i = e.y,
    a = N(i.getOptions().range || [0, 0], 2),
    o = a[0],
    s = a[1]
  return (
    s > o && ((n = N([o, s], 2)), (s = n[0]), (o = n[1])),
    t.map(function (c) {
      var l = c.map(function (u, f) {
        return [r.map(f), se(i.map(u), s, o)]
      })
      return l
    })
  )
}
function os(t, e) {
  e === void 0 && (e = !1)
  var n = e ? t.length - 1 : 0,
    r = t.map(function (i, a) {
      return q([a === n ? 'M' : 'L'], N(i), !1)
    })
  return e ? r.reverse() : r
}
function yl(t, e) {
  if ((e === void 0 && (e = !1), t.length <= 2)) return os(t)
  for (var n = [], r = t.length, i = 0; i < r; i += 1) {
    var a = e ? t[r - i - 1] : t[i]
    eb(a, n.slice(-2)) || n.push.apply(n, q([], N(a), !1))
  }
  var o = x6(n, !1)
  return e ? o.unshift(q(['M'], N(t[r - 1]), !1)) : o.unshift(q(['M'], N(t[0]), !1)), o
}
function Wp(t, e, n) {
  var r = jd(t)
  return r.push(['L', e, n], ['L', 0, n], ['Z']), r
}
function o8(t, e, n, r) {
  return t.map(function (i) {
    return Wp(e ? yl(i) : os(i), n, r)
  })
}
function s8(t, e, n) {
  for (var r = [], i = t.length - 1; i >= 0; i -= 1) {
    var a = t[i],
      o = os(a),
      s = void 0
    if (i === 0) s = Wp(o, e, n)
    else {
      var c = t[i - 1],
        l = os(c, !0)
      ;(l[0][0] = 'L'), (s = q(q(q([], N(o), !1), N(l), !1), [['Z']], !1))
    }
    r.push(s)
  }
  return r
}
function c8(t, e, n) {
  for (var r = [], i = t.length - 1; i >= 0; i -= 1) {
    var a = t[i],
      o = yl(a),
      s = void 0
    if (i === 0) s = Wp(o, e, n)
    else {
      var c = t[i - 1],
        l = yl(c, !0),
        u = a[0]
      ;(l[0][0] = 'L'), (s = q(q(q([], N(o), !1), N(l), !1), [q(['M'], N(u), !1), ['Z']], !1))
    }
    r.push(s)
  }
  return r
}
function Bg(t) {
  return t.length === 0
    ? [0, 0]
    : [
        Kc(
          PP(t, function (e) {
            return Kc(e) || 0
          })
        ),
        qc(
          TP(t, function (e) {
            return qc(e) || 0
          })
        )
      ]
}
function Fg(t) {
  for (
    var e = jd(t),
      n = e[0].length,
      r = N([Array(n).fill(0), Array(n).fill(0)], 2),
      i = r[0],
      a = r[1],
      o = 0;
    o < e.length;
    o += 1
  )
    for (var s = e[o], c = 0; c < n; c += 1)
      s[c] >= 0 ? ((s[c] += i[c]), (i[c] = s[c])) : ((s[c] += a[c]), (a[c] = s[c]))
  return e
}
var l8 = (function (t) {
  rt(e, t)
  function e(n) {
    return (
      t.call(this, n, {
        type: 'line',
        width: 200,
        height: 20,
        isStack: !1,
        color: ['#83daad', '#edbf45', '#d2cef9', '#e290b3', '#6f63f4'],
        smooth: !0,
        lineLineWidth: 1,
        areaOpacity: 0,
        isGroup: !1,
        columnLineWidth: 1,
        columnStroke: '#fff',
        scale: 1,
        spacing: 0
      }) || this
    )
  }
  return (
    Object.defineProperty(e.prototype, 'rawData', {
      get: function () {
        var n = this.attributes.data
        if (!n || (n == null ? void 0 : n.length) === 0) return [[]]
        var r = jd(n)
        return ve(r[0]) ? [r] : r
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'data', {
      get: function () {
        return this.attributes.isStack ? Fg(this.rawData) : this.rawData
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'scales', {
      get: function () {
        return this.createScales(this.data)
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'baseline', {
      get: function () {
        var n = this.scales.y,
          r = N(n.getOptions().domain || [0, 0], 2),
          i = r[0],
          a = r[1]
        return a < 0 ? n.map(a) : n.map(i < 0 ? 0 : i)
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'containerShape', {
      get: function () {
        var n = this.attributes,
          r = n.width,
          i = n.height
        return { width: r, height: i }
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'linesStyle', {
      get: function () {
        var n = this,
          r = this.attributes,
          i = r.type,
          a = r.isStack,
          o = r.smooth
        if (i !== 'line') throw new Error('linesStyle can only be used in line type')
        var s = vt(this.attributes, 'area'),
          c = vt(this.attributes, 'line'),
          l = this.containerShape.width,
          u = this.data
        if (u[0].length === 0) return { lines: [], areas: [] }
        var f = this.scales,
          h = f.x,
          d = f.y,
          p = a8(u, { type: 'line', x: h, y: d }),
          v = []
        if (s) {
          var g = this.baseline
          a ? (v = o ? c8(p, l, g) : s8(p, l, g)) : (v = o8(p, o, l, g))
        }
        return {
          lines: p.map(function (y, m) {
            return z({ stroke: n.getColor(m), path: o ? yl(y) : os(y) }, c)
          }),
          areas: v.map(function (y, m) {
            return z({ path: y, fill: n.getColor(m) }, s)
          })
        }
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'columnsStyle', {
      get: function () {
        var n = this,
          r = vt(this.attributes, 'column'),
          i = this.attributes,
          a = i.isStack,
          o = i.type,
          s = i.scale
        if (o !== 'column') throw new Error('columnsStyle can only be used in column type')
        var c = this.containerShape.height,
          l = this.rawData
        if (!l) return { columns: [] }
        a && (l = Fg(l))
        var u = this.createScales(l),
          f = u.x,
          h = u.y,
          d = N(Bg(l), 2),
          p = d[0],
          v = d[1],
          g = new Ft({ domain: [0, v - (p > 0 ? 0 : p)], range: [0, c * s] }),
          y = f.getBandWidth(),
          m = this.rawData
        return {
          columns: l.map(function (b, x) {
            return b.map(function (w, O) {
              var S = y / l.length,
                _ = function () {
                  return {
                    x: f.map(O) + S * x,
                    y: w >= 0 ? h.map(w) : h.map(0),
                    width: S,
                    height: g.map(Math.abs(w))
                  }
                },
                M = function () {
                  return { x: f.map(O), y: h.map(w), width: y, height: g.map(m[x][O]) }
                }
              return z(z({ fill: n.getColor(x) }, r), a ? M() : _())
            })
          })
        }
      },
      enumerable: !1,
      configurable: !0
    }),
    (e.prototype.render = function (n, r) {
      T6(r, '.container', 'rect').attr('className', 'container').node()
      var i = n.type,
        a = 'spark'.concat(i),
        o = i === 'line' ? this.linesStyle : this.columnsStyle
      ft(r)
        .selectAll('.spark')
        .data([i])
        .join(
          function (s) {
            return s
              .append(function (c) {
                return c === 'line'
                  ? new i8({ className: a, style: o })
                  : new r8({ className: a, style: o })
              })
              .attr('className', 'spark '.concat(a))
          },
          function (s) {
            return s.update(o)
          },
          function (s) {
            return s.remove()
          }
        )
    }),
    (e.prototype.getColor = function (n) {
      var r = this.attributes.color
      return bn(r) ? r[n % r.length] : mn(r) ? r.call(null, n) : r
    }),
    (e.prototype.createScales = function (n) {
      var r,
        i,
        a = this.attributes,
        o = a.type,
        s = a.scale,
        c = a.range,
        l = c === void 0 ? [] : c,
        u = a.spacing,
        f = this.containerShape,
        h = f.width,
        d = f.height,
        p = N(Bg(n), 2),
        v = p[0],
        g = p[1],
        y = new Ft({
          domain: [
            (r = l[0]) !== null && r !== void 0 ? r : v,
            (i = l[1]) !== null && i !== void 0 ? i : g
          ],
          range: [d, d * (1 - s)]
        })
      return o === 'line'
        ? { type: o, x: new Ft({ domain: [0, n[0].length - 1], range: [0, h] }), y }
        : {
            type: o,
            x: new ka({
              domain: n[0].map(function (m, b) {
                return b
              }),
              range: [0, h],
              paddingInner: u,
              paddingOuter: u / 2,
              align: 0.5
            }),
            y
          }
    }),
    (e.tag = 'sparkline'),
    e
  )
})(Te)
function u8(t) {
  return typeof t == 'boolean' ? !1 : 'enter' in t && 'update' in t && 'exit' in t
}
function zg(t) {
  if (!t) return { enter: !1, update: !1, exit: !1 }
  var e = ['enter', 'update', 'exit'],
    n = Object.fromEntries(
      Object.entries(t).filter(function (r) {
        var i = N(r, 1),
          a = i[0]
        return !e.includes(a)
      })
    )
  return Object.fromEntries(
    e.map(function (r) {
      return u8(t) ? (t[r] === !1 ? [r, !1] : [r, z(z({}, t[r]), n)]) : [r, n]
    })
  )
}
function Ja(t, e) {
  t ? t.finished.then(e) : e()
}
function f8(t, e) {
  t.length === 0
    ? e()
    : Promise.all(
        t.map(function (n) {
          return n == null ? void 0 : n.finished
        })
      ).then(e)
}
function yO(t, e) {
  'update' in t ? t.update(e) : t.attr(e)
}
function mO(t, e, n) {
  if (e.length === 0) return null
  if (!n) {
    var r = e.slice(-1)[0]
    return yO(t, { style: r }), null
  }
  return t.animate(e, n)
}
function h8(t, e) {
  return !(
    t.nodeName !== 'text' ||
    e.nodeName !== 'text' ||
    t.attributes.text !== e.attributes.text
  )
}
function d8(t, e, n, r) {
  if ((r === void 0 && (r = 'destroy'), h8(t, e))) return t.remove(), [null]
  var i = function () {
    r === 'destroy' ? t.destroy() : r === 'hide' && si(t), e.isVisible() && js(e)
  }
  if (!n) return i(), [null]
  var a = n.duration,
    o = a === void 0 ? 0 : a,
    s = n.delay,
    c = s === void 0 ? 0 : s,
    l = Math.ceil(+o / 2),
    u = +o / 4,
    f = function (T) {
      if (T.nodeName === 'circle') {
        var C = N(T.getLocalPosition(), 2),
          A = C[0],
          P = C[1],
          k = T.attr('r')
        return [A - k, P - k]
      }
      return T.getLocalPosition()
    },
    h = N(f(t), 2),
    d = h[0],
    p = h[1],
    v = N(f(e), 2),
    g = v[0],
    y = v[1],
    m = N([(d + g) / 2 - d, (p + y) / 2 - p], 2),
    b = m[0],
    x = m[1],
    w = t.style.opacity,
    O = w === void 0 ? 1 : w,
    S = e.style.opacity,
    _ = S === void 0 ? 1 : S,
    M = t.animate(
      [
        { opacity: O, transform: 'translate(0, 0)' },
        { opacity: 0, transform: 'translate('.concat(b, ', ').concat(x, ')') }
      ],
      z(z({ fill: 'both' }, n), { duration: c + l + u })
    ),
    E = e.animate(
      [
        { opacity: 0, transform: 'translate('.concat(-b, ', ').concat(-x, ')'), offset: 0.01 },
        { opacity: _, transform: 'translate(0, 0)' }
      ],
      z(z({ fill: 'both' }, n), { duration: l + u, delay: c + l - u })
    )
  return Ja(E, i), [M, E]
}
function Gn(t, e, n) {
  var r = {},
    i = {}
  return (
    Object.entries(e).forEach(function (a) {
      var o = N(a, 2),
        s = o[0],
        c = o[1]
      if (!nt(c)) {
        var l = t.style[s] || t.parsedStyle[s] || 0
        l !== c && ((r[s] = l), (i[s] = c))
      }
    }),
    n ? mO(t, [r, i], z({ fill: 'both' }, n)) : (yO(t, i), null)
  )
}
function xu(t, e) {
  return t.style.opacity || (t.style.opacity = 1), Gn(t, { opacity: 0 }, e)
}
var bO = {
    fill: '#fff',
    lineWidth: 1,
    radius: 2,
    size: 10,
    stroke: '#bfbfbf',
    strokeOpacity: 1,
    zIndex: 0
  },
  xO = {
    fill: '#000',
    fillOpacity: 0.45,
    fontSize: 12,
    textAlign: 'center',
    textBaseline: 'middle',
    zIndex: 1
  },
  wO = { orientation: 'horizontal', showLabel: !0, type: 'start' },
  Un = In(
    {
      foreground: 'foreground',
      handle: 'handle',
      selection: 'selection',
      sparkline: 'sparkline',
      sparklineGroup: 'sparkline-group',
      track: 'track',
      brushArea: 'brush-area'
    },
    'slider'
  ),
  jr = In(
    {
      labelGroup: 'label-group',
      label: 'label',
      iconGroup: 'icon-group',
      icon: 'icon',
      iconRect: 'icon-rect',
      iconLine: 'icon-line'
    },
    'handle'
  ),
  p8 = (function (t) {
    rt(e, t)
    function e() {
      return (t !== null && t.apply(this, arguments)) || this
    }
    return (
      (e.prototype.render = function (n, r) {
        var i = n.size,
          a = i === void 0 ? 10 : i,
          o = n.radius,
          s = o === void 0 ? a / 4 : o,
          c = n.orientation,
          l = Dt(n, ['size', 'radius', 'orientation']),
          u = a,
          f = u * 2.4,
          h = ft(r)
            .maybeAppendByClassName(jr.iconRect, 'rect')
            .styles(z(z({}, l), { width: u, height: f, radius: s, x: -u / 2, y: -f / 2 })),
          d = (1 / 3) * u,
          p = (2 / 3) * u,
          v = (1 / 4) * f,
          g = (3 / 4) * f
        h
          .maybeAppendByClassName(''.concat(jr.iconLine, '-1'), 'line')
          .styles(z({ x1: d, x2: d, y1: v, y2: g }, l)),
          h
            .maybeAppendByClassName(''.concat(jr.iconLine, '-2'), 'line')
            .styles(z({ x1: p, x2: p, y1: v, y2: g }, l)),
          h.node().setOrigin(u / 2, f / 2),
          c === 'vertical' ? r.setLocalEulerAngles(90) : r.setLocalEulerAngles(0)
      }),
      e
    )
  })(Te),
  OO = (function (t) {
    rt(e, t)
    function e(n) {
      return t.call(this, n, wO) || this
    }
    return (
      (e.prototype.renderLabel = function (n) {
        var r = this,
          i = this.attributes.showLabel,
          a = vt(this.attributes, 'label'),
          o = a.transform,
          s = Dt(a, ['transform']),
          c = N(Pr(s, []), 2),
          l = c[0],
          u = c[1],
          f = ft(n).maybeAppendByClassName(jr.labelGroup, 'g').styles(u),
          h = z(z({}, xO), l),
          d = h.text,
          p = Dt(h, ['text'])
        tn(!!i, f, function (v) {
          ;(r.label = v
            .maybeAppendByClassName(jr.label, 'text')
            .styles(z(z({}, p), { transform: o, text: ''.concat(d) }))),
            r.label.on('mousedown', function (g) {
              g.stopPropagation()
            }),
            r.label.on('touchstart', function (g) {
              g.stopPropagation()
            })
        })
      }),
      (e.prototype.renderIcon = function (n) {
        var r = this.attributes,
          i = r.orientation,
          a = r.type,
          o = z(z({ orientation: i }, bO), vt(this.attributes, 'icon')),
          s = this.attributes.iconShape,
          c =
            s === void 0
              ? function () {
                  return new p8({ style: o })
                }
              : s,
          l = ft(n).maybeAppendByClassName(jr.iconGroup, 'g')
        l.selectAll(jr.icon.class)
          .data([c])
          .join(
            function (u) {
              return u
                .append(
                  typeof c == 'string'
                    ? c
                    : function () {
                        return c(a)
                      }
                )
                .attr('className', jr.icon.name)
            },
            function (u) {
              return u.update(o)
            },
            function (u) {
              return u.remove()
            }
          )
      }),
      (e.prototype.render = function (n, r) {
        this.renderIcon(r), this.renderLabel(r)
      }),
      e
    )
  })(Te),
  SO = (function (t) {
    rt(e, t)
    function e(n) {
      var r =
        t.call(
          this,
          n,
          z(
            z(
              z(
                {
                  animate: { duration: 100, fill: 'both' },
                  brushable: !0,
                  formatter: function (i) {
                    return i.toString()
                  },
                  handleSpacing: 2,
                  orientation: 'horizontal',
                  padding: 0,
                  autoFitLabel: !0,
                  scrollable: !0,
                  selectionFill: '#5B8FF9',
                  selectionFillOpacity: 0.45,
                  selectionZIndex: 2,
                  showHandle: !0,
                  showLabel: !0,
                  slidable: !0,
                  trackFill: '#416180',
                  trackLength: 200,
                  trackOpacity: 0.05,
                  trackSize: 20,
                  trackZIndex: -1,
                  values: [0, 1],
                  type: 'range',
                  selectionType: 'select',
                  handleIconOffset: 0
                },
                Kn(wO, 'handle')
              ),
              Kn(bO, 'handleIcon')
            ),
            Kn(xO, 'handleLabel')
          )
        ) || this
      return (
        (r.range = [0, 1]),
        (r.onDragStart = function (i) {
          return function (a) {
            a.stopPropagation(), (r.target = i), (r.prevPos = r.getOrientVal(vl(a)))
            var o = r.availableSpace,
              s = o.x,
              c = o.y,
              l = r.getBBox(),
              u = l.x,
              f = l.y
            ;(r.selectionStartPos = r.getRatio(
              r.prevPos - r.getOrientVal([s, c]) - r.getOrientVal([+u, +f])
            )),
              (r.selectionWidth = 0),
              document.addEventListener('pointermove', r.onDragging),
              document.addEventListener('pointerup', r.onDragEnd)
          }
        }),
        (r.onDragging = function (i) {
          var a = r.attributes,
            o = a.slidable,
            s = a.brushable,
            c = a.type
          i.stopPropagation()
          var l = r.getOrientVal(vl(i)),
            u = l - r.prevPos
          if (u) {
            var f = r.getRatio(u)
            switch (r.target) {
              case 'start':
                o && r.setValuesOffset(f)
                break
              case 'end':
                o && r.setValuesOffset(0, f)
                break
              case 'selection':
                o && r.setValuesOffset(f, f)
                break
              case 'track':
                if (!s) return
                ;(r.selectionWidth += f),
                  c === 'range'
                    ? r.innerSetValues(
                        [r.selectionStartPos, r.selectionStartPos + r.selectionWidth].sort(),
                        !0
                      )
                    : r.innerSetValues([0, r.selectionStartPos + r.selectionWidth], !0)
                break
            }
            r.prevPos = l
          }
        }),
        (r.onDragEnd = function () {
          document.removeEventListener('pointermove', r.onDragging),
            document.removeEventListener('pointermove', r.onDragging),
            document.removeEventListener('pointerup', r.onDragEnd),
            (r.target = ''),
            r.updateHandlesPosition(!1)
        }),
        (r.onValueChange = function (i) {
          var a = r.attributes,
            o = a.onChange,
            s = a.type,
            c = s === 'range' ? i : i[1],
            l = s === 'range' ? r.getValues() : r.getValues()[1],
            u = new Bt('valuechange', { detail: { oldValue: c, value: l } })
          r.dispatchEvent(u), o == null || o(l)
        }),
        (r.selectionStartPos = 0),
        (r.selectionWidth = 0),
        (r.prevPos = 0),
        (r.target = ''),
        r
      )
    }
    return (
      Object.defineProperty(e.prototype, 'values', {
        get: function () {
          return this.attributes.values
        },
        set: function (n) {
          this.attributes.values = this.clampValues(n)
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'sparklineStyle', {
        get: function () {
          var n = this.attributes.orientation
          if (n !== 'horizontal') return null
          var r = vt(this.attributes, 'sparkline')
          return z(z({ zIndex: 0 }, this.availableSpace), r)
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'shape', {
        get: function () {
          var n = this.attributes,
            r = n.trackLength,
            i = n.trackSize,
            a = N(
              this.getOrientVal([
                [r, i],
                [i, r]
              ]),
              2
            ),
            o = a[0],
            s = a[1]
          return { width: o, height: s }
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'availableSpace', {
        get: function () {
          var n = this.attributes.padding,
            r = N(ke(n), 4),
            i = r[0],
            a = r[1],
            o = r[2],
            s = r[3],
            c = this.shape,
            l = c.width,
            u = c.height
          return { x: s, y: i, width: l - (s + a), height: u - (i + o) }
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.getValues = function () {
        return this.values
      }),
      (e.prototype.setValues = function (n, r) {
        n === void 0 && (n = [0, 0]), r === void 0 && (r = !1), (this.attributes.values = n)
        var i = r === !1 ? !1 : this.attributes.animate
        this.updateSelectionArea(i), this.updateHandlesPosition(i)
      }),
      (e.prototype.updateSelectionArea = function (n) {
        var r = this.calcSelectionArea()
        this.foregroundGroup.selectAll(Un.selection.class).each(function (i, a) {
          Gn(this, r[a], n)
        })
      }),
      (e.prototype.updateHandlesPosition = function (n) {
        this.attributes.showHandle &&
          (this.startHandle && Gn(this.startHandle, this.getHandleStyle('start'), n),
          this.endHandle && Gn(this.endHandle, this.getHandleStyle('end'), n))
      }),
      (e.prototype.innerSetValues = function (n, r) {
        n === void 0 && (n = [0, 0]), r === void 0 && (r = !1)
        var i = this.values,
          a = this.clampValues(n)
        ;(this.attributes.values = a), this.setValues(a), r && this.onValueChange(i)
      }),
      (e.prototype.renderTrack = function (n) {
        var r = vt(this.attributes, 'track')
        this.trackShape = ft(n)
          .maybeAppendByClassName(Un.track, 'rect')
          .styles(z(z({}, this.shape), r))
      }),
      (e.prototype.renderBrushArea = function (n) {
        var r = this.attributes.brushable
        this.brushArea = ft(n)
          .maybeAppendByClassName(Un.brushArea, 'rect')
          .styles(z({ fill: 'transparent', cursor: r ? 'crosshair' : 'default' }, this.shape))
      }),
      (e.prototype.renderSparkline = function (n) {
        var r = this,
          i = this.attributes.orientation,
          a = ft(n).maybeAppendByClassName(Un.sparklineGroup, 'g')
        tn(i === 'horizontal', a, function (o) {
          var s = r.sparklineStyle
          o.maybeAppendByClassName(Un.sparkline, function () {
            return new l8({ style: s })
          }).update(s)
        })
      }),
      (e.prototype.renderHandles = function () {
        var n = this,
          r,
          i = this.attributes,
          a = i.showHandle,
          o = i.type,
          s = o === 'range' ? ['start', 'end'] : ['end'],
          c = a ? s : [],
          l = this
        ;(r = this.foregroundGroup) === null ||
          r === void 0 ||
          r
            .selectAll(Un.handle.class)
            .data(
              c.map(function (u) {
                return { type: u }
              }),
              function (u) {
                return u.type
              }
            )
            .join(
              function (u) {
                return u
                  .append(function (f) {
                    var h = f.type
                    return new OO({ style: n.getHandleStyle(h) })
                  })
                  .each(function (f) {
                    var h = f.type
                    this.attr('class', ''.concat(Un.handle.name, ' ').concat(h, '-handle'))
                    var d = ''.concat(h, 'Handle')
                    ;(l[d] = this), this.addEventListener('pointerdown', l.onDragStart(h))
                  })
              },
              function (u) {
                return u.each(function (f) {
                  var h = f.type
                  this.update(l.getHandleStyle(h))
                })
              },
              function (u) {
                return u
                  .each(function (f) {
                    var h = f.type,
                      d = ''.concat(h, 'Handle')
                    l[d] = void 0
                  })
                  .remove()
              }
            )
      }),
      (e.prototype.renderSelection = function (n) {
        var r = this.attributes,
          i = r.type,
          a = r.selectionType
        this.foregroundGroup = ft(n).maybeAppendByClassName(Un.foreground, 'g')
        var o = vt(this.attributes, 'selection'),
          s = function (l) {
            return l
              .style('visibility', function (u) {
                return u.show ? 'visible' : 'hidden'
              })
              .style('cursor', function (u) {
                return a === 'select' ? 'grab' : a === 'invert' ? 'crosshair' : 'default'
              })
              .styles(o)
          },
          c = this
        this.foregroundGroup
          .selectAll(Un.selection.class)
          .data(
            i === 'value'
              ? []
              : this.calcSelectionArea().map(function (l, u) {
                  return { style: z({}, l), index: u, show: a === 'select' ? u === 1 : u !== 1 }
                }),
            function (l) {
              return l.index
            }
          )
          .join(
            function (l) {
              return l
                .append('rect')
                .attr('className', Un.selection.name)
                .call(s)
                .each(function (u, f) {
                  var h = this
                  f === 1
                    ? ((c.selectionShape = ft(this)),
                      this.on('pointerdown', function (d) {
                        h.attr('cursor', 'grabbing'), c.onDragStart('selection')(d)
                      }),
                      c.dispatchCustomEvent(this, 'pointerenter', 'selectionMouseenter'),
                      c.dispatchCustomEvent(this, 'pointerleave', 'selectionMouseleave'),
                      c.dispatchCustomEvent(this, 'click', 'selectionClick'),
                      this.addEventListener('pointerdown', function () {
                        h.attr('cursor', 'grabbing')
                      }),
                      this.addEventListener('pointerup', function () {
                        h.attr('cursor', 'grab')
                      }))
                    : this.on('pointerdown', c.onDragStart('track'))
                })
            },
            function (l) {
              return l.call(s)
            },
            function (l) {
              return l.remove()
            }
          ),
          this.updateSelectionArea(!1),
          this.renderHandles()
      }),
      (e.prototype.render = function (n, r) {
        this.renderTrack(r),
          this.renderSparkline(r),
          this.renderBrushArea(r),
          this.renderSelection(r)
      }),
      (e.prototype.clampValues = function (n, r) {
        var i
        r === void 0 && (r = 4)
        var a = N(this.range, 2),
          o = a[0],
          s = a[1],
          c = N(
            this.getValues().map(function (g) {
              return $h(g, r)
            }),
            2
          ),
          l = c[0],
          u = c[1],
          f = Array.isArray(n) ? n : [l, n ?? u],
          h = N(
            (f || [l, u]).map(function (g) {
              return $h(g, r)
            }),
            2
          ),
          d = h[0],
          p = h[1]
        if (this.attributes.type === 'value') return [0, se(p, o, s)]
        d > p && ((i = N([p, d], 2)), (d = i[0]), (p = i[1]))
        var v = p - d
        return v > s - o
          ? [o, s]
          : d < o
          ? l === o && u === p
            ? [o, p]
            : [o, v + o]
          : p > s
          ? u === s && l === d
            ? [d, s]
            : [s - v, s]
          : [d, p]
      }),
      (e.prototype.calcSelectionArea = function (n) {
        var r = N(this.clampValues(n), 2),
          i = r[0],
          a = r[1],
          o = this.availableSpace,
          s = o.x,
          c = o.y,
          l = o.width,
          u = o.height
        return this.getOrientVal([
          [
            { y: c, height: u, x: s, width: i * l },
            { y: c, height: u, x: i * l + s, width: (a - i) * l },
            { y: c, height: u, x: a * l, width: (1 - a) * l }
          ],
          [
            { x: s, width: l, y: c, height: i * u },
            { x: s, width: l, y: i * u + c, height: (a - i) * u },
            { x: s, width: l, y: a * u, height: (1 - a) * u }
          ]
        ])
      }),
      (e.prototype.calcHandlePosition = function (n) {
        var r = this.attributes.handleIconOffset,
          i = this.availableSpace,
          a = i.x,
          o = i.y,
          s = i.width,
          c = i.height,
          l = N(this.clampValues(), 2),
          u = l[0],
          f = l[1],
          h = n === 'start' ? -r : r,
          d = (n === 'start' ? u : f) * this.getOrientVal([s, c]) + h
        return { x: a + this.getOrientVal([d, s / 2]), y: o + this.getOrientVal([c / 2, d]) }
      }),
      (e.prototype.inferTextStyle = function (n) {
        var r = this.attributes.orientation
        return r === 'horizontal'
          ? {}
          : n === 'start'
          ? { transform: 'rotate(90)', textAlign: 'start' }
          : n === 'end'
          ? { transform: 'rotate(90)', textAlign: 'end' }
          : {}
      }),
      (e.prototype.calcHandleText = function (n) {
        var r,
          i = this.attributes,
          a = i.type,
          o = i.orientation,
          s = i.formatter,
          c = i.autoFitLabel,
          l = vt(this.attributes, 'handle'),
          u = vt(l, 'label'),
          f = l.spacing,
          h = this.getHandleSize(),
          d = this.clampValues(),
          p = n === 'start' ? d[0] : d[1],
          v = s(p),
          g = new Bp({ style: z(z(z({}, u), this.inferTextStyle(n)), { text: v }) }),
          y = g.getBBox(),
          m = y.width,
          b = y.height
        if ((g.destroy(), !c)) {
          if (a === 'value') return { text: v, x: 0, y: -b - f }
          var x = f + h + (o === 'horizontal' ? m / 2 : 0)
          return (r = { text: v }), (r[o === 'horizontal' ? 'x' : 'y'] = n === 'start' ? -x : x), r
        }
        var w = 0,
          O = 0,
          S = this.availableSpace,
          _ = S.width,
          M = S.height,
          E = this.calcSelectionArea()[1],
          T = E.x,
          C = E.y,
          A = E.width,
          P = E.height,
          k = f + h
        if (o === 'horizontal') {
          var L = k + m / 2
          if (n === 'start') {
            var R = T - k - m
            w = R > 0 ? -L : L
          } else {
            var j = _ - T - A - k > m
            w = j ? L : -L
          }
        } else {
          var I = k,
            D = b + k
          n === 'start' ? (O = C - h > b ? -D : I) : (O = M - (C + P) - h > b ? D : -I)
        }
        return { x: w, y: O, text: v }
      }),
      (e.prototype.getHandleLabelStyle = function (n) {
        var r = vt(this.attributes, 'handleLabel')
        return z(z(z({}, r), this.calcHandleText(n)), this.inferTextStyle(n))
      }),
      (e.prototype.getHandleIconStyle = function () {
        var n = this.attributes.handleIconShape,
          r = vt(this.attributes, 'handleIcon'),
          i = this.getOrientVal(['ew-resize', 'ns-resize']),
          a = this.getHandleSize()
        return z({ cursor: i, shape: n, size: a }, r)
      }),
      (e.prototype.getHandleStyle = function (n) {
        var r = this.attributes,
          i = r.showLabel,
          a = r.showLabelOnInteraction,
          o = r.orientation,
          s = this.calcHandlePosition(n),
          c = this.calcHandleText(n),
          l = i
        return (
          !i && a && (this.target ? (l = !0) : (l = !1)),
          z(
            z(
              z(
                z({}, Kn(this.getHandleIconStyle(), 'icon')),
                Kn(z(z({}, this.getHandleLabelStyle(n)), c), 'label')
              ),
              s
            ),
            { orientation: o, showLabel: l, type: n, zIndex: 3 }
          )
        )
      }),
      (e.prototype.getHandleSize = function () {
        var n = this.attributes,
          r = n.handleIconSize,
          i = n.width,
          a = n.height
        return r || Math.floor((this.getOrientVal([+a, +i]) + 4) / 2.4)
      }),
      (e.prototype.getOrientVal = function (n) {
        var r = N(n, 2),
          i = r[0],
          a = r[1],
          o = this.attributes.orientation
        return o === 'horizontal' ? i : a
      }),
      (e.prototype.setValuesOffset = function (n, r, i) {
        r === void 0 && (r = 0), i === void 0 && (i = !1)
        var a = this.attributes.type,
          o = N(this.getValues(), 2),
          s = o[0],
          c = o[1],
          l = a === 'range' ? n : 0,
          u = [s + l, c + r].sort()
        i ? this.setValues(u) : this.innerSetValues(u, !0)
      }),
      (e.prototype.getRatio = function (n) {
        var r = this.availableSpace,
          i = r.width,
          a = r.height
        return n / this.getOrientVal([i, a])
      }),
      (e.prototype.dispatchCustomEvent = function (n, r, i) {
        var a = this
        n.on(r, function (o) {
          o.stopPropagation(), a.dispatchEvent(new Bt(i, { detail: o }))
        })
      }),
      (e.prototype.bindEvents = function () {
        this.addEventListener('wheel', this.onScroll)
        var n = this.brushArea
        this.dispatchCustomEvent(n, 'click', 'trackClick'),
          this.dispatchCustomEvent(n, 'pointerenter', 'trackMouseenter'),
          this.dispatchCustomEvent(n, 'pointerleave', 'trackMouseleave'),
          n.on('pointerdown', this.onDragStart('track'))
      }),
      (e.prototype.onScroll = function (n) {
        var r = this.attributes.scrollable
        if (r) {
          var i = n.deltaX,
            a = n.deltaY,
            o = a || i,
            s = this.getRatio(o)
          this.setValuesOffset(s, s, !0)
        }
      }),
      (e.tag = 'slider'),
      e
    )
  })(Te),
  v8 = (function (t) {
    rt(e, t)
    function e(n) {
      var r =
        t.call(this, n, {
          isRound: !0,
          orientation: 'vertical',
          padding: [2, 2, 2, 2],
          scrollable: !0,
          slidable: !0,
          thumbCursor: 'default',
          trackSize: 10,
          value: 0
        }) || this
      return (
        (r.range = [0, 1]),
        (r.onValueChange = function (i) {
          var a = r.attributes.value
          if (i !== a) {
            var o = { detail: { oldValue: i, value: a } }
            r.dispatchEvent(new Bt('scroll', o)), r.dispatchEvent(new Bt('valuechange', o))
          }
        }),
        (r.onTrackClick = function (i) {
          var a = r.attributes.slidable
          if (a) {
            var o = N(r.getLocalPosition(), 2),
              s = o[0],
              c = o[1],
              l = N(r.padding, 4),
              u = l[0],
              f = l[3],
              h = r.getOrientVal([s + f, c + u]),
              d = r.getOrientVal(vl(i)),
              p = (d - h) / r.trackLength
            r.setValue(p, !0)
          }
        }),
        (r.onThumbMouseenter = function (i) {
          r.dispatchEvent(new Bt('thumbMouseenter', { detail: i.detail }))
        }),
        (r.onTrackMouseenter = function (i) {
          r.dispatchEvent(new Bt('trackMouseenter', { detail: i.detail }))
        }),
        (r.onThumbMouseleave = function (i) {
          r.dispatchEvent(new Bt('thumbMouseleave', { detail: i.detail }))
        }),
        (r.onTrackMouseleave = function (i) {
          r.dispatchEvent(new Bt('trackMouseleave', { detail: i.detail }))
        }),
        r
      )
    }
    return (
      Object.defineProperty(e.prototype, 'padding', {
        get: function () {
          var n = this.attributes.padding
          return ke(n)
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'value', {
        get: function () {
          var n = this.attributes.value,
            r = N(this.range, 2),
            i = r[0],
            a = r[1]
          return se(n, i, a)
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'trackLength', {
        get: function () {
          var n = this.attributes,
            r = n.viewportLength,
            i = n.trackLength,
            a = i === void 0 ? r : i
          return a
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'availableSpace', {
        get: function () {
          var n = this.attributes.trackSize,
            r = this.trackLength,
            i = N(this.padding, 4),
            a = i[0],
            o = i[1],
            s = i[2],
            c = i[3],
            l = N(
              this.getOrientVal([
                [r, n],
                [n, r]
              ]),
              2
            ),
            u = l[0],
            f = l[1]
          return { x: c, y: a, width: +u - (c + o), height: +f - (a + s) }
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'trackRadius', {
        get: function () {
          var n = this.attributes,
            r = n.isRound,
            i = n.trackSize
          return r ? i / 2 : 0
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'thumbRadius', {
        get: function () {
          var n = this.attributes,
            r = n.isRound,
            i = n.thumbRadius
          if (!r) return 0
          var a = this.availableSpace,
            o = a.width,
            s = a.height
          return i || this.getOrientVal([s, o]) / 2
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.getValues = function (n) {
        n === void 0 && (n = this.value)
        var r = this.attributes,
          i = r.viewportLength,
          a = r.contentLength,
          o = i / a,
          s = N(this.range, 2),
          c = s[0],
          l = s[1],
          u = n * (l - c - o)
        return [u, u + o]
      }),
      (e.prototype.getValue = function () {
        return this.value
      }),
      (e.prototype.renderSlider = function (n) {
        var r = this.attributes,
          i = r.orientation,
          a = r.trackSize,
          o = r.padding,
          s = r.slidable,
          c = vt(this.attributes, 'track'),
          l = vt(this.attributes, 'thumb'),
          u = z(
            z(
              {
                brushable: !1,
                orientation: i,
                padding: o,
                selectionRadius: this.thumbRadius,
                showHandle: !1,
                slidable: s,
                trackLength: this.trackLength,
                trackRadius: this.trackRadius,
                trackSize: a,
                values: this.getValues()
              },
              Kn(c, 'track')
            ),
            Kn(l, 'selection')
          )
        this.slider = ft(n)
          .maybeAppendByClassName('scrollbar', function () {
            return new SO({ style: u })
          })
          .update(u)
          .node()
      }),
      (e.prototype.render = function (n, r) {
        this.renderSlider(r)
      }),
      (e.prototype.setValue = function (n, r) {
        r === void 0 && (r = !1)
        var i = this.attributes.value,
          a = N(this.range, 2),
          o = a[0],
          s = a[1]
        this.slider.setValues(this.getValues(se(n, o, s)), r), this.onValueChange(i)
      }),
      (e.prototype.bindEvents = function () {
        var n = this
        this.slider.addEventListener('trackClick', function (r) {
          r.stopPropagation(), n.onTrackClick(r.detail)
        }),
          this.onHover()
      }),
      (e.prototype.getOrientVal = function (n) {
        var r = this.attributes.orientation
        return r === 'horizontal' ? n[0] : n[1]
      }),
      (e.prototype.onHover = function () {
        this.slider.addEventListener('selectionMouseenter', this.onThumbMouseenter),
          this.slider.addEventListener('trackMouseenter', this.onTrackMouseenter),
          this.slider.addEventListener('selectionMouseleave', this.onThumbMouseleave),
          this.slider.addEventListener('trackMouseleave', this.onTrackMouseleave)
      }),
      (e.tag = 'scrollbar'),
      e
    )
  })(Te),
  Yp = {
    data: [],
    animate: {
      enter: !1,
      update: { duration: 100, easing: 'ease-in-out-sine', fill: 'both' },
      exit: { duration: 100, fill: 'both' }
    },
    showArrow: !0,
    showGrid: !0,
    showLabel: !0,
    showLine: !0,
    showTick: !0,
    showTitle: !0,
    showTrunc: !1,
    dataThreshold: 100,
    lineLineWidth: 1,
    lineStroke: 'black',
    crossPadding: 10,
    titleFill: 'black',
    titleFontSize: 12,
    titlePosition: 'lb',
    titleSpacing: 0,
    titleTextAlign: 'center',
    titleTextBaseline: 'middle',
    lineArrow: function () {
      return new rn({
        style: {
          path: [['M', 10, 10], ['L', -10, 0], ['L', 10, -10], ['L', 0, 0], ['L', 10, 10], ['Z']],
          anchor: '0.5 0.5',
          fill: 'black',
          transformOrigin: 'center'
        }
      })
    },
    labelAlign: 'parallel',
    labelDirection: 'positive',
    labelFontSize: 12,
    labelSpacing: 0,
    gridConnect: 'line',
    gridControlAngles: [],
    gridDirection: 'positive',
    gridLength: 0,
    gridType: 'segment',
    lineArrowOffset: 15,
    lineArrowSize: 10,
    tickDirection: 'positive',
    tickLength: 5,
    tickLineWidth: 1,
    tickStroke: 'black',
    labelOverlap: []
  }
X({}, Yp, { style: { type: 'arc' } })
X({}, Yp, { style: {} })
var Rt = In(
    {
      mainGroup: 'main-group',
      gridGroup: 'grid-group',
      grid: 'grid',
      lineGroup: 'line-group',
      line: 'line',
      tickGroup: 'tick-group',
      tick: 'tick',
      tickItem: 'tick-item',
      labelGroup: 'label-group',
      label: 'label',
      labelItem: 'label-item',
      titleGroup: 'title-group',
      title: 'title',
      lineFirst: 'line-first',
      lineSecond: 'line-second'
    },
    'axis'
  ),
  Da = In(
    { lineGroup: 'line-group', line: 'line', regionGroup: 'region-group', region: 'region' },
    'grid'
  )
function _O(t) {
  return t.reduce(function (e, n, r) {
    return e.push(q([r === 0 ? 'M' : 'L'], N(n), !1)), e
  }, [])
}
function g8(t, e, n) {
  var r = e.connect,
    i = r === void 0 ? 'line' : r,
    a = e.center
  if (i === 'line') return _O(t)
  if (!a) return []
  var o = as(t[0], a),
    s = n ? 0 : 1
  return t.reduce(function (c, l, u) {
    return u === 0 ? c.push(q(['M'], N(l), !1)) : c.push(q(['A', o, o, 0, 0, s], N(l), !1)), c
  }, [])
}
function Bh(t, e, n) {
  return e.type === 'surround' ? g8(t, e, n) : _O(t)
}
function y8(t, e, n) {
  var r = n.type,
    i = n.connect,
    a = n.center,
    o = n.closed,
    s = o ? [['Z']] : [],
    c = N([Bh(t, n), Bh(e.slice().reverse(), n, !0)], 2),
    l = c[0],
    u = c[1],
    f = N([t[0], e.slice(-1)[0]], 2),
    h = f[0],
    d = f[1],
    p = function (m, b) {
      return [l, m, u, b, s].flat()
    }
  if (i === 'line' || r === 'surround') return p([q(['L'], N(d), !1)], [q(['L'], N(h), !1)])
  if (!a) throw new Error('Arc grid need to specified center')
  var v = N([as(d, a), as(h, a)], 2),
    g = v[0],
    y = v[1]
  return p(
    [q(['A', g, g, 0, 0, 1], N(d), !1), q(['L'], N(d), !1)],
    [q(['A', y, y, 0, 0, 0], N(h), !1), q(['L'], N(h), !1)]
  )
}
function m8(t, e, n, r) {
  var i = n.animate,
    a = n.isBillboard,
    o = e.map(function (s, c) {
      return { id: s.id || 'grid-line-'.concat(c), path: Bh(s.points, n) }
    })
  return t
    .selectAll(Da.line.class)
    .data(o, function (s) {
      return s.id
    })
    .join(
      function (s) {
        return s.append('path').each(function (c, l) {
          var u = Cn(jg(z({ path: c.path }, r)), [c, l, o])
          this.attr(
            z(
              {
                class: Da.line.name,
                stroke: '#D9D9D9',
                lineWidth: 1,
                lineDash: [4, 4],
                isBillboard: a
              },
              u
            )
          )
        })
      },
      function (s) {
        return s.transition(function (c, l) {
          var u = Cn(jg(z({ path: c.path }, r)), [c, l, o])
          return Gn(this, u, i.update)
        })
      },
      function (s) {
        return s.transition(function () {
          var c = this,
            l = xu(this, i.exit)
          return (
            Ja(l, function () {
              return c.remove()
            }),
            l
          )
        })
      }
    )
    .transitions()
}
function b8(t, e, n) {
  var r = n.animate,
    i = n.connect,
    a = n.areaFill
  if (e.length < 2 || !a || !i) return []
  for (
    var o = Array.isArray(a) ? a : [a, 'transparent'],
      s = function (p) {
        return o[p % o.length]
      },
      c = [],
      l = 0;
    l < e.length - 1;
    l++
  ) {
    var u = N([e[l].points, e[l + 1].points], 2),
      f = u[0],
      h = u[1],
      d = y8(f, h, n)
    c.push({ path: d, fill: s(l) })
  }
  return t
    .selectAll(Da.region.class)
    .data(c, function (p, v) {
      return v
    })
    .join(
      function (p) {
        return p
          .append('path')
          .each(function (v, g) {
            var y = Cn(v, [v, g, c])
            this.attr(y)
          })
          .attr('className', Da.region.name)
      },
      function (p) {
        return p.transition(function (v, g) {
          var y = Cn(v, [v, g, c])
          return Gn(this, y, r.update)
        })
      },
      function (p) {
        return p.transition(function () {
          var v = this,
            g = xu(this, r.exit)
          return (
            Ja(g, function () {
              return v.remove()
            }),
            g
          )
        })
      }
    )
    .transitions()
}
function x8(t) {
  var e = t.data,
    n = e === void 0 ? [] : e,
    r = t.closed
  return r
    ? n.map(function (i) {
        var a = i.points,
          o = N(a, 1),
          s = o[0]
        return z(z({}, i), { points: q(q([], N(a), !1), [s], !1) })
      })
    : n
}
var w8 = (function (t) {
  rt(e, t)
  function e() {
    return (t !== null && t.apply(this, arguments)) || this
  }
  return (
    (e.prototype.render = function (n, r) {
      n.type, n.center, n.areaFill, n.closed
      var i = Dt(n, ['type', 'center', 'areaFill', 'closed']),
        a = x8(n),
        o = ft(r).maybeAppendByClassName(Da.lineGroup, 'g'),
        s = ft(r).maybeAppendByClassName(Da.regionGroup, 'g'),
        c = m8(o, a, n, i),
        l = b8(s, a, n)
      return q(q([], N(c), !1), N(l), !1)
    }),
    e
  )
})(Te)
function MO(t, e) {
  return Object.fromEntries(
    Object.entries(t).map(function (n) {
      var r = N(n, 2),
        i = r[0],
        a = r[1]
      return [i, Cn(a, e)]
    })
  )
}
function Hp(t, e) {
  return e && mn(e) ? t.filter(e) : t
}
function EO(t, e) {
  var n = e.startAngle,
    r = e.endAngle
  return (r - n) * t + n
}
function wu(t, e) {
  if (e.type === 'linear') {
    var n = N(e.startPos, 2),
      r = n[0],
      i = n[1],
      a = N(e.endPos, 2),
      o = a[0],
      s = a[1],
      c = N([o - r, s - i], 2),
      l = c[0],
      u = c[1]
    return dO([l, u])
  }
  var f = ja(EO(t, e))
  return [-Math.sin(f), Math.cos(f)]
}
function Vp(t, e, n) {
  var r = wu(t, n)
  return m6(r, e !== 'positive')
}
function Ds(t, e) {
  return Vp(t, e.labelDirection, e)
}
function O8(t, e) {
  var n = N(e.startPos, 2),
    r = n[0],
    i = n[1],
    a = N(e.endPos, 2),
    o = a[0],
    s = a[1],
    c = N([o - r, s - i], 2),
    l = c[0],
    u = c[1]
  return [r + l * t, i + u * t]
}
function S8(t, e) {
  var n = e.radius,
    r = N(e.center, 2),
    i = r[0],
    a = r[1],
    o = ja(EO(t, e))
  return [i + n * Math.cos(o), a + n * Math.sin(o)]
}
function Ou(t, e) {
  return e.type === 'linear' ? O8(t, e) : S8(t, e)
}
function TO(t) {
  return wu(0, t)[1] === 0
}
function PO(t) {
  return wu(0, t)[0] === 0
}
function AO(t, e) {
  return e - t === 360
}
function Gg(t, e, n, r, i) {
  var a = e - t,
    o = N([i, i], 2),
    s = o[0],
    c = o[1],
    l = N([ja(t), ja(e)], 2),
    u = l[0],
    f = l[1],
    h = function (M) {
      return [n + i * Math.cos(M), r + i * Math.sin(M)]
    },
    d = N(h(u), 2),
    p = d[0],
    v = d[1],
    g = N(h(f), 2),
    y = g[0],
    m = g[1]
  if (AO(t, e)) {
    var b = (f + u) / 2,
      x = N(h(b), 2),
      w = x[0],
      O = x[1]
    return [
      ['M', p, v],
      ['A', s, c, 0, 1, 0, w, O],
      ['A', s, c, 0, 1, 0, y, m]
    ]
  }
  var S = a > 180 ? 1 : 0,
    _ = t > e ? 0 : 1
  return 'M'
    .concat(p, ',')
    .concat(v, ',A')
    .concat(s, ',')
    .concat(c, ',0,')
    .concat(S, ',')
    .concat(_, ',')
    .concat(y, ',')
    .concat(m)
}
function _8(t) {
  var e = t.attributes,
    n = e.startAngle,
    r = e.endAngle,
    i = e.center,
    a = e.radius
  return q(q([n, r], N(i), !1), [a], !1)
}
function M8(t, e, n, r) {
  var i = e.startAngle,
    a = e.endAngle,
    o = e.center,
    s = e.radius
  return t
    .selectAll(Rt.line.class)
    .data([{ path: Gg.apply(void 0, q(q([i, a], N(o), !1), [s], !1)) }], function (c, l) {
      return l
    })
    .join(
      function (c) {
        return c
          .append('path')
          .attr('className', Rt.line.name)
          .styles(e)
          .styles({
            path: function (l) {
              return l.path
            }
          })
      },
      function (c) {
        return c
          .transition(function () {
            var l = this,
              u = p6(this, _8(this), q(q([i, a], N(o), !1), [s], !1), r.update)
            if (u) {
              var f = function () {
                var h = nb(l.attributes, '__keyframe_data__')
                l.style.path = Gg.apply(void 0, q([], N(h), !1))
              }
              ;(u.onframe = f), (u.onfinish = f)
            }
            return u
          })
          .styles(e)
      },
      function (c) {
        return c.remove()
      }
    )
    .styles(n)
    .transitions()
}
function E8(t, e) {
  e.truncRange, e.truncShape, e.lineExtension
}
function T8(t, e, n) {
  n === void 0 && (n = [0, 0])
  var r = N([t, e, n], 3),
    i = N(r[0], 2),
    a = i[0],
    o = i[1],
    s = N(r[1], 2),
    c = s[0],
    l = s[1],
    u = N(r[2], 2),
    f = u[0],
    h = u[1],
    d = N([c - a, l - o], 2),
    p = d[0],
    v = d[1],
    g = Math.sqrt(Math.pow(p, 2) + Math.pow(v, 2)),
    y = N([-f / g, h / g], 2),
    m = y[0],
    b = y[1]
  return [m * p, m * v, b * p, b * v]
}
function Wg(t) {
  var e = N(t, 2),
    n = N(e[0], 2),
    r = n[0],
    i = n[1],
    a = N(e[1], 2),
    o = a[0],
    s = a[1]
  return { x1: r, y1: i, x2: o, y2: s }
}
function P8(t, e, n, r) {
  var i = e.showTrunc,
    a = e.startPos,
    o = e.endPos,
    s = e.truncRange,
    c = e.lineExtension,
    l = N([a, o], 2),
    u = N(l[0], 2),
    f = u[0],
    h = u[1],
    d = N(l[1], 2),
    p = d[0],
    v = d[1],
    g = N(c ? T8(a, o, c) : new Array(4).fill(0), 4),
    y = g[0],
    m = g[1],
    b = g[2],
    x = g[3],
    w = function (j) {
      return t
        .selectAll(Rt.line.class)
        .data(j, function (I, D) {
          return D
        })
        .join(
          function (I) {
            return I.append('line')
              .attr('className', function (D) {
                return ''.concat(Rt.line.name, ' ').concat(D.className)
              })
              .styles(n)
              .transition(function (D) {
                return Gn(this, Wg(D.line), !1)
              })
          },
          function (I) {
            return I.styles(n).transition(function (D) {
              var $ = D.line
              return Gn(this, Wg($), r.update)
            })
          },
          function (I) {
            return I.remove()
          }
        )
        .transitions()
    }
  if (!i || !s)
    return w([
      {
        line: [
          [f + y, h + m],
          [p + b, v + x]
        ],
        className: Rt.line.name
      }
    ])
  var O = N(s, 2),
    S = O[0],
    _ = O[1],
    M = p - f,
    E = v - h,
    T = N([f + M * S, h + E * S], 2),
    C = T[0],
    A = T[1],
    P = N([f + M * _, h + E * _], 2),
    k = P[0],
    L = P[1],
    R = w([
      {
        line: [
          [f + y, h + m],
          [C, A]
        ],
        className: Rt.lineFirst.name
      },
      {
        line: [
          [k, L],
          [p + b, v + x]
        ],
        className: Rt.lineSecond.name
      }
    ])
  return E8(t, e), R
}
function A8(t, e, n, r) {
  var i = n.showArrow,
    a = n.showTrunc,
    o = n.lineArrow,
    s = n.lineArrowOffset,
    c = n.lineArrowSize,
    l
  if (
    (e === 'arc'
      ? (l = t.select(Rt.line.class))
      : a
      ? (l = t.select(Rt.lineSecond.class))
      : (l = t.select(Rt.line.class)),
    !i || !o || (n.type === 'arc' && AO(n.startAngle, n.endAngle)))
  ) {
    var u = l.node()
    u && (u.style.markerEnd = void 0)
    return
  }
  var f = Bi(o)
  f.attr(r), zp(f, c, !0), l.style('markerEnd', f).style('markerEndOffset', -s)
}
function k8(t, e, n) {
  var r = e.type,
    i,
    a = vt(e, 'line')
  return (
    r === 'linear' ? (i = P8(t, e, Ig(a, 'arrow'), n)) : (i = M8(t, e, Ig(a, 'arrow'), n)),
    A8(t, r, e, a),
    i
  )
}
function C8(t, e) {
  return Vp(t, e.gridDirection, e)
}
function kO(t) {
  var e = t.type,
    n = t.gridCenter
  return e === 'linear' ? n : n || t.center
}
function L8(t, e) {
  var n = e.gridLength
  return t.map(function (r, i) {
    var a = r.value,
      o = N(Ou(a, e), 2),
      s = o[0],
      c = o[1],
      l = N(gr(C8(a, e), n), 2),
      u = l[0],
      f = l[1]
    return {
      id: i,
      points: [
        [s, c],
        [s + u, c + f]
      ]
    }
  })
}
function N8(t, e) {
  var n = e.gridControlAngles,
    r = kO(e)
  if (!r) throw new Error('grid center is not provide')
  if (t.length < 2) throw new Error('Invalid grid data')
  if (!n || n.length === 0) throw new Error('Invalid gridControlAngles')
  var i = N(r, 2),
    a = i[0],
    o = i[1]
  return t.map(function (s, c) {
    var l = s.value,
      u = N(Ou(l, e), 2),
      f = u[0],
      h = u[1],
      d = N([f - a, h - o], 2),
      p = d[0],
      v = d[1],
      g = []
    return (
      n.forEach(function (y) {
        var m = ja(y),
          b = N([Math.cos(m), Math.sin(m)], 2),
          x = b[0],
          w = b[1],
          O = p * x - v * w + a,
          S = p * w + v * x + o
        g.push([O, S])
      }),
      { points: g, id: c }
    )
  })
}
function R8(t, e, n, r) {
  var i = vt(n, 'grid'),
    a = i.type,
    o = i.areaFill,
    s = kO(n),
    c = Hp(e, n.gridFilter),
    l = a === 'segment' ? L8(c, n) : N8(c, n),
    u = z(z({}, i), {
      center: s,
      areaFill: mn(o)
        ? c.map(function (f, h) {
            return Cn(o, [f, h, c])
          })
        : o,
      animate: r,
      data: l
    })
  return t
    .selectAll(Rt.grid.class)
    .data([1])
    .join(
      function (f) {
        return f
          .append(function () {
            return new w8({ style: u })
          })
          .attr('className', Rt.grid.name)
      },
      function (f) {
        return f.transition(function () {
          return this.update(u)
        })
      },
      function (f) {
        return f.remove()
      }
    )
    .transitions()
}
var Fh = (function () {
  function t(e, n, r, i) {
    this.set(e, n, r, i)
  }
  return (
    Object.defineProperty(t.prototype, 'left', {
      get: function () {
        return this.x1
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(t.prototype, 'top', {
      get: function () {
        return this.y1
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(t.prototype, 'right', {
      get: function () {
        return this.x2
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(t.prototype, 'bottom', {
      get: function () {
        return this.y2
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(t.prototype, 'width', {
      get: function () {
        return this.defined('x2') && this.defined('x1') ? this.x2 - this.x1 : void 0
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(t.prototype, 'height', {
      get: function () {
        return this.defined('y2') && this.defined('y1') ? this.y2 - this.y1 : void 0
      },
      enumerable: !1,
      configurable: !0
    }),
    (t.prototype.rotatedPoints = function (e, n, r) {
      var i = this,
        a = i.x1,
        o = i.y1,
        s = i.x2,
        c = i.y2,
        l = Math.cos(e),
        u = Math.sin(e),
        f = n - n * l + r * u,
        h = r - n * u - r * l,
        d = [
          [l * a - u * c + f, u * a + l * c + h],
          [l * s - u * c + f, u * s + l * c + h],
          [l * a - u * o + f, u * a + l * o + h],
          [l * s - u * o + f, u * s + l * o + h]
        ]
      return d
    }),
    (t.prototype.set = function (e, n, r, i) {
      return (
        r < e ? ((this.x2 = e), (this.x1 = r)) : ((this.x1 = e), (this.x2 = r)),
        i < n ? ((this.y2 = n), (this.y1 = i)) : ((this.y1 = n), (this.y2 = i)),
        this
      )
    }),
    (t.prototype.defined = function (e) {
      return this[e] !== Number.MAX_VALUE && this[e] !== -Number.MAX_VALUE
    }),
    t
  )
})()
function zh(t, e) {
  var n = t.getEulerAngles() || 0
  t.setEulerAngles(0)
  var r = t.getLocalBounds(),
    i = N(r.min, 2),
    a = i[0],
    o = i[1],
    s = N(r.max, 2),
    c = s[0],
    l = s[1],
    u = Xp(t),
    f = u.width,
    h = u.height,
    d = h,
    p = 0,
    v = 0,
    g = a,
    y = o,
    m = fO(t)
  if (m) {
    d -= 1.5
    var b = m.style.textAlign,
      x = m.style.textBaseline
    b === 'center' ? (g = (a + c) / 2) : (b === 'right' || b === 'end') && (g = c),
      x === 'middle' ? (y = (o + l) / 2) : x === 'bottom' && (y = l)
  }
  var w = N(ke(e), 4),
    O = w[0],
    S = O === void 0 ? 0 : O,
    _ = w[1],
    M = _ === void 0 ? 0 : _,
    E = w[2],
    T = E === void 0 ? S : E,
    C = w[3],
    A = C === void 0 ? M : C,
    P = new Fh((p += a) - A, (v += o) - S, p + f + M, v + d + T)
  return t.setEulerAngles(n), P.rotatedPoints(ja(n), g, y)
}
function Xp(t) {
  return t.__bbox__ ? t.__bbox__ : t.getBBox()
}
function Oo(t, e) {
  return (
    e[0] <= Math.max(t[0][0], t[1][0]) &&
    e[0] <= Math.min(t[0][0], t[1][0]) &&
    e[1] <= Math.max(t[0][1], t[1][1]) &&
    e[1] <= Math.min(t[0][1], t[1][1])
  )
}
function So(t, e, n) {
  var r = (e[1] - t[1]) * (n[0] - e[0]) - (e[0] - t[0]) * (n[1] - e[1])
  return r === 0 ? 0 : r < 0 ? 2 : 1
}
function I8(t, e) {
  var n = So(t[0], t[1], e[0]),
    r = So(t[0], t[1], e[1]),
    i = So(e[0], e[1], t[0]),
    a = So(e[0], e[1], t[1])
  return !!(
    (n !== r && i !== a) ||
    (n === 0 && Oo(t, e[0])) ||
    (r === 0 && Oo(t, e[1])) ||
    (i === 0 && Oo(e, t[0])) ||
    (a === 0 && Oo(e, t[1]))
  )
}
function j8(t, e) {
  var n = t.length
  if (n < 3) return !1
  var r = [e, [9999, e[1]]],
    i = 0,
    a = 0
  do {
    var o = [t[a], t[(a + 1) % n]]
    if (I8(o, r)) {
      if (So(o[0], e, o[1]) === 0) return Oo(o, e)
      i++
    }
    a = (a + 1) % n
  } while (a !== 0)
  return !!(i & 1)
}
function D8(t, e) {
  return e.every(function (n) {
    return j8(t, n)
  })
}
function $8(t, e, n) {
  var r = t.x1,
    i = t.x2,
    a = t.y1,
    o = t.y2,
    s = [
      [r, a],
      [i, a],
      [i, o],
      [r, o]
    ],
    c = zh(e, n)
  return D8(s, c)
}
function B8(t, e) {
  var n = N(t, 4),
    r = n[0],
    i = n[1],
    a = n[2],
    o = n[3],
    s = N(e, 4),
    c = s[0],
    l = s[1],
    u = s[2],
    f = s[3],
    h = a - r,
    d = o - i,
    p = u - c,
    v = f - l,
    g = h * v - p * d
  if (g === 0) return !1
  var y = g > 0,
    m = r - c,
    b = i - l,
    x = h * b - d * m
  if (x < 0 === y) return !1
  var w = p * b - v * m
  return !(w < 0 === y || x > g === y || w > g === y)
}
function F8(t, e) {
  var n = [
    [t[0], t[1], t[2], t[3]],
    [t[2], t[3], t[4], t[5]],
    [t[4], t[5], t[6], t[7]],
    [t[6], t[7], t[0], t[1]]
  ]
  return n.some(function (r) {
    return B8(e, r)
  })
}
function z8(t, e, n) {
  var r,
    i,
    a = zh(t, n).flat(1),
    o = zh(e, n).flat(1),
    s = [
      [a[0], a[1], a[2], a[3]],
      [a[0], a[1], a[4], a[5]],
      [a[4], a[5], a[6], a[7]],
      [a[2], a[3], a[6], a[7]]
    ]
  try {
    for (var c = hn(s), l = c.next(); !l.done; l = c.next()) {
      var u = l.value
      if (F8(o, u)) return !0
    }
  } catch (f) {
    r = { error: f }
  } finally {
    try {
      l && !l.done && (i = c.return) && i.call(c)
    } finally {
      if (r) throw r.error
    }
  }
  return !1
}
function G8(t, e) {
  var n = t.type,
    r = t.labelDirection,
    i = t.crossSize
  if (!i) return !1
  if (n === 'arc') {
    var a = t.center,
      o = t.radius,
      s = N(a, 2),
      c = s[0],
      l = s[1],
      u = r === 'negative' ? 0 : i,
      f = -o - u,
      h = o + u,
      d = N(ke(e), 4),
      p = d[0],
      v = d[1],
      g = d[2],
      y = d[3]
    return new Fh(c + f - y, l + f - p, c + h + v, l + h + g)
  }
  var m = N(t.startPos, 2),
    b = m[0],
    x = m[1],
    w = N(t.endPos, 2),
    O = w[0],
    S = w[1],
    _ = N(PO(t) ? [-e, 0, e, 0] : [0, e, 0, -e], 4),
    M = _[0],
    E = _[1],
    T = _[2],
    C = _[3],
    A = Ds(0, t),
    P = gr(A, i),
    k = new Fh(b, x, O, S)
  return (k.x1 += C), (k.y1 += M), (k.x2 += E + P[0]), (k.y2 += T + P[1]), k
}
function Su(t, e, n) {
  var r,
    i,
    a = e.crossPadding,
    o = new Set(),
    s = null,
    c = G8(e, a),
    l = function (p) {
      return c ? $8(c, p) : !0
    },
    u = function (p, v) {
      return p ? !z8(p, v, ke(n)) : !0
    }
  try {
    for (var f = hn(t), h = f.next(); !h.done; h = f.next()) {
      var d = h.value
      l(d) ? (!s || u(s, d) ? (s = d) : (o.add(s), o.add(d))) : o.add(d)
    }
  } catch (p) {
    r = { error: p }
  } finally {
    try {
      h && !h.done && (i = f.return) && i.call(f)
    } finally {
      if (r) throw r.error
    }
  }
  return Array.from(o)
}
function gf(t, e) {
  return e === void 0 && (e = {}), nt(t) ? 0 : typeof t == 'number' ? t : Math.floor(c6(t, e))
}
function W8(t, e, n, r) {
  if (!(t.length <= 1)) {
    var i = e.suffix,
      a = i === void 0 ? '...' : i,
      o = e.minLength,
      s = e.maxLength,
      c = s === void 0 ? 1 / 0 : s,
      l = e.step,
      u = l === void 0 ? ' ' : l,
      f = e.margin,
      h = f === void 0 ? [0, 0, 0, 0] : f,
      d = jh(r.getTextShape(t[0])),
      p = gf(u, d),
      v = o ? gf(o, d) : p,
      g = gf(c, d)
    ;(nt(g) || g === 1 / 0) &&
      (g = Math.max.apply(
        null,
        t.map(function (O) {
          return Xp(O).width
        })
      ))
    var y = t.slice(),
      m = N(h, 4)
    m[0], m[1], m[2], m[3]
    for (
      var b = function (O) {
          if (
            (y.forEach(function (S) {
              r.ellipsis(r.getTextShape(S), O, a)
            }),
            (y = Su(t, n, h)),
            y.length < 1)
          )
            return { value: void 0 }
        },
        x = g;
      x > v + p;
      x -= p
    ) {
      var w = b(x)
      if (typeof w == 'object') return w.value
    }
  }
}
var Y8 = {
    parity: function (t, e) {
      var n = e.seq,
        r = n === void 0 ? 2 : n
      return t.filter(function (i, a) {
        return a % r ? (si(i), !1) : !0
      })
    }
  },
  H8 = function (t) {
    return t.filter(uO)
  }
function V8(t, e, n, r) {
  var i = t.length,
    a = e.keepHeader,
    o = e.keepTail
  if (!(i <= 1 || (i === 2 && a && o))) {
    var s = Y8.parity,
      c = function (b) {
        return b.forEach(r.show), b
      },
      l = 2,
      u = t.slice(),
      f = t.slice(),
      h = Math.min.apply(
        Math,
        q(
          [1],
          N(
            t.map(function (b) {
              return Xp(b).width
            })
          ),
          !1
        )
      )
    if (n.type === 'linear' && (TO(n) || PO(n))) {
      var d = Dg(t[0]).left,
        p = Dg(t[i - 1]).right,
        v = Math.abs(p - d) || 1
      l = Math.max(Math.floor((i * h) / v), l)
    }
    var g, y
    for (
      a && (g = u.splice(0, 1)[0]), o && ((y = u.splice(-1, 1)[0]), u.reverse()), c(u);
      l < t.length &&
      Su(H8(y ? q(q([y], N(f), !1), [g], !1) : q([g], N(f), !1)), n, e == null ? void 0 : e.margin)
        .length;

    ) {
      if (y && !g && l % 2 === 0) {
        var m = u.splice(0, 1)
        m.forEach(r.hide)
      } else if (y && g) {
        var m = u.splice(0, 1)
        m.forEach(r.hide)
      }
      ;(f = s(c(u), { seq: l })), l++
    }
  }
}
function X8(t, e, n, r) {
  var i,
    a,
    o = e.optionalAngles,
    s = o === void 0 ? [0, 45, 90] : o,
    c = e.margin,
    l = e.recoverWhenFailed,
    u = l === void 0 ? !0 : l,
    f = t.map(function (y) {
      return y.getLocalEulerAngles()
    }),
    h = function () {
      return Su(t, n, c).length < 1
    },
    d = function (y) {
      return t.forEach(function (m, b) {
        var x = Array.isArray(y) ? y[b] : y
        r.rotate(m, +x)
      })
    }
  try {
    for (var p = hn(s), v = p.next(); !v.done; v = p.next()) {
      var g = v.value
      if ((d(g), h())) return
    }
  } catch (y) {
    i = { error: y }
  } finally {
    try {
      v && !v.done && (a = p.return) && a.call(p)
    } finally {
      if (i) throw i.error
    }
  }
  u && d(f)
}
function U8(t) {
  var e = t.type,
    n = t.labelDirection
  return e === 'linear' && TO(t) ? (n === 'negative' ? 'bottom' : 'top') : 'middle'
}
function q8(t, e, n, r) {
  var i = e.wordWrapWidth,
    a = i === void 0 ? 50 : i,
    o = e.maxLines,
    s = o === void 0 ? 3 : o,
    c = e.recoverWhenFailed,
    l = c === void 0 ? !0 : c,
    u = e.margin,
    f = u === void 0 ? [0, 0, 0, 0] : u,
    h = t.map(function (m) {
      return m.attr('maxLines') || 1
    }),
    d = Math.min.apply(Math, q([], N(h), !1)),
    p = function () {
      return Su(t, n, f).length < 1
    },
    v = U8(n),
    g = function (m) {
      return t.forEach(function (b, x) {
        var w = Array.isArray(m) ? m[x] : m
        r.wrap(b, a, w, v)
      })
    }
  if (!(d > s)) {
    for (var y = d; y <= s; y++) if ((g(y), p())) return
    l && g(h)
  }
}
var K8 = new Map([
  ['hide', V8],
  ['rotate', X8],
  ['ellipsis', W8],
  ['wrap', q8]
])
function Z8(t, e, n) {
  return e.labelOverlap.length < 1
    ? !1
    : n === 'hide'
    ? !o6(t[0])
    : n === 'rotate'
    ? !t.some(function (r) {
        var i
        return !!(!((i = r.attr('transform')) === null || i === void 0) && i.includes('rotate'))
      })
    : n === 'ellipsis' || n === 'wrap'
    ? t.filter(function (r) {
        return r.querySelector('text')
      }).length > 1
    : !0
}
function Q8(t, e, n) {
  var r = e.labelOverlap,
    i = r === void 0 ? [] : r
  i.length &&
    i.forEach(function (a) {
      var o = a.type,
        s = K8.get(o)
      Z8(t, e, o) && (s == null || s(t, a, e, n))
    })
}
function J8() {
  for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e]
  var n = function (r) {
    return r === 'positive' ? -1 : 1
  }
  return t.reduce(function (r, i) {
    return r * n(i)
  }, 1)
}
function Yg(t) {
  for (var e = t; e < 0; ) e += 360
  return Math.round(e % 360)
}
function Gh(t, e) {
  var n = N(t, 2),
    r = n[0],
    i = n[1],
    a = N(e, 2),
    o = a[0],
    s = a[1],
    c = N([r * o + i * s, r * s - i * o], 2),
    l = c[0],
    u = c[1]
  return Math.atan2(u, l)
}
function tI(t) {
  var e = (t + 360) % 180
  return Ae(e, -90, 90) || (e += 180), e
}
function eI(t, e, n) {
  var r,
    i = n.labelAlign,
    a = (r = e.style.transform) === null || r === void 0 ? void 0 : r.includes('rotate')
  if (a) return e.getLocalEulerAngles()
  var o = 0,
    s = Ds(t.value, n),
    c = wu(t.value, n)
  return i === 'horizontal'
    ? 0
    : (i === 'perpendicular' ? (o = Gh([1, 0], s)) : (o = Gh([c[0] < 0 ? -1 : 1, 0], c)), tI(cO(o)))
}
function CO(t, e, n) {
  var r = n.type,
    i = n.labelAlign,
    a = Ds(t, n),
    o = Yg(e),
    s = Yg(cO(Gh([1, 0], a))),
    c = 'center',
    l = 'middle'
  return (
    r === 'linear'
      ? [90, 270].includes(s) && o === 0
        ? ((c = 'center'), (l = a[1] === 1 ? 'top' : 'bottom'))
        : !(s % 180) && [90, 270].includes(o)
        ? (c = 'center')
        : s === 0
        ? (Ae(o, 0, 90, !1, !0) || Ae(o, 0, 90) || Ae(o, 270, 360)) && (c = 'start')
        : s === 90
        ? Ae(o, 0, 90, !1, !0)
          ? (c = 'start')
          : (Ae(o, 90, 180) || Ae(o, 270, 360)) && (c = 'end')
        : s === 270
        ? Ae(o, 0, 90, !1, !0)
          ? (c = 'end')
          : (Ae(o, 90, 180) || Ae(o, 270, 360)) && (c = 'start')
        : s === 180 && (o === 90 ? (c = 'start') : (Ae(o, 0, 90) || Ae(o, 270, 360)) && (c = 'end'))
      : i === 'parallel'
      ? Ae(s, 0, 180, !0)
        ? (l = 'top')
        : (l = 'bottom')
      : i === 'horizontal'
      ? Ae(s, 90, 270, !1)
        ? (c = 'end')
        : (Ae(s, 270, 360, !1) || Ae(s, 0, 90)) && (c = 'start')
      : i === 'perpendicular' && (Ae(s, 90, 270) ? (c = 'end') : (c = 'start')),
    { textAlign: c, textBaseline: l }
  )
}
function nI(t, e, n) {
  e.setLocalEulerAngles(t)
  var r = e.__data__.value,
    i = CO(r, t, n),
    a = e.querySelector(Rt.labelItem.class)
  a && LO(a, i)
}
function Hg(t, e, n) {
  var r = n.showTick,
    i = n.tickLength,
    a = n.tickDirection,
    o = n.labelDirection,
    s = n.labelSpacing,
    c = e.indexOf(t),
    l = Cn(s, [t, c, e]),
    u = N([Ds(t.value, n), J8(o, a)], 2),
    f = u[0],
    h = u[1],
    d = h === 1 ? Cn(r ? i : 0, [t, c, e]) : 0,
    p = N(wo(gr(f, l + d), Ou(t.value, n)), 2),
    v = p[0],
    g = p[1]
  return { x: v, y: g }
}
function rI(t, e, n, r) {
  var i = r.labelFormatter,
    a = mn(i)
      ? function () {
          return Bi(Cn(i, [t, e, n, Ds(t.value, r)]))
        }
      : function () {
          return Bi(t.label || '')
        }
  return a
}
function LO(t, e) {
  t.nodeName === 'text' && t.attr(e)
}
function Vg(t) {
  Q8(this.node().childNodes, t, {
    hide: si,
    show: js,
    rotate: function (e, n) {
      nI(+n, e, t)
    },
    ellipsis: function (e, n, r) {
      e && Dh(e, n || 1 / 0, r)
    },
    wrap: function (e, n, r) {
      e && l6(e, n, r)
    },
    getTextShape: function (e) {
      return e.querySelector('text')
    }
  })
}
function Xg(t, e, n, r, i) {
  var a = n.indexOf(e),
    o = ft(t).append(rI(e, a, n, i)).attr('className', Rt.labelItem.name).node(),
    s = N(Pr(MO(r, [e, a, n])), 2),
    c = s[0],
    l = s[1],
    u = l.transform,
    f = Dt(l, ['transform'])
  gl(t, u)
  var h = eI(e, t, i)
  return t.setLocalEulerAngles(+h), LO(o, z(z({}, CO(e.value, h, i)), c)), gl(t, u), t.attr(f), o
}
function iI(t, e, n, r) {
  var i = Hp(e, n.labelFilter),
    a = vt(n, 'label')
  return t
    .selectAll(Rt.label.class)
    .data(i, function (o, s) {
      return s
    })
    .join(
      function (o) {
        return o
          .append('g')
          .attr('className', Rt.label.name)
          .transition(function (s) {
            return Xg(this, s, e, a, n), this.attr(Hg(s, e, n)), (this.__bbox__ = s.bbox), null
          })
          .call(function () {
            return Vg.call(t, n)
          })
      },
      function (o) {
        return o
          .transition(function (s) {
            var c = this.querySelector(Rt.labelItem.class),
              l = Xg(this, s, e, a, n),
              u = d8(c, l, r.update),
              f = Gn(this, Hg(s, e, n), r.update)
            return (this.__bbox__ = s.bbox), q(q([], N(u), !1), [f], !1)
          })
          .call(function (s) {
            var c = nb(s, '_transitions').flat().filter(uO)
            f8(c, function () {
              return Vg.call(t, n)
            })
          })
      },
      function (o) {
        return o.transition(function () {
          var s = this,
            c = xu(this.childNodes[0], r.exit)
          return (
            Ja(c, function () {
              return ft(s).remove()
            }),
            c
          )
        })
      }
    )
    .transitions()
}
function NO(t, e) {
  return Vp(t, e.tickDirection, e)
}
function aI(t, e) {
  var n = N(t, 2),
    r = n[0],
    i = n[1]
  return [
    [0, 0],
    [r * e, i * e]
  ]
}
function oI(t, e, n, r, i) {
  var a = i.tickLength,
    o = N(aI(r, Cn(a, [t, e, n])), 2),
    s = N(o[0], 2),
    c = s[0],
    l = s[1],
    u = N(o[1], 2),
    f = u[0],
    h = u[1]
  return { x1: c, x2: f, y1: l, y2: h }
}
function sI(t, e, n, r, i) {
  var a = i.tickFormatter,
    o = NO(e.value, i),
    s = 'line'
  return (
    mn(a) &&
      (s = function () {
        return Cn(a, [e, n, r, o])
      }),
    t.append(s).attr('className', Rt.tickItem.name)
  )
}
function cI(t, e, n, r, i, a, o) {
  var s = NO(t.value, a),
    c = oI(t, e, n, s, a),
    l = c.x1,
    u = c.x2,
    f = c.y1,
    h = c.y2,
    d = N(Pr(MO(o, [t, e, n, s])), 2),
    p = d[0],
    v = d[1]
  r.node().nodeName === 'line' && r.styles(z({ x1: l, x2: u, y1: f, y2: h }, p)),
    i.attr(v),
    r.styles(p)
}
function Ug(t, e, n, r, i, a) {
  var o = sI(ft(this), t, e, n, r)
  cI(t, e, n, o, this, r, i)
  var s = N(Ou(t.value, r), 2),
    c = s[0],
    l = s[1]
  return Gn(this, { x: c, y: l }, a)
}
function lI(t, e, n, r) {
  var i = Hp(e, n.tickFilter),
    a = vt(n, 'tick')
  return t
    .selectAll(Rt.tick.class)
    .data(i, function (o) {
      return o.id || o.label
    })
    .join(
      function (o) {
        return o
          .append('g')
          .attr('className', Rt.tick.name)
          .transition(function (s, c) {
            return Ug.call(this, s, c, i, n, a, !1)
          })
      },
      function (o) {
        return o.transition(function (s, c) {
          return this.removeChildren(), Ug.call(this, s, c, i, n, a, r.update)
        })
      },
      function (o) {
        return o.transition(function () {
          var s = this,
            c = xu(this.childNodes[0], r.exit)
          return (
            Ja(c, function () {
              return s.remove()
            }),
            c
          )
        })
      }
    )
    .transitions()
}
var qg = In({ text: 'text' }, 'title')
function _u(t) {
  return /\S+-\S+/g.test(t)
    ? t.split('-').map(function (e) {
        return e[0]
      })
    : t.length > 2
    ? [t[0]]
    : t.split('')
}
function uI(t, e) {
  var n = t.attributes,
    r = n.position,
    i = n.spacing,
    a = n.inset,
    o = n.text,
    s = t.getBBox(),
    c = e.getBBox(),
    l = _u(r),
    u = N(ke(o ? i : 0), 4),
    f = u[0],
    h = u[1],
    d = u[2],
    p = u[3],
    v = N(ke(a), 4),
    g = v[0],
    y = v[1],
    m = v[2],
    b = v[3],
    x = N([p + h, f + d], 2),
    w = x[0],
    O = x[1],
    S = N([b + y, g + m], 2),
    _ = S[0],
    M = S[1]
  if (l[0] === 'l')
    return new te(s.x, s.y, c.width + s.width + w + _, Math.max(c.height + M, s.height))
  if (l[0] === 't')
    return new te(s.x, s.y, Math.max(c.width + _, s.width), c.height + s.height + O + M)
  var E = N([e.attributes.width || c.width, e.attributes.height || c.height], 2),
    T = E[0],
    C = E[1]
  return new te(c.x, c.y, T + s.width + w + _, C + s.height + O + M)
}
function fI(t, e) {
  var n = Object.entries(e).reduce(function (r, i) {
    var a = N(i, 2),
      o = a[0],
      s = a[1],
      c = t.node().attr(o)
    return c || (r[o] = s), r
  }, {})
  t.styles(n)
}
function hI(t) {
  var e,
    n,
    r,
    i,
    a = t,
    o = a.width,
    s = a.height,
    c = a.position,
    l = N([+o / 2, +s / 2], 2),
    u = l[0],
    f = l[1],
    h = N([+u, +f, 'center', 'middle'], 4),
    d = h[0],
    p = h[1],
    v = h[2],
    g = h[3],
    y = _u(c)
  return (
    y.includes('l') && ((e = N([0, 'start'], 2)), (d = e[0]), (v = e[1])),
    y.includes('r') && ((n = N([+o, 'end'], 2)), (d = n[0]), (v = n[1])),
    y.includes('t') && ((r = N([0, 'top'], 2)), (p = r[0]), (g = r[1])),
    y.includes('b') && ((i = N([+s, 'bottom'], 2)), (p = i[0]), (g = i[1])),
    { x: d, y: p, textAlign: v, textBaseline: g }
  )
}
var RO = (function (t) {
  rt(e, t)
  function e(n) {
    return (
      t.call(this, n, {
        text: '',
        width: 0,
        height: 0,
        fill: '#4a505a',
        fontWeight: 'bold',
        fontSize: 12,
        fontFamily: 'sans-serif',
        inset: 0,
        spacing: 0,
        position: 'top-left'
      }) || this
    )
  }
  return (
    (e.prototype.getAvailableSpace = function () {
      var n = this,
        r = this.attributes,
        i = r.width,
        a = r.height,
        o = r.position,
        s = r.spacing,
        c = r.inset,
        l = n.querySelector(qg.text.class)
      if (!l) return new te(0, 0, +i, +a)
      var u = l.getBBox(),
        f = u.width,
        h = u.height,
        d = N(ke(s), 4),
        p = d[0],
        v = d[1],
        g = d[2],
        y = d[3],
        m = N([0, 0, +i, +a], 4),
        b = m[0],
        x = m[1],
        w = m[2],
        O = m[3],
        S = _u(o)
      if (S.includes('i')) return new te(b, x, w, O)
      S.forEach(function (L, R) {
        var j, I, D, $
        L === 't' && ((j = N(R === 0 ? [h + g, +a - h - g] : [0, +a], 2)), (x = j[0]), (O = j[1])),
          L === 'r' && ((I = N([+i - f - y], 1)), (w = I[0])),
          L === 'b' && ((D = N([+a - h - p], 1)), (O = D[0])),
          L === 'l' && (($ = N(R === 0 ? [f + v, +i - f - v] : [0, +i], 2)), (b = $[0]), (w = $[1]))
      })
      var _ = N(ke(c), 4),
        M = _[0],
        E = _[1],
        T = _[2],
        C = _[3],
        A = N([C + E, M + T], 2),
        P = A[0],
        k = A[1]
      return new te(b + C, x + M, w - P, O - k)
    }),
    (e.prototype.getBBox = function () {
      return this.title ? this.title.getBBox() : new te(0, 0, 0, 0)
    }),
    (e.prototype.render = function (n, r) {
      var i = this
      n.width, n.height, n.position, n.spacing
      var a = Dt(n, ['width', 'height', 'position', 'spacing']),
        o = N(Pr(a), 1),
        s = o[0],
        c = hI(n),
        l = c.x,
        u = c.y,
        f = c.textAlign,
        h = c.textBaseline
      tn(!!a.text, ft(r), function (d) {
        i.title = d
          .maybeAppendByClassName(qg.text, 'text')
          .styles(s)
          .call(fI, { x: l, y: u, textAlign: f, textBaseline: h })
          .node()
      })
    }),
    e
  )
})(Te)
function dI(t, e, n) {
  var r = n.titlePosition,
    i = r === void 0 ? 'lb' : r,
    a = n.titleSpacing,
    o = _u(i),
    s = t.node().getLocalBounds(),
    c = N(s.min, 2),
    l = c[0],
    u = c[1],
    f = N(s.halfExtents, 2),
    h = f[0],
    d = f[1],
    p = N(e.node().getLocalBounds().halfExtents, 2),
    v = p[0],
    g = p[1],
    y = N([l + h, u + d], 2),
    m = y[0],
    b = y[1],
    x = N(ke(a), 4),
    w = x[0],
    O = x[1],
    S = x[2],
    _ = x[3]
  if (['start', 'end'].includes(i) && n.type === 'linear') {
    var M = n.startPos,
      E = n.endPos,
      T = N(i === 'start' ? [M, E] : [E, M], 2),
      C = T[0],
      A = T[1],
      P = dO([-A[0] + C[0], -A[1] + C[1]]),
      k = N(gr(P, w), 2),
      L = k[0],
      R = k[1]
    return { x: C[0] + L, y: C[1] + R }
  }
  return (
    o.includes('t') && (b -= d + g + w),
    o.includes('r') && (m += h + v + O),
    o.includes('l') && (m -= h + v * 2 + _),
    o.includes('b') && (b += d + g * 2 + S),
    { x: m, y: b }
  )
}
function pI(t, e, n) {
  var r = t.cloneNode(!0)
  ;(r.style.transform = 'scale(1, 1)'), (r.style.transform = 'none')
  var i = r.getBBox().height
  if (e === 'vertical') {
    if (n === 'left') return 'rotate(-90) translate(0, '.concat(i / 2, ')')
    if (n === 'right') return 'rotate(-90) translate(0, -'.concat(i / 2, ')')
  }
  return ''
}
function Kg(t, e, n, r, i) {
  var a = vt(r, 'title'),
    o = N(Pr(a), 2),
    s = o[0],
    c = o[1],
    l = c.transform,
    u = Dt(c, ['transform'])
  t.styles(s), e.styles(u)
  var f = l || pI(t.node(), s.direction, s.position)
  gl(t.node(), f)
  var h = dI(ft(n._offscreen || n.querySelector(Rt.mainGroup.class)), e, r),
    d = h.x,
    p = h.y,
    v = Gn(e.node(), { x: d, y: p }, i)
  return gl(t.node(), f), v
}
function vI(t, e, n, r) {
  var i = n.titleText
  return t
    .selectAll(Rt.title.class)
    .data(
      [{ title: i }].filter(function (a) {
        return !!a.title
      }),
      function (a, o) {
        return a.title
      }
    )
    .join(
      function (a) {
        return a
          .append(function () {
            return Bi(i)
          })
          .attr('className', Rt.title.name)
          .transition(function () {
            return Kg(ft(this), t, e, n, r.enter)
          })
      },
      function (a) {
        return a.transition(function () {
          return Kg(ft(this), t, e, n, r.update)
        })
      },
      function (a) {
        return a.remove()
      }
    )
    .transitions()
}
function Zg(t, e, n, r) {
  var i = t.showLine,
    a = t.showTick,
    o = t.showLabel,
    s = e.maybeAppendByClassName(Rt.lineGroup, 'g'),
    c =
      tn(i, s, function (d) {
        return k8(d, t, r)
      }) || [],
    l = e.maybeAppendByClassName(Rt.tickGroup, 'g'),
    u =
      tn(a, l, function (d) {
        return lI(d, n, t, r)
      }) || [],
    f = e.maybeAppendByClassName(Rt.labelGroup, 'g'),
    h =
      tn(o, f, function (d) {
        return iI(d, n, t, r)
      }) || []
  return q(q(q([], N(c), !1), N(u), !1), N(h), !1).filter(function (d) {
    return !!d
  })
}
var Up = (function (t) {
    rt(e, t)
    function e(n) {
      return t.call(this, n, Yp) || this
    }
    return (
      (e.prototype.render = function (n, r, i) {
        var a = this,
          o = n.titleText,
          s = n.data,
          c = n.animate,
          l = n.showTitle,
          u = n.showGrid,
          f = n.dataThreshold,
          h = n.truncRange,
          d = S6(s, f).filter(function (w) {
            var O = w.value
            return !(h && O > h[0] && O < h[1])
          }),
          p = zg(i === void 0 ? c : i),
          v = ft(r).maybeAppendByClassName(Rt.gridGroup, 'g'),
          g =
            tn(u, v, function (w) {
              return R8(w, d, n, p)
            }) || [],
          y = ft(r).maybeAppendByClassName(Rt.mainGroup, 'g')
        o &&
          ((!this.initialized && p.enter) || (this.initialized && p.update)) &&
          Zg(n, ft(this.offscreenGroup), d, zg(!1))
        var m = Zg(n, ft(y.node()), d, p),
          b = ft(r).maybeAppendByClassName(Rt.titleGroup, 'g'),
          x =
            tn(l, b, function (w) {
              return vI(w, a, n, p)
            }) || []
        return q(q(q([], N(g), !1), N(m), !1), N(x), !1)
          .flat()
          .filter(function (w) {
            return !!w
          })
      }),
      e
    )
  })(Te),
  _n = In(
    {
      prevBtnGroup: 'prev-btn-group',
      prevBtn: 'prev-btn',
      nextBtnGroup: 'next-btn-group',
      nextBtn: 'next-btn',
      pageInfoGroup: 'page-info-group',
      pageInfo: 'page-info',
      playWindow: 'play-window',
      contentGroup: 'content-group',
      controller: 'controller',
      clipPath: 'clip-path'
    },
    'navigator'
  ),
  gI = (function (t) {
    rt(e, t)
    function e(n) {
      var r =
        t.call(this, n, {
          animate: { easing: 'linear', duration: 200, fill: 'both' },
          buttonCursor: 'pointer',
          buttonFill: 'black',
          buttonPath: t8(0, 0, 6),
          buttonSize: 12,
          controllerPadding: 5,
          controllerSpacing: 5,
          formatter: function (i, a) {
            return ''.concat(i, '/').concat(a)
          },
          defaultPage: 0,
          loop: !1,
          orientation: 'horizontal',
          pageNumFill: 'black',
          pageNumFontSize: 12,
          pageNumTextAlign: 'start',
          pageNumTextBaseline: 'middle'
        }) || this
      return (
        (r.playState = 'idle'),
        (r.contentGroup = r.appendChild(new je({ class: _n.contentGroup.name }))),
        (r.playWindow = r.contentGroup.appendChild(new je({ class: _n.playWindow.name }))),
        (r.innerCurrPage = r.defaultPage),
        r
      )
    }
    return (
      Object.defineProperty(e.prototype, 'defaultPage', {
        get: function () {
          var n = this.attributes.defaultPage
          return se(n, 0, Math.max(this.pageViews.length - 1, 0))
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'pageViews', {
        get: function () {
          return this.playWindow.children
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'controllerShape', {
        get: function () {
          return this.totalPages > 1 ? { width: 55, height: 0 } : { width: 0, height: 0 }
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'pageShape', {
        get: function () {
          var n = this.pageViews,
            r = N(
              I6(
                n.map(function (f) {
                  var h = f.getBBox(),
                    d = h.width,
                    p = h.height
                  return [d, p]
                })
              ).map(function (f) {
                return Math.max.apply(Math, q([], N(f), !1))
              }),
              2
            ),
            i = r[0],
            a = r[1],
            o = this.attributes,
            s = o.pageWidth,
            c = s === void 0 ? i : s,
            l = o.pageHeight,
            u = l === void 0 ? a : l
          return { pageWidth: c, pageHeight: u }
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.getContainer = function () {
        return this.playWindow
      }),
      Object.defineProperty(e.prototype, 'totalPages', {
        get: function () {
          return this.pageViews.length
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'currPage', {
        get: function () {
          return this.innerCurrPage
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.getBBox = function () {
        var n = t.prototype.getBBox.call(this),
          r = n.x,
          i = n.y,
          a = this.controllerShape,
          o = this.pageShape,
          s = o.pageWidth,
          c = o.pageHeight
        return new te(r, i, s + a.width, c)
      }),
      (e.prototype.goTo = function (n) {
        var r = this,
          i = this.attributes.animate,
          a = this,
          o = a.currPage,
          s = a.playState,
          c = a.playWindow,
          l = a.pageViews
        if (s !== 'idle' || n < 0 || l.length <= 0 || n >= l.length) return null
        l[o].setLocalPosition(0, 0), this.prepareFollowingPage(n)
        var u = N(this.getFollowingPageDiff(n), 2),
          f = u[0],
          h = u[1]
        this.playState = 'running'
        var d = mO(
          c,
          [
            { transform: 'translate(0, 0)' },
            { transform: 'translate('.concat(-f, ', ').concat(-h, ')') }
          ],
          i
        )
        return (
          Ja(d, function () {
            ;(r.innerCurrPage = n),
              (r.playState = 'idle'),
              r.setVisiblePages([n]),
              r.updatePageInfo()
          }),
          d
        )
      }),
      (e.prototype.prev = function () {
        var n = this.attributes.loop,
          r = this.pageViews.length,
          i = this.currPage
        if (!n && i <= 0) return null
        var a = n ? (i - 1 + r) % r : se(i - 1, 0, r)
        return this.goTo(a)
      }),
      (e.prototype.next = function () {
        var n = this.attributes.loop,
          r = this.pageViews.length,
          i = this.currPage
        if (!n && i >= r - 1) return null
        var a = n ? (i + 1) % r : se(i + 1, 0, r)
        return this.goTo(a)
      }),
      (e.prototype.renderClipPath = function (n) {
        var r = this.pageShape,
          i = r.pageWidth,
          a = r.pageHeight
        if (!i || !a) {
          this.contentGroup.style.clipPath = void 0
          return
        }
        ;(this.clipPath = n
          .maybeAppendByClassName(_n.clipPath, 'rect')
          .styles({ width: i, height: a })),
          this.contentGroup.attr('clipPath', this.clipPath.node())
      }),
      (e.prototype.setVisiblePages = function (n) {
        this.playWindow.children.forEach(function (r, i) {
          n.includes(i) ? js(r) : si(r)
        })
      }),
      (e.prototype.adjustControllerLayout = function () {
        var n = this,
          r = n.prevBtnGroup,
          i = n.nextBtnGroup,
          a = n.pageInfoGroup,
          o = this.attributes,
          s = o.orientation,
          c = o.controllerPadding,
          l = a.getBBox(),
          u = l.width
        l.height
        var f = N(s === 'horizontal' ? [-180, 0] : [-90, 90], 2),
          h = f[0],
          d = f[1]
        r.setLocalEulerAngles(h), i.setLocalEulerAngles(d)
        var p = r.getBBox(),
          v = p.width,
          g = p.height,
          y = i.getBBox(),
          m = y.width,
          b = y.height,
          x = Math.max(v, u, m),
          w =
            s === 'horizontal'
              ? {
                  offset: [
                    [0, 0],
                    [v / 2 + c, 0],
                    [v + u + c * 2, 0]
                  ],
                  textAlign: 'start'
                }
              : {
                  offset: [
                    [x / 2, -g - c],
                    [x / 2, 0],
                    [x / 2, b + c]
                  ],
                  textAlign: 'center'
                },
          O = N(w.offset, 3),
          S = N(O[0], 2),
          _ = S[0],
          M = S[1],
          E = N(O[1], 2),
          T = E[0],
          C = E[1],
          A = N(O[2], 2),
          P = A[0],
          k = A[1],
          L = w.textAlign,
          R = a.querySelector('text')
        R && (R.style.textAlign = L),
          r.setLocalPosition(_, M),
          a.setLocalPosition(T, C),
          i.setLocalPosition(P, k)
      }),
      (e.prototype.updatePageInfo = function () {
        var n,
          r = this,
          i = r.currPage,
          a = r.pageViews,
          o = r.attributes.formatter
        a.length < 2 ||
          ((n = this.pageInfoGroup.querySelector(_n.pageInfo.class)) === null ||
            n === void 0 ||
            n.attr('text', o(i + 1, a.length)),
          this.adjustControllerLayout())
      }),
      (e.prototype.getFollowingPageDiff = function (n) {
        var r = this.currPage
        if (r === n) return [0, 0]
        var i = this.attributes.orientation,
          a = this.pageShape,
          o = a.pageWidth,
          s = a.pageHeight,
          c = n < r ? -1 : 1
        return i === 'horizontal' ? [c * o, 0] : [0, c * s]
      }),
      (e.prototype.prepareFollowingPage = function (n) {
        var r = this,
          i = r.currPage,
          a = r.pageViews
        if ((this.setVisiblePages([n, i]), n !== i)) {
          var o = N(this.getFollowingPageDiff(n), 2),
            s = o[0],
            c = o[1]
          a[n].setLocalPosition(s, c)
        }
      }),
      (e.prototype.renderController = function (n) {
        var r = this,
          i = this.attributes.controllerSpacing,
          a = this.pageShape,
          o = a.pageWidth,
          s = a.pageHeight,
          c = this.pageViews.length >= 2,
          l = n.maybeAppendByClassName(_n.controller, 'g')
        if ((bu(l.node(), c), !!c)) {
          var u = vt(this.attributes, 'button'),
            f = vt(this.attributes, 'pageNum'),
            h = N(Pr(u), 2),
            d = h[0],
            p = h[1],
            v = d.size,
            g = Dt(d, ['size']),
            y = !l.select(_n.prevBtnGroup.class).node(),
            m = l.maybeAppendByClassName(_n.prevBtnGroup, 'g').styles(p)
          this.prevBtnGroup = m.node()
          var b = m.maybeAppendByClassName(_n.prevBtn, 'path'),
            x = l.maybeAppendByClassName(_n.nextBtnGroup, 'g').styles(p)
          this.nextBtnGroup = x.node()
          var w = x.maybeAppendByClassName(_n.nextBtn, 'path')
          ;[b, w].forEach(function (S) {
            S.styles(z(z({}, g), { transformOrigin: 'center' })), zp(S.node(), v, !0)
          })
          var O = l.maybeAppendByClassName(_n.pageInfoGroup, 'g')
          ;(this.pageInfoGroup = O.node()),
            O.maybeAppendByClassName(_n.pageInfo, 'text').styles(f),
            this.updatePageInfo(),
            l.node().setLocalPosition(o + i, s / 2),
            y &&
              (this.prevBtnGroup.addEventListener('click', function () {
                r.prev()
              }),
              this.nextBtnGroup.addEventListener('click', function () {
                r.next()
              }))
        }
      }),
      (e.prototype.render = function (n, r) {
        var i = ft(r)
        this.renderClipPath(i),
          this.renderController(i),
          this.setVisiblePages([this.defaultPage]),
          this.goTo(this.defaultPage)
      }),
      (e.prototype.bindEvents = function () {
        var n = this,
          r = J1(function () {
            return n.render(n.attributes, n)
          }, 50)
        this.playWindow.addEventListener(dt.INSERTED, r),
          this.playWindow.addEventListener(dt.REMOVED, r)
      }),
      e
    )
  })(Te)
function yI(t, e, n) {
  var r = Math.round((t - n) / e)
  return n + r * e
}
function mI(t, e, n) {
  var r = 1.4,
    i = r * n
  return [['M', t - n, e - i], ['L', t + n, e - i], ['L', t + n, e + i], ['L', t - n, e + i], ['Z']]
}
var IO = 1.4,
  jO = 0.4
function bI(t, e, n) {
  var r = n,
    i = r * IO,
    a = r / 2,
    o = r / 6,
    s = t + i * jO
  return [
    ['M', t, e],
    ['L', s, e + a],
    ['L', t + i, e + a],
    ['L', t + i, e - a],
    ['L', s, e - a],
    ['Z'],
    ['M', s, e + o],
    ['L', t + i - 2, e + o],
    ['M', s, e - o],
    ['L', t + i - 2, e - o]
  ]
}
function xI(t, e, n) {
  var r = n,
    i = r * IO,
    a = r / 2,
    o = r / 6,
    s = e + i * jO
  return [
    ['M', t, e],
    ['L', t - a, s],
    ['L', t - a, e + i],
    ['L', t + a, e + i],
    ['L', t + a, s],
    ['Z'],
    ['M', t - o, s],
    ['L', t - o, e + i - 2],
    ['M', t + o, s],
    ['L', t + o, e + i - 2]
  ]
}
$t.registerSymbol('hiddenHandle', mI)
$t.registerSymbol('verticalHandle', bI)
$t.registerSymbol('horizontalHandle', xI)
function wI(t, e, n, r) {
  var i,
    a = N(t, 2),
    o = a[0],
    s = a[1],
    c = N(e, 2),
    l = c[0],
    u = c[1],
    f = N(n, 2),
    h = f[0],
    d = f[1],
    p = N([l, u], 2),
    v = p[0],
    g = p[1],
    y = g - v
  return (
    v > g && ((i = N([g, v], 2)), (v = i[0]), (g = i[1])),
    y > s - o
      ? [o, s]
      : v < o
      ? h === o && d === g
        ? [o, g]
        : [o, y + o]
      : g > s
      ? d === s && h === v
        ? [v, s]
        : [s - y, s]
      : [v, g]
  )
}
function er(t, e, n) {
  return t === void 0 && (t = 'horizontal'), t === 'horizontal' ? e : n
}
var sn = In(
  {
    layout: 'flex',
    markerGroup: 'marker-group',
    marker: 'marker',
    labelGroup: 'label-group',
    label: 'label',
    valueGroup: 'value-group',
    value: 'value',
    backgroundGroup: 'background-group',
    background: 'background'
  },
  'legend-category-item'
)
function OI(t) {
  var e = t.querySelector(sn.marker.class)
  return e ? e.style : {}
}
var SI = (function (t) {
    rt(e, t)
    function e(n) {
      return (
        t.call(this, n, {
          span: [1, 1],
          marker: function () {
            return new Ns({ style: { r: 6 } })
          },
          markerSize: 10,
          labelFill: '#646464',
          valueFill: '#646464',
          labelFontSize: 12,
          valueFontSize: 12,
          labelTextBaseline: 'middle',
          valueTextBaseline: 'middle'
        }) || this
      )
    }
    return (
      Object.defineProperty(e.prototype, 'showValue', {
        get: function () {
          var n = this.attributes.valueText
          return n
            ? typeof n == 'string' || typeof n == 'number'
              ? n !== ''
              : typeof n == 'function'
              ? !0
              : n.attr('text') !== ''
            : !1
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'actualSpace', {
        get: function () {
          var n = this.labelGroup,
            r = this.valueGroup,
            i = this.attributes.markerSize,
            a = n.node().getBBox(),
            o = a.width,
            s = a.height,
            c = r.node().getBBox(),
            l = c.width,
            u = c.height
          return { markerWidth: i, labelWidth: o, valueWidth: l, height: Math.max(i, s, u) }
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'span', {
        get: function () {
          var n = this.attributes.span
          if (!n) return [1, 1]
          var r = N(ke(n), 2),
            i = r[0],
            a = r[1],
            o = this.showValue ? a : 0,
            s = i + o
          return [i / s, o / s]
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'shape', {
        get: function () {
          var n,
            r = this.attributes,
            i = r.markerSize,
            a = r.width,
            o = this.actualSpace,
            s = o.markerWidth,
            c = o.height,
            l = this.actualSpace,
            u = l.labelWidth,
            f = l.valueWidth,
            h = N(this.spacing, 2),
            d = h[0],
            p = h[1]
          if (a) {
            var v = a - i - d - p,
              g = N(this.span, 2),
              y = g[0],
              m = g[1]
            ;(n = N([y * v, m * v], 2)), (u = n[0]), (f = n[1])
          }
          var b = s + u + f + d + p
          return { width: b, height: c, markerWidth: s, labelWidth: u, valueWidth: f }
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'spacing', {
        get: function () {
          var n = this.attributes.spacing
          if (!n) return [0, 0]
          var r = N(ke(n), 2),
            i = r[0],
            a = r[1]
          return this.showValue ? [i, a] : [i, 0]
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'layout', {
        get: function () {
          var n = this.shape,
            r = n.markerWidth,
            i = n.labelWidth,
            a = n.valueWidth,
            o = n.width,
            s = n.height,
            c = N(this.spacing, 2),
            l = c[0],
            u = c[1]
          return {
            height: s,
            width: o,
            markerWidth: r,
            labelWidth: i,
            valueWidth: a,
            position: [r / 2, r + l, r + i + l + u]
          }
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'scaleSize', {
        get: function () {
          var n = OI(this.markerGroup.node()),
            r = this.attributes,
            i = r.markerSize,
            a = r.markerStrokeWidth,
            o = a === void 0 ? n.strokeWidth : a,
            s = r.markerLineWidth,
            c = s === void 0 ? n.lineWidth : s,
            l = r.markerStroke,
            u = l === void 0 ? n.stroke : l,
            f = +(o || c || (u ? 1 : 0)) * Math.sqrt(2),
            h = this.markerGroup.node().getBBox(),
            d = h.width,
            p = h.height
          return (1 - f / Math.max(d, p)) * i
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.renderMarker = function (n) {
        var r = this,
          i = this.attributes.marker,
          a = vt(this.attributes, 'marker')
        ;(this.markerGroup = n.maybeAppendByClassName(sn.markerGroup, 'g').style('zIndex', 0)),
          tn(!!i, this.markerGroup, function () {
            var o = r.markerGroup.node(),
              s = o.getElementsByClassName(sn.marker.name)[0],
              c = i()
            s
              ? c.nodeName === s.nodeName
                ? (A6(s, c), ft(s).styles(a))
                : (s.remove(), ft(c).attr('className', sn.marker.name).styles(a), o.appendChild(c))
              : (ft(c).attr('className', sn.marker.name).styles(a), o.appendChild(c)),
              r.markerGroup.node().scale(1 / r.markerGroup.node().getScale()[0]),
              zp(r.markerGroup.node(), r.scaleSize, !0)
          })
      }),
      (e.prototype.renderLabel = function (n) {
        var r = vt(this.attributes, 'label'),
          i = r.text,
          a = Dt(r, ['text'])
        ;(this.labelGroup = n.maybeAppendByClassName(sn.labelGroup, 'g').style('zIndex', 0)),
          this.labelGroup
            .maybeAppendByClassName(sn.label, function () {
              return Bi(i)
            })
            .styles(a)
      }),
      (e.prototype.renderValue = function (n) {
        var r = this,
          i = vt(this.attributes, 'value'),
          a = i.text,
          o = Dt(i, ['text'])
        ;(this.valueGroup = n.maybeAppendByClassName(sn.valueGroup, 'g').style('zIndex', 0)),
          tn(this.showValue, this.valueGroup, function () {
            r.valueGroup
              .maybeAppendByClassName(sn.value, function () {
                return Bi(a)
              })
              .styles(o)
          })
      }),
      (e.prototype.renderBackground = function (n) {
        var r = this.shape,
          i = r.width,
          a = r.height,
          o = vt(this.attributes, 'background')
        ;(this.background = n.maybeAppendByClassName(sn.backgroundGroup, 'g').style('zIndex', -1)),
          this.background
            .maybeAppendByClassName(sn.background, 'rect')
            .styles(z({ width: i, height: a }, o))
      }),
      (e.prototype.adjustLayout = function () {
        var n = this.layout,
          r = n.labelWidth,
          i = n.valueWidth,
          a = n.height,
          o = N(n.position, 3),
          s = o[0],
          c = o[1],
          l = o[2],
          u = a / 2
        this.markerGroup.styles({ x: s, y: u }),
          this.labelGroup.styles({ x: c, y: u }),
          Dh(this.labelGroup.select(sn.label.class).node(), Math.ceil(r)),
          this.showValue &&
            (this.valueGroup.styles({ x: l, y: u }),
            Dh(this.valueGroup.select(sn.value.class).node(), Math.ceil(i)))
      }),
      (e.prototype.render = function (n, r) {
        var i = ft(r)
        this.renderMarker(i),
          this.renderLabel(i),
          this.renderValue(i),
          this.renderBackground(i),
          this.adjustLayout()
      }),
      e
    )
  })(Te),
  xi = In({ page: 'item-page', navigator: 'navigator', item: 'item' }, 'items'),
  Qg = function (t, e, n) {
    return n === void 0 && (n = !0), t ? e(t) : n
  },
  _I = (function (t) {
    rt(e, t)
    function e(n) {
      var r =
        t.call(this, n, {
          data: [],
          gridRow: 1 / 0,
          gridCol: void 0,
          padding: 0,
          width: 1e3,
          height: 100,
          rowPadding: 0,
          colPadding: 0,
          layout: 'flex',
          orientation: 'horizontal',
          click: Gu,
          mouseenter: Gu,
          mouseleave: Gu
        }) || this
      return (r.navigatorShape = [0, 0]), r
    }
    return (
      Object.defineProperty(e.prototype, 'pageViews', {
        get: function () {
          return this.navigator.getContainer()
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'grid', {
        get: function () {
          var n = this.attributes,
            r = n.gridRow,
            i = n.gridCol,
            a = n.data
          if (!r && !i) throw new Error('gridRow and gridCol can not be set null at the same time')
          return r && i ? [r, i] : r ? [r, a.length] : [a.length, i]
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'renderData', {
        get: function () {
          var n = this.attributes,
            r = n.data,
            i = n.layout,
            a = vt(this.attributes, 'item'),
            o = r.map(function (s, c) {
              var l = s.id,
                u = l === void 0 ? c : l,
                f = s.label,
                h = s.value
              return {
                id: ''.concat(u),
                index: c,
                style: z(
                  { layout: i, labelText: f, valueText: h },
                  Object.fromEntries(
                    Object.entries(a).map(function (d) {
                      var p = N(d, 2),
                        v = p[0],
                        g = p[1]
                      return [v, Cn(g, [s, c, r])]
                    })
                  )
                )
              }
            })
          return o
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.getGridLayout = function () {
        var n = this,
          r = this.attributes,
          i = r.orientation,
          a = r.width,
          o = r.rowPadding,
          s = r.colPadding,
          c = N(this.navigatorShape, 1),
          l = c[0],
          u = N(this.grid, 2),
          f = u[0],
          h = u[1],
          d = h * f,
          p = 0
        return this.pageViews.children.map(function (v, g) {
          var y,
            m,
            b = Math.floor(g / d),
            x = g % d,
            w = n.ifHorizontal(h, f),
            O = [Math.floor(x / w), x % w]
          i === 'vertical' && O.reverse()
          var S = N(O, 2),
            _ = S[0],
            M = S[1],
            E = (a - l - (h - 1) * s) / h,
            T = v.getBBox().height,
            C = N([0, 0], 2),
            A = C[0],
            P = C[1]
          return (
            i === 'horizontal'
              ? ((y = N([p, _ * (T + o)], 2)),
                (A = y[0]),
                (P = y[1]),
                (p = M === h - 1 ? 0 : p + E + s))
              : ((m = N([M * (E + s), p], 2)),
                (A = m[0]),
                (P = m[1]),
                (p = _ === f - 1 ? 0 : p + T + o)),
            { page: b, index: g, row: _, col: M, pageIndex: x, width: E, height: T, x: A, y: P }
          )
        })
      }),
      (e.prototype.getFlexLayout = function () {
        var n = this.attributes,
          r = n.width,
          i = n.height,
          a = n.rowPadding,
          o = n.colPadding,
          s = N(this.navigatorShape, 1),
          c = s[0],
          l = N(this.grid, 2),
          u = l[0],
          f = l[1],
          h = N([r - c, i], 2),
          d = h[0],
          p = h[1],
          v = N([0, 0, 0, 0, 0, 0, 0, 0], 8),
          g = v[0],
          y = v[1],
          m = v[2],
          b = v[3],
          x = v[4],
          w = v[5],
          O = v[6],
          S = v[7]
        return this.pageViews.children.map(function (_, M) {
          var E,
            T,
            C,
            A,
            P = _.getBBox(),
            k = P.width,
            L = P.height,
            R = O === 0 ? 0 : o,
            j = O + R + k
          if (
            j <= d &&
            Qg(x, function (D) {
              return D < f
            })
          )
            return (
              (E = N([O + R, S, j], 3)),
              (g = E[0]),
              (y = E[1]),
              (O = E[2]),
              { width: k, height: L, x: g, y, page: m, index: M, pageIndex: b++, row: w, col: x++ }
            )
          ;(T = N([w + 1, 0, 0, S + L + a], 4)), (w = T[0]), (x = T[1]), (O = T[2]), (S = T[3])
          var I = S + L
          return I <= p &&
            Qg(w, function (D) {
              return D < u
            })
            ? ((C = N([O, S, k], 3)),
              (g = C[0]),
              (y = C[1]),
              (O = C[2]),
              { width: k, height: L, x: g, y, page: m, index: M, pageIndex: b++, row: w, col: x++ })
            : ((A = N([0, 0, k, 0, m + 1, 0, 0, 0], 8)),
              (g = A[0]),
              (y = A[1]),
              (O = A[2]),
              (S = A[3]),
              (m = A[4]),
              (b = A[5]),
              (w = A[6]),
              (x = A[7]),
              { width: k, height: L, x: g, y, page: m, index: M, pageIndex: b++, row: w, col: x++ })
        })
      }),
      Object.defineProperty(e.prototype, 'itemsLayout', {
        get: function () {
          this.navigatorShape = [0, 0]
          var n = this.attributes.layout === 'grid' ? this.getGridLayout : this.getFlexLayout,
            r = n.call(this)
          return r.slice(-1)[0].page > 0 ? ((this.navigatorShape = [55, 0]), n.call(this)) : r
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.ifHorizontal = function (n, r) {
        var i = this.attributes.orientation
        return er(i, n, r)
      }),
      (e.prototype.flattenPage = function (n) {
        n.querySelectorAll(xi.item.class).forEach(function (r) {
          n.appendChild(r)
        }),
          n.querySelectorAll(xi.page.class).forEach(function (r) {
            var i = n.removeChild(r)
            i.destroy()
          })
      }),
      (e.prototype.renderItems = function (n) {
        var r = this.attributes,
          i = r.click,
          a = r.mouseenter,
          o = r.mouseleave
        this.flattenPage(n)
        var s = this.dispatchCustomEvent.bind(this)
        ft(n)
          .selectAll(xi.item.class)
          .data(this.renderData, function (c) {
            return c.id
          })
          .join(
            function (c) {
              return c
                .append(function (l) {
                  var u = l.style
                  return new SI({ style: u })
                })
                .attr('className', xi.item.name)
                .on('click', function () {
                  i == null || i(this), s('itemClick', { item: this })
                })
                .on('pointerenter', function () {
                  a == null || a(this), s('itemMouseenter', { item: this })
                })
                .on('pointerleave', function () {
                  o == null || o(this), s('itemMouseleave', { item: this })
                })
            },
            function (c) {
              return c.each(function (l) {
                var u = l.style
                this.update(u)
              })
            },
            function (c) {
              return c.remove()
            }
          )
      }),
      (e.prototype.relayoutNavigator = function () {
        var n,
          r = this.attributes,
          i = r.layout,
          a = r.width,
          o =
            ((n = this.pageViews.children[0]) === null || n === void 0
              ? void 0
              : n.getBBox().height) || 0,
          s = N(this.navigatorShape, 2),
          c = s[0],
          l = s[1]
        this.navigator.update(i === 'grid' ? { pageWidth: a - c, pageHeight: o - l } : {})
      }),
      (e.prototype.adjustLayout = function () {
        var n = this,
          r = Object.entries(u6(this.itemsLayout, 'page')).map(function (a) {
            var o = N(a, 2),
              s = o[0],
              c = o[1]
            return { page: s, layouts: c }
          }),
          i = q([], N(this.navigator.getContainer().children), !1)
        r.forEach(function (a) {
          var o = a.layouts,
            s = n.pageViews.appendChild(new je({ className: xi.page.name }))
          o.forEach(function (c) {
            var l = c.x,
              u = c.y,
              f = c.index,
              h = c.width,
              d = c.height,
              p = i[f]
            s.appendChild(p), BP(p, '__layout__', c), p.update({ x: l, y: u, width: h, height: d })
          })
        }),
          this.relayoutNavigator()
      }),
      (e.prototype.renderNavigator = function (n) {
        var r = this.attributes.orientation,
          i = vt(this.attributes, 'nav'),
          a = Tr({ orientation: r }, i),
          o = this
        return (
          n
            .selectAll(xi.navigator.class)
            .data(['nav'])
            .join(
              function (s) {
                return s
                  .append(function () {
                    return new gI({ style: a })
                  })
                  .attr('className', xi.navigator.name)
                  .each(function () {
                    o.navigator = this
                  })
              },
              function (s) {
                return s.each(function () {
                  this.update(a)
                })
              },
              function (s) {
                return s.remove()
              }
            ),
          this.navigator
        )
      }),
      (e.prototype.getBBox = function () {
        return this.navigator.getBBox()
      }),
      (e.prototype.render = function (n, r) {
        var i = this.attributes.data
        if (!(!i || i.length === 0)) {
          var a = this.renderNavigator(ft(r))
          this.renderItems(a.getContainer()), this.adjustLayout()
        }
      }),
      (e.prototype.dispatchCustomEvent = function (n, r) {
        var i = new Bt(n, { detail: r })
        this.dispatchEvent(i)
      }),
      e
    )
  })(Te),
  vo = In(
    { markerGroup: 'marker-group', marker: 'marker', labelGroup: 'label-group', label: 'label' },
    'handle'
  ),
  DO = {
    showLabel: !0,
    formatter: function (t) {
      return t.toString()
    },
    markerSize: 25,
    markerStroke: '#c5c5c5',
    markerFill: '#fff',
    markerLineWidth: 1,
    labelFontSize: 12,
    labelFill: '#c5c5c5',
    labelText: '',
    orientation: 'vertical',
    spacing: 0
  },
  MI = (function (t) {
    rt(e, t)
    function e(n) {
      return t.call(this, n, DO) || this
    }
    return (
      (e.prototype.render = function (n, r) {
        var i = ft(r).maybeAppendByClassName(vo.markerGroup, 'g')
        this.renderMarker(i)
        var a = ft(r).maybeAppendByClassName(vo.labelGroup, 'g')
        this.renderLabel(a)
      }),
      (e.prototype.renderMarker = function (n) {
        var r = this,
          i = this.attributes,
          a = i.orientation,
          o = i.markerSymbol,
          s = o === void 0 ? er(a, 'horizontalHandle', 'verticalHandle') : o
        tn(!!s, n, function (c) {
          var l = vt(r.attributes, 'marker'),
            u = z({ symbol: s }, l)
          r.marker = c
            .maybeAppendByClassName(vo.marker, function () {
              return new $t({ style: u })
            })
            .update(u)
        })
      }),
      (e.prototype.renderLabel = function (n) {
        var r = this,
          i = this.attributes,
          a = i.showLabel,
          o = i.orientation,
          s = i.spacing,
          c = s === void 0 ? 0 : s,
          l = i.formatter
        tn(a, n, function (u) {
          var f,
            h = vt(r.attributes, 'label'),
            d = h.text,
            p = Dt(h, ['text']),
            v =
              ((f = u.select(vo.marker.class)) === null || f === void 0
                ? void 0
                : f.node().getBBox()) || {},
            g = v.width,
            y = g === void 0 ? 0 : g,
            m = v.height,
            b = m === void 0 ? 0 : m,
            x = N(er(o, [0, b + c, 'center', 'top'], [y + c, 0, 'start', 'middle']), 4),
            w = x[0],
            O = x[1],
            S = x[2],
            _ = x[3]
          u.maybeAppendByClassName(vo.label, 'text').styles(
            z(z({}, p), { x: w, y: O, text: l(d).toString(), textAlign: S, textBaseline: _ })
          )
        })
      }),
      e
    )
  })(Te),
  $O = {
    showTitle: !0,
    padding: 0,
    orientation: 'horizontal',
    backgroundFill: 'transparent',
    titleText: '',
    titleSpacing: 4,
    titlePosition: 'top-left',
    titleFill: '#2C3542',
    titleFontWeight: 'bold',
    titleFontFamily: 'sans-serif',
    titleFontSize: 12
  },
  EI = Tr({}, $O, {}),
  TI = Tr({}, $O, Kn(DO, 'handle'), {
    color: [
      '#d0e3fa',
      '#acc7f6',
      '#8daaf2',
      '#6d8eea',
      '#4d73cd',
      '#325bb1',
      '#5a3e75',
      '#8c3c79',
      '#e23455',
      '#e7655b'
    ],
    indicatorBackgroundFill: '#262626',
    indicatorLabelFill: 'white',
    indicatorLabelFontSize: 12,
    indicatorVisibility: 'hidden',
    labelAlign: 'value',
    labelDirection: 'positive',
    labelSpacing: 5,
    showHandle: !0,
    showIndicator: !0,
    showLabel: !0,
    slidable: !0,
    titleText: '',
    type: 'continuous'
  }),
  PI = 0.01,
  _e = In(
    {
      title: 'title',
      titleGroup: 'title-group',
      items: 'items',
      itemsGroup: 'items-group',
      contentGroup: 'content-group',
      ribbonGroup: 'ribbon-group',
      ribbon: 'ribbon',
      handlesGroup: 'handles-group',
      handle: 'handle',
      startHandle: 'start-handle',
      endHandle: 'end-handle',
      labelGroup: 'label-group',
      label: 'label',
      indicator: 'indicator'
    },
    'legend'
  ),
  AI = (function (t) {
    rt(e, t)
    function e(n) {
      return t.call(this, n, EI) || this
    }
    return (
      (e.prototype.renderTitle = function (n, r, i) {
        var a = this.attributes,
          o = a.showTitle,
          s = a.titleText,
          c = vt(this.attributes, 'title'),
          l = N(Pr(c), 2),
          u = l[0],
          f = l[1]
        this.titleGroup = n.maybeAppendByClassName(_e.titleGroup, 'g').styles(f)
        var h = z(z({ width: r, height: i }, u), { text: o ? s : '' })
        this.title = this.titleGroup
          .maybeAppendByClassName(_e.title, function () {
            return new RO({ style: h })
          })
          .update(h)
      }),
      (e.prototype.renderItems = function (n, r) {
        var i = r.x,
          a = r.y,
          o = r.width,
          s = r.height,
          c = vt(this.attributes, 'title', !0),
          l = N(Pr(c), 2),
          u = l[0],
          f = l[1],
          h = z(z({}, u), { width: o, height: s, x: 0, y: 0 })
        this.itemsGroup = n.maybeAppendByClassName(_e.itemsGroup, 'g').styles(z({ x: i, y: a }, f))
        var d = this
        this.itemsGroup
          .selectAll(_e.items.class)
          .data(['items'])
          .join(
            function (p) {
              return p
                .append(function () {
                  return new _I({ style: h })
                })
                .attr('className', _e.items.name)
                .each(function () {
                  d.items = ft(this)
                })
            },
            function (p) {
              return p.update(h)
            },
            function (p) {
              return p.remove()
            }
          )
      }),
      (e.prototype.adjustLayout = function () {
        var n = this.attributes.showTitle
        if (n) {
          var r = this.title.node().getAvailableSpace(),
            i = r.x,
            a = r.y
          this.itemsGroup.node().setLocalPosition(i, a)
        }
      }),
      Object.defineProperty(e.prototype, 'availableSpace', {
        get: function () {
          var n = this.attributes,
            r = n.showTitle,
            i = n.width,
            a = n.height
          return r ? this.title.node().getAvailableSpace() : new te(0, 0, i, a)
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.getBBox = function () {
        var n,
          r,
          i = (n = this.title) === null || n === void 0 ? void 0 : n.node(),
          a = (r = this.items) === null || r === void 0 ? void 0 : r.node()
        return !i || !a ? t.prototype.getBBox.call(this) : uI(i, a)
      }),
      (e.prototype.render = function (n, r) {
        var i = n.width,
          a = n.height,
          o = ft(r)
        this.renderTitle(o, i, a), this.renderItems(o, this.availableSpace), this.adjustLayout()
      }),
      e
    )
  })(Te),
  kI = {
    backgroundFill: '#262626',
    backgroundLineCap: 'round',
    backgroundLineWidth: 1,
    backgroundStroke: '#333',
    backgroundZIndex: -1,
    formatter: function (t) {
      return t.toString()
    },
    labelFill: '#fff',
    labelFontSize: 12,
    labelTextBaseline: 'middle',
    padding: [2, 4],
    position: 'right',
    radius: 0,
    zIndex: 999
  },
  yf = In({ background: 'background', labelGroup: 'label-group', label: 'label' }, 'indicator'),
  CI = (function (t) {
    rt(e, t)
    function e(n) {
      var r = t.call(this, n, kI) || this
      return (
        (r.point = [0, 0]), (r.group = r.appendChild(new je({}))), (r.isMutationObserved = !0), r
      )
    }
    return (
      (e.prototype.renderBackground = function () {
        if (this.label) {
          var n = this.attributes,
            r = n.position,
            i = n.padding,
            a = N(ke(i), 4),
            o = a[0],
            s = a[1],
            c = a[2],
            l = a[3],
            u = this.label.node().getLocalBounds(),
            f = u.min,
            h = u.max,
            d = new te(f[0] - l, f[1] - o, h[0] + s - f[0] + l, h[1] + c - f[1] + o),
            p = this.getPath(r, d),
            v = vt(this.attributes, 'background')
          ;(this.background = ft(this.group)
            .maybeAppendByClassName(yf.background, 'path')
            .styles(z(z({}, v), { path: p }))),
            this.group.appendChild(this.label.node())
        }
      }),
      (e.prototype.renderLabel = function () {
        var n = this.attributes,
          r = n.formatter,
          i = n.labelText,
          a = vt(this.attributes, 'label'),
          o = N(Pr(a), 2),
          s = o[0],
          c = o[1]
        s.text
        var l = Dt(s, ['text'])
        if (
          ((this.label = ft(this.group).maybeAppendByClassName(yf.labelGroup, 'g').styles(c)), !!i)
        ) {
          var u = this.label
            .maybeAppendByClassName(yf.label, function () {
              return Bi(r(i))
            })
            .style('text', r(i).toString())
          u.selectAll('text').styles(l)
        }
      }),
      (e.prototype.adjustLayout = function () {
        var n = N(this.point, 2),
          r = n[0],
          i = n[1]
        this.group.attr('x', -r).attr('y', -i)
      }),
      (e.prototype.getPath = function (n, r) {
        var i = this.attributes.radius,
          a = r.x,
          o = r.y,
          s = r.width,
          c = r.height,
          l = [
            ['M', a + i, o],
            ['L', a + s - i, o],
            ['A', i, i, 0, 0, 1, a + s, o + i],
            ['L', a + s, o + c - i],
            ['A', i, i, 0, 0, 1, a + s - i, o + c],
            ['L', a + i, o + c],
            ['A', i, i, 0, 0, 1, a, o + c - i],
            ['L', a, o + i],
            ['A', i, i, 0, 0, 1, a + i, o],
            ['Z']
          ],
          u = { top: 4, right: 6, bottom: 0, left: 2 },
          f = u[n],
          h = this.createCorner([l[f].slice(-2), l[f + 1].slice(-2)])
        return l.splice.apply(l, q([f + 1, 1], N(h), !1)), (l[0][0] = 'M'), l
      }),
      (e.prototype.createCorner = function (n, r) {
        r === void 0 && (r = 10)
        var i = 0.8,
          a = P6.apply(void 0, q([], N(n), !1)),
          o = N(n, 2),
          s = N(o[0], 2),
          c = s[0],
          l = s[1],
          u = N(o[1], 2),
          f = u[0],
          h = u[1],
          d = N(a ? [f - c, [c, f]] : [h - l, [l, h]], 2),
          p = d[0],
          v = N(d[1], 2),
          g = v[0],
          y = v[1],
          m = p / 2,
          b = p / Math.abs(p),
          x = r * b,
          w = x / 2,
          O = ((x * Math.sqrt(3)) / 2) * i,
          S = N([g, g + m - w, g + m, g + m + w, y], 5),
          _ = S[0],
          M = S[1],
          E = S[2],
          T = S[3],
          C = S[4]
        return a
          ? ((this.point = [E, l - O]),
            [
              ['L', _, l],
              ['L', M, l],
              ['L', E, l - O],
              ['L', T, l],
              ['L', C, l]
            ])
          : ((this.point = [c + O, E]),
            [
              ['L', c, _],
              ['L', c, M],
              ['L', c + O, E],
              ['L', c, T],
              ['L', c, C]
            ])
      }),
      (e.prototype.applyVisibility = function () {
        var n = this.attributes.visibility
        n === 'hidden' ? si(this) : js(this)
      }),
      (e.prototype.bindEvents = function () {
        this.label.on(dt.BOUNDS_CHANGED, this.renderBackground)
      }),
      (e.prototype.render = function () {
        this.renderLabel(), this.renderBackground(), this.adjustLayout(), this.applyVisibility()
      }),
      e
    )
  })(Te)
function LI(t, e) {
  for (var n = 1; n < t.length; n += 1) {
    var r = t[n - 1],
      i = t[n]
    if (e >= r && e <= i) return [r, i]
  }
  return [e, e]
}
function NI(t, e, n) {
  var r = Array.from(e),
    i = t.length
  return new Array(i).fill(0).reduce(function (a, o, s) {
    var c = r[s % r.length]
    return (a += ' '
      .concat(t[s], ':')
      .concat(c)
      .concat(s < i - 1 ? ' '.concat(t[s + 1], ':').concat(c) : ''))
  }, 'l('.concat(n === 'horizontal' ? '0' : '270', ')'))
}
function Jg(t, e) {
  var n = N(LI(t, e), 2),
    r = n[0],
    i = n[1]
  return { tick: e > (r + i) / 2 ? i : r, range: [r, i] }
}
var ss = In(
  {
    trackGroup: 'background-group',
    track: 'background',
    selectionGroup: 'ribbon-group',
    selection: 'ribbon',
    clipPath: 'clip-path'
  },
  'ribbon'
)
function BO(t) {
  var e = t.orientation,
    n = t.size,
    r = t.length
  return er(e, [r, n], [n, r])
}
function FO(t) {
  var e = t.type,
    n = N(BO(t), 2),
    r = n[0],
    i = n[1]
  return e === 'size'
    ? [['M', 0, i], ['L', 0 + r, 0], ['L', 0 + r, i], ['Z']]
    : [['M', 0, i], ['L', 0, 0], ['L', 0 + r, 0], ['L', 0 + r, i], ['Z']]
}
function RI(t) {
  return FO(t)
}
function II(t) {
  var e = t.orientation,
    n = t.color,
    r = t.block,
    i = t.partition,
    a
  if (mn(n)) {
    var o = 20
    a = new Array(o).fill(0).map(function (l, u, f) {
      return n(u / (f.length - 1))
    })
  } else a = n
  var s = a.length,
    c = a.map(function (l) {
      return Or(l).toString()
    })
  return s
    ? s === 1
      ? c[0]
      : r
      ? NI(i, c, e)
      : c.reduce(function (l, u, f) {
          return (l += ' '.concat(f / (s - 1), ':').concat(u))
        }, 'l('.concat(er(e, '0', '270'), ')'))
    : ''
}
function jI(t) {
  var e = t.orientation,
    n = t.range
  if (!n) return []
  var r = N(BO(t), 2),
    i = r[0],
    a = r[1],
    o = N(n, 2),
    s = o[0],
    c = o[1],
    l = er(e, s * i, 0),
    u = er(e, 0, s * a),
    f = er(e, c * i, i),
    h = er(e, a, c * a)
  return [['M', l, u], ['L', l, h], ['L', f, h], ['L', f, u], ['Z']]
}
function DI(t, e) {
  var n = vt(e, 'track')
  t.maybeAppendByClassName(ss.track, 'path').styles(z({ path: FO(e) }, n))
}
function $I(t, e) {
  var n = vt(e, 'selection'),
    r = II(e),
    i = t.maybeAppendByClassName(ss.selection, 'path').styles(z({ path: RI(e), fill: r }, n)),
    a = i
      .maybeAppendByClassName(ss.clipPath, 'path')
      .styles({ path: jI(e) })
      .node()
  i.style('clip-path', a)
}
var BI = (function (t) {
  rt(e, t)
  function e(n) {
    return (
      t.call(this, n, {
        type: 'color',
        orientation: 'horizontal',
        size: 30,
        range: [0, 1],
        length: 200,
        block: !1,
        partition: [],
        color: ['#fff', '#000'],
        trackFill: '#e5e5e5'
      }) || this
    )
  }
  return (
    (e.prototype.render = function (n, r) {
      var i = ft(r).maybeAppendByClassName(ss.trackGroup, 'g')
      DI(i, n)
      var a = ft(r).maybeAppendByClassName(ss.selectionGroup, 'g')
      $I(a, n)
    }),
    e
  )
})(Te)
function FI(t) {
  return {
    min: Math.min.apply(
      Math,
      q(
        [],
        N(
          t.map(function (e) {
            return e.value
          })
        ),
        !1
      )
    ),
    max: Math.max.apply(
      Math,
      q(
        [],
        N(
          t.map(function (e) {
            return e.value
          })
        ),
        !1
      )
    )
  }
}
var zI = (function (t) {
  rt(e, t)
  function e(n) {
    var r = t.call(this, n, TI) || this
    return (
      (r.eventToOffsetScale = new Ft({})),
      (r.innerRibbonScale = new Ft({})),
      (r.cacheLabelBBox = null),
      (r.cacheHandleBBox = null),
      (r.onHovering = function (i) {
        var a = r.attributes,
          o = a.data,
          s = a.block
        i.stopPropagation()
        var c = r.getValueByCanvasPoint(i)
        if (s) {
          var l = Jg(
            o.map(function (f) {
              var h = f.value
              return h
            }),
            c
          ).range
          r.showIndicator((l[0] + l[1]) / 2, ''.concat(l[0], '-').concat(l[1])),
            r.dispatchIndicated(c, l)
        } else {
          var u = r.getTickValue(c)
          r.showIndicator(u), r.dispatchIndicated(u)
        }
      }),
      (r.onDragStart = function (i) {
        return function (a) {
          a.stopPropagation(),
            r.attributes.slidable &&
              ((r.target = i),
              (r.prevValue = r.getTickValue(r.getValueByCanvasPoint(a))),
              document.addEventListener('mousemove', r.onDragging),
              document.addEventListener('touchmove', r.onDragging),
              document.addEventListener('mouseleave', r.onDragEnd),
              document.addEventListener('mouseup', r.onDragEnd),
              document.addEventListener('mouseup', r.onDragEnd),
              document.addEventListener('touchend', r.onDragEnd))
        }
      }),
      (r.onDragging = function (i) {
        var a = r.target
        r.updateMouse()
        var o = N(r.selection, 2),
          s = o[0],
          c = o[1],
          l = r.getTickValue(r.getValueByCanvasPoint(i)),
          u = l - r.prevValue
        a === 'start'
          ? s !== l && r.updateSelection(l, c)
          : a === 'end'
          ? c !== l && r.updateSelection(s, l)
          : a === 'ribbon' && u !== 0 && ((r.prevValue = l), r.updateSelection(u, u, !0))
      }),
      (r.onDragEnd = function () {
        ;(r.style.cursor = 'default'),
          document.removeEventListener('mousemove', r.onDragging),
          document.removeEventListener('touchmove', r.onDragging),
          document.removeEventListener('mouseup', r.onDragEnd),
          document.removeEventListener('touchend', r.onDragEnd)
      }),
      r
    )
  }
  return (
    Object.defineProperty(e.prototype, 'handleOffsetRatio', {
      get: function () {
        return this.ifHorizontal(0.5, 0.5)
      },
      enumerable: !1,
      configurable: !0
    }),
    (e.prototype.getBBox = function () {
      var n = this.attributes,
        r = n.width,
        i = n.height
      return new te(0, 0, r, i)
    }),
    (e.prototype.render = function (n, r) {
      var i = this,
        a = n.showLabel
      this.renderTitle(ft(r))
      var o = this.availableSpace,
        s = o.x,
        c = o.y,
        l = ft(r).maybeAppendByClassName(_e.contentGroup, 'g').styles({ x: s, y: c }),
        u = l.maybeAppendByClassName(_e.labelGroup, 'g').styles({ zIndex: 1 })
      tn(!!a, u, function (h) {
        i.renderLabel(h)
      })
      var f = l.maybeAppendByClassName(_e.ribbonGroup, 'g').styles({ zIndex: 0 })
      ;(this.handlesGroup = l.maybeAppendByClassName(_e.handlesGroup, 'g').styles({ zIndex: 2 })),
        this.renderHandles(),
        this.renderRibbon(f),
        this.renderIndicator(l),
        this.adjustLabel(),
        this.adjustHandles()
    }),
    Object.defineProperty(e.prototype, 'range', {
      get: function () {
        var n = this.attributes,
          r = n.data,
          i = n.domain
        return i ? { min: i[0], max: i[1] } : FI(r)
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'ribbonScale', {
      get: function () {
        var n = this.range,
          r = n.min,
          i = n.max
        return (
          this.innerRibbonScale.update({ domain: [r, i], range: [0, 1] }), this.innerRibbonScale
        )
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'ribbonRange', {
      get: function () {
        var n = N(this.selection, 2),
          r = n[0],
          i = n[1],
          a = this.ribbonScale
        return [a.map(r), a.map(i)]
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'selection', {
      get: function () {
        var n = this.range,
          r = n.min,
          i = n.max,
          a = this.attributes.defaultValue,
          o = a === void 0 ? [r, i] : a,
          s = N(o, 2),
          c = s[0],
          l = s[1]
        return [c, l]
      },
      enumerable: !1,
      configurable: !0
    }),
    (e.prototype.ifHorizontal = function (n, r) {
      return er(
        this.attributes.orientation,
        typeof n == 'function' ? n() : n,
        typeof r == 'function' ? r() : r
      )
    }),
    (e.prototype.renderTitle = function (n) {
      var r = this.attributes,
        i = r.showTitle,
        a = r.titleText,
        o = r.width,
        s = r.height,
        c = vt(this.attributes, 'title'),
        l = z(z({}, c), { width: o, height: s, text: a }),
        u = this
      n.selectAll(_e.title.class)
        .data(i ? [a] : [])
        .join(
          function (f) {
            return f
              .append(function () {
                return new RO({ style: l })
              })
              .attr('className', _e.title.name)
              .each(function () {
                u.title = this
              })
          },
          function (f) {
            return f.update(l)
          },
          function (f) {
            return f
              .each(function () {
                u.title = void 0
              })
              .remove()
          }
        )
    }),
    Object.defineProperty(e.prototype, 'availableSpace', {
      get: function () {
        if (this.title) return this.title.getAvailableSpace()
        var n = this.attributes,
          r = n.width,
          i = n.height
        return new te(0, 0, r, i)
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'labelFixedSpacing', {
      get: function () {
        var n = this.attributes.showTick
        return n ? 5 : 0
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'labelPosition', {
      get: function () {
        var n = this.attributes,
          r = n.orientation,
          i = n.labelDirection,
          a = {
            vertical: { positive: 'right', negative: 'left' },
            horizontal: { positive: 'bottom', negative: 'top' }
          }
        return a[r][i]
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'labelBBox', {
      get: function () {
        var n,
          r = this.attributes.showLabel
        if (!r) return new te(0, 0, 0, 0)
        if (this.cacheLabelBBox) return this.cacheLabelBBox
        var i = (
            (n = this.label.querySelector(Rt.labelGroup.class)) === null || n === void 0
              ? void 0
              : n.children.slice(-1)[0]
          ).getBBox(),
          a = i.width,
          o = i.height
        return (this.cacheLabelBBox = new te(0, 0, a, o)), this.cacheLabelBBox
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'labelShape', {
      get: function () {
        var n = this.attributes,
          r = n.showLabel,
          i = n.labelSpacing,
          a = i === void 0 ? 0 : i
        if (!r) return { width: 0, height: 0, size: 0, length: 0 }
        var o = this.labelBBox,
          s = o.width,
          c = o.height,
          l = this.ifHorizontal(c, s) + a + this.labelFixedSpacing,
          u = this.ifHorizontal(s, c)
        return { width: s, height: c, size: l, length: u }
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'ribbonBBox', {
      get: function () {
        var n = this.attributes,
          r = n.showHandle,
          i = n.ribbonSize,
          a = this.availableSpace,
          o = a.width,
          s = a.height,
          c = this.labelShape,
          l = c.size,
          u = c.length,
          f = N(this.ifHorizontal([s, o], [o, s]), 2),
          h = f[0],
          d = f[1],
          p = r ? this.handleShape : { size: 0, length: 0 },
          v = p.size,
          g = p.length,
          y = this.handleOffsetRatio,
          m = 0,
          b = this.labelPosition
        i
          ? (m = i)
          : ['bottom', 'right'].includes(b)
          ? (m = Math.min(h - l, (h - v) / y))
          : h * (1 - y) > v
          ? (m = Math.max(h - l, 0))
          : (m = Math.max((h - l - v) / y, 0))
        var x = Math.max(g, u),
          w = d - x,
          O = N(this.ifHorizontal([w, m], [m, w]), 2),
          S = O[0],
          _ = O[1],
          M = ['top', 'left'].includes(b) ? l : 0,
          E = N(this.ifHorizontal([x / 2, M], [M, x / 2]), 2),
          T = E[0],
          C = E[1]
        return new te(T, C, S, _)
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'ribbonShape', {
      get: function () {
        var n = this.ribbonBBox,
          r = n.width,
          i = n.height
        return this.ifHorizontal({ size: i, length: r }, { size: r, length: i })
      },
      enumerable: !1,
      configurable: !0
    }),
    (e.prototype.renderRibbon = function (n) {
      var r = this.attributes,
        i = r.data,
        a = r.type,
        o = r.orientation,
        s = r.color,
        c = r.block,
        l = vt(this.attributes, 'ribbon'),
        u = this.range,
        f = u.min,
        h = u.max,
        d = this.ribbonBBox,
        p = d.x,
        v = d.y,
        g = this.ribbonShape,
        y = g.length,
        m = g.size,
        b = Tr(
          {
            x: p,
            y: v,
            length: y,
            size: m,
            type: a,
            orientation: o,
            color: s,
            block: c,
            partition: i.map(function (x) {
              return (x.value - f) / (h - f)
            }),
            range: this.ribbonRange
          },
          l
        )
      this.ribbon = n
        .maybeAppendByClassName(_e.ribbon, function () {
          return new BI({ style: b })
        })
        .update(b)
    }),
    (e.prototype.getHandleClassName = function (n) {
      return ''.concat(_e.prefix(''.concat(n, '-handle')))
    }),
    (e.prototype.renderHandles = function () {
      var n = this.attributes,
        r = n.showHandle,
        i = n.orientation,
        a = vt(this.attributes, 'handle'),
        o = N(this.selection, 2),
        s = o[0],
        c = o[1],
        l = z(z({}, a), { orientation: i }),
        u = a.shape,
        f = u === void 0 ? 'slider' : u,
        h = f === 'basic' ? MI : OO,
        d = this
      this.handlesGroup
        .selectAll(_e.handle.class)
        .data(
          r
            ? [
                { value: s, type: 'start' },
                { value: c, type: 'end' }
              ]
            : [],
          function (p) {
            return p.type
          }
        )
        .join(
          function (p) {
            return p
              .append(function () {
                return new h({ style: l })
              })
              .attr('className', function (v) {
                var g = v.type
                return ''.concat(_e.handle, ' ').concat(d.getHandleClassName(g))
              })
              .each(function (v) {
                var g = v.type,
                  y = v.value
                this.update({ labelText: y })
                var m = ''.concat(g, 'Handle')
                ;(d[m] = this), this.addEventListener('pointerdown', d.onDragStart(g))
              })
          },
          function (p) {
            return p.update(l).each(function (v) {
              var g = v.value
              this.update({ labelText: g })
            })
          },
          function (p) {
            return p
              .each(function (v) {
                var g = v.type,
                  y = ''.concat(g, 'Handle')
                d[y] = void 0
              })
              .remove()
          }
        )
    }),
    (e.prototype.adjustHandles = function () {
      var n = N(this.selection, 2),
        r = n[0],
        i = n[1]
      this.setHandlePosition('start', r), this.setHandlePosition('end', i)
    }),
    (e.prototype.adjustTitle = function () {
      var n = this.attributes,
        r = n.titlePosition,
        i = n.orientation,
        a = N(this.getElementsByClassName(_e.title.name), 1),
        o = a[0],
        s = this.handlesGroup.select('.'.concat(this.getHandleClassName('start'))).node()
      if (!(!o || !s) && !(r !== 'top-left' || i !== 'horizontal')) {
        var c = N(s.getLocalBounds().min, 1),
          l = c[0],
          u = N(o.getLocalBounds().min, 1),
          f = u[0],
          h = l - f
        o.style.x = +(this.style.x || 0) + h
      }
    }),
    Object.defineProperty(e.prototype, 'handleBBox', {
      get: function () {
        if (this.cacheHandleBBox) return this.cacheHandleBBox
        if (!this.attributes.showHandle) return new te(0, 0, 0, 0)
        var n = this.startHandle.getBBox(),
          r = n.width,
          i = n.height,
          a = this.endHandle.getBBox(),
          o = a.width,
          s = a.height,
          c = N([Math.max(r, o), Math.max(i, s)], 2),
          l = c[0],
          u = c[1]
        return (this.cacheHandleBBox = new te(0, 0, l, u)), this.cacheHandleBBox
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'handleShape', {
      get: function () {
        var n = this.handleBBox,
          r = n.width,
          i = n.height,
          a = N(this.ifHorizontal([i, r], [r, i]), 2),
          o = a[0],
          s = a[1]
        return { width: r, height: i, size: o, length: s }
      },
      enumerable: !1,
      configurable: !0
    }),
    (e.prototype.setHandlePosition = function (n, r) {
      var i = this.attributes.handleFormatter,
        a = this.ribbonBBox,
        o = a.x,
        s = a.y,
        c = this.ribbonShape.size,
        l = this.getOffset(r),
        u = N(
          this.ifHorizontal(
            [o + l, s + c * this.handleOffsetRatio],
            [o + c * this.handleOffsetRatio, s + l]
          ),
          2
        ),
        f = u[0],
        h = u[1],
        d = this.handlesGroup.select('.'.concat(this.getHandleClassName(n))).node()
      d == null || d.update({ x: f, y: h, formatter: i })
    }),
    (e.prototype.renderIndicator = function (n) {
      var r = vt(this.attributes, 'indicator')
      this.indicator = n
        .maybeAppendByClassName(_e.indicator, function () {
          return new CI({})
        })
        .update(r)
    }),
    Object.defineProperty(e.prototype, 'labelData', {
      get: function () {
        var n = this,
          r = this.attributes.data
        return r.reduce(function (i, a, o, s) {
          var c,
            l,
            u = (c = a == null ? void 0 : a.id) !== null && c !== void 0 ? c : o.toString()
          if (
            (i.push(
              z(z({}, a), {
                id: u,
                index: o,
                type: 'value',
                label:
                  (l = a == null ? void 0 : a.label) !== null && l !== void 0
                    ? l
                    : a.value.toString(),
                value: n.ribbonScale.map(a.value)
              })
            ),
            o < s.length - 1)
          ) {
            var f = s[o + 1],
              h = N([a.value, f.value], 2),
              d = h[0],
              p = h[1],
              v = (d + p) / 2
            i.push(
              z(z({}, a), {
                id: u,
                index: o,
                type: 'range',
                range: [d, p],
                label: [d, p].join('~'),
                value: n.ribbonScale.map(v)
              })
            )
          }
          return i
        }, [])
      },
      enumerable: !1,
      configurable: !0
    }),
    Object.defineProperty(e.prototype, 'labelStyle', {
      get: function () {
        var n = N(['center', 'middle'], 2),
          r = n[0],
          i = n[1],
          a = this.labelPosition
        return (
          a === 'top'
            ? (i = 'bottom')
            : a === 'bottom'
            ? (i = 'top')
            : a === 'left'
            ? (r = 'end')
            : a === 'right' && (r = 'start'),
          { labelTextAlign: r, labelTextBaseline: i }
        )
      },
      enumerable: !1,
      configurable: !0
    }),
    (e.prototype.renderLabel = function (n) {
      var r = this.attributes,
        i = r.showTick,
        a = i === void 0 ? !1 : i,
        o = r.labelFilter,
        s = r.labelFormatter,
        c = vt(this.attributes, 'tick'),
        l = vt(this.attributes, 'label'),
        u = l.align,
        f = Tr(
          z(
            {
              showLine: !1,
              showGrid: !1,
              showTick: a,
              type: 'linear',
              startPos: [0, 0],
              endPos: [0, 0],
              tickDirection: 'negative',
              labelTransform: 'rotate(0)'
            },
            this.labelStyle
          ),
          Kn(c, 'tick'),
          Kn(l, 'label'),
          { data: this.labelData }
        ),
        h = {
          tickFilter: function (p, v, g) {
            return (p == null ? void 0 : p.type) !== 'value'
              ? !1
              : o
              ? o(
                  p,
                  p.index,
                  g.filter(function (y) {
                    return y.type !== 'value'
                  })
                )
              : !0
          },
          labelFilter: function (p, v, g) {
            return (p == null ? void 0 : p.type) !== u
              ? !1
              : o
              ? o(
                  p,
                  p.index,
                  g.filter(function (y) {
                    return y.type === u
                  })
                )
              : !0
          },
          labelFormatter: s
        },
        d = z(z(z({}, f), h), { labelOverlap: [{ type: 'hide' }] })
      ;(this.label = n
        .maybeAppendByClassName(_e.label, function () {
          return new Up({ style: d })
        })
        .node()),
        this.label.update(d, !1)
    }),
    Object.defineProperty(e.prototype, 'labelAxisStyle', {
      get: function () {
        var n = this.attributes,
          r = n.showTick,
          i = n.labelDirection,
          a = n.labelSpacing,
          o = n.tickLength,
          s = this.ribbonShape.size,
          c = this.labelPosition,
          l = this.labelFixedSpacing,
          u = N([0, 0, 0], 3),
          f = u[0]
        u[1]
        var h = u[2],
          d = o ?? s
        return (
          r
            ? ((h = d),
              i === 'positive'
                ? c === 'right'
                  ? ((f = d), (h = d))
                  : c === 'bottom' && (f = h)
                : i === 'negative' && (c === 'top' || c === 'left') && (f = s))
            : i === 'positive' && (c === 'right' || (c === 'bottom' && (f = s + l))),
          { offset: f, spacing: a, tickLength: h }
        )
      },
      enumerable: !1,
      configurable: !0
    }),
    (e.prototype.adjustLabel = function () {
      var n = this.attributes.showLabel
      if (n) {
        var r = this.ribbonBBox,
          i = r.x,
          a = r.y,
          o = r.width,
          s = r.height,
          c = this.labelAxisStyle,
          l = c.offset,
          u = c.spacing,
          f = c.tickLength,
          h = N(
            this.ifHorizontal(
              [
                [i, a + l],
                [i + o, a + l]
              ],
              [
                [i + l, a + s],
                [i + l, a]
              ]
            ),
            2
          ),
          d = h[0],
          p = h[1]
        this.label.update({ startPos: d, endPos: p, tickLength: f, labelSpacing: u }, !1)
      }
    }),
    (e.prototype.bindEvents = function () {
      this.ribbon.on('pointerdown', this.onDragStart('ribbon')),
        this.ribbon.on('pointermove', this.onHovering),
        this.addEventListener('pointerout', this.hideIndicator)
    }),
    (e.prototype.showIndicator = function (n, r) {
      r === void 0 && (r = ''.concat(n))
      var i = this.attributes.showIndicator
      if (!i || typeof n != 'number') {
        this.hideIndicator()
        return
      }
      var a = this.range,
        o = a.min,
        s = a.max,
        c = this.ribbonBBox,
        l = c.x,
        u = c.y,
        f = se(n, o, s),
        h = this.getOffset(f),
        d = this.ifHorizontal([h + l, u], [l, h + u])
      this.indicator.update({
        x: d[0],
        y: d[1],
        position: this.ifHorizontal('top', 'left'),
        labelText: r
      }),
        js(this.indicator.node())
    }),
    (e.prototype.hideIndicator = function () {
      si(this.indicator.node())
    }),
    (e.prototype.updateMouse = function () {
      this.attributes.slidable && (this.style.cursor = 'grabbing')
    }),
    (e.prototype.setSelection = function (n, r) {
      this.updateSelection(n, r)
    }),
    (e.prototype.updateSelection = function (n, r, i) {
      var a
      i === void 0 && (i = !1)
      var o = N(this.selection, 2),
        s = o[0],
        c = o[1],
        l = N([n, r], 2),
        u = l[0],
        f = l[1]
      i && ((u += s), (f += c))
      var h = this.range,
        d = h.min,
        p = h.max
      ;(a = N(wI([d, p], [u, f], this.selection), 2)),
        (u = a[0]),
        (f = a[1]),
        this.update({ defaultValue: [u, f] }),
        this.dispatchSelection()
    }),
    Object.defineProperty(e.prototype, 'step', {
      get: function () {
        var n = this.attributes.step,
          r = n === void 0 ? 1 : n,
          i = this.range,
          a = i.min,
          o = i.max
        return Qt(r) ? $h((o - a) * PI, 0) : r
      },
      enumerable: !1,
      configurable: !0
    }),
    (e.prototype.getTickValue = function (n) {
      var r = this.attributes,
        i = r.data,
        a = r.block,
        o = this.range.min
      return a
        ? Jg(
            i.map(function (s) {
              var c = s.value
              return c
            }),
            n
          ).tick
        : yI(n, this.step, o)
    }),
    (e.prototype.getValueByCanvasPoint = function (n, r) {
      var i = this.range,
        a = i.min,
        o = i.max,
        s = N(this.ribbon.node().getPosition(), 2),
        c = s[0],
        l = s[1],
        u = this.ifHorizontal(c, l),
        f = this.ifHorizontal.apply(this, q([], N(vl(n)), !1)),
        h = f - u,
        d = se(this.getOffset(h, !0), a, o)
      return d
    }),
    (e.prototype.getOffset = function (n, r) {
      r === void 0 && (r = !1)
      var i = this.range,
        a = i.min,
        o = i.max,
        s = this.ribbonShape.length,
        c = this.eventToOffsetScale
      return c.update({ domain: [a, o], range: [0, s] }), r ? c.invert(n) : c.map(n)
    }),
    (e.prototype.dispatchSelection = function () {
      var n = new Bt('valuechange', { detail: { value: this.selection } })
      this.dispatchEvent(n)
    }),
    (e.prototype.dispatchIndicated = function (n, r) {
      var i = new Bt('indicate', { detail: { value: n, range: r } })
      this.dispatchEvent(i)
    }),
    e
  )
})(Te)
function Wh(t) {
  return (
    t === void 0 && (t = ''),
    {
      CONTAINER: ''.concat(t, 'tooltip'),
      TITLE: ''.concat(t, 'tooltip-title'),
      LIST: ''.concat(t, 'tooltip-list'),
      LIST_ITEM: ''.concat(t, 'tooltip-list-item'),
      NAME: ''.concat(t, 'tooltip-list-item-name'),
      MARKER: ''.concat(t, 'tooltip-list-item-marker'),
      NAME_LABEL: ''.concat(t, 'tooltip-list-item-name-label'),
      VALUE: ''.concat(t, 'tooltip-list-item-value'),
      CROSSHAIR_X: ''.concat(t, 'tooltip-crosshair-x'),
      CROSSHAIR_Y: ''.concat(t, 'tooltip-crosshair-y')
    }
  )
}
var ty = { overflow: 'hidden', 'white-space': 'nowrap', 'text-overflow': 'ellipsis' }
function GI(t) {
  var e
  t === void 0 && (t = '')
  var n = Wh(t)
  return (
    (e = {}),
    (e['.'.concat(n.CONTAINER)] = {
      position: 'absolute',
      visibility: 'visible',
      'z-index': 8,
      transition:
        'visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)',
      'background-color': 'rgba(255, 255, 255, 0.96)',
      'box-shadow': '0 6px 12px 0 rgba(0, 0, 0, 0.12)',
      'border-radius': '4px',
      color: 'rgba(0, 0, 0, 0.65)',
      'font-size': '12px',
      'line-height': '20px',
      padding: '12px',
      'min-width': '120px',
      'max-width': '360px',
      'font-family': 'Roboto-Regular'
    }),
    (e['.'.concat(n.TITLE)] = { color: 'rgba(0, 0, 0, 0.45)' }),
    (e['.'.concat(n.LIST)] = { margin: '0px', 'list-style-type': 'none', padding: '0px' }),
    (e['.'.concat(n.LIST_ITEM)] = {
      'list-style-type': 'none',
      display: 'flex',
      'line-height': '2em',
      'align-items': 'center',
      'justify-content': 'space-between',
      'white-space': 'nowrap'
    }),
    (e['.'.concat(n.MARKER)] = {
      width: '8px',
      height: '8px',
      'border-radius': '50%',
      display: 'inline-block',
      'margin-right': '4px'
    }),
    (e['.'.concat(n.NAME)] = { display: 'flex', 'align-items': 'center', 'max-width': '216px' }),
    (e['.'.concat(n.NAME_LABEL)] = z({ flex: 1 }, ty)),
    (e['.'.concat(n.VALUE)] = z(
      {
        display: 'inline-block',
        float: 'right',
        flex: 1,
        'text-align': 'right',
        'min-width': '28px',
        'margin-left': '30px',
        color: 'rgba(0, 0, 0, 0.85)'
      },
      ty
    )),
    (e['.'.concat(n.CROSSHAIR_X)] = {
      position: 'absolute',
      width: '1px',
      'background-color': 'rgba(0, 0, 0, 0.25)'
    }),
    (e['.'.concat(n.CROSSHAIR_Y)] = {
      position: 'absolute',
      height: '1px',
      'background-color': 'rgba(0, 0, 0, 0.25)'
    }),
    e
  )
}
var WI = (function (t) {
    rt(e, t)
    function e(n) {
      var r = this,
        i,
        a,
        o =
          (a = (i = n.style) === null || i === void 0 ? void 0 : i.template) === null ||
          a === void 0
            ? void 0
            : a.prefixCls,
        s = Wh(o)
      return (
        (r =
          t.call(this, n, {
            data: [],
            x: 0,
            y: 0,
            visibility: 'visible',
            title: '',
            position: 'bottom-right',
            offset: [5, 5],
            enterable: !1,
            container: { x: 0, y: 0 },
            bounding: null,
            template: {
              prefixCls: '',
              container: '<div class="'.concat(s.CONTAINER, '"></div>'),
              title: '<div class="'.concat(s.TITLE, '"></div>'),
              item: '<li class="'
                .concat(
                  s.LIST_ITEM,
                  `" data-index={index}>
        <span class="`
                )
                .concat(
                  s.NAME,
                  `">
          <span class="`
                )
                .concat(
                  s.MARKER,
                  `" style="background:{color}"></span>
          <span class="`
                )
                .concat(
                  s.NAME_LABEL,
                  `" title="{name}">{name}</span>
        </span>
        <span class="`
                )
                .concat(
                  s.VALUE,
                  `" title="{value}">{value}</span>
      </li>`
                )
            },
            style: GI(o)
          }) || this),
        (r.prevCustomContentKey = r.attributes.contentKey),
        r.initShape(),
        r.render(r.attributes, r),
        r
      )
    }
    return (
      Object.defineProperty(e.prototype, 'HTMLTooltipElement', {
        get: function () {
          return this.element
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.getContainer = function () {
        return this.element
      }),
      Object.defineProperty(e.prototype, 'position', {
        set: function (n) {
          var r = N(n, 2),
            i = r[0],
            a = r[1]
          ;(this.attributes.x = i), (this.attributes.y = a), this.updatePosition()
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'elementSize', {
        get: function () {
          var n = this.element.offsetWidth,
            r = this.element.offsetHeight
          return { width: n, height: r }
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'HTMLTooltipItemsElements', {
        get: function () {
          var n = this.attributes,
            r = n.data,
            i = n.template
          return r.map(function (a, o) {
            var s = a.name,
              c = s === void 0 ? '' : s,
              l = a.color,
              u = l === void 0 ? 'black' : l,
              f = a.index,
              h = Dt(a, ['name', 'color', 'index']),
              d = z({ name: c, color: u, index: f ?? o }, h)
            return xv(CP(i.item, d))
          })
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.render = function (n, r) {
        this.renderHTMLTooltipElement(), this.updatePosition()
      }),
      (e.prototype.destroy = function () {
        var n
        ;(n = this.element) === null || n === void 0 || n.remove(), t.prototype.destroy.call(this)
      }),
      (e.prototype.show = function (n, r) {
        var i = this,
          a = n !== void 0 && r !== void 0
        if (a) {
          var o = this.element.style.transition
          ;(this.element.style.transition = 'none'),
            (this.position = [n ?? +this.attributes.x, r ?? +this.attributes.y]),
            setTimeout(function () {
              i.element.style.transition = o
            }, 10)
        }
        this.element.style.visibility = 'visible'
      }),
      (e.prototype.hide = function () {
        this.element.style.visibility = 'hidden'
      }),
      (e.prototype.initShape = function () {
        var n = this.attributes.template
        ;(this.element = xv(n.container)), this.id && this.element.setAttribute('id', this.id)
      }),
      (e.prototype.renderCustomContent = function () {
        if (
          !(
            this.prevCustomContentKey !== void 0 &&
            this.prevCustomContentKey === this.attributes.contentKey
          )
        ) {
          this.prevCustomContentKey = this.attributes.contentKey
          var n = this.attributes.content
          n &&
            (typeof n == 'string' ? (this.element.innerHTML = n) : this.element.replaceChildren(n))
        }
      }),
      (e.prototype.renderHTMLTooltipElement = function () {
        var n,
          r,
          i = this.attributes,
          a = i.template,
          o = i.title,
          s = i.enterable,
          c = i.style,
          l = i.content,
          u = Wh(a.prefixCls),
          f = this.element
        if (((this.element.style.pointerEvents = s ? 'auto' : 'none'), l))
          this.renderCustomContent()
        else {
          o
            ? ((f.innerHTML = a.title), (f.getElementsByClassName(u.TITLE)[0].innerHTML = o))
            : (r =
                (n = f.getElementsByClassName(u.TITLE)) === null || n === void 0
                  ? void 0
                  : n[0]) === null ||
              r === void 0 ||
              r.remove()
          var h = this.HTMLTooltipItemsElements,
            d = document.createElement('ul')
          ;(d.className = u.LIST), d.replaceChildren.apply(d, q([], N(h), !1))
          var p = this.element.querySelector('.'.concat(u.LIST))
          p ? p.replaceWith(d) : f.appendChild(d)
        }
        L6(f, c)
      }),
      (e.prototype.getRelativeOffsetFromCursor = function (n) {
        var r = this.attributes,
          i = r.position,
          a = r.offset,
          o = n || i,
          s = o.split('-'),
          c = { left: [-1, 0], right: [1, 0], top: [0, -1], bottom: [0, 1] },
          l = this.elementSize,
          u = l.width,
          f = l.height,
          h = [-u / 2, -f / 2]
        return (
          s.forEach(function (d) {
            var p = N(h, 2),
              v = p[0],
              g = p[1],
              y = N(c[d], 2),
              m = y[0],
              b = y[1]
            h = [v + (u / 2 + a[0]) * m, g + (f / 2 + a[1]) * b]
          }),
          h
        )
      }),
      (e.prototype.setOffsetPosition = function (n) {
        var r = N(n, 2),
          i = r[0],
          a = r[1],
          o = this.attributes,
          s = o.x,
          c = s === void 0 ? 0 : s,
          l = o.y,
          u = l === void 0 ? 0 : l,
          f = o.container,
          h = f.x,
          d = f.y
        ;(this.element.style.left = ''.concat(+c + h + i, 'px')),
          (this.element.style.top = ''.concat(+u + d + a, 'px'))
      }),
      (e.prototype.updatePosition = function () {
        this.setOffsetPosition(this.autoPosition(this.getRelativeOffsetFromCursor()))
      }),
      (e.prototype.autoPosition = function (n) {
        var r = N(n, 2),
          i = r[0],
          a = r[1],
          o = this.attributes,
          s = o.x,
          c = o.y,
          l = o.bounding,
          u = o.position
        if (!l) return [i, a]
        var f = this.element,
          h = f.offsetWidth,
          d = f.offsetHeight,
          p = N([+s + i, +c + a], 2),
          v = p[0],
          g = p[1],
          y = { left: 'right', right: 'left', top: 'bottom', bottom: 'top' },
          m = l.x,
          b = l.y,
          x = l.width,
          w = l.height,
          O = { left: v < m, right: v + h > m + x, top: g < b, bottom: g + d > b + w },
          S = []
        u.split('-').forEach(function (M) {
          O[M] ? S.push(y[M]) : S.push(M)
        })
        var _ = S.join('-')
        return this.getRelativeOffsetFromCursor(_)
      }),
      (e.tag = 'tooltip'),
      LA([N6(100, !0)], e.prototype, 'updatePosition', null),
      e
    )
  })(Te),
  YI = (function (t) {
    rt(e, t)
    function e(n) {
      var r = t.call(this, n) || this
      ;(r.layoutEvents = [dt.BOUNDS_CHANGED, dt.INSERTED, dt.REMOVED]),
        (r.$margin = ke(0)),
        (r.$padding = ke(0))
      var i = n.style || {},
        a = i.margin,
        o = a === void 0 ? 0 : a,
        s = i.padding,
        c = s === void 0 ? 0 : s
      return (r.margin = o), (r.padding = c), (r.isMutationObserved = !0), r.bindEvents(), r
    }
    return (
      Object.defineProperty(e.prototype, 'margin', {
        get: function () {
          return this.$margin
        },
        set: function (n) {
          this.$margin = ke(n)
        },
        enumerable: !1,
        configurable: !0
      }),
      Object.defineProperty(e.prototype, 'padding', {
        get: function () {
          return this.$padding
        },
        set: function (n) {
          this.$padding = ke(n)
        },
        enumerable: !1,
        configurable: !0
      }),
      (e.prototype.getBBox = function () {
        var n = this.attributes,
          r = n.x,
          i = r === void 0 ? 0 : r,
          a = n.y,
          o = a === void 0 ? 0 : a,
          s = n.width,
          c = n.height,
          l = N(this.$margin, 4),
          u = l[0],
          f = l[1],
          h = l[2],
          d = l[3]
        return new te(i - d, o - u, s + d + f, c + u + h)
      }),
      (e.prototype.appendChild = function (n, r) {
        return (n.isMutationObserved = !0), t.prototype.appendChild.call(this, n, r), n
      }),
      (e.prototype.getAvailableSpace = function () {
        var n = this.attributes,
          r = n.width,
          i = n.height,
          a = N(this.$padding, 4),
          o = a[0],
          s = a[1],
          c = a[2],
          l = a[3],
          u = N(this.$margin, 4),
          f = u[0],
          h = u[3]
        return new te(l + h, o + f, r - l - s, i - o - c)
      }),
      (e.prototype.layout = function () {
        if (
          !(!this.attributes.display || !this.isConnected) &&
          !this.children.some(function (r) {
            return !r.isConnected
          })
        )
          try {
            var n = y6(
              this.getAvailableSpace(),
              this.children.map(function (r) {
                return r.getBBox()
              }),
              this.attributes
            )
            this.children.forEach(function (r, i) {
              var a = n[i],
                o = a.x,
                s = a.y
              r.attr({ x: o, y: s })
            })
          } catch {}
      }),
      (e.prototype.bindEvents = function () {
        var n = this
        this.layoutEvents.forEach(function (r) {
          n.addEventListener(r, function (i) {
            ;(i.target.isMutationObserved = !0), n.layout()
          })
        })
      }),
      (e.prototype.attributeChangedCallback = function (n, r, i) {
        n === 'margin' ? (this.margin = i) : n === 'padding' && (this.padding = i), this.layout()
      }),
      e
    )
  })(je),
  mf =
    (globalThis && globalThis.__rest) ||
    function (t, e) {
      var n = {}
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
      if (t != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          e.indexOf(r[i]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
            (n[r[i]] = t[r[i]])
      return n
    }
function HI(t) {
  const {
    min: [e, n],
    max: [r, i]
  } = t.getLocalBounds()
  let a = 0,
    o = 0
  return e > 0 && (a = e), r < 0 && (a = r), n > 0 && (o = n), i < 0 && (o = i), [a, o]
}
function VI(t, e = []) {
  const [n = 0, r = 0, i = n, a = r] = e,
    o = t.parentNode,
    s = o.getEulerAngles()
  o.setEulerAngles(0)
  const { min: c, halfExtents: l } = t.getLocalBounds(),
    [u, f] = c,
    [h, d] = l
  return o.setEulerAngles(s), { x: u - a, y: f - n, width: h * 2 + a + r, height: d * 2 + n + i }
}
const XI = (t, e, n) => {
  const r = Ut(t, e),
    i = Ut(e, n),
    a = Ut(n, t)
  return (Math.pow(r, 2) + Math.pow(i, 2) - Math.pow(a, 2)) / (2 * r * i)
}
function UI(t, e, n, r) {
  const [[i, a], [o, s]] = e,
    [c, l] = HI(t)
  if (i === o && a === s)
    return Kr()([
      [0, 0],
      [c, l]
    ])
  const u = [[i - o, a - s]].concat(n.length ? n : [[0, 0]]),
    f = [r[0] - o, r[1] - s],
    [h, d] = u
  if (XI(f, h, d) > 0) {
    const p = (() => {
      const { min: v, max: g } = t.getLocalBounds(),
        y = h[0] + ((h[1] - f[1]) * (h[1] - 0)) / (h[0] - f[0])
      return g[0] < f[0] ? Math.min(g[0], y) : Math.max(v[0], y)
    })()
    u.splice(1, 1, [p, 0])
  }
  return Kr()(u)
}
const zO = Ia((t) => {
    const e = t.attributes,
      {
        className: n,
        class: r,
        transform: i,
        rotate: a,
        labelTransform: o,
        labelTransformOrigin: s,
        x: c,
        y: l,
        x0: u = c,
        y0: f = l,
        text: h,
        background: d,
        connector: p,
        startMarker: v,
        endMarker: g,
        coordCenter: y,
        innerHTML: m
      } = e,
      b = mf(e, [
        'className',
        'class',
        'transform',
        'rotate',
        'labelTransform',
        'labelTransformOrigin',
        'x',
        'y',
        'x0',
        'y0',
        'text',
        'background',
        'connector',
        'startMarker',
        'endMarker',
        'coordCenter',
        'innerHTML'
      ])
    if ([c, l, u, f].some((L) => !ve(L))) {
      t.children.forEach((L) => L.remove())
      return
    }
    const x = et(b, 'background'),
      { padding: w } = x,
      O = mf(x, ['padding']),
      S = et(b, 'connector'),
      { points: _ = [] } = S,
      M = mf(S, ['points']),
      E = [
        [+u, +f],
        [+c, +l]
      ]
    let T
    m
      ? (T = ot(t)
          .maybeAppend('html', 'html', n)
          .style('zIndex', 0)
          .style('innerHTML', m)
          .call(at, Object.assign({ transform: o, transformOrigin: s }, b))
          .node())
      : (T = ot(t)
          .maybeAppend('text', 'text')
          .style('zIndex', 0)
          .style('text', h)
          .call(at, Object.assign({ textBaseline: 'middle', transform: o, transformOrigin: s }, b))
          .node())
    const C = ot(t)
        .maybeAppend('background', 'rect')
        .style('zIndex', -1)
        .call(at, VI(T, w))
        .call(at, d ? O : {})
        .node(),
      A = UI(C, E, _, y),
      P =
        v &&
        new $t({ id: 'startMarker', style: Object.assign({ x: 0, y: 0 }, et(b, 'startMarker')) }),
      k = g && new $t({ id: 'endMarker', style: Object.assign({ x: 0, y: 0 }, et(b, 'endMarker')) })
    ot(t)
      .maybeAppend('connector', 'path')
      .style('zIndex', 0)
      .style('path', A)
      .style('markerStart', P)
      .style('markerEnd', k)
      .call(at, p ? M : {})
  }),
  GO = (t, e) => {
    const { coordinate: n } = e
    return (r, i, a) => {
      const { color: o, text: s = '', fontSize: c, rotate: l = 0, transform: u = '' } = i,
        f = { text: String(s), stroke: o, fill: o, fontSize: c },
        [[h, d]] = r
      return ot(new zO())
        .style('x', h)
        .style('y', d)
        .call(at, a)
        .style('transform', `${u}rotate(${+l})`)
        .style('coordCenter', n.getCenter())
        .call(at, f)
        .call(at, t)
        .node()
    }
  }
GO.props = {
  defaultMarker: 'point',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var Yh =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function qI(t) {
  const e = t / Math.sqrt(2),
    n = t * Math.sqrt(2),
    [r, i] = [-e, e - n],
    [a, o] = [0, 0],
    [s, c] = [e, e - n]
  return [['M', r, i], ['A', t, t, 0, 1, 1, s, c], ['L', a, o], ['Z']]
}
function KI(t) {
  const { min: e, max: n } = t.getLocalBounds()
  return [(e[0] + n[0]) * 0.5, (e[1] + n[1]) * 0.5]
}
const ZI = Ia((t) => {
    const e = t.attributes,
      n = Yh(e, ['class', 'x', 'y']),
      r = et(n, 'marker'),
      { size: i = 24 } = r,
      a = () => qI(i / 2),
      o = ot(t)
        .maybeAppend('marker', () => new $t({}))
        .call((l) => l.node().update(Object.assign({ symbol: a }, r)))
        .node(),
      [s, c] = KI(o)
    ot(t).maybeAppend('text', 'text').style('x', s).style('y', c).call(at, n)
  }),
  WO = (t, e) => {
    const n = Yh(t, [])
    return (r, i, a) => {
      const { color: o } = a,
        s = Yh(a, ['color']),
        { color: c = o, text: l = '' } = i,
        u = { text: String(l), stroke: c, fill: c },
        [[f, h]] = r
      return ot(new ZI()).call(at, s).style('x', f).style('y', h).call(at, u).call(at, n).node()
    }
  }
WO.props = {
  defaultMarker: 'point',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var QI =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function JI(t, e) {
  const n = [],
    r = [],
    i = []
  let a = !1,
    o = null
  const s = t.length / 2
  for (let c = 0; c < s; c++) {
    const l = t[c],
      u = t[c + s]
    if ([...l, ...u].some((f) => !e(f))) a = !0
    else {
      if ((n.push(l), r.push(u), a && o)) {
        a = !1
        const [f, h] = o
        i.push([f, l, h, u])
      }
      o = [l, u]
    }
  }
  return [n.concat(r), i]
}
const ey = Ia((t) => {
    const { areaPath: e, connectPath: n, areaStyle: r, connectStyle: i } = t.attributes,
      a = t.ownerDocument
    ot(t)
      .maybeAppend('connect-path', () => a.createElement('path', {}))
      .style('d', n)
      .call(at, i),
      ot(t)
        .maybeAppend('area-path', () => a.createElement('path', {}))
        .style('d', e)
        .call(at, r)
  }),
  Hn = (t, e) => {
    const {
        curve: n,
        gradient: r = !1,
        defined: i = (l) => !Number.isNaN(l) && l !== void 0 && l !== null,
        connect: a = !1
      } = t,
      o = QI(t, ['curve', 'gradient', 'defined', 'connect']),
      { coordinate: s, document: c } = e
    return (l, u, f) => {
      const { color: h } = f,
        { color: d = h, seriesColor: p, seriesX: v, seriesY: g } = u,
        y = hw(s, u),
        m = r && p ? uw(p, v, g, r) : d,
        b = Object.assign(
          Object.assign(
            Object.assign(Object.assign({}, f), { stroke: m, fill: m }),
            y && { transform: y }
          ),
          o
        ),
        [x, w] = JI(l, i),
        O = et(b, 'connect'),
        S = !!w.length,
        _ = (M) =>
          ot(c.createElement('path', {}))
            .style('d', M || '')
            .call(at, b)
            .node()
      if (Zt(s)) {
        const M = (E) => {
          const T = s.getCenter(),
            C = E.slice(0, E.length / 2),
            A = E.slice(E.length / 2)
          return MC()
            .angle((P, k) => Ca(oe(C[k], T)))
            .outerRadius((P, k) => Ut(C[k], T))
            .innerRadius((P, k) => Ut(A[k], T))
            .defined((P, k) => [...C[k], ...A[k]].every(i))
            .curve(n)(A)
        }
        return !S || (a && !Object.keys(O).length)
          ? _(M(x))
          : S && !a
          ? _(M(l))
          : ot(new ey())
              .style('areaStyle', b)
              .style('connectStyle', Object.assign(Object.assign({}, O), o))
              .style('areaPath', M(l))
              .style('connectPath', w.map(M).join(''))
              .node()
      } else {
        const M = (E) => {
          const T = E.slice(0, E.length / 2),
            C = E.slice(E.length / 2)
          return ce(s)
            ? yh()
                .y((A, P) => T[P][1])
                .x1((A, P) => T[P][0])
                .x0((A, P) => C[P][0])
                .defined((A, P) => [...T[P], ...C[P]].every(i))
                .curve(n)(T)
            : yh()
                .x((A, P) => T[P][0])
                .y1((A, P) => T[P][1])
                .y0((A, P) => C[P][1])
                .defined((A, P) => [...T[P], ...C[P]].every(i))
                .curve(n)(T)
        }
        return !S || (a && !Object.keys(O).length)
          ? _(M(x))
          : S && !a
          ? _(M(l))
          : ot(new ey())
              .style('areaStyle', b)
              .style('connectStyle', Object.assign(Object.assign({}, O), o))
              .style('areaPath', M(l))
              .style('connectPath', w.map(M).join(''))
              .node()
      }
    }
  }
Hn.props = {
  defaultMarker: 'smooth',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
const YO = (t, e) => {
  const { coordinate: n } = e
  return (...r) => {
    const i = Zt(n) ? dp : As
    return Hn(Object.assign({ curve: i }, t), e)(...r)
  }
}
YO.props = Object.assign(Object.assign({}, Hn.props), { defaultMarker: 'square' })
var tj =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const HO = (t, e) => {
  const { alpha: n = 0.5 } = t,
    r = tj(t, ['alpha']),
    { coordinate: i } = e
  return (...a) => {
    const o = Zt(i) ? g2 : p2
    return Hn(Object.assign({ curve: o.alpha(n) }, r), e)(...a)
  }
}
HO.props = Object.assign(Object.assign({}, Hn.props), { defaultMarker: 'smooth' })
const VO =
  (t, e) =>
  (...n) =>
    Hn(Object.assign({ curve: m2 }, t), e)(...n)
VO.props = Object.assign(Object.assign({}, Hn.props), { defaultMarker: 'hvh' })
const XO =
  (t, e) =>
  (...n) =>
    Hn(Object.assign({ curve: b2 }, t), e)(...n)
XO.props = Object.assign(Object.assign({}, Hn.props), { defaultMarker: 'vh' })
const UO =
  (t, e) =>
  (...n) =>
    Hn(Object.assign({ curve: x2 }, t), e)(...n)
UO.props = Object.assign(Object.assign({}, Hn.props), { defaultMarker: 'hv' })
const qO = (t, e) => {
  const { arrow: n = !1 } = t
  return (...r) => $p(Object.assign(Object.assign({}, t), { arrow: n }), e)(...r)
}
qO.props = {
  defaultMarker: 'line',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var ny =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const KO = (t, e) => {
  const n = ny(t, []),
    { document: r } = e
  return (i, a, o) => {
    const { color: s } = o,
      c = ny(o, ['color']),
      { color: l = s, transform: u } = a,
      [f, h] = i,
      d = Nn()
    return (
      d.moveTo(f[0], f[1]),
      d.bezierCurveTo(f[0] / 2 + h[0] / 2, f[1], f[0] / 2 + h[0] / 2, h[1], h[0], h[1]),
      ot(r.createElement('path', {}))
        .call(at, c)
        .style('d', d.toString())
        .style('stroke', l)
        .style('transform', u)
        .call(at, n)
        .node()
    )
  }
}
KO.props = {
  defaultMarker: 'smooth',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var ry =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function ej(t, e, n, r) {
  const i = Nn()
  if (Zt(n)) {
    const a = n.getCenter(),
      o = Ut(t, a),
      c = (Ut(e, a) - o) * r + o
    return i.moveTo(t[0], t[1]), is(i, t, e, a, c), i.lineTo(e[0], e[1]), i
  }
  return ce(n)
    ? (i.moveTo(t[0], t[1]),
      i.lineTo(t[0] + (e[0] - t[0]) * r, t[1]),
      i.lineTo(t[0] + (e[0] - t[0]) * r, e[1]),
      i.lineTo(e[0], e[1]),
      i)
    : (i.moveTo(t[0], t[1]),
      i.lineTo(t[0], t[1] + (e[1] - t[1]) * r),
      i.lineTo(e[0], t[1] + (e[1] - t[1]) * r),
      i.lineTo(e[0], e[1]),
      i)
}
const ZO = (t, e) => {
  const { cornerRatio: n = 1 / 3 } = t,
    r = ry(t, ['cornerRatio']),
    { coordinate: i, document: a } = e
  return (o, s, c) => {
    const { defaultColor: l } = c,
      u = ry(c, ['defaultColor']),
      { color: f = l, transform: h } = s,
      [d, p] = o,
      v = ej(d, p, i, n)
    return ot(a.createElement('path', {}))
      .call(at, u)
      .style('d', v.toString())
      .style('stroke', f)
      .style('transform', h)
      .call(at, r)
      .node()
  }
}
ZO.props = {
  defaultMarker: 'vhv',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var iy =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const QO = (t, e) => {
  const n = iy(t, []),
    { coordinate: r, document: i } = e
  return (a, o, s) => {
    const { color: c } = s,
      l = iy(s, ['color']),
      { color: u = c, transform: f } = o,
      [h, d] = a,
      p = Nn()
    if ((p.moveTo(h[0], h[1]), Zt(r))) {
      const v = r.getCenter()
      p.quadraticCurveTo(v[0], v[1], d[0], d[1])
    } else {
      const v = t2(h, d),
        g = Ut(h, d) / 2
      is(p, h, d, v, g)
    }
    return ot(i.createElement('path', {}))
      .call(at, l)
      .style('d', p.toString())
      .style('stroke', u)
      .style('transform', f)
      .call(at, n)
      .node()
  }
}
QO.props = {
  defaultMarker: 'smooth',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
function nj(t, e) {
  return t.parent === e.parent ? 1 : 2
}
function rj(t) {
  return t.reduce(ij, 0) / t.length
}
function ij(t, e) {
  return t + e.x
}
function aj(t) {
  return 1 + t.reduce(oj, 0)
}
function oj(t, e) {
  return Math.max(t, e.y)
}
function sj(t) {
  for (var e; (e = t.children); ) t = e[0]
  return t
}
function cj(t) {
  for (var e; (e = t.children); ) t = e[e.length - 1]
  return t
}
function lj() {
  var t = nj,
    e = 1,
    n = 1,
    r = !1
  function i(a) {
    var o,
      s = 0
    a.eachAfter(function (h) {
      var d = h.children
      d ? ((h.x = rj(d)), (h.y = aj(d))) : ((h.x = o ? (s += t(h, o)) : 0), (h.y = 0), (o = h))
    })
    var c = sj(a),
      l = cj(a),
      u = c.x - t(c, l) / 2,
      f = l.x + t(l, c) / 2
    return a.eachAfter(
      r
        ? function (h) {
            ;(h.x = (h.x - a.x) * e), (h.y = (a.y - h.y) * n)
          }
        : function (h) {
            ;(h.x = ((h.x - u) / (f - u)) * e), (h.y = (1 - (a.y ? h.y / a.y : 1)) * n)
          }
    )
  }
  return (
    (i.separation = function (a) {
      return arguments.length ? ((t = a), i) : t
    }),
    (i.size = function (a) {
      return arguments.length ? ((r = !1), (e = +a[0]), (n = +a[1]), i) : r ? null : [e, n]
    }),
    (i.nodeSize = function (a) {
      return arguments.length ? ((r = !0), (e = +a[0]), (n = +a[1]), i) : r ? [e, n] : null
    }),
    i
  )
}
function uj(t) {
  var e = 0,
    n = t.children,
    r = n && n.length
  if (!r) e = 1
  else for (; --r >= 0; ) e += n[r].value
  t.value = e
}
function fj() {
  return this.eachAfter(uj)
}
function hj(t, e) {
  let n = -1
  for (const r of this) t.call(e, r, ++n, this)
  return this
}
function dj(t, e) {
  for (var n = this, r = [n], i, a, o = -1; (n = r.pop()); )
    if ((t.call(e, n, ++o, this), (i = n.children)))
      for (a = i.length - 1; a >= 0; --a) r.push(i[a])
  return this
}
function pj(t, e) {
  for (var n = this, r = [n], i = [], a, o, s, c = -1; (n = r.pop()); )
    if ((i.push(n), (a = n.children))) for (o = 0, s = a.length; o < s; ++o) r.push(a[o])
  for (; (n = i.pop()); ) t.call(e, n, ++c, this)
  return this
}
function vj(t, e) {
  let n = -1
  for (const r of this) if (t.call(e, r, ++n, this)) return r
}
function gj(t) {
  return this.eachAfter(function (e) {
    for (var n = +t(e.data) || 0, r = e.children, i = r && r.length; --i >= 0; ) n += r[i].value
    e.value = n
  })
}
function yj(t) {
  return this.eachBefore(function (e) {
    e.children && e.children.sort(t)
  })
}
function mj(t) {
  for (var e = this, n = bj(e, t), r = [e]; e !== n; ) (e = e.parent), r.push(e)
  for (var i = r.length; t !== n; ) r.splice(i, 0, t), (t = t.parent)
  return r
}
function bj(t, e) {
  if (t === e) return t
  var n = t.ancestors(),
    r = e.ancestors(),
    i = null
  for (t = n.pop(), e = r.pop(); t === e; ) (i = t), (t = n.pop()), (e = r.pop())
  return i
}
function xj() {
  for (var t = this, e = [t]; (t = t.parent); ) e.push(t)
  return e
}
function wj() {
  return Array.from(this)
}
function Oj() {
  var t = []
  return (
    this.eachBefore(function (e) {
      e.children || t.push(e)
    }),
    t
  )
}
function Sj() {
  var t = this,
    e = []
  return (
    t.each(function (n) {
      n !== t && e.push({ source: n.parent, target: n })
    }),
    e
  )
}
function* _j() {
  var t = this,
    e,
    n = [t],
    r,
    i,
    a
  do
    for (e = n.reverse(), n = []; (t = e.pop()); )
      if ((yield t, (r = t.children))) for (i = 0, a = r.length; i < a; ++i) n.push(r[i])
  while (n.length)
}
function $s(t, e) {
  t instanceof Map ? ((t = [void 0, t]), e === void 0 && (e = Tj)) : e === void 0 && (e = Ej)
  for (var n = new $a(t), r, i = [n], a, o, s, c; (r = i.pop()); )
    if ((o = e(r.data)) && (c = (o = Array.from(o)).length))
      for (r.children = o, s = c - 1; s >= 0; --s)
        i.push((a = o[s] = new $a(o[s]))), (a.parent = r), (a.depth = r.depth + 1)
  return n.eachBefore(JO)
}
function Mj() {
  return $s(this).eachBefore(Pj)
}
function Ej(t) {
  return t.children
}
function Tj(t) {
  return Array.isArray(t) ? t[1] : null
}
function Pj(t) {
  t.data.value !== void 0 && (t.value = t.data.value), (t.data = t.data.data)
}
function JO(t) {
  var e = 0
  do t.height = e
  while ((t = t.parent) && t.height < ++e)
}
function $a(t) {
  ;(this.data = t), (this.depth = this.height = 0), (this.parent = null)
}
$a.prototype = $s.prototype = {
  constructor: $a,
  count: fj,
  each: hj,
  eachAfter: pj,
  eachBefore: dj,
  find: vj,
  sum: gj,
  sort: yj,
  path: mj,
  ancestors: xj,
  descendants: wj,
  leaves: Oj,
  links: Sj,
  copy: Mj,
  [Symbol.iterator]: _j
}
function zc(t) {
  return t == null ? null : tS(t)
}
function tS(t) {
  if (typeof t != 'function') throw new Error()
  return t
}
function Oi() {
  return 0
}
function oa(t) {
  return function () {
    return t
  }
}
const Aj = 1664525,
  kj = 1013904223,
  ay = 4294967296
function Cj() {
  let t = 1
  return () => (t = (Aj * t + kj) % ay) / ay
}
function Lj(t) {
  return typeof t == 'object' && 'length' in t ? t : Array.from(t)
}
function Nj(t, e) {
  let n = t.length,
    r,
    i
  for (; n; ) (i = (e() * n--) | 0), (r = t[n]), (t[n] = t[i]), (t[i] = r)
  return t
}
function Rj(t, e) {
  for (var n = 0, r = (t = Nj(Array.from(t), e)).length, i = [], a, o; n < r; )
    (a = t[n]), o && eS(o, a) ? ++n : ((o = jj((i = Ij(i, a)))), (n = 0))
  return o
}
function Ij(t, e) {
  var n, r
  if (bf(e, t)) return [e]
  for (n = 0; n < t.length; ++n) if (mc(e, t[n]) && bf(_o(t[n], e), t)) return [t[n], e]
  for (n = 0; n < t.length - 1; ++n)
    for (r = n + 1; r < t.length; ++r)
      if (
        mc(_o(t[n], t[r]), e) &&
        mc(_o(t[n], e), t[r]) &&
        mc(_o(t[r], e), t[n]) &&
        bf(nS(t[n], t[r], e), t)
      )
        return [t[n], t[r], e]
  throw new Error()
}
function mc(t, e) {
  var n = t.r - e.r,
    r = e.x - t.x,
    i = e.y - t.y
  return n < 0 || n * n < r * r + i * i
}
function eS(t, e) {
  var n = t.r - e.r + Math.max(t.r, e.r, 1) * 1e-9,
    r = e.x - t.x,
    i = e.y - t.y
  return n > 0 && n * n > r * r + i * i
}
function bf(t, e) {
  for (var n = 0; n < e.length; ++n) if (!eS(t, e[n])) return !1
  return !0
}
function jj(t) {
  switch (t.length) {
    case 1:
      return Dj(t[0])
    case 2:
      return _o(t[0], t[1])
    case 3:
      return nS(t[0], t[1], t[2])
  }
}
function Dj(t) {
  return { x: t.x, y: t.y, r: t.r }
}
function _o(t, e) {
  var n = t.x,
    r = t.y,
    i = t.r,
    a = e.x,
    o = e.y,
    s = e.r,
    c = a - n,
    l = o - r,
    u = s - i,
    f = Math.sqrt(c * c + l * l)
  return { x: (n + a + (c / f) * u) / 2, y: (r + o + (l / f) * u) / 2, r: (f + i + s) / 2 }
}
function nS(t, e, n) {
  var r = t.x,
    i = t.y,
    a = t.r,
    o = e.x,
    s = e.y,
    c = e.r,
    l = n.x,
    u = n.y,
    f = n.r,
    h = r - o,
    d = r - l,
    p = i - s,
    v = i - u,
    g = c - a,
    y = f - a,
    m = r * r + i * i - a * a,
    b = m - o * o - s * s + c * c,
    x = m - l * l - u * u + f * f,
    w = d * p - h * v,
    O = (p * x - v * b) / (w * 2) - r,
    S = (v * g - p * y) / w,
    _ = (d * b - h * x) / (w * 2) - i,
    M = (h * y - d * g) / w,
    E = S * S + M * M - 1,
    T = 2 * (a + O * S + _ * M),
    C = O * O + _ * _ - a * a,
    A = -(Math.abs(E) > 1e-6 ? (T + Math.sqrt(T * T - 4 * E * C)) / (2 * E) : C / T)
  return { x: r + O + S * A, y: i + _ + M * A, r: A }
}
function oy(t, e, n) {
  var r = t.x - e.x,
    i,
    a,
    o = t.y - e.y,
    s,
    c,
    l = r * r + o * o
  l
    ? ((a = e.r + n.r),
      (a *= a),
      (c = t.r + n.r),
      (c *= c),
      a > c
        ? ((i = (l + c - a) / (2 * l)),
          (s = Math.sqrt(Math.max(0, c / l - i * i))),
          (n.x = t.x - i * r - s * o),
          (n.y = t.y - i * o + s * r))
        : ((i = (l + a - c) / (2 * l)),
          (s = Math.sqrt(Math.max(0, a / l - i * i))),
          (n.x = e.x + i * r - s * o),
          (n.y = e.y + i * o + s * r)))
    : ((n.x = e.x + n.r), (n.y = e.y))
}
function sy(t, e) {
  var n = t.r + e.r - 1e-6,
    r = e.x - t.x,
    i = e.y - t.y
  return n > 0 && n * n > r * r + i * i
}
function cy(t) {
  var e = t._,
    n = t.next._,
    r = e.r + n.r,
    i = (e.x * n.r + n.x * e.r) / r,
    a = (e.y * n.r + n.y * e.r) / r
  return i * i + a * a
}
function bc(t) {
  ;(this._ = t), (this.next = null), (this.previous = null)
}
function $j(t, e) {
  if (!(a = (t = Lj(t)).length)) return 0
  var n, r, i, a, o, s, c, l, u, f, h
  if (((n = t[0]), (n.x = 0), (n.y = 0), !(a > 1))) return n.r
  if (((r = t[1]), (n.x = -r.r), (r.x = n.r), (r.y = 0), !(a > 2))) return n.r + r.r
  oy(r, n, (i = t[2])),
    (n = new bc(n)),
    (r = new bc(r)),
    (i = new bc(i)),
    (n.next = i.previous = r),
    (r.next = n.previous = i),
    (i.next = r.previous = n)
  t: for (c = 3; c < a; ++c) {
    oy(n._, r._, (i = t[c])),
      (i = new bc(i)),
      (l = r.next),
      (u = n.previous),
      (f = r._.r),
      (h = n._.r)
    do
      if (f <= h) {
        if (sy(l._, i._)) {
          ;(r = l), (n.next = r), (r.previous = n), --c
          continue t
        }
        ;(f += l._.r), (l = l.next)
      } else {
        if (sy(u._, i._)) {
          ;(n = u), (n.next = r), (r.previous = n), --c
          continue t
        }
        ;(h += u._.r), (u = u.previous)
      }
    while (l !== u.next)
    for (i.previous = n, i.next = r, n.next = r.previous = r = i, o = cy(n); (i = i.next) !== r; )
      (s = cy(i)) < o && ((n = i), (o = s))
    r = n.next
  }
  for (n = [r._], i = r; (i = i.next) !== r; ) n.push(i._)
  for (i = Rj(n, e), c = 0; c < a; ++c) (n = t[c]), (n.x -= i.x), (n.y -= i.y)
  return i.r
}
function Bj(t) {
  return Math.sqrt(t.value)
}
function Fj() {
  var t = null,
    e = 1,
    n = 1,
    r = Oi
  function i(a) {
    const o = Cj()
    return (
      (a.x = e / 2),
      (a.y = n / 2),
      t
        ? a.eachBefore(ly(t)).eachAfter(xf(r, 0.5, o)).eachBefore(uy(1))
        : a
            .eachBefore(ly(Bj))
            .eachAfter(xf(Oi, 1, o))
            .eachAfter(xf(r, a.r / Math.min(e, n), o))
            .eachBefore(uy(Math.min(e, n) / (2 * a.r))),
      a
    )
  }
  return (
    (i.radius = function (a) {
      return arguments.length ? ((t = zc(a)), i) : t
    }),
    (i.size = function (a) {
      return arguments.length ? ((e = +a[0]), (n = +a[1]), i) : [e, n]
    }),
    (i.padding = function (a) {
      return arguments.length ? ((r = typeof a == 'function' ? a : oa(+a)), i) : r
    }),
    i
  )
}
function ly(t) {
  return function (e) {
    e.children || (e.r = Math.max(0, +t(e) || 0))
  }
}
function xf(t, e, n) {
  return function (r) {
    if ((i = r.children)) {
      var i,
        a,
        o = i.length,
        s = t(r) * e || 0,
        c
      if (s) for (a = 0; a < o; ++a) i[a].r += s
      if (((c = $j(i, n)), s)) for (a = 0; a < o; ++a) i[a].r -= s
      r.r = c + s
    }
  }
}
function uy(t) {
  return function (e) {
    var n = e.parent
    ;(e.r *= t), n && ((e.x = n.x + t * e.x), (e.y = n.y + t * e.y))
  }
}
function zj(t) {
  ;(t.x0 = Math.round(t.x0)),
    (t.y0 = Math.round(t.y0)),
    (t.x1 = Math.round(t.x1)),
    (t.y1 = Math.round(t.y1))
}
function Mu(t, e, n, r, i) {
  for (var a = t.children, o, s = -1, c = a.length, l = t.value && (r - e) / t.value; ++s < c; )
    (o = a[s]), (o.y0 = n), (o.y1 = i), (o.x0 = e), (o.x1 = e += o.value * l)
}
var Gj = { depth: -1 },
  fy = {},
  wf = {}
function Wj(t) {
  return t.id
}
function Yj(t) {
  return t.parentId
}
function Hh() {
  var t = Wj,
    e = Yj,
    n
  function r(i) {
    var a = Array.from(i),
      o = t,
      s = e,
      c,
      l,
      u,
      f,
      h,
      d,
      p,
      v,
      g = new Map()
    if (n != null) {
      const y = a.map((x, w) => Hj(n(x, w, i))),
        m = y.map(hy),
        b = new Set(y).add('')
      for (const x of m) b.has(x) || (b.add(x), y.push(x), m.push(hy(x)), a.push(wf))
      ;(o = (x, w) => y[w]), (s = (x, w) => m[w])
    }
    for (u = 0, c = a.length; u < c; ++u)
      (l = a[u]),
        (d = a[u] = new $a(l)),
        (p = o(l, u, i)) != null && (p += '') && ((v = d.id = p), g.set(v, g.has(v) ? fy : d)),
        (p = s(l, u, i)) != null && (p += '') && (d.parent = p)
    for (u = 0; u < c; ++u)
      if (((d = a[u]), (p = d.parent))) {
        if (((h = g.get(p)), !h)) throw new Error('missing: ' + p)
        if (h === fy) throw new Error('ambiguous: ' + p)
        h.children ? h.children.push(d) : (h.children = [d]), (d.parent = h)
      } else {
        if (f) throw new Error('multiple roots')
        f = d
      }
    if (!f) throw new Error('no root')
    if (n != null) {
      for (; f.data === wf && f.children.length === 1; ) (f = f.children[0]), --c
      for (let y = a.length - 1; y >= 0 && ((d = a[y]), d.data === wf); --y) d.data = null
    }
    if (
      ((f.parent = Gj),
      f
        .eachBefore(function (y) {
          ;(y.depth = y.parent.depth + 1), --c
        })
        .eachBefore(JO),
      (f.parent = null),
      c > 0)
    )
      throw new Error('cycle')
    return f
  }
  return (
    (r.id = function (i) {
      return arguments.length ? ((t = zc(i)), r) : t
    }),
    (r.parentId = function (i) {
      return arguments.length ? ((e = zc(i)), r) : e
    }),
    (r.path = function (i) {
      return arguments.length ? ((n = zc(i)), r) : n
    }),
    r
  )
}
function Hj(t) {
  t = `${t}`
  let e = t.length
  return Vh(t, e - 1) && !Vh(t, e - 2) && (t = t.slice(0, -1)), t[0] === '/' ? t : `/${t}`
}
function hy(t) {
  let e = t.length
  if (e < 2) return ''
  for (; --e > 1 && !Vh(t, e); );
  return t.slice(0, e)
}
function Vh(t, e) {
  if (t[e] === '/') {
    let n = 0
    for (; e > 0 && t[--e] === '\\'; ) ++n
    if (!(n & 1)) return !0
  }
  return !1
}
function Vj(t, e) {
  return t.parent === e.parent ? 1 : 2
}
function Of(t) {
  var e = t.children
  return e ? e[0] : t.t
}
function Sf(t) {
  var e = t.children
  return e ? e[e.length - 1] : t.t
}
function Xj(t, e, n) {
  var r = n / (e.i - t.i)
  ;(e.c -= r), (e.s += n), (t.c += r), (e.z += n), (e.m += n)
}
function Uj(t) {
  for (var e = 0, n = 0, r = t.children, i = r.length, a; --i >= 0; )
    (a = r[i]), (a.z += e), (a.m += e), (e += a.s + (n += a.c))
}
function qj(t, e, n) {
  return t.a.parent === e.parent ? t.a : n
}
function Gc(t, e) {
  ;(this._ = t),
    (this.parent = null),
    (this.children = null),
    (this.A = null),
    (this.a = this),
    (this.z = 0),
    (this.m = 0),
    (this.c = 0),
    (this.s = 0),
    (this.t = null),
    (this.i = e)
}
Gc.prototype = Object.create($a.prototype)
function Kj(t) {
  for (var e = new Gc(t, 0), n, r = [e], i, a, o, s; (n = r.pop()); )
    if ((a = n._.children))
      for (n.children = new Array((s = a.length)), o = s - 1; o >= 0; --o)
        r.push((i = n.children[o] = new Gc(a[o], o))), (i.parent = n)
  return ((e.parent = new Gc(null, 0)).children = [e]), e
}
function Zj() {
  var t = Vj,
    e = 1,
    n = 1,
    r = null
  function i(l) {
    var u = Kj(l)
    if ((u.eachAfter(a), (u.parent.m = -u.z), u.eachBefore(o), r)) l.eachBefore(c)
    else {
      var f = l,
        h = l,
        d = l
      l.eachBefore(function (m) {
        m.x < f.x && (f = m), m.x > h.x && (h = m), m.depth > d.depth && (d = m)
      })
      var p = f === h ? 1 : t(f, h) / 2,
        v = p - f.x,
        g = e / (h.x + p + v),
        y = n / (d.depth || 1)
      l.eachBefore(function (m) {
        ;(m.x = (m.x + v) * g), (m.y = m.depth * y)
      })
    }
    return l
  }
  function a(l) {
    var u = l.children,
      f = l.parent.children,
      h = l.i ? f[l.i - 1] : null
    if (u) {
      Uj(l)
      var d = (u[0].z + u[u.length - 1].z) / 2
      h ? ((l.z = h.z + t(l._, h._)), (l.m = l.z - d)) : (l.z = d)
    } else h && (l.z = h.z + t(l._, h._))
    l.parent.A = s(l, h, l.parent.A || f[0])
  }
  function o(l) {
    ;(l._.x = l.z + l.parent.m), (l.m += l.parent.m)
  }
  function s(l, u, f) {
    if (u) {
      for (
        var h = l, d = l, p = u, v = h.parent.children[0], g = h.m, y = d.m, m = p.m, b = v.m, x;
        (p = Sf(p)), (h = Of(h)), p && h;

      )
        (v = Of(v)),
          (d = Sf(d)),
          (d.a = l),
          (x = p.z + m - h.z - g + t(p._, h._)),
          x > 0 && (Xj(qj(p, l, f), l, x), (g += x), (y += x)),
          (m += p.m),
          (g += h.m),
          (b += v.m),
          (y += d.m)
      p && !Sf(d) && ((d.t = p), (d.m += m - y)),
        h && !Of(v) && ((v.t = h), (v.m += g - b), (f = l))
    }
    return f
  }
  function c(l) {
    ;(l.x *= e), (l.y = l.depth * n)
  }
  return (
    (i.separation = function (l) {
      return arguments.length ? ((t = l), i) : t
    }),
    (i.size = function (l) {
      return arguments.length ? ((r = !1), (e = +l[0]), (n = +l[1]), i) : r ? null : [e, n]
    }),
    (i.nodeSize = function (l) {
      return arguments.length ? ((r = !0), (e = +l[0]), (n = +l[1]), i) : r ? [e, n] : null
    }),
    i
  )
}
function Eu(t, e, n, r, i) {
  for (var a = t.children, o, s = -1, c = a.length, l = t.value && (i - n) / t.value; ++s < c; )
    (o = a[s]), (o.x0 = e), (o.x1 = r), (o.y0 = n), (o.y1 = n += o.value * l)
}
var rS = (1 + Math.sqrt(5)) / 2
function iS(t, e, n, r, i, a) {
  for (
    var o = [],
      s = e.children,
      c,
      l,
      u = 0,
      f = 0,
      h = s.length,
      d,
      p,
      v = e.value,
      g,
      y,
      m,
      b,
      x,
      w,
      O;
    u < h;

  ) {
    ;(d = i - n), (p = a - r)
    do g = s[f++].value
    while (!g && f < h)
    for (
      y = m = g, w = Math.max(p / d, d / p) / (v * t), O = g * g * w, x = Math.max(m / O, O / y);
      f < h;
      ++f
    ) {
      if (
        ((g += l = s[f].value),
        l < y && (y = l),
        l > m && (m = l),
        (O = g * g * w),
        (b = Math.max(m / O, O / y)),
        b > x)
      ) {
        g -= l
        break
      }
      x = b
    }
    o.push((c = { value: g, dice: d < p, children: s.slice(u, f) })),
      c.dice
        ? Mu(c, n, r, i, v ? (r += (p * g) / v) : a)
        : Eu(c, n, r, v ? (n += (d * g) / v) : i, a),
      (v -= g),
      (u = f)
  }
  return o
}
const aS = (function t(e) {
  function n(r, i, a, o, s) {
    iS(e, r, i, a, o, s)
  }
  return (
    (n.ratio = function (r) {
      return t((r = +r) > 1 ? r : 1)
    }),
    n
  )
})(rS)
function Qj() {
  var t = aS,
    e = !1,
    n = 1,
    r = 1,
    i = [0],
    a = Oi,
    o = Oi,
    s = Oi,
    c = Oi,
    l = Oi
  function u(h) {
    return (
      (h.x0 = h.y0 = 0),
      (h.x1 = n),
      (h.y1 = r),
      h.eachBefore(f),
      (i = [0]),
      e && h.eachBefore(zj),
      h
    )
  }
  function f(h) {
    var d = i[h.depth],
      p = h.x0 + d,
      v = h.y0 + d,
      g = h.x1 - d,
      y = h.y1 - d
    g < p && (p = g = (p + g) / 2),
      y < v && (v = y = (v + y) / 2),
      (h.x0 = p),
      (h.y0 = v),
      (h.x1 = g),
      (h.y1 = y),
      h.children &&
        ((d = i[h.depth + 1] = a(h) / 2),
        (p += l(h) - d),
        (v += o(h) - d),
        (g -= s(h) - d),
        (y -= c(h) - d),
        g < p && (p = g = (p + g) / 2),
        y < v && (v = y = (v + y) / 2),
        t(h, p, v, g, y))
  }
  return (
    (u.round = function (h) {
      return arguments.length ? ((e = !!h), u) : e
    }),
    (u.size = function (h) {
      return arguments.length ? ((n = +h[0]), (r = +h[1]), u) : [n, r]
    }),
    (u.tile = function (h) {
      return arguments.length ? ((t = tS(h)), u) : t
    }),
    (u.padding = function (h) {
      return arguments.length ? u.paddingInner(h).paddingOuter(h) : u.paddingInner()
    }),
    (u.paddingInner = function (h) {
      return arguments.length ? ((a = typeof h == 'function' ? h : oa(+h)), u) : a
    }),
    (u.paddingOuter = function (h) {
      return arguments.length
        ? u.paddingTop(h).paddingRight(h).paddingBottom(h).paddingLeft(h)
        : u.paddingTop()
    }),
    (u.paddingTop = function (h) {
      return arguments.length ? ((o = typeof h == 'function' ? h : oa(+h)), u) : o
    }),
    (u.paddingRight = function (h) {
      return arguments.length ? ((s = typeof h == 'function' ? h : oa(+h)), u) : s
    }),
    (u.paddingBottom = function (h) {
      return arguments.length ? ((c = typeof h == 'function' ? h : oa(+h)), u) : c
    }),
    (u.paddingLeft = function (h) {
      return arguments.length ? ((l = typeof h == 'function' ? h : oa(+h)), u) : l
    }),
    u
  )
}
function Jj(t, e, n, r, i) {
  var a = t.children,
    o,
    s = a.length,
    c,
    l = new Array(s + 1)
  for (l[0] = c = o = 0; o < s; ++o) l[o + 1] = c += a[o].value
  u(0, s, t.value, e, n, r, i)
  function u(f, h, d, p, v, g, y) {
    if (f >= h - 1) {
      var m = a[f]
      ;(m.x0 = p), (m.y0 = v), (m.x1 = g), (m.y1 = y)
      return
    }
    for (var b = l[f], x = d / 2 + b, w = f + 1, O = h - 1; w < O; ) {
      var S = (w + O) >>> 1
      l[S] < x ? (w = S + 1) : (O = S)
    }
    x - l[w - 1] < l[w] - x && f + 1 < w && --w
    var _ = l[w] - b,
      M = d - _
    if (g - p > y - v) {
      var E = d ? (p * M + g * _) / d : g
      u(f, w, _, p, v, E, y), u(w, h, M, E, v, g, y)
    } else {
      var T = d ? (v * M + y * _) / d : y
      u(f, w, _, p, v, g, T), u(w, h, M, p, T, g, y)
    }
  }
}
function t9(t, e, n, r, i) {
  ;(t.depth & 1 ? Eu : Mu)(t, e, n, r, i)
}
const e9 = (function t(e) {
  function n(r, i, a, o, s) {
    if ((c = r._squarify) && c.ratio === e)
      for (var c, l, u, f, h = -1, d, p = c.length, v = r.value; ++h < p; ) {
        for (l = c[h], u = l.children, f = l.value = 0, d = u.length; f < d; ++f)
          l.value += u[f].value
        l.dice
          ? Mu(l, i, a, o, v ? (a += ((s - a) * l.value) / v) : s)
          : Eu(l, i, a, v ? (i += ((o - i) * l.value) / v) : o, s),
          (v -= l.value)
      }
    else (r._squarify = c = iS(e, r, i, a, o, s)), (c.ratio = e)
  }
  return (
    (n.ratio = function (r) {
      return t((r = +r) > 1 ? r : 1)
    }),
    n
  )
})(rS)
function oS(t = {}) {
  const { shapes: e } = t
  return [
    { name: 'color' },
    { name: 'opacity' },
    { name: 'shape', range: e },
    { name: 'enterType' },
    { name: 'enterDelay', scaleKey: 'enter' },
    { name: 'enterDuration', scaleKey: 'enter' },
    { name: 'enterEasing' },
    { name: 'key', scale: 'identity' },
    { name: 'groupKey', scale: 'identity' },
    { name: 'label', scale: 'identity' }
  ]
}
function Ye(t = {}) {
  return [...oS(t), { name: 'title', scale: 'identity' }]
}
function ci() {
  return [
    { type: Kl, channel: 'color' },
    { type: Ql, channel: ['x', 'y'] }
  ]
}
function to() {
  return [
    { type: Kl, channel: 'x' },
    { type: Ql, channel: ['y'] }
  ]
}
function n9() {
  return [
    { type: Kl, channel: 'color' },
    { type: Ql, channel: ['position'] }
  ]
}
function eo(t = {}) {
  return oS(t)
}
function de() {
  return [{ type: zb }]
}
function ge() {
  return []
}
function _f(t, e) {
  return t.getBandWidth(t.invert(e))
}
function qi(t, e, n = {}) {
  const { x: r, y: i, series: a } = e,
    { x: o, y: s, series: c } = t,
    { style: { bandOffset: l = c ? 0 : 0.5, bandOffsetX: u = l, bandOffsetY: f = l } = {} } = n,
    h = !!(o != null && o.getBandWidth),
    d = !!(s != null && s.getBandWidth),
    p = !!(c != null && c.getBandWidth)
  return !h && !d
    ? (v) => v
    : (v, g) => {
        const y = h ? _f(o, r[g]) : 0,
          m = d ? _f(s, i[g]) : 0,
          x = p && a ? (() => (_f(c, a[g]) / 2 + +a[g]) * y)() : 0,
          [w, O] = v
        return [w + u * y + x, O + f * m]
      }
}
function ml(t) {
  return parseFloat(t) / 100
}
function qp(t, e, n, r) {
  const { x: i, y: a } = n,
    { innerWidth: o, innerHeight: s } = r.getOptions(),
    c = Array.from(t, (l) => {
      const u = i[l],
        f = a[l],
        h = typeof u == 'string' ? ml(u) * o : +u,
        d = typeof f == 'string' ? ml(f) * s : +f
      return [[h, d]]
    })
  return [t, c]
}
function Sr(t) {
  return typeof t == 'function' ? t : (e) => e[t]
}
function Mf(t, e) {
  return Array.from(t, Sr(e))
}
function sS(t, e) {
  const { source: n = (u) => u.source, target: r = (u) => u.target, value: i = (u) => u.value } = e,
    { links: a, nodes: o } = t,
    s = Mf(a, n),
    c = Mf(a, r),
    l = Mf(a, i)
  return {
    links: a.map((u, f) => ({ target: c[f], source: s[f], value: l[f] })),
    nodes: o || Array.from(new Set([...s, ...c]), (u) => ({ key: u }))
  }
}
function r9(t, e) {
  return Array.isArray(t) ? (typeof e == 'function' ? Hh().path(e)(t) : Hh()(t)) : $s(t)
}
var i9 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const cS = (t, e) => {
  const { coordinate: n, document: r } = e
  return (i, a, o) => {
    const { color: s } = o,
      c = i9(o, ['color']),
      { color: l = s, src: u = '', size: f = 32, transform: h = '' } = a
    let { width: d = f, height: p = f } = t
    const [[v, g]] = i,
      [y, m] = n.getSize()
    ;(d = typeof d == 'string' ? ml(d) * y : d), (p = typeof p == 'string' ? ml(p) * m : p)
    const b = v - Number(d) / 2,
      x = g - Number(p) / 2
    return ot(r.createElement('image', {}))
      .call(at, c)
      .style('x', b)
      .style('y', x)
      .style('img', u)
      .style('stroke', l)
      .style('transform', h)
      .call(at, t)
      .style('width', d)
      .style('height', p)
      .node()
  }
}
cS.props = {
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var a9 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function o9(t, e) {
  const n = Nn()
  if (Zt(e)) {
    const r = e.getCenter(),
      i = [...t, t[0]],
      a = i.map((o) => Ut(o, r))
    return (
      i.forEach((o, s) => {
        if (s === 0) {
          n.moveTo(o[0], o[1])
          return
        }
        const c = a[s],
          l = t[s - 1],
          u = a[s - 1]
        u !== void 0 && Math.abs(c - u) < 1e-10 ? is(n, l, o, r, c) : n.lineTo(o[0], o[1])
      }),
      n.closePath(),
      n
    )
  }
  return VR(n, t)
}
const lS = (t, e) => {
  const { coordinate: n, document: r } = e
  return (i, a, o) => {
    const { color: s } = o,
      c = a9(o, ['color']),
      { color: l = s, transform: u } = a,
      f = o9(i, n)
    return ot(r.createElement('path', {}))
      .call(at, c)
      .style('d', f.toString())
      .style('stroke', l)
      .style('fill', l)
      .style('transform', u)
      .call(at, t)
      .node()
  }
}
lS.props = {
  defaultMarker: 'square',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var dy =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function s9(t, e) {
  const [n, r, i, a] = t,
    o = Nn()
  if (Zt(e)) {
    const s = e.getCenter(),
      c = Ut(s, n)
    return (
      o.moveTo(n[0], n[1]),
      o.quadraticCurveTo(s[0], s[1], i[0], i[1]),
      is(o, i, a, s, c),
      o.quadraticCurveTo(s[0], s[1], r[0], r[1]),
      is(o, r, n, s, c),
      o.closePath(),
      o
    )
  }
  return (
    o.moveTo(n[0], n[1]),
    o.bezierCurveTo(n[0] / 2 + i[0] / 2, n[1], n[0] / 2 + i[0] / 2, i[1], i[0], i[1]),
    o.lineTo(a[0], a[1]),
    o.bezierCurveTo(a[0] / 2 + r[0] / 2, a[1], a[0] / 2 + r[0] / 2, r[1], r[0], r[1]),
    o.lineTo(n[0], n[1]),
    o.closePath(),
    o
  )
}
const uS = (t, e) => {
  const n = dy(t, []),
    { coordinate: r, document: i } = e
  return (a, o, s) => {
    const { color: c } = s,
      l = dy(s, ['color']),
      { color: u = c, transform: f } = o,
      h = s9(a, r)
    return ot(i.createElement('path', {}))
      .call(at, l)
      .style('d', h.toString())
      .style('fill', u || c)
      .style('stroke', u || c)
      .style('transform', f)
      .call(at, n)
      .node()
  }
}
uS.props = {
  defaultMarker: 'square',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var c9 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function l9(t, e) {
  const n = Nn()
  if (!Zt(e))
    n.moveTo(...t[0]),
      n.lineTo(...t[1]),
      n.moveTo(...t[2]),
      n.lineTo(...t[3]),
      n.moveTo(...t[4]),
      n.lineTo(...t[5]),
      n.lineTo(...t[6]),
      n.lineTo(...t[7]),
      n.closePath(),
      n.moveTo(...t[8]),
      n.lineTo(...t[9]),
      n.moveTo(...t[10]),
      n.lineTo(...t[11]),
      n.moveTo(...t[12]),
      n.lineTo(...t[13])
  else {
    const r = e.getCenter(),
      [i, a] = r,
      o = kn(oe(t[0], r)),
      s = kn(oe(t[1], r)),
      c = Ut(r, t[2]),
      l = Ut(r, t[3]),
      u = Ut(r, t[8]),
      f = Ut(r, t[10]),
      h = Ut(r, t[11])
    n.moveTo(...t[0]),
      n.arc(i, a, c, o, s),
      n.arc(i, a, c, s, o, !0),
      n.moveTo(...t[2]),
      n.lineTo(...t[3]),
      n.moveTo(...t[4]),
      n.arc(i, a, l, o, s),
      n.lineTo(...t[6]),
      n.arc(i, a, f, s, o, !0),
      n.closePath(),
      n.moveTo(...t[8]),
      n.arc(i, a, u, o, s),
      n.arc(i, a, u, s, o, !0),
      n.moveTo(...t[10]),
      n.lineTo(...t[11]),
      n.moveTo(...t[12]),
      n.arc(i, a, h, o, s),
      n.arc(i, a, h, s, o, !0)
  }
  return n
}
const fS = (t, e) => {
  const { coordinate: n, document: r } = e
  return (i, a, o) => {
    const { color: s, transform: c } = a,
      { color: l, fill: u = l, stroke: f = l } = o,
      h = c9(o, ['color', 'fill', 'stroke']),
      d = l9(i, n)
    return ot(r.createElement('path', {}))
      .call(at, h)
      .style('d', d.toString())
      .style('stroke', f)
      .style('fill', s || u)
      .style('transform', c)
      .call(at, t)
      .node()
  }
}
fS.props = {
  defaultMarker: 'point',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var u9 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function f9(t, e, n = 4) {
  const r = Nn()
  if (!Zt(e))
    return (
      r.moveTo(...t[2]),
      r.lineTo(...t[3]),
      r.lineTo(t[3][0] - n, t[3][1]),
      r.lineTo(t[10][0] - n, t[10][1]),
      r.lineTo(t[10][0] + n, t[10][1]),
      r.lineTo(t[3][0] + n, t[3][1]),
      r.lineTo(...t[3]),
      r.closePath(),
      r.moveTo(...t[10]),
      r.lineTo(...t[11]),
      r.moveTo(t[3][0] + n / 2, t[8][1]),
      r.arc(t[3][0], t[8][1], n / 2, 0, Math.PI * 2),
      r.closePath(),
      r
    )
  const i = e.getCenter(),
    [a, o] = i,
    s = Ut(i, t[3]),
    c = Ut(i, t[8]),
    l = Ut(i, t[10]),
    u = kn(oe(t[2], i)),
    f = Math.asin(n / c),
    h = u - f,
    d = u + f
  r.moveTo(...t[2]),
    r.lineTo(...t[3]),
    r.moveTo(Math.cos(h) * s + a, Math.sin(h) * s + o),
    r.arc(a, o, s, h, d),
    r.lineTo(Math.cos(d) * l + a, Math.sin(d) * l + o),
    r.arc(a, o, l, d, h, !0),
    r.lineTo(Math.cos(h) * s + a, Math.sin(h) * s + o),
    r.closePath(),
    r.moveTo(...t[10]),
    r.lineTo(...t[11])
  const p = (h + d) / 2
  return (
    r.moveTo(Math.cos(p) * (c + n / 2) + a, Math.sin(p) * (c + n / 2) + o),
    r.arc(Math.cos(p) * c + a, Math.sin(p) * c + o, n / 2, p, Math.PI * 2 + p),
    r.closePath(),
    r
  )
}
const hS = (t, e) => {
  const { coordinate: n, document: r } = e
  return (i, a, o) => {
    const { color: s, transform: c } = a,
      l = 4,
      { color: u, fill: f = u, stroke: h = u } = o,
      d = u9(o, ['color', 'fill', 'stroke']),
      p = f9(i, n, l)
    return ot(r.createElement('path', {}))
      .call(at, d)
      .style('d', p.toString())
      .style('stroke', h)
      .style('fill', s || f)
      .style('transform', c)
      .call(at, t)
      .node()
  }
}
hS.props = {
  defaultMarker: 'point',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var py =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function h9(t, e, n) {
  return t.createElement('path', {
    style: Object.assign(
      {
        path: `M ${e},${e} L -${e},0 L ${e},-${e} L 0,0 Z`,
        anchor: '0.5 0.5',
        transformOrigin: 'center'
      },
      n
    )
  })
}
function d9(t, e) {
  if (!Zt(e))
    return Kr()
      .x((r) => r[0])
      .y((r) => r[1])(t)
  const n = e.getCenter()
  return lp()({
    startAngle: 0,
    endAngle: Math.PI * 2,
    outerRadius: Ut(t[0], n),
    innerRadius: Ut(t[1], n)
  })
}
function p9(t, e) {
  if (!Zt(t)) return e
  const [n, r] = t.getCenter()
  return `translate(${n}, ${r}) ${e || ''}`
}
const Kp = (t, e) => {
  const { arrow: n, arrowSize: r = 4 } = t,
    i = py(t, ['arrow', 'arrowSize']),
    { coordinate: a, document: o } = e
  return (s, c, l) => {
    const { color: u, lineWidth: f } = l,
      h = py(l, ['color', 'lineWidth']),
      { color: d = u, size: p = f } = c,
      v = n
        ? h9(o, r, Object.assign({ fill: i.stroke || d, stroke: i.stroke || d }, et(i, 'arrow')))
        : null,
      g = d9(s, a),
      y = p9(a, c.transform)
    return ot(o.createElement('path', {}))
      .call(at, h)
      .style('d', g)
      .style('stroke', d)
      .style('lineWidth', p)
      .style('transform', y)
      .style('markerEnd', v)
      .call(at, i)
      .node()
  }
}
Kp.props = {
  defaultMarker: 'line',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var vy =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function v9(t, e, n) {
  return [['M', t, e], ['L', t + 2 * n, e - n], ['L', t + 2 * n, e + n], ['Z']]
}
function g9(t) {
  return Kr()
    .x((e) => e[0])
    .y((e) => e[1])(t)
}
function y9(t, e, n, r, i = 0) {
  const [[a, o], [s, c]] = e
  if (ce(t)) {
    const h = a + n,
      d = s + r,
      p = h + i
    return [
      [h, o],
      [p, o],
      [p, c],
      [d, c]
    ]
  }
  const l = o - n,
    u = c - r,
    f = l - i
  return [
    [a, l],
    [a, f],
    [s, f],
    [s, u]
  ]
}
const dS = (t, e) => {
  const { offset: n = 0, offset1: r = n, offset2: i = n, connectLength1: a, endMarker: o = !0 } = t,
    s = vy(t, ['offset', 'offset1', 'offset2', 'connectLength1', 'endMarker']),
    { coordinate: c } = e
  return (l, u, f) => {
    const { color: h, connectLength1: d } = f,
      p = vy(f, ['color', 'connectLength1']),
      { color: v, transform: g } = u,
      y = y9(c, l, r, i, a ?? d),
      m = et(Object.assign(Object.assign({}, s), f), 'endMarker')
    return ot(new rn())
      .call(at, p)
      .style('path', g9(y))
      .style('stroke', v || h)
      .style('transform', g)
      .style(
        'markerEnd',
        o
          ? new $t({
              className: 'marker',
              style: Object.assign(Object.assign({}, m), { symbol: v9 })
            })
          : null
      )
      .call(at, s)
      .node()
  }
}
dS.props = {
  defaultMarker: 'line',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
function pS(t) {
  return t.replace(/-(\w)/g, function (e, n) {
    return n.toUpperCase()
  })
}
function m9(t) {
  return t.replace(/([A-Z])/g, '-$1').toLowerCase()
}
function b9(t, e, n, r) {
  const i = e.length / 2,
    a = e.slice(0, i),
    o = e.slice(i)
  let s = qa(a, (d, p) => Math.abs(d[1] - o[p][1]))
  s = Math.max(Math.min(s, i - 2), 1)
  const c = (d) => [a[d][0], (a[d][1] + o[d][1]) / 2],
    l = c(s),
    u = c(s - 1),
    f = c(s + 1),
    h = (kn(oe(f, u)) / Math.PI) * 180
  return {
    x: l[0],
    y: l[1],
    transform: `rotate(${h})`,
    textAlign: 'center',
    textBaseline: 'middle'
  }
}
function vS(t, e, n, r) {
  const { bounds: i } = n,
    [[a, o], [s, c]] = i,
    l = s - a,
    u = c - o,
    f = (h) => {
      const { x: d, y: p } = h,
        v = Ov(n.x, l),
        g = Ov(n.y, u)
      return Object.assign(Object.assign({}, h), { x: (v || d) + a, y: (g || p) + o })
    }
  return f(
    t === 'left'
      ? { x: 0, y: u / 2, textAnchor: 'start', textBaseline: 'middle' }
      : t === 'right'
      ? { x: l, y: u / 2, textAnchor: 'end', textBaseline: 'middle' }
      : t === 'top'
      ? { x: l / 2, y: 0, textAnchor: 'center', textBaseline: 'top' }
      : t === 'bottom'
      ? { x: l / 2, y: u, textAnchor: 'center', textBaseline: 'bottom' }
      : t === 'top-left'
      ? { x: 0, y: 0, textAnchor: 'start', textBaseline: 'top' }
      : t === 'top-right'
      ? { x: l, y: 0, textAnchor: 'end', textBaseline: 'top' }
      : t === 'bottom-left'
      ? { x: 0, y: u, textAnchor: 'start', textBaseline: 'bottom' }
      : t === 'bottom-right'
      ? { x: l, y: u, textAnchor: 'end', textBaseline: 'bottom' }
      : { x: l / 2, y: u / 2, textAnchor: 'center', textBaseline: 'middle' }
  )
}
function gS(t, e, n, r) {
  const { y: i, y1: a, autoRotate: o, rotateToAlignArc: s } = n,
    c = r.getCenter(),
    l = Qa(r, e, [i, a]),
    { innerRadius: u, outerRadius: f, startAngle: h, endAngle: d } = l,
    p = t === 'inside' ? (h + d) / 2 : d,
    v = Zp(p, o, s),
    g = (() => {
      const [y, m] = e,
        b = u + (f - u) * 0.5,
        [x, w] = t === 'inside' ? cs(c, p, b) : t2(y, m)
      return { x, y: w }
    })()
  return Object.assign(Object.assign({}, g), {
    textAlign: t === 'inside' ? 'center' : 'start',
    textBaseline: 'middle',
    rotate: v
  })
}
function cs(t, e, n) {
  return [t[0] + Math.sin(e) * n, t[1] - Math.cos(e) * n]
}
function Zp(t, e, n) {
  if (!e) return 0
  const r = n ? 0 : Math.sin(t) < 0 ? 90 : -90
  return (t / Math.PI) * 180 + r
}
function x9(t, e, n, r) {
  const { y: i, y1: a, autoRotate: o, rotateToAlignArc: s, radius: c = 0.5, offset: l = 0 } = n,
    u = Qa(r, e, [i, a]),
    { startAngle: f, endAngle: h } = u,
    d = r.getCenter(),
    p = (f + h) / 2,
    g = { textAlign: 'center', textBaseline: 'middle', rotate: Zp(p, o, s) },
    { innerRadius: y, outerRadius: m } = u,
    x = y + (m - y) * c + l,
    [w, O] = cs(d, p, x)
  return Object.assign({ x: w, y: O }, g)
}
function gy(t) {
  return t === void 0 ? null : t
}
function yS(t, e, n, r) {
  const { bounds: i } = n,
    [a] = i
  return { x: gy(a[0]), y: gy(a[1]) }
}
function fr(t, e, n, r) {
  const { bounds: i } = n
  return i.length === 1 ? yS(t, e, n) : (su(r) ? gS : Ka(r) ? x9 : vS)(t, e, n, r)
}
function w9(t, e, n, r, i) {
  const [a, o] = cs(t, e, n),
    [s, c] = cs(t, e, r),
    l = Math.sin(e) > 0 ? 1 : -1
  return [
    [a, o],
    [s, c],
    [s + l * i, c]
  ]
}
function mS(t, e, n) {
  const r = Qa(n, t, [e.y, e.y1]),
    { innerRadius: i, outerRadius: a } = r
  return i + (a - i)
}
function bS(t, e, n) {
  const r = Qa(n, t, [e.y, e.y1]),
    { startAngle: i, endAngle: a } = r
  return (i + a) / 2
}
function Qp(t, e, n, r) {
  const {
      autoRotate: i,
      rotateToAlignArc: a,
      offset: o = 0,
      connector: s = !0,
      connectorLength: c = o,
      connectorLength2: l = 0,
      connectorDistance: u = 0
    } = n,
    f = r.getCenter(),
    h = bS(e, n, r),
    d = Math.sin(h) > 0 ? 1 : -1,
    p = Zp(h, i, a),
    v = { textAlign: d > 0 || su(r) ? 'start' : 'end', textBaseline: 'middle', rotate: p },
    g = mS(e, n, r),
    y = g + (s ? c : o),
    [[m, b], [x, w], [O, S]] = w9(f, h, g, y, s ? l : 0),
    _ = s ? +u * d : 0,
    M = O + _,
    E = S,
    T = {
      connector: s,
      connectorPoints: [
        [x - M, w - E],
        [O - M, S - E]
      ]
    }
  return Object.assign(Object.assign({ x0: m, y0: b, x: O + _, y: S }, v), T)
}
function O9(t, e, n, r) {
  const { bounds: i } = n
  return i.length === 1 ? yS(t, e, n) : (su(r) ? gS : Ka(r) ? Qp : vS)(t, e, n, r)
}
var S9 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function _9(t, e, n, r) {
  if (!Ka(r)) return {}
  const { connectorLength: i, connectorLength2: a, connectorDistance: o } = n,
    s = S9(Qp('outside', e, n, r), []),
    c = r.getCenter(),
    l = mS(e, n, r),
    u = bS(e, n, r),
    f = l + i + a,
    h = Math.sin(u) > 0 ? 1 : -1,
    d = c[0] + (f + +o) * h,
    { x: p } = s,
    v = d - p
  return (s.x += v), (s.connectorPoints[0][0] -= v), s
}
var M9 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function E9(t, e, n, r) {
  if (!Ka(r)) return {}
  const { connectorLength: i, connectorLength2: a, connectorDistance: o } = n,
    s = M9(Qp('outside', e, n, r), []),
    { x0: c, y0: l } = s,
    u = r.getCenter(),
    h = PC(r) + i,
    d = Ca([c - u[0], l - u[1]]),
    p = Math.sin(d) > 0 ? 1 : -1,
    [v, g] = cs(u, d, h)
  return (s.x = v + (a + o) * p), (s.y = g), s
}
const T9 = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      area: b9,
      bottom: fr,
      bottomLeft: fr,
      bottomRight: fr,
      inside: fr,
      left: fr,
      outside: O9,
      right: fr,
      spider: _9,
      surround: E9,
      top: fr,
      topLeft: fr,
      topRight: fr
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
var yy =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function P9(t, e) {
  return t !== void 0 ? t : Ka(e) ? 'inside' : ce(e) ? 'right' : 'top'
}
function A9(t, e, n, r, i) {
  const { position: a } = e,
    { render: o } = i,
    s = P9(a, n),
    l = r[o ? 'htmlLabel' : s === 'inside' ? 'innerLabel' : 'label'],
    u = Object.assign({}, l, e),
    f = T9[pS(s)]
  if (!f) throw new Error(`Unknown position: ${s}`)
  return Object.assign(Object.assign({}, l), f(s, t, u, n, i))
}
const xS = (t, e) => {
  const { coordinate: n, theme: r } = e,
    { render: i } = t
  return (a, o) => {
    const { text: s, x: c, y: l, transform: u = '', transformOrigin: f, className: h = '' } = o,
      d = yy(o, ['text', 'x', 'y', 'transform', 'transformOrigin', 'className']),
      p = A9(a, o, n, r, t),
      { rotate: v = 0, transform: g = '' } = p,
      y = yy(p, ['rotate', 'transform'])
    return ot(new zO())
      .call(at, y)
      .style('text', `${s}`)
      .style('className', `${h} g2-label`)
      .style('innerHTML', i ? i(s, o.datum, o.index) : void 0)
      .style('labelTransform', `${g} rotate(${+v}) ${u}`.trim())
      .style('labelTransformOrigin', f)
      .style('coordCenter', n.getCenter())
      .call(at, d)
      .node()
  }
}
xS.props = { defaultMarker: 'point' }
var my =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const Jp = (t, e) => {
  const { arrow: n, colorAttribute: r } = t,
    i = my(t, ['arrow', 'colorAttribute']),
    { coordinate: a, document: o } = e
  return (s, c, l) => {
    const { color: u, stroke: f } = l,
      h = my(l, ['color', 'stroke']),
      { d, color: p = u } = c,
      [v, g] = a.getSize()
    return ot(o.createElement('path', {}))
      .call(at, h)
      .style('d', typeof d == 'function' ? d({ width: v, height: g }) : d)
      .style(r, p)
      .call(at, i)
      .node()
  }
}
Jp.props = {
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
const wS = (t, e) => Jp(Object.assign({ colorAttribute: 'fill' }, t), e)
wS.props = {
  defaultMarker: 'hvh',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
const OS = (t, e) => Jp(Object.assign({ fill: 'none', colorAttribute: 'stroke' }, t), e)
OS.props = {
  defaultMarker: 'hvh',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var k9 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const SS = (t, e) => {
  const { document: n } = e
  return (r, i, a) => {
    const { transform: o } = i,
      { color: s } = a,
      c = k9(a, ['color']),
      { color: l = s } = i,
      [u, ...f] = r,
      h = Nn()
    return (
      h.moveTo(...u),
      f.forEach(([d, p]) => {
        h.lineTo(d, p)
      }),
      h.closePath(),
      ot(n.createElement('path', {}))
        .call(at, c)
        .style('d', h.toString())
        .style('stroke', l || s)
        .style('fill', l || s)
        .style('fillOpacity', 0.4)
        .style('transform', o)
        .call(at, t)
        .node()
    )
  }
}
SS.props = {
  defaultMarker: 'square',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
Dd(3)
function C9(t, e = (...r) => `${r[0]}`, n = 16) {
  const r = Dd(n)
  return (...i) => {
    const a = e(...i)
    let o = r.get(a)
    return r.has(a) ? r.get(a) : ((o = t(...i)), r.set(a, o), o)
  }
}
function L9(t) {
  return typeof t == 'string'
    ? t.split(' ').map((e) => {
        const [n, r] = e.split(':')
        return [+n, r]
      })
    : t
}
function bl(t, e, n) {
  const r = t ? t() : document.createElement('canvas')
  return (r.width = e), (r.height = n), r
}
const N9 = C9(
  (t, e, n) => {
    const r = bl(n, t * 2, t * 2),
      i = r.getContext('2d'),
      a = t,
      o = t
    if (e === 1)
      i.beginPath(), i.arc(a, o, t, 0, 2 * Math.PI, !1), (i.fillStyle = 'rgba(0,0,0,1)'), i.fill()
    else {
      const s = i.createRadialGradient(a, o, t * e, a, o, t)
      s.addColorStop(0, 'rgba(0,0,0,1)'),
        s.addColorStop(1, 'rgba(0,0,0,0)'),
        (i.fillStyle = s),
        i.fillRect(0, 0, 2 * t, 2 * t)
    }
    return r
  },
  (t) => `${t}`
)
function R9(t, e) {
  const r = bl(e, 256, 1).getContext('2d'),
    i = r.createLinearGradient(0, 0, 256, 1)
  return (
    L9(t).forEach(([a, o]) => {
      i.addColorStop(a, o)
    }),
    (r.fillStyle = i),
    r.fillRect(0, 0, 256, 1),
    r.getImageData(0, 0, 256, 1).data
  )
}
function I9(t, e, n, r, i, a) {
  const { blur: o } = i
  let s = r.length
  for (; s--; ) {
    const { x: c, y: l, value: u, radius: f } = r[s],
      h = Math.min(u, n),
      d = c - f,
      p = l - f,
      v = N9(f, 1 - o, a),
      g = (h - e) / (n - e)
    ;(t.globalAlpha = Math.max(g, 0.001)), t.drawImage(v, d, p)
  }
  return t
}
function j9(t, e, n, r, i) {
  const { minOpacity: a, opacity: o, maxOpacity: s, useGradientOpacity: c } = i,
    l = 0,
    u = 0,
    f = e,
    h = n,
    d = t.getImageData(l, u, f, h),
    p = d.data,
    v = p.length
  for (let g = 3; g < v; g += 4) {
    const y = p[g],
      m = y * 4
    if (!m) continue
    const b = o || Math.max(0, Math.min(s, Math.max(a, y)))
    ;(p[g - 3] = r[m]), (p[g - 2] = r[m + 1]), (p[g - 1] = r[m + 2]), (p[g] = c ? r[m + 3] : b)
  }
  return d
}
function D9(t, e, n, r, i, a, o) {
  const s = Object.assign(
    {
      blur: 0.85,
      minOpacity: 0,
      opacity: 0.6,
      maxOpacity: 1,
      gradient: [
        [0.25, 'rgb(0,0,255)'],
        [0.55, 'rgb(0,255,0)'],
        [0.85, 'yellow'],
        [1, 'rgb(255,0,0)']
      ]
    },
    a
  )
  ;(s.minOpacity *= 255), (s.opacity *= 255), (s.maxOpacity *= 255)
  const l = bl(o, t, e).getContext('2d'),
    u = R9(s.gradient, o)
  l.clearRect(0, 0, t, e), I9(l, n, r, i, s, o)
  const f = j9(l, t, e, u, s),
    d = bl(o, t, e).getContext('2d')
  return d.putImageData(f, 0, 0), d
}
var $9 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function B9(t, e) {
  return Object.keys(t).reduce((n, r) => {
    const i = t[r]
    return e(i, r) || (n[r] = i), n
  }, {})
}
const _S = (t, e) => {
  const {
      gradient: n,
      opacity: r,
      maxOpacity: i,
      minOpacity: a,
      blur: o,
      useGradientOpacity: s
    } = t,
    c = $9(t, ['gradient', 'opacity', 'maxOpacity', 'minOpacity', 'blur', 'useGradientOpacity']),
    { coordinate: l, createCanvas: u, document: f } = e
  return (h, d, p) => {
    const { transform: v } = d,
      [g, y] = l.getSize(),
      m = h.map((S) => ({ x: S[0], y: S[1], value: S[2], radius: S[3] })),
      b = gn(h, (S) => S[2]),
      x = Ct(h, (S) => S[2]),
      O =
        g && y
          ? D9(
              g,
              y,
              b,
              x,
              m,
              B9(
                {
                  gradient: n,
                  opacity: r,
                  minOpacity: a,
                  maxOpacity: i,
                  blur: o,
                  useGradientOpacity: s
                },
                (S) => S === void 0
              ),
              u
            )
          : { canvas: null }
    return ot(f.createElement('image', {}))
      .call(at, p)
      .style('x', 0)
      .style('y', 0)
      .style('width', g)
      .style('height', y)
      .style('src', O.canvas)
      .style('transform', v)
      .call(at, c)
      .node()
  }
}
_S.props = {
  defaultMarker: 'point',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
var F9 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const MS = (t, e) => {
  const { render: n } = t,
    r = F9(t, ['render'])
  return (i) => {
    const [[a, o]] = i
    return n(Object.assign(Object.assign({}, r), { x: a, y: o }), e)
  }
}
MS.props = {
  defaultMarker: 'point',
  defaultEnterAnimation: 'fadeIn',
  defaultUpdateAnimation: 'morphing',
  defaultExitAnimation: 'fadeOut'
}
const by = 5e3
function xy(t, e, n) {
  return t + (e - t) * n
}
function z9(t, e, n, r) {
  return e === 0
    ? [
        [t + ((1 / 2) * n) / Math.PI / 2, r / 2],
        [t + ((1 / 2) * n) / Math.PI, r],
        [t + n / 4, r]
      ]
    : e === 1
    ? [
        [t + (((1 / 2) * n) / Math.PI / 2) * (Math.PI - 2), r],
        [t + (((1 / 2) * n) / Math.PI / 2) * (Math.PI - 1), r / 2],
        [t + n / 4, 0]
      ]
    : e === 2
    ? [
        [t + ((1 / 2) * n) / Math.PI / 2, -r / 2],
        [t + ((1 / 2) * n) / Math.PI, -r],
        [t + n / 4, -r]
      ]
    : [
        [t + (((1 / 2) * n) / Math.PI / 2) * (Math.PI - 2), -r],
        [t + (((1 / 2) * n) / Math.PI / 2) * (Math.PI - 1), -r / 2],
        [t + n / 4, 0]
      ]
}
function G9(t, e, n, r, i, a, o) {
  const s = Math.ceil(((2 * t) / n) * 4) * 4,
    c = []
  let l = r
  for (; l < -Math.PI * 2; ) l += Math.PI * 2
  for (; l > 0; ) l -= Math.PI * 2
  l = (l / Math.PI / 2) * n
  const u = a - t + l - t * 2
  c.push(['M', u, e])
  let f = 0
  for (let h = 0; h < s; ++h) {
    const d = h % 4,
      p = z9((h * n) / 4, d, n, i)
    c.push(['C', p[0][0] + u, -p[0][1] + e, p[1][0] + u, -p[1][1] + e, p[2][0] + u, -p[2][1] + e]),
      h === s - 1 && (f = p[2][0])
  }
  return c.push(['L', f + u, o + t]), c.push(['L', u, o + t]), c.push(['Z']), c
}
function W9(t, e, n, r, i, a, o, s, c, l, u) {
  const { fill: f, fillOpacity: h, opacity: d } = i
  for (let p = 0; p < r; p++) {
    const v = r <= 1 ? 1 : p / (r - 1),
      g = G9(s, o + s * n, c, 0, s / 40, t, e),
      y = u.createElement('path', {
        style: { path: g, fill: f, opacity: xy(0.2, 0.9, v) * Number(d || h) }
      })
    a.appendChild(y)
    try {
      if (l === !1) return
      const m = [{ transform: 'translate(0, 0)' }, { transform: `translate(${c * 2}px, 0)` }]
      y.animate(m, { duration: xy(0.5 * by, by, v) * 2, iterations: 1 / 0 })
    } catch {
      console.warn('off-screen group animate error!')
    }
  }
}
function Y9(t, e, n) {
  return `
      M ${t} ${e - n} 
      a ${n} ${n} 0 1 0 0 ${n * 2}
      a ${n} ${n} 0 1 0 0 ${-n * 2}
      Z
    `
}
function H9(t, e, n) {
  const i = n * 0.618
  return `
      M ${t - i} ${e - n}
      L ${t + i} ${e - n}
      L ${t + i} ${e + n}
      L ${t - i} ${e + n}
      Z
    `
}
function V9(t, e, n) {
  return `
      M ${t} ${e - n}
      L ${t + n} ${e}
      L ${t} ${e + n}
      L ${t - n} ${e}
      Z
    `
}
function X9(t, e, n) {
  return `
      M ${t} ${e - n}
      L ${t + n} ${e + n}
      L ${t - n} ${e + n}
      Z
    `
}
function U9(t, e, n) {
  const r = (n * 4) / 3,
    i = Math.max(r, n * 2),
    a = r / 2,
    o = t,
    s = a + e - i / 2,
    c = Math.asin(a / ((i - a) * 0.85)),
    l = Math.sin(c) * a,
    u = Math.cos(c) * a,
    f = o - u,
    h = s + l,
    d = t,
    p = s + a / Math.sin(c)
  return `
      M ${f} ${h}
      A ${a} ${a} 0 1 1 ${f + u * 2} ${h}
      Q ${d} ${p} ${t} ${e + i / 2}
      Q ${d} ${p} ${f} ${h}
      Z 
    `
}
const wy = { pin: U9, rect: H9, circle: Y9, diamond: V9, triangle: X9 }
var Oy =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const q9 = (t = 'circle') => wy[t] || wy.circle,
  ES = (t, e) => {
    if (!e) return
    const { coordinate: n } = e,
      { liquidOptions: r, styleOptions: i } = t,
      { liquidShape: a, percent: o } = r,
      { background: s, outline: c = {}, wave: l = {} } = i,
      u = Oy(i, ['background', 'outline', 'wave']),
      { border: f = 2, distance: h = 0 } = c,
      d = Oy(c, ['border', 'distance']),
      { length: p = 192, count: v = 3 } = l
    return (g, y, m) => {
      const { document: b } = e.canvas,
        { color: x, fillOpacity: w } = m,
        O = Object.assign(Object.assign({ fill: x }, m), u),
        S = b.createElement('g', {}),
        [_, M] = n.getCenter(),
        E = n.getSize(),
        T = Math.min(...E) / 2,
        A = (mn(a) ? a : q9(a))(_, M, T, ...E)
      if (Object.keys(s).length) {
        const L = b.createElement('path', { style: Object.assign({ path: A, fill: '#fff' }, s) })
        S.appendChild(L)
      }
      if (o > 0) {
        const L = b.createElement('path', { style: { path: A } })
        S.appendChild(L),
          (S.style.clipPath = L),
          W9(_, M, 1 - o, v, O, S, L.getBBox().y, T * 2, p, !0, b)
      }
      const P = b.createElement('path', {
          style: { path: A, fill: 'transparent', lineWidth: f + 2 * h, stroke: '#fff' }
        }),
        k = b.createElement('path', {
          style: Object.assign(
            Object.assign(
              Object.assign({ path: A, stroke: x, strokeOpacity: w, lineWidth: f }, O),
              d
            ),
            { fill: 'transparent' }
          )
        })
      return S.appendChild(P), S.appendChild(k), S
    }
  }
ES.props = {}
function Sy(t, e) {
  return t.getBandWidth(t.invert(e))
}
const _y = { rect: Ui, hollow: yu, funnel: kp, pyramid: vw },
  TS = () => (t, e, n, r) => {
    const { x: i, y: a, y1: o, series: s, size: c } = n,
      l = e.x,
      u = e.series,
      [f] = r.getSize(),
      h = c ? c.map((v) => +v / f) : null,
      d = c
        ? (v, g, y) => {
            const m = v + g / 2,
              b = h[y]
            return [m - b / 2, m + b / 2]
          }
        : (v, g, y) => [v, v + g],
      p = Array.from(t, (v) => {
        const g = Sy(l, i[v]),
          y = u ? Sy(u, s == null ? void 0 : s[v]) : 1,
          m = g * y,
          b = (+(s == null ? void 0 : s[v]) || 0) * g,
          x = +i[v] + b,
          [w, O] = d(x, m, v),
          S = +a[v],
          _ = +o[v]
        return [
          [w, S],
          [O, S],
          [O, _],
          [w, _]
        ].map((A) => r.map(A))
      })
    return [t, p]
  }
TS.props = {
  defaultShape: 'rect',
  defaultLabelShape: 'label',
  composite: !1,
  shape: _y,
  channels: [
    ...Ye({ shapes: Object.keys(_y) }),
    { name: 'x', scale: 'band', required: !0 },
    { name: 'y', required: !0 },
    { name: 'series', scale: 'band' },
    { name: 'size' }
  ],
  preInference: [...de(), { type: Os }, { type: Hi }],
  postInference: [...ge(), ...to()],
  interaction: { shareTooltip: !0 }
}
const My = { rect: Ui, hollow: yu },
  PS = () => (t, e, n, r) => {
    const { x: i, x1: a, y: o, y1: s } = n,
      c = Array.from(t, (l) => {
        const u = [+i[l], +o[l]],
          f = [+a[l], +o[l]],
          h = [+a[l], +s[l]],
          d = [+i[l], +s[l]]
        return [u, f, h, d].map((p) => r.map(p))
      })
    return [t, c]
  }
PS.props = {
  defaultShape: 'rect',
  defaultLabelShape: 'label',
  composite: !1,
  shape: My,
  channels: [
    ...Ye({ shapes: Object.keys(My) }),
    { name: 'x', required: !0 },
    { name: 'y', required: !0 }
  ],
  preInference: [...de(), { type: Os }],
  postInference: [...ge(), ...to()],
  interaction: { shareTooltip: !0 }
}
const Ey = { line: gw, smooth: yw, hv: mw, vh: bw, hvh: xw, trail: ww },
  K9 = (t, e, n, r) => {
    var i, a
    const { series: o, x: s, y: c } = n,
      { x: l, y: u } = e
    if (s === void 0 || c === void 0) throw new Error('Missing encode for x or y channel.')
    const f = o ? Array.from(qt(t, (g) => o[g]).values()) : [t],
      h = f.map((g) => g[0]).filter((g) => g !== void 0),
      d =
        (((i = l == null ? void 0 : l.getBandWidth) === null || i === void 0
          ? void 0
          : i.call(l)) || 0) / 2,
      p =
        (((a = u == null ? void 0 : u.getBandWidth) === null || a === void 0
          ? void 0
          : a.call(u)) || 0) / 2,
      v = Array.from(f, (g) => g.map((y) => r.map([+s[y] + d, +c[y] + p])))
    return [h, v, f]
  },
  Z9 = (t, e, n, r) => {
    const i = Object.entries(n)
      .filter(([o]) => o.startsWith('position'))
      .map(([, o]) => o)
    if (i.length === 0) throw new Error('Missing encode for position channel.')
    const a = Array.from(t, (o) => {
      const s = i.map((u) => +u[o]),
        c = r.map(s),
        l = []
      for (let u = 0; u < c.length; u += 2) l.push([c[u], c[u + 1]])
      return l
    })
    return [t, a]
  },
  AS = () => (t, e, n, r) => (cu(r) ? Z9 : K9)(t, e, n, r)
AS.props = {
  defaultShape: 'line',
  defaultLabelShape: 'label',
  composite: !1,
  shape: Ey,
  channels: [
    ...Ye({ shapes: Object.keys(Ey) }),
    { name: 'x' },
    { name: 'y' },
    { name: 'position', independent: !0 },
    { name: 'size' },
    { name: 'series', scale: 'band' }
  ],
  preInference: [...de(), { type: Xb }, { type: Zd }],
  postInference: [...ge(), ...to(), ...n9()],
  interaction: { shareTooltip: !0, seriesTooltip: !0, crosshairs: !0 }
}
const Ty = {
    hollow: Yw,
    hollowDiamond: Gw,
    hollowHexagon: Ww,
    hollowSquare: Hw,
    hollowTriangleDown: Xw,
    hollowTriangle: Vw,
    hollowBowtie: zw,
    point: eO,
    plus: tO,
    diamond: Kw,
    square: nO,
    triangle: iO,
    hexagon: Zw,
    cross: qw,
    bowtie: Uw,
    hyphen: Qw,
    line: Jw,
    tick: rO,
    triangleDown: aO
  },
  kS = (t) => (e, n, r, i) => {
    const { x: a, y: o, x1: s, y1: c, size: l, dx: u, dy: f } = r,
      [h, d] = i.getSize(),
      p = qi(n, r, t),
      v = (y) => {
        const m = +((u == null ? void 0 : u[y]) || 0),
          b = +((f == null ? void 0 : f[y]) || 0),
          x = s ? (+a[y] + +s[y]) / 2 : +a[y],
          w = c ? (+o[y] + +c[y]) / 2 : +o[y],
          O = x + m,
          S = w + b
        return [O, S]
      },
      g = l
        ? Array.from(e, (y) => {
            const [m, b] = v(y),
              x = +l[y],
              w = x / h,
              O = x / d,
              S = [m - w, b - O],
              _ = [m + w, b + O]
            return [i.map(p(S, y)), i.map(p(_, y))]
          })
        : Array.from(e, (y) => [i.map(p(v(y), y))])
    return [e, g]
  }
kS.props = {
  defaultShape: 'hollow',
  defaultLabelShape: 'label',
  composite: !1,
  shape: Ty,
  channels: [
    ...Ye({ shapes: Object.keys(Ty) }),
    { name: 'x', required: !0 },
    { name: 'y', required: !0 },
    { name: 'series', scale: 'band' },
    { name: 'size', quantitative: 'sqrt' },
    { name: 'dx', scale: 'identity' },
    { name: 'dy', scale: 'identity' }
  ],
  preInference: [...de(), { type: Hi }, { type: Zl }],
  postInference: [...ge(), { type: Fb }, ...ci()]
}
const Py = { text: GO, badge: WO },
  CS = (t) => {
    const { cartesian: e = !1 } = t
    return e
      ? qp
      : (n, r, i, a) => {
          const { x: o, y: s } = i,
            c = qi(r, i, t),
            l = Array.from(n, (u) => {
              const f = [+o[u], +s[u]]
              return [a.map(c(f, u))]
            })
          return [n, l]
        }
  }
CS.props = {
  defaultShape: 'text',
  defaultLabelShape: 'label',
  composite: !1,
  shape: Py,
  channels: [
    ...Ye({ shapes: Object.keys(Py) }),
    { name: 'x', required: !0 },
    { name: 'y', required: !0 },
    { name: 'text', scale: 'identity' },
    { name: 'fontSize' },
    { name: 'rotate' }
  ],
  preInference: [...de(), { type: tu }, { type: Jl }],
  postInference: [...ge(), ...ci()]
}
const Ay = { cell: Ui, hollow: yu },
  LS = () => (t, e, n, r) => {
    const { x: i, y: a } = n,
      o = e.x,
      s = e.y,
      c = Array.from(t, (l) => {
        const u = o.getBandWidth(o.invert(+i[l])),
          f = s.getBandWidth(s.invert(+a[l])),
          h = +i[l],
          d = +a[l],
          p = [h, d],
          v = [h + u, d],
          g = [h + u, d + f],
          y = [h, d + f]
        return [p, v, g, y].map((m) => r.map(m))
      })
    return [t, c]
  }
LS.props = {
  defaultShape: 'cell',
  defaultLabelShape: 'label',
  shape: Ay,
  composite: !1,
  channels: [
    ...Ye({ shapes: Object.keys(Ay) }),
    { name: 'x', required: !0, scale: 'band' },
    { name: 'y', required: !0, scale: 'band' }
  ],
  preInference: [...de(), { type: Hi }, { type: Zl }, { type: Qd }],
  postInference: [...ge(), ...ci()]
}
const ky = { area: YO, smooth: HO, hvh: VO, vh: XO, hv: UO },
  NS = () => (t, e, n, r) => {
    var i, a
    const { x: o, y: s, y1: c, series: l } = n,
      { x: u, y: f } = e,
      h = l ? Array.from(qt(t, (y) => l[y]).values()) : [t],
      d = h.map((y) => y[0]).filter((y) => y !== void 0),
      p =
        (((i = u == null ? void 0 : u.getBandWidth) === null || i === void 0
          ? void 0
          : i.call(u)) || 0) / 2,
      v =
        (((a = f == null ? void 0 : f.getBandWidth) === null || a === void 0
          ? void 0
          : a.call(f)) || 0) / 2,
      g = Array.from(h, (y) => {
        const m = y.length,
          b = new Array(m * 2)
        for (let x = 0; x < y.length; x++) {
          const w = y[x]
          ;(b[x] = r.map([+o[w] + p, +s[w] + v])), (b[m + x] = r.map([+o[w] + p, +c[w] + v]))
        }
        return b
      })
    return [d, g, h]
  }
NS.props = {
  defaultShape: 'area',
  defaultLabelShape: 'label',
  composite: !1,
  shape: ky,
  channels: [
    ...Ye({ shapes: Object.keys(ky) }),
    { name: 'x', required: !0 },
    { name: 'y', required: !0 },
    { name: 'size' },
    { name: 'series', scale: 'band' }
  ],
  preInference: [...de(), { type: Zd }, { type: Os }, { type: Qd }],
  postInference: [...ge(), ...to()],
  interaction: { shareTooltip: !0, seriesTooltip: !0, crosshairs: !0 }
}
const Cy = { link: qO, arc: QO, smooth: KO, vhv: ZO },
  t0 = (t) => (e, n, r, i) => {
    const { x: a, y: o, x1: s = a, y1: c = o } = r,
      l = qi(n, r, t),
      u = e.map((f) => [i.map(l([+a[f], +o[f]], f)), i.map(l([+s[f], +c[f]], f))])
    return [e, u]
  }
t0.props = {
  defaultShape: 'link',
  defaultLabelShape: 'label',
  composite: !1,
  shape: Cy,
  channels: [
    ...Ye({ shapes: Object.keys(Cy) }),
    { name: 'x', required: !0 },
    { name: 'y', required: !0 }
  ],
  preInference: [...de(), { type: Yb }, { type: Hb }],
  postInference: [...ge(), ...ci()]
}
const Ly = { image: cS },
  RS = (t) => {
    const { cartesian: e } = t
    return e
      ? qp
      : (n, r, i, a) => {
          const { x: o, y: s } = i,
            c = qi(r, i, t),
            l = Array.from(n, (u) => {
              const f = [+o[u], +s[u]]
              return [a.map(c(f, u))]
            })
          return [n, l]
        }
  }
RS.props = {
  defaultShape: 'image',
  defaultLabelShape: 'label',
  composite: !1,
  shape: Ly,
  channels: [
    ...Ye({ shapes: Object.keys(Ly) }),
    { name: 'x', required: !0 },
    { name: 'y', required: !0 },
    { name: 'src', scale: 'identity' },
    { name: 'size' }
  ],
  preInference: [...de(), { type: tu }, { type: Jl }],
  postInference: [...ge(), ...ci()]
}
const Ny = { polygon: lS, ribbon: uS },
  IS = () => (t, e, n, r) => {
    const i = Object.entries(n)
        .filter(([s]) => s.startsWith('x'))
        .map(([, s]) => s),
      a = Object.entries(n)
        .filter(([s]) => s.startsWith('y'))
        .map(([, s]) => s),
      o = t.map((s) => {
        const c = []
        for (let l = 0; l < i.length; l++) {
          const u = i[l][s]
          if (u === void 0) break
          const f = a[l][s]
          c.push(r.map([+u, +f]))
        }
        return c
      })
    return [t, o]
  }
IS.props = {
  defaultShape: 'polygon',
  defaultLabelShape: 'label',
  composite: !1,
  shape: Ny,
  channels: [
    ...Ye({ shapes: Object.keys(Ny) }),
    { name: 'x', required: !0 },
    { name: 'y', required: !0 }
  ],
  preInference: [...de()],
  postInference: [...ge(), ...ci()]
}
const Ry = { box: fS, violin: hS },
  jS = () => (t, e, n, r) => {
    const { x: i, y: a, y1: o, y2: s, y3: c, y4: l, series: u } = n,
      f = e.x,
      h = e.series,
      d = Array.from(t, (p) => {
        const v = f.getBandWidth(f.invert(+i[p])),
          g = h ? h.getBandWidth(h.invert(+(u == null ? void 0 : u[p]))) : 1,
          y = v * g,
          m = (+(u == null ? void 0 : u[p]) || 0) * v,
          b = +i[p] + m + y / 2,
          [x, w, O, S, _] = [+a[p], +o[p], +s[p], +c[p], +l[p]]
        return [
          [b - y / 2, _],
          [b + y / 2, _],
          [b, _],
          [b, S],
          [b - y / 2, S],
          [b + y / 2, S],
          [b + y / 2, w],
          [b - y / 2, w],
          [b - y / 2, O],
          [b + y / 2, O],
          [b, w],
          [b, x],
          [b - y / 2, x],
          [b + y / 2, x]
        ].map((E) => r.map(E))
      })
    return [t, d]
  }
jS.props = {
  defaultShape: 'box',
  defaultLabelShape: 'label',
  composite: !1,
  shape: Ry,
  channels: [
    ...Ye({ shapes: Object.keys(Ry) }),
    { name: 'x', scale: 'band', required: !0 },
    { name: 'y', required: !0 },
    { name: 'series', scale: 'band' }
  ],
  preInference: [...de(), { type: Hi }],
  postInference: [...ge(), ...to()],
  interaction: { shareTooltip: !0 }
}
const Iy = { vector: $p },
  DS = () => (t, e, n, r) => {
    const { x: i, y: a, size: o, rotate: s } = n,
      [c, l] = r.getSize(),
      u = t.map((f) => {
        const h = (+s[f] / 180) * Math.PI,
          d = +o[f],
          p = d / c,
          v = d / l,
          g = p * Math.cos(h),
          y = -v * Math.sin(h)
        return [r.map([+i[f] - g / 2, +a[f] - y / 2]), r.map([+i[f] + g / 2, +a[f] + y / 2])]
      })
    return [t, u]
  }
DS.props = {
  defaultShape: 'vector',
  defaultLabelShape: 'label',
  composite: !1,
  shape: Iy,
  channels: [
    ...Ye({ shapes: Object.keys(Iy) }),
    { name: 'x', required: !0 },
    { name: 'y', required: !0 },
    { name: 'rotate', required: !0, scale: 'identity' },
    { name: 'size', required: !0 }
  ],
  preInference: [...de()],
  postInference: [...ge(), ...ci()]
}
const jy = { line: Kp },
  $S = (t) => (e, n, r, i) => {
    const { y: a } = r,
      o = qi(n, r, X({ style: { bandOffset: 0 } }, t)),
      s = Array.from(e, (c) => {
        const l = [0, a[c]],
          u = [1, a[c]]
        return [l, u].map((f) => i.map(o(f, c)))
      })
    return [e, s]
  }
$S.props = {
  defaultShape: 'line',
  defaultLabelShape: 'label',
  composite: !1,
  shape: jy,
  channels: [...eo({ shapes: Object.keys(jy) }), { name: 'y', required: !0 }],
  preInference: [...de(), { type: Gb }],
  postInference: [...ge()]
}
const Dy = { line: Kp },
  BS = (t) => (e, n, r, i) => {
    const { x: a } = r,
      o = qi(n, r, X({ style: { bandOffset: 0 } }, t)),
      s = Array.from(e, (c) => {
        const l = [a[c], 1],
          u = [a[c], 0]
        return [l, u].map((f) => i.map(o(f, c)))
      })
    return [e, s]
  }
BS.props = {
  defaultShape: 'line',
  defaultLabelShape: 'label',
  composite: !1,
  shape: Dy,
  channels: [...eo({ shapes: Object.keys(Dy) }), { name: 'x', required: !0 }],
  preInference: [...de(), { type: Wb }],
  postInference: [...ge()]
}
const $y = { connector: dS },
  FS = (...t) => t0(...t)
FS.props = {
  defaultShape: 'connector',
  defaultLabelShape: 'label',
  composite: !1,
  shape: $y,
  channels: [
    ...eo({ shapes: Object.keys($y) }),
    { name: 'x', required: !0 },
    { name: 'y', required: !0 }
  ],
  preInference: [...de()],
  postInference: [...ge()]
}
function By(t, e, n, r) {
  if (e) return () => [0, 1]
  const { [t]: i, [`${t}1`]: a } = n
  return (o) => {
    var s
    const c =
      ((s = r.getBandWidth) === null || s === void 0 ? void 0 : s.call(r, r.invert(+a[o]))) || 0
    return [i[o], a[o] + c]
  }
}
function e0(t = {}) {
  const { extendX: e = !1, extendY: n = !1 } = t
  return (r, i, a, o) => {
    const s = By('x', e, a, i.x),
      c = By('y', n, a, i.y),
      l = Array.from(r, (u) => {
        const [f, h] = s(u),
          [d, p] = c(u)
        return [
          [f, d],
          [h, d],
          [h, p],
          [f, p]
        ].map((b) => o.map(b))
      })
    return [r, l]
  }
}
const Fy = { range: Ui },
  zS = () => e0()
zS.props = {
  defaultShape: 'range',
  defaultLabelShape: 'label',
  composite: !1,
  shape: Fy,
  channels: [
    ...eo({ shapes: Object.keys(Fy) }),
    { name: 'x', required: !0 },
    { name: 'y', required: !0 }
  ],
  preInference: [...de()],
  postInference: [...ge()]
}
const zy = { range: Ui },
  GS = () => e0({ extendY: !0 })
GS.props = {
  defaultShape: 'range',
  defaultLabelShape: 'label',
  composite: !1,
  shape: zy,
  channels: [...eo({ shapes: Object.keys(zy) }), { name: 'x', required: !0 }],
  preInference: [...de()],
  postInference: [...ge()]
}
const Gy = { range: Ui },
  WS = () => e0({ extendX: !0 })
WS.props = {
  defaultShape: 'range',
  defaultLabelShape: 'label',
  composite: !1,
  shape: Gy,
  channels: [...eo({ shapes: Object.keys(Gy) }), { name: 'y', required: !0 }],
  preInference: [...de()],
  postInference: [...ge()]
}
function Q9(t) {
  return t.target.depth
}
function J9(t) {
  return t.depth
}
function t7(t, e) {
  return e - 1 - t.height
}
function xl(t, e) {
  return t.sourceLinks.length ? t.depth : e - 1
}
function e7(t) {
  return t.targetLinks.length ? t.depth : t.sourceLinks.length ? gn(t.sourceLinks, Q9) - 1 : 0
}
function xc(t) {
  return function () {
    return t
  }
}
function Wy(t, e) {
  return wl(t.source, e.source) || t.index - e.index
}
function Yy(t, e) {
  return wl(t.target, e.target) || t.index - e.index
}
function wl(t, e) {
  return t.y0 - e.y0
}
function Ef(t) {
  return t.value
}
function n7(t) {
  return t.index
}
function r7(t) {
  return t.nodes
}
function i7(t) {
  return t.links
}
function Hy(t, e) {
  const n = t.get(e)
  if (!n) throw new Error('missing: ' + e)
  return n
}
function Vy({ nodes: t }) {
  for (const e of t) {
    let n = e.y0,
      r = n
    for (const i of e.sourceLinks) (i.y0 = n + i.width / 2), (n += i.width)
    for (const i of e.targetLinks) (i.y1 = r + i.width / 2), (r += i.width)
  }
}
function a7() {
  let t = 0,
    e = 0,
    n = 1,
    r = 1,
    i = 24,
    a = 8,
    o,
    s = n7,
    c = xl,
    l,
    u,
    f,
    h = r7,
    d = i7,
    p = 6
  function v(L) {
    const R = { nodes: h(L), links: d(L) }
    return g(R), y(R), m(R), b(R), O(R), Vy(R), R
  }
  ;(v.update = function (L) {
    return Vy(L), L
  }),
    (v.nodeId = function (L) {
      return arguments.length ? ((s = typeof L == 'function' ? L : xc(L)), v) : s
    }),
    (v.nodeAlign = function (L) {
      return arguments.length ? ((c = typeof L == 'function' ? L : xc(L)), v) : c
    }),
    (v.nodeDepth = function (L) {
      return arguments.length ? ((l = L), v) : l
    }),
    (v.nodeSort = function (L) {
      return arguments.length ? ((u = L), v) : u
    }),
    (v.nodeWidth = function (L) {
      return arguments.length ? ((i = +L), v) : i
    }),
    (v.nodePadding = function (L) {
      return arguments.length ? ((a = o = +L), v) : a
    }),
    (v.nodes = function (L) {
      return arguments.length ? ((h = typeof L == 'function' ? L : xc(L)), v) : h
    }),
    (v.links = function (L) {
      return arguments.length ? ((d = typeof L == 'function' ? L : xc(L)), v) : d
    }),
    (v.linkSort = function (L) {
      return arguments.length ? ((f = L), v) : f
    }),
    (v.size = function (L) {
      return arguments.length ? ((t = e = 0), (n = +L[0]), (r = +L[1]), v) : [n - t, r - e]
    }),
    (v.extent = function (L) {
      return arguments.length
        ? ((t = +L[0][0]), (n = +L[1][0]), (e = +L[0][1]), (r = +L[1][1]), v)
        : [
            [t, e],
            [n, r]
          ]
    }),
    (v.iterations = function (L) {
      return arguments.length ? ((p = +L), v) : p
    })
  function g({ nodes: L, links: R }) {
    L.forEach((I, D) => {
      ;(I.index = D), (I.sourceLinks = []), (I.targetLinks = [])
    })
    const j = new Map(L.map((I) => [s(I), I]))
    if (
      (R.forEach((I, D) => {
        I.index = D
        let { source: $, target: B } = I
        typeof $ != 'object' && ($ = I.source = Hy(j, $)),
          typeof B != 'object' && (B = I.target = Hy(j, B)),
          $.sourceLinks.push(I),
          B.targetLinks.push(I)
      }),
      f != null)
    )
      for (const { sourceLinks: I, targetLinks: D } of L) I.sort(f), D.sort(f)
  }
  function y({ nodes: L }) {
    for (const R of L)
      R.value =
        R.fixedValue === void 0
          ? Math.max(Pn(R.sourceLinks, Ef), Pn(R.targetLinks, Ef))
          : R.fixedValue
  }
  function m({ nodes: L }) {
    const R = L.length
    let j = new Set(L),
      I = new Set(),
      D = 0
    for (; j.size; ) {
      if (
        (j.forEach(($) => {
          $.depth = D
          for (const { target: B } of $.sourceLinks) I.add(B)
        }),
        ++D > R)
      )
        throw new Error('circular link')
      ;(j = I), (I = new Set())
    }
    if (l) {
      const $ = Math.max(Ct(L, (F) => F.depth) + 1, 0)
      let B
      for (let F = 0; F < L.length; F++) (B = L[F]), (B.depth = l.call(null, B, $))
    }
  }
  function b({ nodes: L }) {
    const R = L.length
    let j = new Set(L),
      I = new Set(),
      D = 0
    for (; j.size; ) {
      if (
        (j.forEach(($) => {
          $.height = D
          for (const { source: B } of $.targetLinks) I.add(B)
        }),
        ++D > R)
      )
        throw new Error('circular link')
      ;(j = I), (I = new Set())
    }
  }
  function x({ nodes: L }) {
    const R = Math.max(Ct(L, (D) => D.depth) + 1, 0),
      j = (n - t - i) / (R - 1),
      I = new Array(R).fill(0).map(() => [])
    for (const D of L) {
      const $ = Math.max(0, Math.min(R - 1, Math.floor(c.call(null, D, R))))
      ;(D.layer = $), (D.x0 = t + $ * j), (D.x1 = D.x0 + i), I[$] ? I[$].push(D) : (I[$] = [D])
    }
    if (u) for (const D of I) D.sort(u)
    return I
  }
  function w(L) {
    const R = gn(L, (j) => (r - e - (j.length - 1) * o) / Pn(j, Ef))
    for (const j of L) {
      let I = e
      for (const D of j) {
        ;(D.y0 = I), (D.y1 = I + D.value * R), (I = D.y1 + o)
        for (const $ of D.sourceLinks) $.width = $.value * R
      }
      I = (r - I + o) / (j.length + 1)
      for (let D = 0; D < j.length; ++D) {
        const $ = j[D]
        ;($.y0 += I * (D + 1)), ($.y1 += I * (D + 1))
      }
      A(j)
    }
  }
  function O(L) {
    const R = x(L)
    ;(o = Math.min(a, (r - e) / (Ct(R, (j) => j.length) - 1))), w(R)
    for (let j = 0; j < p; ++j) {
      const I = Math.pow(0.99, j),
        D = Math.max(1 - I, (j + 1) / p)
      _(R, I, D), S(R, I, D)
    }
  }
  function S(L, R, j) {
    for (let I = 1, D = L.length; I < D; ++I) {
      const $ = L[I]
      for (const B of $) {
        let F = 0,
          W = 0
        for (const { source: K, value: V } of B.targetLinks) {
          const H = V * (B.layer - K.layer)
          ;(F += P(K, B) * H), (W += H)
        }
        if (!(W > 0)) continue
        const U = (F / W - B.y0) * R
        ;(B.y0 += U), (B.y1 += U), C(B)
      }
      u === void 0 && $.sort(wl), $.length && M($, j)
    }
  }
  function _(L, R, j) {
    for (let I = L.length, D = I - 2; D >= 0; --D) {
      const $ = L[D]
      for (const B of $) {
        let F = 0,
          W = 0
        for (const { target: K, value: V } of B.sourceLinks) {
          const H = V * (K.layer - B.layer)
          ;(F += k(B, K) * H), (W += H)
        }
        if (!(W > 0)) continue
        const U = (F / W - B.y0) * R
        ;(B.y0 += U), (B.y1 += U), C(B)
      }
      u === void 0 && $.sort(wl), $.length && M($, j)
    }
  }
  function M(L, R) {
    const j = L.length >> 1,
      I = L[j]
    T(L, I.y0 - o, j - 1, R), E(L, I.y1 + o, j + 1, R), T(L, r, L.length - 1, R), E(L, e, 0, R)
  }
  function E(L, R, j, I) {
    for (; j < L.length; ++j) {
      const D = L[j],
        $ = (R - D.y0) * I
      $ > 1e-6 && ((D.y0 += $), (D.y1 += $)), (R = D.y1 + o)
    }
  }
  function T(L, R, j, I) {
    for (; j >= 0; --j) {
      const D = L[j],
        $ = (D.y1 - R) * I
      $ > 1e-6 && ((D.y0 -= $), (D.y1 -= $)), (R = D.y0 - o)
    }
  }
  function C({ sourceLinks: L, targetLinks: R }) {
    if (f === void 0) {
      for (const {
        source: { sourceLinks: j }
      } of R)
        j.sort(Yy)
      for (const {
        target: { targetLinks: j }
      } of L)
        j.sort(Wy)
    }
  }
  function A(L) {
    if (f === void 0) for (const { sourceLinks: R, targetLinks: j } of L) R.sort(Yy), j.sort(Wy)
  }
  function P(L, R) {
    let j = L.y0 - ((L.sourceLinks.length - 1) * o) / 2
    for (const { target: I, width: D } of L.sourceLinks) {
      if (I === R) break
      j += D + o
    }
    for (const { source: I, width: D } of R.targetLinks) {
      if (I === L) break
      j -= D
    }
    return j
  }
  function k(L, R) {
    let j = R.y0 - ((R.targetLinks.length - 1) * o) / 2
    for (const { source: I, width: D } of R.targetLinks) {
      if (I === L) break
      j += D + o
    }
    for (const { target: I, width: D } of L.sourceLinks) {
      if (I === R) break
      j -= D
    }
    return j
  }
  return v
}
const o7 = {
    nodeAlign: 'justify',
    nodeWidth: 0.008,
    nodePadding: 0.03,
    nodes: (t) => t.nodes,
    links: (t) => t.links,
    nodeSort: void 0,
    linkSort: void 0,
    iterations: 6
  },
  s7 = { left: J9, right: t7, center: e7, justify: xl }
function c7(t) {
  const e = typeof t
  return e === 'string' ? s7[t] || xl : e === 'function' ? t : xl
}
const YS = (t) => (e) => {
  const {
      nodeId: n,
      nodeSort: r,
      nodeAlign: i,
      nodeWidth: a,
      nodePadding: o,
      nodeDepth: s,
      nodes: c,
      links: l,
      linkSort: u,
      iterations: f
    } = Object.assign({}, o7, t),
    h = a7()
      .nodeSort(r)
      .linkSort(u)
      .links(l)
      .nodes(c)
      .nodeWidth(a)
      .nodePadding(o)
      .nodeDepth(s)
      .nodeAlign(c7(i))
      .iterations(f)
      .extent([
        [0, 0],
        [1, 1]
      ])
  typeof n == 'function' && h.nodeId(n)
  const d = h(e),
    { nodes: p, links: v } = d,
    g = p.map((m) => {
      const { x0: b, x1: x, y0: w, y1: O } = m
      return Object.assign(Object.assign({}, m), { x: [b, x, x, b], y: [w, w, O, O] })
    }),
    y = v.map((m) => {
      const { source: b, target: x } = m,
        w = b.x1,
        O = x.x0,
        S = m.width / 2
      return Object.assign(Object.assign({}, m), {
        x: [w, w, O, O],
        y: [m.y0 + S, m.y0 - S, m.y1 + S, m.y1 - S]
      })
    })
  return { nodes: g, links: y }
}
YS.props = {}
function Qr(t, e, n = {}, r = !1) {
  if (Er(t) || (Array.isArray(t) && r)) return t
  const i = et(t, e)
  return X(n, i)
}
function n0(t, e = {}) {
  return Er(t) || Array.isArray(t) || !HS(t) ? t : X(e, t)
}
function HS(t) {
  if (Object.keys(t).length === 0) return !0
  const { title: e, items: n } = t
  return e !== void 0 || n !== void 0
}
function Jr(t, e) {
  return typeof t == 'object' ? et(t, e) : t
}
var l7 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const u7 = { nodeId: (t) => t.key, nodeWidth: 0.02, nodePadding: 0.02 },
  f7 = {
    type: 'polygon',
    axis: !1,
    legend: !1,
    encode: { shape: 'polygon', x: 'x', y: 'y' },
    scale: { x: { type: 'identity' }, y: { type: 'identity' } },
    style: { stroke: '#000' }
  },
  h7 = {
    type: 'polygon',
    axis: !1,
    legend: !1,
    encode: { shape: 'ribbon', x: 'x', y: 'y' },
    style: { fillOpacity: 0.5, stroke: void 0 }
  },
  d7 = {
    textAlign: (t) => (t.x[0] < 0.5 ? 'start' : 'end'),
    position: (t) => (t.x[0] < 0.5 ? 'right' : 'left'),
    fontSize: 10
  },
  VS = (t) => {
    const {
        data: e,
        encode: n = {},
        scale: r,
        style: i = {},
        layout: a = {},
        nodeLabels: o = [],
        linkLabels: s = [],
        animate: c = {},
        tooltip: l = {}
      } = t,
      { links: u, nodes: f } = sS(e, n),
      h = et(n, 'node'),
      d = et(n, 'link'),
      { key: p = (M) => M.key, color: v = p } = h,
      { links: g, nodes: y } = YS(
        Object.assign(Object.assign(Object.assign({}, u7), { nodeId: Sr(p) }), a)
      )({ links: u, nodes: f }),
      m = et(i, 'label'),
      { text: b = p, spacing: x = 5 } = m,
      w = l7(m, ['text', 'spacing']),
      O = Sr(p),
      S = Qr(l, 'node', { title: O, items: [{ field: 'value' }] }, !0),
      _ = Qr(l, 'link', {
        title: '',
        items: [
          (M) => ({ name: 'source', value: O(M.source) }),
          (M) => ({ name: 'target', value: O(M.target) })
        ]
      })
    return [
      X({}, f7, {
        data: y,
        encode: Object.assign(Object.assign({}, h), { color: v }),
        scale: r,
        style: et(i, 'node'),
        labels: [
          Object.assign(
            Object.assign(Object.assign({}, d7), { text: b, dx: (M) => (M.x[0] < 0.5 ? x : -x) }),
            w
          ),
          ...o
        ],
        tooltip: S,
        animate: Jr(c, 'node'),
        axis: !1
      }),
      X({}, h7, {
        data: g,
        encode: d,
        labels: s,
        style: Object.assign({ fill: d.color ? void 0 : '#aaa', strokeWidth: 0 }, et(i, 'link')),
        tooltip: _,
        animate: Jr(c, 'link')
      })
    ]
  }
VS.props = {}
const Xy = { path: wS, hollow: OS },
  XS = (t) => (e, n, r, i) => [e, e.map(() => [[0, 0]])]
XS.props = {
  defaultShape: 'path',
  defaultLabelShape: 'label',
  shape: Xy,
  composite: !1,
  channels: [...Ye({ shapes: Object.keys(Xy) }), { name: 'd', scale: 'identity' }],
  preInference: [...de()],
  postInference: [...ge()]
}
var p7 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function v7(t, e) {
  const n = {
      treemapBinary: Jj,
      treemapDice: Mu,
      treemapSlice: Eu,
      treemapSliceDice: t9,
      treemapSquarify: aS,
      treemapResquarify: e9
    },
    r = t === 'treemapSquarify' ? n[t].ratio(e) : n[t]
  if (!r) throw new TypeError('Invalid tile method!')
  return r
}
function g7(t, e, n) {
  const { value: r } = n,
    i = v7(e.tile, e.ratio),
    a = r9(t, e.path)
  return (
    r ? a.sum((o) => (e.ignoreParentValue && o.children ? 0 : Sr(r)(o))).sort(e.sort) : a.count(),
    Qj()
      .tile(i)
      .size(e.size)
      .round(e.round)
      .paddingInner(e.paddingInner)
      .paddingOuter(e.paddingOuter)
      .paddingTop(e.paddingTop)
      .paddingRight(e.paddingRight)
      .paddingBottom(e.paddingBottom)
      .paddingLeft(e.paddingLeft)(a),
    a
      .descendants()
      .map((o) => Object.assign(o, { x: [o.x0, o.x1], y: [o.y0, o.y1] }))
      .filter(typeof e.layer == 'function' ? e.layer : (o) => o.height === e.layer)
  )
}
const y7 = (t, e) => ({
    tile: 'treemapSquarify',
    ratio: 0.5 * (1 + Math.sqrt(5)),
    size: [t, e],
    round: !1,
    ignoreParentValue: !0,
    padding: 0,
    paddingInner: 0,
    paddingOuter: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    sort: (n, r) => r.value - n.value,
    layer: 0
  }),
  m7 = (t, e) => ({
    type: 'rect',
    axis: !1,
    encode: { x: 'x', y: 'y', color: (n) => n.data.parent.name },
    scale: { x: { domain: [0, t], range: [0, 1] }, y: { domain: [0, e], range: [0, 1] } },
    style: { stroke: '#fff' }
  }),
  b7 = {
    fontSize: 10,
    text: (t) => t.data.name,
    position: 'inside',
    fill: '#000',
    textOverflow: 'clip',
    wordWrap: !0,
    maxLines: 1,
    wordWrapWidth: (t) => t.x1 - t.x0
  },
  x7 = { title: (t) => t.data.name, items: [{ field: 'value' }] },
  US = (t, e) => {
    const { width: n, height: r } = e,
      {
        data: i,
        encode: a = {},
        scale: o,
        style: s = {},
        layout: c = {},
        labels: l = [],
        tooltip: u = {}
      } = t,
      f = p7(t, ['data', 'encode', 'scale', 'style', 'layout', 'labels', 'tooltip']),
      h = g7(i, X({}, y7(n, r), c), a),
      d = et(s, 'label')
    return X(
      {},
      m7(n, r),
      Object.assign(
        Object.assign(
          {
            data: h,
            encode: a,
            scale: o,
            style: s,
            labels: [Object.assign(Object.assign({}, b7), d), ...l]
          },
          f
        ),
        { tooltip: n0(u, x7), axis: !1 }
      )
    )
  }
US.props = {}
var w7 =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const O7 = (t, e) => ({ size: [t, e], padding: 0, sort: (n, r) => r.value - n.value }),
  S7 = (t, e, n) => ({
    type: 'point',
    axis: !1,
    legend: !1,
    scale: { x: { domain: [0, t] }, y: { domain: [0, e] }, size: { type: 'identity' } },
    encode: { x: 'x', y: 'y', size: 'r', shape: 'point' },
    style: {
      fill: n.color ? void 0 : (r) => (r.height === 0 ? '#ddd' : '#fff'),
      stroke: n.color ? void 0 : (r) => (r.height === 0 ? '' : '#000')
    }
  }),
  _7 = {
    text: '',
    position: 'inside',
    textOverflow: 'clip',
    wordWrap: !0,
    maxLines: 1,
    wordWrapWidth: (t) => t.r * 2
  },
  M7 = { title: (t) => t.data.name, items: [{ field: 'value' }] },
  E7 = (t, e, n) => {
    const { value: r } = n,
      i = bn(t) ? Hh().path(e.path)(t) : $s(t)
    return (
      r ? i.sum((a) => Sr(r)(a)).sort(e.sort) : i.count(),
      Fj().size(e.size).padding(e.padding)(i),
      i.descendants()
    )
  },
  qS = (t, e) => {
    const { width: n, height: r } = e,
      {
        data: i,
        encode: a = {},
        scale: o = {},
        style: s = {},
        layout: c = {},
        labels: l = [],
        tooltip: u = {}
      } = t,
      f = w7(t, ['data', 'encode', 'scale', 'style', 'layout', 'labels', 'tooltip']),
      h = S7(n, r, a),
      d = E7(i, X({}, O7(n, r), c), X({}, h.encode, a)),
      p = et(s, 'label')
    return X(
      {},
      h,
      Object.assign(
        Object.assign(
          {
            data: d,
            encode: a,
            scale: o,
            style: s,
            labels: [Object.assign(Object.assign({}, _7), p), ...l]
          },
          f
        ),
        { tooltip: n0(u, M7), axis: !1 }
      )
    )
  }
qS.props = {}
var Uy =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function T7(t, e) {
  return gn(t, (n) => e[n])
}
function P7(t, e) {
  return Ct(t, (n) => e[n])
}
function KS(t, e) {
  const n = r0(t, e) * 2.5 - i0(t, e) * 1.5
  return gn(t, (r) => (e[r] >= n ? e[r] : NaN))
}
function r0(t, e) {
  return Ul(t, 0.25, (n) => e[n])
}
function A7(t, e) {
  return Ul(t, 0.5, (n) => e[n])
}
function i0(t, e) {
  return Ul(t, 0.75, (n) => e[n])
}
function ZS(t, e) {
  const n = i0(t, e) * 2.5 - r0(t, e) * 1.5
  return Ct(t, (r) => (e[r] <= n ? e[r] : NaN))
}
function k7() {
  return (t, e) => {
    const { encode: n } = e,
      { y: r, x: i } = n,
      { value: a } = r,
      { value: o } = i
    return [
      Array.from(qt(t, (l) => o[+l]).values()).flatMap((l) => {
        const u = KS(l, a),
          f = ZS(l, a)
        return l.filter((h) => a[h] < u || a[h] > f)
      }),
      e
    ]
  }
}
const QS = (t) => {
  const { data: e, encode: n, style: r = {}, tooltip: i = {}, transform: a, animate: o } = t,
    s = Uy(t, ['data', 'encode', 'style', 'tooltip', 'transform', 'animate']),
    { point: c = !0 } = r,
    l = Uy(r, ['point']),
    { y: u } = n,
    f = { y: u, y1: u, y2: u, y3: u, y4: u },
    h = { y1: r0, y2: A7, y3: i0 },
    d = Qr(
      i,
      'box',
      {
        items: [
          { channel: 'y', name: 'min' },
          { channel: 'y1', name: 'q1' },
          { channel: 'y2', name: 'q2' },
          { channel: 'y3', name: 'q3' },
          { channel: 'y4', name: 'max' }
        ]
      },
      !0
    ),
    p = Qr(i, 'point', { title: { channel: 'x' }, items: [{ name: 'outlier', channel: 'y' }] })
  if (!c)
    return Object.assign(
      {
        type: 'box',
        data: e,
        transform: [Object.assign(Object.assign({ type: 'groupX', y: T7 }, h), { y4: P7 })],
        encode: Object.assign(Object.assign({}, n), f),
        style: l,
        tooltip: d
      },
      s
    )
  const v = et(l, 'box'),
    g = et(l, 'point')
  return [
    Object.assign(
      {
        type: 'box',
        data: e,
        transform: [Object.assign(Object.assign({ type: 'groupX', y: KS }, h), { y4: ZS })],
        encode: Object.assign(Object.assign({}, n), f),
        style: v,
        tooltip: d,
        animate: Jr(o, 'box')
      },
      s
    ),
    {
      type: 'point',
      data: e,
      transform: [{ type: k7 }],
      encode: n,
      style: Object.assign({}, g),
      tooltip: p,
      animate: Jr(o, 'point')
    }
  ]
}
QS.props = {}
const C7 = { shape: MS },
  JS = (t) => {
    const { cartesian: e } = t
    return e
      ? qp
      : (n, r, i, a) => {
          const { x: o, y: s } = i,
            c = qi(r, i, t),
            l = Array.from(n, (u) => {
              const f = [+o[u], +s[u]]
              return [a.map(c(f, u))]
            })
          return [n, l]
        }
  }
JS.props = {
  defaultShape: 'shape',
  defaultLabelShape: 'label',
  composite: !1,
  shape: C7,
  channels: [
    { name: 'x', required: !0 },
    { name: 'y', required: !0 }
  ],
  preInference: [...de(), { type: tu }, { type: Jl }, { type: Vb }]
}
function L7(t, e) {
  var n,
    r = 1
  t == null && (t = 0), e == null && (e = 0)
  function i() {
    var a,
      o = n.length,
      s,
      c = 0,
      l = 0
    for (a = 0; a < o; ++a) (s = n[a]), (c += s.x), (l += s.y)
    for (c = (c / o - t) * r, l = (l / o - e) * r, a = 0; a < o; ++a)
      (s = n[a]), (s.x -= c), (s.y -= l)
  }
  return (
    (i.initialize = function (a) {
      n = a
    }),
    (i.x = function (a) {
      return arguments.length ? ((t = +a), i) : t
    }),
    (i.y = function (a) {
      return arguments.length ? ((e = +a), i) : e
    }),
    (i.strength = function (a) {
      return arguments.length ? ((r = +a), i) : r
    }),
    i
  )
}
function N7(t) {
  const e = +this._x.call(null, t),
    n = +this._y.call(null, t)
  return t_(this.cover(e, n), e, n, t)
}
function t_(t, e, n, r) {
  if (isNaN(e) || isNaN(n)) return t
  var i,
    a = t._root,
    o = { data: r },
    s = t._x0,
    c = t._y0,
    l = t._x1,
    u = t._y1,
    f,
    h,
    d,
    p,
    v,
    g,
    y,
    m
  if (!a) return (t._root = o), t
  for (; a.length; )
    if (
      ((v = e >= (f = (s + l) / 2)) ? (s = f) : (l = f),
      (g = n >= (h = (c + u) / 2)) ? (c = h) : (u = h),
      (i = a),
      !(a = a[(y = (g << 1) | v)]))
    )
      return (i[y] = o), t
  if (((d = +t._x.call(null, a.data)), (p = +t._y.call(null, a.data)), e === d && n === p))
    return (o.next = a), i ? (i[y] = o) : (t._root = o), t
  do
    (i = i ? (i[y] = new Array(4)) : (t._root = new Array(4))),
      (v = e >= (f = (s + l) / 2)) ? (s = f) : (l = f),
      (g = n >= (h = (c + u) / 2)) ? (c = h) : (u = h)
  while ((y = (g << 1) | v) === (m = ((p >= h) << 1) | (d >= f)))
  return (i[m] = a), (i[y] = o), t
}
function R7(t) {
  var e,
    n,
    r = t.length,
    i,
    a,
    o = new Array(r),
    s = new Array(r),
    c = 1 / 0,
    l = 1 / 0,
    u = -1 / 0,
    f = -1 / 0
  for (n = 0; n < r; ++n)
    isNaN((i = +this._x.call(null, (e = t[n])))) ||
      isNaN((a = +this._y.call(null, e))) ||
      ((o[n] = i),
      (s[n] = a),
      i < c && (c = i),
      i > u && (u = i),
      a < l && (l = a),
      a > f && (f = a))
  if (c > u || l > f) return this
  for (this.cover(c, l).cover(u, f), n = 0; n < r; ++n) t_(this, o[n], s[n], t[n])
  return this
}
function I7(t, e) {
  if (isNaN((t = +t)) || isNaN((e = +e))) return this
  var n = this._x0,
    r = this._y0,
    i = this._x1,
    a = this._y1
  if (isNaN(n)) (i = (n = Math.floor(t)) + 1), (a = (r = Math.floor(e)) + 1)
  else {
    for (var o = i - n || 1, s = this._root, c, l; n > t || t >= i || r > e || e >= a; )
      switch (
        ((l = ((e < r) << 1) | (t < n)), (c = new Array(4)), (c[l] = s), (s = c), (o *= 2), l)
      ) {
        case 0:
          ;(i = n + o), (a = r + o)
          break
        case 1:
          ;(n = i - o), (a = r + o)
          break
        case 2:
          ;(i = n + o), (r = a - o)
          break
        case 3:
          ;(n = i - o), (r = a - o)
          break
      }
    this._root && this._root.length && (this._root = s)
  }
  return (this._x0 = n), (this._y0 = r), (this._x1 = i), (this._y1 = a), this
}
function j7() {
  var t = []
  return (
    this.visit(function (e) {
      if (!e.length)
        do t.push(e.data)
        while ((e = e.next))
    }),
    t
  )
}
function D7(t) {
  return arguments.length
    ? this.cover(+t[0][0], +t[0][1]).cover(+t[1][0], +t[1][1])
    : isNaN(this._x0)
    ? void 0
    : [
        [this._x0, this._y0],
        [this._x1, this._y1]
      ]
}
function We(t, e, n, r, i) {
  ;(this.node = t), (this.x0 = e), (this.y0 = n), (this.x1 = r), (this.y1 = i)
}
function $7(t, e, n) {
  var r,
    i = this._x0,
    a = this._y0,
    o,
    s,
    c,
    l,
    u = this._x1,
    f = this._y1,
    h = [],
    d = this._root,
    p,
    v
  for (
    d && h.push(new We(d, i, a, u, f)),
      n == null ? (n = 1 / 0) : ((i = t - n), (a = e - n), (u = t + n), (f = e + n), (n *= n));
    (p = h.pop());

  )
    if (!(!(d = p.node) || (o = p.x0) > u || (s = p.y0) > f || (c = p.x1) < i || (l = p.y1) < a))
      if (d.length) {
        var g = (o + c) / 2,
          y = (s + l) / 2
        h.push(
          new We(d[3], g, y, c, l),
          new We(d[2], o, y, g, l),
          new We(d[1], g, s, c, y),
          new We(d[0], o, s, g, y)
        ),
          (v = ((e >= y) << 1) | (t >= g)) &&
            ((p = h[h.length - 1]),
            (h[h.length - 1] = h[h.length - 1 - v]),
            (h[h.length - 1 - v] = p))
      } else {
        var m = t - +this._x.call(null, d.data),
          b = e - +this._y.call(null, d.data),
          x = m * m + b * b
        if (x < n) {
          var w = Math.sqrt((n = x))
          ;(i = t - w), (a = e - w), (u = t + w), (f = e + w), (r = d.data)
        }
      }
  return r
}
function B7(t) {
  if (isNaN((u = +this._x.call(null, t))) || isNaN((f = +this._y.call(null, t)))) return this
  var e,
    n = this._root,
    r,
    i,
    a,
    o = this._x0,
    s = this._y0,
    c = this._x1,
    l = this._y1,
    u,
    f,
    h,
    d,
    p,
    v,
    g,
    y
  if (!n) return this
  if (n.length)
    for (;;) {
      if (
        ((p = u >= (h = (o + c) / 2)) ? (o = h) : (c = h),
        (v = f >= (d = (s + l) / 2)) ? (s = d) : (l = d),
        (e = n),
        !(n = n[(g = (v << 1) | p)]))
      )
        return this
      if (!n.length) break
      ;(e[(g + 1) & 3] || e[(g + 2) & 3] || e[(g + 3) & 3]) && ((r = e), (y = g))
    }
  for (; n.data !== t; ) if (((i = n), !(n = n.next))) return this
  return (
    (a = n.next) && delete n.next,
    i
      ? (a ? (i.next = a) : delete i.next, this)
      : e
      ? (a ? (e[g] = a) : delete e[g],
        (n = e[0] || e[1] || e[2] || e[3]) &&
          n === (e[3] || e[2] || e[1] || e[0]) &&
          !n.length &&
          (r ? (r[y] = n) : (this._root = n)),
        this)
      : ((this._root = a), this)
  )
}
function F7(t) {
  for (var e = 0, n = t.length; e < n; ++e) this.remove(t[e])
  return this
}
function z7() {
  return this._root
}
function G7() {
  var t = 0
  return (
    this.visit(function (e) {
      if (!e.length)
        do ++t
        while ((e = e.next))
    }),
    t
  )
}
function W7(t) {
  var e = [],
    n,
    r = this._root,
    i,
    a,
    o,
    s,
    c
  for (r && e.push(new We(r, this._x0, this._y0, this._x1, this._y1)); (n = e.pop()); )
    if (!t((r = n.node), (a = n.x0), (o = n.y0), (s = n.x1), (c = n.y1)) && r.length) {
      var l = (a + s) / 2,
        u = (o + c) / 2
      ;(i = r[3]) && e.push(new We(i, l, u, s, c)),
        (i = r[2]) && e.push(new We(i, a, u, l, c)),
        (i = r[1]) && e.push(new We(i, l, o, s, u)),
        (i = r[0]) && e.push(new We(i, a, o, l, u))
    }
  return this
}
function Y7(t) {
  var e = [],
    n = [],
    r
  for (
    this._root && e.push(new We(this._root, this._x0, this._y0, this._x1, this._y1));
    (r = e.pop());

  ) {
    var i = r.node
    if (i.length) {
      var a,
        o = r.x0,
        s = r.y0,
        c = r.x1,
        l = r.y1,
        u = (o + c) / 2,
        f = (s + l) / 2
      ;(a = i[0]) && e.push(new We(a, o, s, u, f)),
        (a = i[1]) && e.push(new We(a, u, s, c, f)),
        (a = i[2]) && e.push(new We(a, o, f, u, l)),
        (a = i[3]) && e.push(new We(a, u, f, c, l))
    }
    n.push(r)
  }
  for (; (r = n.pop()); ) t(r.node, r.x0, r.y0, r.x1, r.y1)
  return this
}
function H7(t) {
  return t[0]
}
function V7(t) {
  return arguments.length ? ((this._x = t), this) : this._x
}
function X7(t) {
  return t[1]
}
function U7(t) {
  return arguments.length ? ((this._y = t), this) : this._y
}
function e_(t, e, n) {
  var r = new a0(e ?? H7, n ?? X7, NaN, NaN, NaN, NaN)
  return t == null ? r : r.addAll(t)
}
function a0(t, e, n, r, i, a) {
  ;(this._x = t),
    (this._y = e),
    (this._x0 = n),
    (this._y0 = r),
    (this._x1 = i),
    (this._y1 = a),
    (this._root = void 0)
}
function qy(t) {
  for (var e = { data: t.data }, n = e; (t = t.next); ) n = n.next = { data: t.data }
  return e
}
var He = (e_.prototype = a0.prototype)
He.copy = function () {
  var t = new a0(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
    e = this._root,
    n,
    r
  if (!e) return t
  if (!e.length) return (t._root = qy(e)), t
  for (n = [{ source: e, target: (t._root = new Array(4)) }]; (e = n.pop()); )
    for (var i = 0; i < 4; ++i)
      (r = e.source[i]) &&
        (r.length
          ? n.push({ source: r, target: (e.target[i] = new Array(4)) })
          : (e.target[i] = qy(r)))
  return t
}
He.add = N7
He.addAll = R7
He.cover = I7
He.data = j7
He.extent = D7
He.find = $7
He.remove = B7
He.removeAll = F7
He.root = z7
He.size = G7
He.visit = W7
He.visitAfter = Y7
He.x = V7
He.y = U7
function vn(t) {
  return function () {
    return t
  }
}
function da(t) {
  return (t() - 0.5) * 1e-6
}
function q7(t) {
  return t.index
}
function Ky(t, e) {
  var n = t.get(e)
  if (!n) throw new Error('node not found: ' + e)
  return n
}
function K7(t) {
  var e = q7,
    n = f,
    r,
    i = vn(30),
    a,
    o,
    s,
    c,
    l,
    u = 1
  t == null && (t = [])
  function f(g) {
    return 1 / Math.min(s[g.source.index], s[g.target.index])
  }
  function h(g) {
    for (var y = 0, m = t.length; y < u; ++y)
      for (var b = 0, x, w, O, S, _, M, E; b < m; ++b)
        (x = t[b]),
          (w = x.source),
          (O = x.target),
          (S = O.x + O.vx - w.x - w.vx || da(l)),
          (_ = O.y + O.vy - w.y - w.vy || da(l)),
          (M = Math.sqrt(S * S + _ * _)),
          (M = ((M - a[b]) / M) * g * r[b]),
          (S *= M),
          (_ *= M),
          (O.vx -= S * (E = c[b])),
          (O.vy -= _ * E),
          (w.vx += S * (E = 1 - E)),
          (w.vy += _ * E)
  }
  function d() {
    if (o) {
      var g,
        y = o.length,
        m = t.length,
        b = new Map(o.map((w, O) => [e(w, O, o), w])),
        x
      for (g = 0, s = new Array(y); g < m; ++g)
        (x = t[g]),
          (x.index = g),
          typeof x.source != 'object' && (x.source = Ky(b, x.source)),
          typeof x.target != 'object' && (x.target = Ky(b, x.target)),
          (s[x.source.index] = (s[x.source.index] || 0) + 1),
          (s[x.target.index] = (s[x.target.index] || 0) + 1)
      for (g = 0, c = new Array(m); g < m; ++g)
        (x = t[g]), (c[g] = s[x.source.index] / (s[x.source.index] + s[x.target.index]))
      ;(r = new Array(m)), p(), (a = new Array(m)), v()
    }
  }
  function p() {
    if (o) for (var g = 0, y = t.length; g < y; ++g) r[g] = +n(t[g], g, t)
  }
  function v() {
    if (o) for (var g = 0, y = t.length; g < y; ++g) a[g] = +i(t[g], g, t)
  }
  return (
    (h.initialize = function (g, y) {
      ;(o = g), (l = y), d()
    }),
    (h.links = function (g) {
      return arguments.length ? ((t = g), d(), h) : t
    }),
    (h.id = function (g) {
      return arguments.length ? ((e = g), h) : e
    }),
    (h.iterations = function (g) {
      return arguments.length ? ((u = +g), h) : u
    }),
    (h.strength = function (g) {
      return arguments.length ? ((n = typeof g == 'function' ? g : vn(+g)), p(), h) : n
    }),
    (h.distance = function (g) {
      return arguments.length ? ((i = typeof g == 'function' ? g : vn(+g)), v(), h) : i
    }),
    h
  )
}
var Z7 = { value: () => {} }
function n_() {
  for (var t = 0, e = arguments.length, n = {}, r; t < e; ++t) {
    if (!(r = arguments[t] + '') || r in n || /[\s.]/.test(r)) throw new Error('illegal type: ' + r)
    n[r] = []
  }
  return new Wc(n)
}
function Wc(t) {
  this._ = t
}
function Q7(t, e) {
  return t
    .trim()
    .split(/^|\s+/)
    .map(function (n) {
      var r = '',
        i = n.indexOf('.')
      if ((i >= 0 && ((r = n.slice(i + 1)), (n = n.slice(0, i))), n && !e.hasOwnProperty(n)))
        throw new Error('unknown type: ' + n)
      return { type: n, name: r }
    })
}
Wc.prototype = n_.prototype = {
  constructor: Wc,
  on: function (t, e) {
    var n = this._,
      r = Q7(t + '', n),
      i,
      a = -1,
      o = r.length
    if (arguments.length < 2) {
      for (; ++a < o; ) if ((i = (t = r[a]).type) && (i = J7(n[i], t.name))) return i
      return
    }
    if (e != null && typeof e != 'function') throw new Error('invalid callback: ' + e)
    for (; ++a < o; )
      if ((i = (t = r[a]).type)) n[i] = Zy(n[i], t.name, e)
      else if (e == null) for (i in n) n[i] = Zy(n[i], t.name, null)
    return this
  },
  copy: function () {
    var t = {},
      e = this._
    for (var n in e) t[n] = e[n].slice()
    return new Wc(t)
  },
  call: function (t, e) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), r = 0, i, a; r < i; ++r) n[r] = arguments[r + 2]
    if (!this._.hasOwnProperty(t)) throw new Error('unknown type: ' + t)
    for (a = this._[t], r = 0, i = a.length; r < i; ++r) a[r].value.apply(e, n)
  },
  apply: function (t, e, n) {
    if (!this._.hasOwnProperty(t)) throw new Error('unknown type: ' + t)
    for (var r = this._[t], i = 0, a = r.length; i < a; ++i) r[i].value.apply(e, n)
  }
}
function J7(t, e) {
  for (var n = 0, r = t.length, i; n < r; ++n) if ((i = t[n]).name === e) return i.value
}
function Zy(t, e, n) {
  for (var r = 0, i = t.length; r < i; ++r)
    if (t[r].name === e) {
      ;(t[r] = Z7), (t = t.slice(0, r).concat(t.slice(r + 1)))
      break
    }
  return n != null && t.push({ name: e, value: n }), t
}
var Ba = 0,
  Mo = 0,
  go = 0,
  r_ = 1e3,
  Ol,
  Eo,
  Sl = 0,
  Fi = 0,
  Tu = 0,
  ls = typeof performance == 'object' && performance.now ? performance : Date,
  i_ =
    typeof window == 'object' && window.requestAnimationFrame
      ? window.requestAnimationFrame.bind(window)
      : function (t) {
          setTimeout(t, 17)
        }
function a_() {
  return Fi || (i_(tD), (Fi = ls.now() + Tu))
}
function tD() {
  Fi = 0
}
function Xh() {
  this._call = this._time = this._next = null
}
Xh.prototype = o_.prototype = {
  constructor: Xh,
  restart: function (t, e, n) {
    if (typeof t != 'function') throw new TypeError('callback is not a function')
    ;(n = (n == null ? a_() : +n) + (e == null ? 0 : +e)),
      !this._next && Eo !== this && (Eo ? (Eo._next = this) : (Ol = this), (Eo = this)),
      (this._call = t),
      (this._time = n),
      Uh()
  },
  stop: function () {
    this._call && ((this._call = null), (this._time = 1 / 0), Uh())
  }
}
function o_(t, e, n) {
  var r = new Xh()
  return r.restart(t, e, n), r
}
function eD() {
  a_(), ++Ba
  for (var t = Ol, e; t; ) (e = Fi - t._time) >= 0 && t._call.call(void 0, e), (t = t._next)
  --Ba
}
function Qy() {
  ;(Fi = (Sl = ls.now()) + Tu), (Ba = Mo = 0)
  try {
    eD()
  } finally {
    ;(Ba = 0), rD(), (Fi = 0)
  }
}
function nD() {
  var t = ls.now(),
    e = t - Sl
  e > r_ && ((Tu -= e), (Sl = t))
}
function rD() {
  for (var t, e = Ol, n, r = 1 / 0; e; )
    e._call
      ? (r > e._time && (r = e._time), (t = e), (e = e._next))
      : ((n = e._next), (e._next = null), (e = t ? (t._next = n) : (Ol = n)))
  ;(Eo = t), Uh(r)
}
function Uh(t) {
  if (!Ba) {
    Mo && (Mo = clearTimeout(Mo))
    var e = t - Fi
    e > 24
      ? (t < 1 / 0 && (Mo = setTimeout(Qy, t - ls.now() - Tu)), go && (go = clearInterval(go)))
      : (go || ((Sl = ls.now()), (go = setInterval(nD, r_))), (Ba = 1), i_(Qy))
  }
}
const iD = 1664525,
  aD = 1013904223,
  Jy = 4294967296
function oD() {
  let t = 1
  return () => (t = (iD * t + aD) % Jy) / Jy
}
function sD(t) {
  return t.x
}
function cD(t) {
  return t.y
}
var lD = 10,
  uD = Math.PI * (3 - Math.sqrt(5))
function fD(t) {
  var e,
    n = 1,
    r = 0.001,
    i = 1 - Math.pow(r, 1 / 300),
    a = 0,
    o = 0.6,
    s = new Map(),
    c = o_(f),
    l = n_('tick', 'end'),
    u = oD()
  t == null && (t = [])
  function f() {
    h(), l.call('tick', e), n < r && (c.stop(), l.call('end', e))
  }
  function h(v) {
    var g,
      y = t.length,
      m
    v === void 0 && (v = 1)
    for (var b = 0; b < v; ++b)
      for (
        n += (a - n) * i,
          s.forEach(function (x) {
            x(n)
          }),
          g = 0;
        g < y;
        ++g
      )
        (m = t[g]),
          m.fx == null ? (m.x += m.vx *= o) : ((m.x = m.fx), (m.vx = 0)),
          m.fy == null ? (m.y += m.vy *= o) : ((m.y = m.fy), (m.vy = 0))
    return e
  }
  function d() {
    for (var v = 0, g = t.length, y; v < g; ++v) {
      if (
        ((y = t[v]),
        (y.index = v),
        y.fx != null && (y.x = y.fx),
        y.fy != null && (y.y = y.fy),
        isNaN(y.x) || isNaN(y.y))
      ) {
        var m = lD * Math.sqrt(0.5 + v),
          b = v * uD
        ;(y.x = m * Math.cos(b)), (y.y = m * Math.sin(b))
      }
      ;(isNaN(y.vx) || isNaN(y.vy)) && (y.vx = y.vy = 0)
    }
  }
  function p(v) {
    return v.initialize && v.initialize(t, u), v
  }
  return (
    d(),
    (e = {
      tick: h,
      restart: function () {
        return c.restart(f), e
      },
      stop: function () {
        return c.stop(), e
      },
      nodes: function (v) {
        return arguments.length ? ((t = v), d(), s.forEach(p), e) : t
      },
      alpha: function (v) {
        return arguments.length ? ((n = +v), e) : n
      },
      alphaMin: function (v) {
        return arguments.length ? ((r = +v), e) : r
      },
      alphaDecay: function (v) {
        return arguments.length ? ((i = +v), e) : +i
      },
      alphaTarget: function (v) {
        return arguments.length ? ((a = +v), e) : a
      },
      velocityDecay: function (v) {
        return arguments.length ? ((o = 1 - v), e) : 1 - o
      },
      randomSource: function (v) {
        return arguments.length ? ((u = v), s.forEach(p), e) : u
      },
      force: function (v, g) {
        return arguments.length > 1 ? (g == null ? s.delete(v) : s.set(v, p(g)), e) : s.get(v)
      },
      find: function (v, g, y) {
        var m = 0,
          b = t.length,
          x,
          w,
          O,
          S,
          _
        for (y == null ? (y = 1 / 0) : (y *= y), m = 0; m < b; ++m)
          (S = t[m]), (x = v - S.x), (w = g - S.y), (O = x * x + w * w), O < y && ((_ = S), (y = O))
        return _
      },
      on: function (v, g) {
        return arguments.length > 1 ? (l.on(v, g), e) : l.on(v)
      }
    })
  )
}
function hD() {
  var t,
    e,
    n,
    r,
    i = vn(-30),
    a,
    o = 1,
    s = 1 / 0,
    c = 0.81
  function l(d) {
    var p,
      v = t.length,
      g = e_(t, sD, cD).visitAfter(f)
    for (r = d, p = 0; p < v; ++p) (e = t[p]), g.visit(h)
  }
  function u() {
    if (t) {
      var d,
        p = t.length,
        v
      for (a = new Array(p), d = 0; d < p; ++d) (v = t[d]), (a[v.index] = +i(v, d, t))
    }
  }
  function f(d) {
    var p = 0,
      v,
      g,
      y = 0,
      m,
      b,
      x
    if (d.length) {
      for (m = b = x = 0; x < 4; ++x)
        (v = d[x]) &&
          (g = Math.abs(v.value)) &&
          ((p += v.value), (y += g), (m += g * v.x), (b += g * v.y))
      ;(d.x = m / y), (d.y = b / y)
    } else {
      ;(v = d), (v.x = v.data.x), (v.y = v.data.y)
      do p += a[v.data.index]
      while ((v = v.next))
    }
    d.value = p
  }
  function h(d, p, v, g) {
    if (!d.value) return !0
    var y = d.x - e.x,
      m = d.y - e.y,
      b = g - p,
      x = y * y + m * m
    if ((b * b) / c < x)
      return (
        x < s &&
          (y === 0 && ((y = da(n)), (x += y * y)),
          m === 0 && ((m = da(n)), (x += m * m)),
          x < o && (x = Math.sqrt(o * x)),
          (e.vx += (y * d.value * r) / x),
          (e.vy += (m * d.value * r) / x)),
        !0
      )
    if (d.length || x >= s) return
    ;(d.data !== e || d.next) &&
      (y === 0 && ((y = da(n)), (x += y * y)),
      m === 0 && ((m = da(n)), (x += m * m)),
      x < o && (x = Math.sqrt(o * x)))
    do d.data !== e && ((b = (a[d.data.index] * r) / x), (e.vx += y * b), (e.vy += m * b))
    while ((d = d.next))
  }
  return (
    (l.initialize = function (d, p) {
      ;(t = d), (n = p), u()
    }),
    (l.strength = function (d) {
      return arguments.length ? ((i = typeof d == 'function' ? d : vn(+d)), u(), l) : i
    }),
    (l.distanceMin = function (d) {
      return arguments.length ? ((o = d * d), l) : Math.sqrt(o)
    }),
    (l.distanceMax = function (d) {
      return arguments.length ? ((s = d * d), l) : Math.sqrt(s)
    }),
    (l.theta = function (d) {
      return arguments.length ? ((c = d * d), l) : Math.sqrt(c)
    }),
    l
  )
}
function dD(t) {
  var e = vn(0.1),
    n,
    r,
    i
  typeof t != 'function' && (t = vn(t == null ? 0 : +t))
  function a(s) {
    for (var c = 0, l = n.length, u; c < l; ++c) (u = n[c]), (u.vx += (i[c] - u.x) * r[c] * s)
  }
  function o() {
    if (n) {
      var s,
        c = n.length
      for (r = new Array(c), i = new Array(c), s = 0; s < c; ++s)
        r[s] = isNaN((i[s] = +t(n[s], s, n))) ? 0 : +e(n[s], s, n)
    }
  }
  return (
    (a.initialize = function (s) {
      ;(n = s), o()
    }),
    (a.strength = function (s) {
      return arguments.length ? ((e = typeof s == 'function' ? s : vn(+s)), o(), a) : e
    }),
    (a.x = function (s) {
      return arguments.length ? ((t = typeof s == 'function' ? s : vn(+s)), o(), a) : t
    }),
    a
  )
}
function pD(t) {
  var e = vn(0.1),
    n,
    r,
    i
  typeof t != 'function' && (t = vn(t == null ? 0 : +t))
  function a(s) {
    for (var c = 0, l = n.length, u; c < l; ++c) (u = n[c]), (u.vy += (i[c] - u.y) * r[c] * s)
  }
  function o() {
    if (n) {
      var s,
        c = n.length
      for (r = new Array(c), i = new Array(c), s = 0; s < c; ++s)
        r[s] = isNaN((i[s] = +t(n[s], s, n))) ? 0 : +e(n[s], s, n)
    }
  }
  return (
    (a.initialize = function (s) {
      ;(n = s), o()
    }),
    (a.strength = function (s) {
      return arguments.length ? ((e = typeof s == 'function' ? s : vn(+s)), o(), a) : e
    }),
    (a.y = function (s) {
      return arguments.length ? ((t = typeof s == 'function' ? s : vn(+s)), o(), a) : t
    }),
    a
  )
}
var vD =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const gD = { joint: !0 },
  yD = {
    type: 'link',
    axis: !1,
    legend: !1,
    encode: {
      x: [(t) => t.source.x, (t) => t.target.x],
      y: [(t) => t.source.y, (t) => t.target.y]
    },
    style: { stroke: '#999', strokeOpacity: 0.6 }
  },
  mD = {
    type: 'point',
    axis: !1,
    legend: !1,
    encode: { x: 'x', y: 'y', size: 5, color: 'group', shape: 'point' },
    style: { stroke: '#fff' }
  },
  bD = { text: '' }
function xD(t, e, n) {
  const { nodes: r, links: i } = t,
    { joint: a, nodeStrength: o, linkStrength: s } = e,
    { nodeKey: c = (p) => p.id, linkKey: l = (p) => p.id } = n,
    u = hD(),
    f = K7(i).id(Sr(l))
  typeof o == 'function' && u.strength(o), typeof s == 'function' && f.strength(s)
  const h = fD(r).force('link', f).force('charge', u)
  a ? h.force('center', L7()) : h.force('x', dD()).force('y', pD()), h.stop()
  const d = Math.ceil(Math.log(h.alphaMin()) / Math.log(1 - h.alphaDecay()))
  for (let p = 0; p < d; p++) h.tick()
  return { nodesData: r, linksData: i }
}
const s_ = (t) => {
  const {
      data: e,
      encode: n = {},
      scale: r,
      style: i = {},
      layout: a = {},
      nodeLabels: o = [],
      linkLabels: s = [],
      animate: c = {},
      tooltip: l = {}
    } = t,
    { nodeKey: u = (O) => O.id, linkKey: f = (O) => O.id } = n,
    h = vD(n, ['nodeKey', 'linkKey']),
    d = Object.assign({ nodeKey: u, linkKey: f }, h),
    p = et(d, 'node'),
    v = et(d, 'link'),
    { links: g, nodes: y } = sS(e, d),
    { nodesData: m, linksData: b } = xD({ links: g, nodes: y }, X({}, gD, a), d),
    x = Qr(l, 'link', {
      items: [
        (O) => ({ name: 'source', value: Sr(f)(O.source) }),
        (O) => ({ name: 'target', value: Sr(f)(O.target) })
      ]
    }),
    w = Qr(l, 'node', { items: [(O) => ({ name: 'key', value: Sr(u)(O) })] }, !0)
  return [
    X({}, yD, {
      data: b,
      encode: v,
      labels: s,
      style: et(i, 'link'),
      tooltip: x,
      animate: Jr(c, 'link')
    }),
    X({}, mD, {
      data: m,
      encode: Object.assign({}, p),
      scale: r,
      style: et(i, 'node'),
      tooltip: w,
      labels: [Object.assign(Object.assign({}, bD), et(i, 'label')), ...o],
      animate: Jr(c, 'link')
    })
  ]
}
s_.props = {}
const c_ = (t) => (e) => (n) => {
    const { field: r = 'value', nodeSize: i, separation: a, sortBy: o, as: s = ['x', 'y'] } = e,
      [c, l] = s,
      u = $s(n, (p) => p.children)
        .sum((p) => p[r])
        .sort(o),
      f = t()
    f.size([1, 1]), i && f.nodeSize(i), a && f.separation(a), f(u)
    const h = []
    u.each((p) => {
      ;(p[c] = p.x), (p[l] = p.y), (p.name = p.data.name), h.push(p)
    })
    const d = u.links()
    return (
      d.forEach((p) => {
        ;(p[c] = [p.source[c], p.target[c]]), (p[l] = [p.source[l], p.target[l]])
      }),
      { nodes: h, edges: d }
    )
  },
  l_ = (t) => c_(lj)(t)
l_.props = {}
const u_ = (t) => c_(Zj)(t)
u_.props = {}
const wD = { sortBy: (t, e) => e.value - t.value },
  OD = { axis: !1, legend: !1, type: 'point', encode: { x: 'x', y: 'y', size: 2, shape: 'point' } },
  SD = { type: 'link', encode: { x: 'x', y: 'y', shape: 'smooth' } },
  _D = { text: '', fontSize: 10 },
  f_ = (t) => {
    const {
        data: e,
        encode: n = {},
        scale: r = {},
        style: i = {},
        layout: a = {},
        nodeLabels: o = [],
        linkLabels: s = [],
        animate: c = {},
        tooltip: l = {}
      } = t,
      u = n == null ? void 0 : n.value,
      { nodes: f, edges: h } = u_(
        Object.assign(Object.assign(Object.assign({}, wD), a), { field: u })
      )(e),
      d = Qr(l, 'node', { title: 'name', items: ['value'] }, !0),
      p = Qr(l, 'link', {
        title: '',
        items: [
          (v) => ({ name: 'source', value: v.source.name }),
          (v) => ({ name: 'target', value: v.target.name })
        ]
      })
    return [
      X({}, SD, {
        data: h,
        encode: et(n, 'link'),
        scale: et(r, 'link'),
        labels: s,
        style: Object.assign({ stroke: '#999' }, et(i, 'link')),
        tooltip: p,
        animate: Jr(c, 'link')
      }),
      X({}, OD, {
        data: f,
        scale: et(r, 'node'),
        encode: et(n, 'node'),
        labels: [Object.assign(Object.assign({}, _D), et(i, 'label')), ...o],
        style: Object.assign({}, et(i, 'node')),
        tooltip: d,
        animate: Jr(c, 'node')
      })
    ]
  }
f_.props = {}
var tm = {},
  Tf = {},
  Pf = 34,
  yo = 10,
  Af = 13
function h_(t) {
  return new Function(
    'd',
    'return {' +
      t
        .map(function (e, n) {
          return JSON.stringify(e) + ': d[' + n + '] || ""'
        })
        .join(',') +
      '}'
  )
}
function MD(t, e) {
  var n = h_(t)
  return function (r, i) {
    return e(n(r), i, t)
  }
}
function em(t) {
  var e = Object.create(null),
    n = []
  return (
    t.forEach(function (r) {
      for (var i in r) i in e || n.push((e[i] = i))
    }),
    n
  )
}
function Ke(t, e) {
  var n = t + '',
    r = n.length
  return r < e ? new Array(e - r + 1).join(0) + n : n
}
function ED(t) {
  return t < 0 ? '-' + Ke(-t, 6) : t > 9999 ? '+' + Ke(t, 6) : Ke(t, 4)
}
function TD(t) {
  var e = t.getUTCHours(),
    n = t.getUTCMinutes(),
    r = t.getUTCSeconds(),
    i = t.getUTCMilliseconds()
  return isNaN(t)
    ? 'Invalid Date'
    : ED(t.getUTCFullYear()) +
        '-' +
        Ke(t.getUTCMonth() + 1, 2) +
        '-' +
        Ke(t.getUTCDate(), 2) +
        (i
          ? 'T' + Ke(e, 2) + ':' + Ke(n, 2) + ':' + Ke(r, 2) + '.' + Ke(i, 3) + 'Z'
          : r
          ? 'T' + Ke(e, 2) + ':' + Ke(n, 2) + ':' + Ke(r, 2) + 'Z'
          : n || e
          ? 'T' + Ke(e, 2) + ':' + Ke(n, 2) + 'Z'
          : '')
}
function PD(t) {
  var e = new RegExp(
      '["' +
        t +
        `
\r]`
    ),
    n = t.charCodeAt(0)
  function r(f, h) {
    var d,
      p,
      v = i(f, function (g, y) {
        if (d) return d(g, y - 1)
        ;(p = g), (d = h ? MD(g, h) : h_(g))
      })
    return (v.columns = p || []), v
  }
  function i(f, h) {
    var d = [],
      p = f.length,
      v = 0,
      g = 0,
      y,
      m = p <= 0,
      b = !1
    f.charCodeAt(p - 1) === yo && --p, f.charCodeAt(p - 1) === Af && --p
    function x() {
      if (m) return Tf
      if (b) return (b = !1), tm
      var O,
        S = v,
        _
      if (f.charCodeAt(S) === Pf) {
        for (; (v++ < p && f.charCodeAt(v) !== Pf) || f.charCodeAt(++v) === Pf; );
        return (
          (O = v) >= p
            ? (m = !0)
            : (_ = f.charCodeAt(v++)) === yo
            ? (b = !0)
            : _ === Af && ((b = !0), f.charCodeAt(v) === yo && ++v),
          f.slice(S + 1, O - 1).replace(/""/g, '"')
        )
      }
      for (; v < p; ) {
        if ((_ = f.charCodeAt((O = v++))) === yo) b = !0
        else if (_ === Af) (b = !0), f.charCodeAt(v) === yo && ++v
        else if (_ !== n) continue
        return f.slice(S, O)
      }
      return (m = !0), f.slice(S, p)
    }
    for (; (y = x()) !== Tf; ) {
      for (var w = []; y !== tm && y !== Tf; ) w.push(y), (y = x())
      ;(h && (w = h(w, g++)) == null) || d.push(w)
    }
    return d
  }
  function a(f, h) {
    return f.map(function (d) {
      return h
        .map(function (p) {
          return u(d[p])
        })
        .join(t)
    })
  }
  function o(f, h) {
    return (
      h == null && (h = em(f)),
      [h.map(u).join(t)].concat(a(f, h)).join(`
`)
    )
  }
  function s(f, h) {
    return (
      h == null && (h = em(f)),
      a(f, h).join(`
`)
    )
  }
  function c(f) {
    return f.map(l).join(`
`)
  }
  function l(f) {
    return f.map(u).join(t)
  }
  function u(f) {
    return f == null
      ? ''
      : f instanceof Date
      ? TD(f)
      : e.test((f += ''))
      ? '"' + f.replace(/"/g, '""') + '"'
      : f
  }
  return {
    parse: r,
    parseRows: i,
    format: o,
    formatBody: s,
    formatRows: c,
    formatRow: l,
    formatValue: u
  }
}
function AD(t) {
  for (var e in t) {
    var n = t[e].trim(),
      r,
      i
    if (!n) n = null
    else if (n === 'true') n = !0
    else if (n === 'false') n = !1
    else if (n === 'NaN') n = NaN
    else if (!isNaN((r = +n))) n = r
    else if (
      (i = n.match(
        /^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/
      ))
    )
      kD && i[4] && !i[7] && (n = n.replace(/-/g, '/').replace(/T/, ' ')), (n = new Date(n))
    else continue
    t[e] = n
  }
  return t
}
const kD = new Date('2019-01-01T00:00').getHours() || new Date('2019-07-01T00:00').getHours()
var CD =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(a) {
      return a instanceof n
        ? a
        : new n(function (o) {
            o(a)
          })
    }
    return new (n || (n = Promise))(function (a, o) {
      function s(u) {
        try {
          l(r.next(u))
        } catch (f) {
          o(f)
        }
      }
      function c(u) {
        try {
          l(r.throw(u))
        } catch (f) {
          o(f)
        }
      }
      function l(u) {
        u.done ? a(u.value) : i(u.value).then(s, c)
      }
      l((r = r.apply(t, e || [])).next())
    })
  }
const d_ = (t) => {
  const { value: e, format: n = e.split('.').pop(), delimiter: r = ',', autoType: i = !0 } = t
  return () =>
    CD(void 0, void 0, void 0, function* () {
      const a = yield fetch(e)
      if (n === 'csv') {
        const o = yield a.text()
        return PD(r).parse(o, i ? AD : Ri)
      } else if (n === 'json') return yield a.json()
      throw new Error(`Unknown format: ${n}.`)
    })
}
d_.props = {}
function LD(t) {
  return !t || Object.keys(t).length === 0
}
const p_ = (t) => {
  const { fields: e, key: n = 'key', value: r = 'value' } = t
  return (i) =>
    LD(e)
      ? i
      : i.flatMap((a) => e.map((o) => Object.assign(Object.assign({}, a), { [n]: o, [r]: a[o] })))
}
p_.props = {}
function ND(t) {
  return t != null && !Number.isNaN(t)
}
const v_ = (t) => {
  const { callback: e = ND } = t
  return (n) => n.filter(e)
}
v_.props = {}
const g_ = (t) => {
  const { callback: e } = t
  return (n) => (Array.isArray(n) ? [...n].sort(e) : n)
}
g_.props = {}
function RD(t, e = []) {
  return e.reduce((n, r) => (r in t && (n[r] = t[r]), n), {})
}
const y_ = (t) => {
  const { fields: e } = t
  return (n) => n.map((r) => RD(r, e))
}
y_.props = {}
function ID(t) {
  return Object.keys(t).length === 0
}
const m_ = (t) => (e) => {
  if (!t || ID(t)) return e
  const n = (r) => Object.entries(r).reduce((i, [a, o]) => ((i[t[a] || a] = o), i), {})
  return e.map(n)
}
m_.props = {}
function jD(t, e) {
  return t.map((n) => {
    if (Array.isArray(n)) {
      const [r, i = e] = n
      return [r, i]
    }
    return [n, e]
  })
}
const b_ = (t) => {
  const { fields: e = [] } = t,
    n = jD(e, !0)
  return (r) => {
    const i = (a, o) =>
      n.reduce(
        (s, [c, l = !0]) =>
          s !== 0
            ? s
            : l
            ? a[c] < o[c]
              ? -1
              : +(a[c] !== o[c])
            : a[c] > o[c]
            ? -1
            : +(a[c] !== o[c]),
        0
      )
    return [...r].sort(i)
  }
}
b_.props = {}
const x_ = (t) => {
  const { value: e } = t
  return () => e
}
x_.props = {}
const w_ = (t) => {
  const { callback: e = Ri } = t
  return (n) => e(n)
}
w_.props = {}
const O_ = (t) => {
  const { callback: e = Ri } = t
  return (n) => (Array.isArray(n) ? n.map(e) : n)
}
O_.props = {}
function DD(t, e) {
  return e.value - t.value
}
function $D(t, e) {
  return e.frequency - t.frequency
}
function BD(t, e) {
  return `${t.id}`.localeCompare(`${e.id}`)
}
function FD(t, e) {
  return `${t.name}`.localeCompare(`${e.name}`)
}
const zD = Object.freeze(
    Object.defineProperty(
      { __proto__: null, frequency: $D, id: BD, name: FD, weight: DD },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  GD = {
    y: 0,
    thickness: 0.05,
    weight: !1,
    marginRatio: 0.1,
    id: (t) => t.id,
    source: (t) => t.source,
    target: (t) => t.target,
    sourceWeight: (t) => t.value || 1,
    targetWeight: (t) => t.value || 1,
    sortBy: null
  }
function WD(t) {
  const {
    y: e,
    thickness: n,
    weight: r,
    marginRatio: i,
    id: a,
    source: o,
    target: s,
    sourceWeight: c,
    targetWeight: l,
    sortBy: u
  } = Object.assign(Object.assign({}, GD), t)
  function f(g) {
    const y = g.nodes.map((b) => Object.assign({}, b)),
      m = g.edges.map((b) => Object.assign({}, b))
    return h(y, m), d(y), p(y, m), v(y, m), { nodes: y, edges: m }
  }
  function h(g, y) {
    y.forEach((x) => {
      ;(x.source = o(x)), (x.target = s(x)), (x.sourceWeight = c(x)), (x.targetWeight = l(x))
    })
    const m = qt(y, (x) => x.source),
      b = qt(y, (x) => x.target)
    return (
      g.forEach((x) => {
        x.id = a(x)
        const w = m.has(x.id) ? m.get(x.id) : [],
          O = b.has(x.id) ? b.get(x.id) : []
        ;(x.frequency = w.length + O.length),
          (x.value = Pn(w, (S) => S.sourceWeight) + Pn(O, (S) => S.targetWeight))
      }),
      { nodes: g, edges: y }
    )
  }
  function d(g, y) {
    const m = typeof u == 'function' ? u : zD[u]
    m && g.sort(m)
  }
  function p(g, y) {
    const m = g.length
    if (!m) throw ql("Invalid nodes: it's empty!")
    if (!r) {
      const w = 1 / m
      return (
        g.forEach((O, S) => {
          ;(O.x = (S + 0.5) * w), (O.y = e)
        }),
        { nodes: g, edges: y }
      )
    }
    const b = i / (2 * m),
      x = g.reduce((w, O) => (w += O.value), 0)
    return (
      g.reduce((w, O) => {
        ;(O.weight = O.value / x), (O.width = O.weight * (1 - i)), (O.height = n)
        const S = b + w,
          _ = S + O.width,
          M = e - n / 2,
          E = M + n
        return (O.x = [S, _, _, S]), (O.y = [M, M, E, E]), w + O.width + 2 * b
      }, 0),
      { nodes: g, edges: y }
    )
  }
  function v(g, y) {
    const m = new Map(g.map((w) => [w.id, w]))
    if (!r)
      return (
        y.forEach((w) => {
          const O = o(w),
            S = s(w),
            _ = m.get(O),
            M = m.get(S)
          _ && M && ((w.x = [_.x, M.x]), (w.y = [_.y, M.y]))
        }),
        { nodes: g, edges: y }
      )
    y.forEach((w) => {
      ;(w.x = [0, 0, 0, 0]), (w.y = [e, e, e, e])
    })
    const b = qt(y, (w) => w.source),
      x = qt(y, (w) => w.target)
    g.forEach((w) => {
      const { edges: O, width: S, x: _, y: M, value: E, id: T } = w,
        C = b.get(T) || [],
        A = x.get(T) || []
      let P = 0
      C.map((k) => {
        const L = (k.sourceWeight / E) * S
        ;(k.x[0] = w.x[0] + P), (k.x[1] = w.x[0] + P + L), (P += L)
      }),
        A.forEach((k) => {
          const L = (k.targetWeight / E) * S
          ;(k.x[3] = w.x[0] + P), (k.x[2] = w.x[0] + P + L), (P += L)
        })
    })
  }
  return f
}
const S_ = (t) => (e) => WD(t)(e)
S_.props = {}
const kf = Math.PI / 180,
  To = 64,
  Yc = 2048
function YD(t) {
  return t.text
}
function HD() {
  return 'serif'
}
function nm() {
  return 'normal'
}
function VD(t) {
  return t.value
}
function XD() {
  return ~~(Math.random() * 2) * 90
}
function UD() {
  return 1
}
function qD() {}
function KD(t, e, n, r) {
  if (e.sprite) return
  const i = t.context,
    a = t.ratio
  i.clearRect(0, 0, (To << 5) / a, Yc / a)
  let o = 0,
    s = 0,
    c = 0
  const l = n.length
  for (--r; ++r < l; ) {
    ;(e = n[r]),
      i.save(),
      (i.font = e.style + ' ' + e.weight + ' ' + ~~((e.size + 1) / a) + 'px ' + e.font)
    let h = i.measureText(e.text + 'm').width * a,
      d = e.size << 1
    if (e.rotate) {
      const p = Math.sin(e.rotate * kf),
        v = Math.cos(e.rotate * kf),
        g = h * v,
        y = h * p,
        m = d * v,
        b = d * p
      ;(h = ((Math.max(Math.abs(g + b), Math.abs(g - b)) + 31) >> 5) << 5),
        (d = ~~Math.max(Math.abs(y + m), Math.abs(y - m)))
    } else h = ((h + 31) >> 5) << 5
    if ((d > c && (c = d), o + h >= To << 5 && ((o = 0), (s += c), (c = 0)), s + d >= Yc)) break
    i.translate((o + (h >> 1)) / a, (s + (d >> 1)) / a),
      e.rotate && i.rotate(e.rotate * kf),
      i.fillText(e.text, 0, 0),
      e.padding && ((i.lineWidth = 2 * e.padding), i.strokeText(e.text, 0, 0)),
      i.restore(),
      (e.width = h),
      (e.height = d),
      (e.xoff = o),
      (e.yoff = s),
      (e.x1 = h >> 1),
      (e.y1 = d >> 1),
      (e.x0 = -e.x1),
      (e.y0 = -e.y1),
      (e.hasText = !0),
      (o += h)
  }
  const u = i.getImageData(0, 0, (To << 5) / a, Yc / a).data,
    f = []
  for (; --r >= 0; ) {
    if (((e = n[r]), !e.hasText)) continue
    const h = e.width,
      d = h >> 5
    let p = e.y1 - e.y0
    for (let y = 0; y < p * d; y++) f[y] = 0
    if (((o = e.xoff), o == null)) return
    s = e.yoff
    let v = 0,
      g = -1
    for (let y = 0; y < p; y++) {
      for (let m = 0; m < h; m++) {
        const b = d * y + (m >> 5),
          x = u[((s + y) * (To << 5) + (o + m)) << 2] ? 1 << (31 - (m % 32)) : 0
        ;(f[b] |= x), (v |= x)
      }
      v ? (g = y) : (e.y0++, p--, y--, s++)
    }
    ;(e.y1 = e.y0 + g), (e.sprite = f.slice(0, (e.y1 - e.y0) * d))
  }
}
function ZD(t, e, n) {
  n >>= 5
  const r = t.sprite,
    i = t.width >> 5,
    a = t.x - (i << 4),
    o = a & 127,
    s = 32 - o,
    c = t.y1 - t.y0
  let l = (t.y + t.y0) * n + (a >> 5),
    u
  for (let f = 0; f < c; f++) {
    u = 0
    for (let h = 0; h <= i; h++)
      if (((u << s) | (h < i ? (u = r[f * i + h]) >>> o : 0)) & e[l + h]) return !0
    l += n
  }
  return !1
}
function QD(t, e) {
  const n = t[0],
    r = t[1]
  e.x + e.x0 < n.x && (n.x = e.x + e.x0),
    e.y + e.y0 < n.y && (n.y = e.y + e.y0),
    e.x + e.x1 > r.x && (r.x = e.x + e.x1),
    e.y + e.y1 > r.y && (r.y = e.y + e.y1)
}
function JD(t, e) {
  return t.x + t.x1 > e[0].x && t.x + t.x0 < e[1].x && t.y + t.y1 > e[0].y && t.y + t.y0 < e[1].y
}
function __(t) {
  const e = t[0] / t[1]
  return function (n) {
    return [e * (n *= 0.1) * Math.cos(n), n * Math.sin(n)]
  }
}
function t$(t) {
  const n = (4 * t[0]) / t[1]
  let r = 0,
    i = 0
  return function (a) {
    const o = a < 0 ? -1 : 1
    switch ((Math.sqrt(1 + 4 * o * a) - o) & 3) {
      case 0:
        r += n
        break
      case 1:
        i += 4
        break
      case 2:
        r -= n
        break
      default:
        i -= 4
        break
    }
    return [r, i]
  }
}
function rm(t) {
  const e = []
  let n = -1
  for (; ++n < t; ) e[n] = 0
  return e
}
function e$() {
  return document.createElement('canvas')
}
function Cr(t) {
  return typeof t == 'function'
    ? t
    : function () {
        return t
      }
}
const n$ = { archimedean: __, rectangular: t$ }
function r$() {
  let t = [256, 256],
    e = YD,
    n = HD,
    r = VD,
    i = nm,
    a = XD,
    o = UD,
    s = __,
    c = Math.random,
    l = qD,
    u = [],
    f = null,
    h = 1 / 0
  const d = nm,
    p = e$,
    v = {}
  ;(v.start = function () {
    const [m, b] = t,
      x = g(p()),
      w = v.board ? v.board : rm((t[0] >> 5) * t[1]),
      O = u.length,
      S = [],
      _ = u
        .map(function (C, A, P) {
          return (
            (C.text = e.call(this, C, A, P)),
            (C.font = n.call(this, C, A, P)),
            (C.style = d.call(this, C, A, P)),
            (C.weight = i.call(this, C, A, P)),
            (C.rotate = a.call(this, C, A, P)),
            (C.size = ~~r.call(this, C, A, P)),
            (C.padding = o.call(this, C, A, P)),
            C
          )
        })
        .sort(function (C, A) {
          return A.size - C.size
        })
    let M = -1,
      E = v.board
        ? [
            { x: 0, y: 0 },
            { x: m, y: b }
          ]
        : void 0
    f && clearInterval(f), (f = setInterval(T, 0)), T()
    function T() {
      const C = Date.now()
      for (; Date.now() - C < h && ++M < O; ) {
        const A = _[M]
        ;(A.x = (m * (c() + 0.5)) >> 1),
          (A.y = (b * (c() + 0.5)) >> 1),
          KD(x, A, _, M),
          A.hasText &&
            y(w, A, E) &&
            (l.call(null, 'word', { cloud: v, word: A }),
            S.push(A),
            E
              ? v.hasImage || QD(E, A)
              : (E = [
                  { x: A.x + A.x0, y: A.y + A.y0 },
                  { x: A.x + A.x1, y: A.y + A.y1 }
                ]),
            (A.x -= t[0] >> 1),
            (A.y -= t[1] >> 1))
      }
      ;(v._tags = S),
        (v._bounds = E),
        M >= O && (v.stop(), l.call(null, 'end', { cloud: v, words: S, bounds: E }))
    }
    return v
  }),
    (v.stop = function () {
      return f && (clearInterval(f), (f = null)), v
    })
  function g(m) {
    m.width = m.height = 1
    const b = Math.sqrt(m.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2)
    ;(m.width = (To << 5) / b), (m.height = Yc / b)
    const x = m.getContext('2d')
    return (x.fillStyle = x.strokeStyle = 'red'), (x.textAlign = 'center'), { context: x, ratio: b }
  }
  function y(m, b, x) {
    const w = b.x,
      O = b.y,
      S = Math.sqrt(t[0] * t[0] + t[1] * t[1]),
      _ = s(t),
      M = c() < 0.5 ? 1 : -1
    let E,
      T = -M,
      C,
      A
    for (
      ;
      (E = _((T += M))) && ((C = ~~E[0]), (A = ~~E[1]), !(Math.min(Math.abs(C), Math.abs(A)) >= S));

    )
      if (
        ((b.x = w + C),
        (b.y = O + A),
        !(b.x + b.x0 < 0 || b.y + b.y0 < 0 || b.x + b.x1 > t[0] || b.y + b.y1 > t[1]) &&
          (!x || !ZD(b, m, t[0])) &&
          (!x || JD(b, x)))
      ) {
        const P = b.sprite,
          k = b.width >> 5,
          L = t[0] >> 5,
          R = b.x - (k << 4),
          j = R & 127,
          I = 32 - j,
          D = b.y1 - b.y0
        let $,
          B = (b.y + b.y0) * L + (R >> 5)
        for (let F = 0; F < D; F++) {
          $ = 0
          for (let W = 0; W <= k; W++) m[B + W] |= ($ << I) | (W < k ? ($ = P[F * k + W]) >>> j : 0)
          B += L
        }
        return delete b.sprite, !0
      }
    return !1
  }
  return (
    (v.createMask = (m) => {
      const b = document.createElement('canvas'),
        [x, w] = t
      if (!x || !w) return
      const O = x >> 5,
        S = rm((x >> 5) * w)
      ;(b.width = x), (b.height = w)
      const _ = b.getContext('2d')
      _.drawImage(m, 0, 0, m.width, m.height, 0, 0, x, w)
      const M = _.getImageData(0, 0, x, w).data
      for (let E = 0; E < w; E++)
        for (let T = 0; T < x; T++) {
          const C = O * E + (T >> 5),
            A = (E * x + T) << 2,
            k = M[A] >= 250 && M[A + 1] >= 250 && M[A + 2] >= 250 ? 1 << (31 - (T % 32)) : 0
          S[C] |= k
        }
      ;(v.board = S), (v.hasImage = !0)
    }),
    (v.timeInterval = function (m) {
      h = m ?? 1 / 0
    }),
    (v.words = function (m) {
      u = m
    }),
    (v.size = function (m = []) {
      t = [+m[0], +m[1]]
    }),
    (v.text = function (m) {
      e = Cr(m)
    }),
    (v.font = function (m) {
      n = Cr(m)
    }),
    (v.fontWeight = function (m) {
      i = Cr(m)
    }),
    (v.rotate = function (m) {
      a = Cr(m)
    }),
    (v.spiral = function (m) {
      s = n$[m] || m
    }),
    (v.fontSize = function (m) {
      r = Cr(m)
    }),
    (v.padding = function (m) {
      o = Cr(m)
    }),
    (v.random = function (m) {
      c = Cr(m)
    }),
    (v.on = function (m) {
      l = Cr(m)
    }),
    v
  )
}
var i$ =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(a) {
      return a instanceof n
        ? a
        : new n(function (o) {
            o(a)
          })
    }
    return new (n || (n = Promise))(function (a, o) {
      function s(u) {
        try {
          l(r.next(u))
        } catch (f) {
          o(f)
        }
      }
      function c(u) {
        try {
          l(r.throw(u))
        } catch (f) {
          o(f)
        }
      }
      function l(u) {
        u.done ? a(u.value) : i(u.value).then(s, c)
      }
      l((r = r.apply(t, e || [])).next())
    })
  }
function a$(t, e) {
  return {
    set(n, r, i) {
      if (e[n] === void 0) return this
      const a = r ? r.call(null, e[n]) : e[n]
      return i ? i.call(null, a) : typeof t[n] == 'function' ? t[n](a) : (t[n] = a), this
    },
    setAsync(n, r, i) {
      return i$(this, void 0, void 0, function* () {
        if (e[n] === void 0) return this
        const a = r ? yield r.call(null, e[n]) : e[n]
        return i ? i.call(null, a) : typeof t[n] == 'function' ? t[n](a) : (t[n] = a), this
      })
    }
  }
}
var o$ =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, r) {
      function i(a) {
        return a instanceof n
          ? a
          : new n(function (o) {
              o(a)
            })
      }
      return new (n || (n = Promise))(function (a, o) {
        function s(u) {
          try {
            l(r.next(u))
          } catch (f) {
            o(f)
          }
        }
        function c(u) {
          try {
            l(r.throw(u))
          } catch (f) {
            o(f)
          }
        }
        function l(u) {
          u.done ? a(u.value) : i(u.value).then(s, c)
        }
        l((r = r.apply(t, e || [])).next())
      })
    },
  s$ =
    (globalThis && globalThis.__rest) ||
    function (t, e) {
      var n = {}
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
      if (t != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          e.indexOf(r[i]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
            (n[r[i]] = t[r[i]])
      return n
    }
const c$ = { size: [500, 500], fontSize: [14, 28] }
function l$(t) {
  return new Promise((e, n) => {
    if (t instanceof HTMLImageElement) {
      e(t)
      return
    }
    if (typeof t == 'string') {
      const r = new Image()
      ;(r.crossOrigin = 'anonymous'),
        (r.src = t),
        (r.onload = () => e(r)),
        (r.onerror = () => {
          console.error(`'image ${t} load failed !!!'`), n()
        })
      return
    }
    n()
  })
}
function u$(t, e) {
  if (typeof t == 'function') return t
  if (Array.isArray(t)) {
    const [n, r] = t
    if (!e) return () => (r + n) / 2
    const [i, a] = e
    return a === i ? () => (r + n) / 2 : ({ value: o }) => ((r - n) / (a - i)) * (o - i) + n
  }
  return () => t
}
const M_ = (t) => (e) =>
  o$(void 0, void 0, void 0, function* () {
    const n = Object.assign({}, c$, t),
      r = r$()
    yield a$(r, n)
      .set('fontSize', (y) => {
        const m = e.map((b) => b.value)
        return u$(y, [gn(m), Ct(m)])
      })
      .set('font')
      .set('fontStyle')
      .set('fontWeight')
      .set('padding')
      .set('rotate')
      .set('size')
      .set('spiral')
      .set('timeInterval')
      .set('random')
      .set('text')
      .set('on')
      .setAsync('imageMask', l$, r.createMask),
      r.words([...e])
    const i = r.start(),
      [a, o] = n.size,
      s = [
        { x: 0, y: 0 },
        { x: a, y: o }
      ],
      { _bounds: c = s, _tags: l, hasImage: u } = i,
      f = l.map((y) => {
        var { x: m, y: b } = y,
          x = s$(y, ['x', 'y'])
        return Object.assign(Object.assign({}, x), { x: m + a / 2, y: b + o / 2 })
      }),
      [{ x: h, y: d }, { x: p, y: v }] = c,
      g = { text: '', value: 0, opacity: 0, fontSize: 0 }
    return (
      f.push(
        Object.assign(Object.assign({}, g), { x: u ? 0 : h, y: u ? 0 : d }),
        Object.assign(Object.assign({}, g), { x: u ? a : p, y: u ? o : v })
      ),
      f
    )
  })
M_.props = {}
function im(t) {
  return typeof t == 'string' ? (e) => e[t] : t
}
const E_ = (t) => {
  const { join: e, on: n, select: r = [], as: i = r, unknown: a = NaN } = t,
    [o, s] = n,
    c = im(s),
    l = im(o),
    u = Hd(
      e,
      ([f]) => f,
      (f) => c(f)
    )
  return (f) =>
    f.map((h) => {
      const d = u.get(l(h))
      return Object.assign(
        Object.assign({}, h),
        r.reduce((p, v, g) => ((p[i[g]] = d ? d[v] : a), p), {})
      )
    })
}
E_.props = {}
const T_ = (t) => {
  const { start: e, end: n } = t
  return (r) => r.slice(e, n)
}
T_.props = {}
var P_ = { exports: {} },
  A_ = { exports: {} }
;(function (t) {
  var e = t.exports
  ;(t.exports.isNumber = function (n) {
    return typeof n == 'number'
  }),
    (t.exports.findMin = function (n) {
      if (n.length === 0) return 1 / 0
      for (var r = n[0], i = 1; i < n.length; i++) r = Math.min(r, n[i])
      return r
    }),
    (t.exports.findMax = function (n) {
      if (n.length === 0) return -1 / 0
      for (var r = n[0], i = 1; i < n.length; i++) r = Math.max(r, n[i])
      return r
    }),
    (t.exports.findMinMulti = function (n) {
      for (var r = e.findMin(n[0]), i = 1; i < n.length; i++) r = Math.min(r, e.findMin(n[i]))
      return r
    }),
    (t.exports.findMaxMulti = function (n) {
      for (var r = e.findMax(n[0]), i = 1; i < n.length; i++) r = Math.max(r, e.findMax(n[i]))
      return r
    }),
    (t.exports.inside = function (n, r, i) {
      return n <= i && i <= r
    })
})(A_)
var f$ = A_.exports
;(function (t) {
  var e = 50,
    n = 2,
    r = Math.log(2),
    i = t.exports,
    a = f$
  function o(c) {
    return 1 - Math.abs(c)
  }
  ;(t.exports.getUnifiedMinMax = function (c, l) {
    return i.getUnifiedMinMaxMulti([c], l)
  }),
    (t.exports.getUnifiedMinMaxMulti = function (c, l) {
      l = l || {}
      var u = !1,
        f = !1,
        h = a.isNumber(l.width) ? l.width : n,
        d = a.isNumber(l.size) ? l.size : e,
        p = a.isNumber(l.min) ? l.min : ((u = !0), a.findMinMulti(c)),
        v = a.isNumber(l.max) ? l.max : ((f = !0), a.findMaxMulti(c)),
        g = v - p,
        y = g / (d - 1)
      return u && (p = p - 2 * h * y), f && (v = v + 2 * h * y), { min: p, max: v }
    }),
    (t.exports.create = function (c, l) {
      if (((l = l || {}), !c || c.length === 0)) return []
      var u = a.isNumber(l.size) ? l.size : e,
        f = a.isNumber(l.width) ? l.width : n,
        h = i.getUnifiedMinMax(c, { size: u, width: f, min: l.min, max: l.max }),
        d = h.min,
        p = h.max,
        v = p - d,
        g = v / (u - 1)
      if (v === 0) return [{ x: d, y: 1 }]
      for (var y = [], m = 0; m < u; m++) y.push({ x: d + m * g, y: 0 })
      var b = function (T) {
          return Math.floor((T - d) / g)
        },
        x = s(o, f),
        w = x[f],
        O = x[f - 1] - x[f - 2],
        S = 0
      c.forEach(function (T) {
        var C = b(T)
        if (!(C + f < 0 || C - f >= y.length)) {
          var A = Math.max(C - f, 0),
            P = C,
            k = Math.min(C + f, y.length - 1),
            L = A - (C - f),
            R = C + f - k,
            j = x[-f - 1 + L] || 0,
            I = x[-f - 1 + R] || 0,
            D = w / (w - j - I)
          L > 0 && (S += D * (L - 1) * O)
          var $ = Math.max(0, C - f + 1)
          a.inside(0, y.length - 1, $) && (y[$].y += D * 1 * O),
            a.inside(0, y.length - 1, P + 1) && (y[P + 1].y -= D * 2 * O),
            a.inside(0, y.length - 1, k + 1) && (y[k + 1].y += D * 1 * O)
        }
      })
      var _ = S,
        M = 0,
        E = 0
      return (
        y.forEach(function (T) {
          ;(M += T.y), (_ += M), (T.y = _), (E += _)
        }),
        E > 0 &&
          y.forEach(function (T) {
            T.y /= E
          }),
        y
      )
    })
  function s(c, l) {
    for (var u = {}, f = 0, h = -l; h <= l; h++) (f += c(h / l)), (u[h] = f)
    return u
  }
  ;(t.exports.getExpectedValueFromPdf = function (c) {
    if (!(!c || c.length === 0)) {
      var l = 0
      return (
        c.forEach(function (u) {
          l += u.x * u.y
        }),
        l
      )
    }
  }),
    (t.exports.getXWithLeftTailArea = function (c, l) {
      if (!(!c || c.length === 0)) {
        for (var u = 0, f = 0, h = 0; h < c.length && ((f = h), (u += c[h].y), !(u >= l)); h++);
        return c[f].x
      }
    }),
    (t.exports.getPerplexity = function (c) {
      if (!(!c || c.length === 0)) {
        var l = 0
        return (
          c.forEach(function (u) {
            var f = Math.log(u.y)
            isFinite(f) && (l += u.y * f)
          }),
          (l = -l / r),
          Math.pow(2, l)
        )
      }
    })
})(P_)
var h$ = P_.exports
const d$ = Ld(h$),
  k_ = (t) => {
    const {
        field: e,
        groupBy: n,
        as: r = ['y', 'size'],
        min: i,
        max: a,
        size: o = 10,
        width: s
      } = t,
      [c, l] = r
    return (u) =>
      Array.from(qt(u, (h) => n.map((d) => h[d]).join('-')).values()).map((h) => {
        const d = d$.create(
            h.map((g) => g[e]),
            { min: i, max: a, size: o, width: s }
          ),
          p = d.map((g) => g.x),
          v = d.map((g) => g.y)
        return Object.assign(Object.assign({}, h[0]), { [c]: p, [l]: v })
      })
  }
k_.props = {}
function p$(t, e, n, r) {
  r = r || {}
  var i = r.maxIterations || 100,
    a = r.tolerance || 1e-10,
    o = t(e),
    s = t(n),
    c = n - e
  if (o * s > 0) throw 'Initial bisect points must have opposite signs'
  if (o === 0) return e
  if (s === 0) return n
  for (var l = 0; l < i; ++l) {
    c /= 2
    var u = e + c,
      f = t(u)
    if ((f * o >= 0 && (e = u), Math.abs(c) < a || f === 0)) return u
  }
  return e + c
}
function qh(t) {
  for (var e = new Array(t), n = 0; n < t; ++n) e[n] = 0
  return e
}
function am(t, e) {
  return qh(t).map(function () {
    return qh(e)
  })
}
function xa(t, e) {
  for (var n = 0, r = 0; r < t.length; ++r) n += t[r] * e[r]
  return n
}
function Kh(t) {
  return Math.sqrt(xa(t, t))
}
function Zh(t, e, n) {
  for (var r = 0; r < e.length; ++r) t[r] = e[r] * n
}
function yr(t, e, n, r, i) {
  for (var a = 0; a < t.length; ++a) t[a] = e * n[a] + r * i[a]
}
function v$(t, e, n) {
  n = n || {}
  var r = n.maxIterations || e.length * 200,
    i = n.nonZeroDelta || 1.05,
    a = n.zeroDelta || 0.001,
    o = n.minErrorDelta || 1e-6,
    s = n.minErrorDelta || 1e-5,
    c = n.rho !== void 0 ? n.rho : 1,
    l = n.chi !== void 0 ? n.chi : 2,
    u = n.psi !== void 0 ? n.psi : -0.5,
    f = n.sigma !== void 0 ? n.sigma : 0.5,
    h,
    d = e.length,
    p = new Array(d + 1)
  ;(p[0] = e), (p[0].fx = t(e)), (p[0].id = 0)
  for (var v = 0; v < d; ++v) {
    var g = e.slice()
    ;(g[v] = g[v] ? g[v] * i : a), (p[v + 1] = g), (p[v + 1].fx = t(g)), (p[v + 1].id = v + 1)
  }
  function y(C) {
    for (var A = 0; A < C.length; A++) p[d][A] = C[A]
    p[d].fx = C.fx
  }
  for (
    var m = function (C, A) {
        return C.fx - A.fx
      },
      b = e.slice(),
      x = e.slice(),
      w = e.slice(),
      O = e.slice(),
      S = 0;
    S < r;
    ++S
  ) {
    if ((p.sort(m), n.history)) {
      var _ = p.map(function (C) {
        var A = C.slice()
        return (A.fx = C.fx), (A.id = C.id), A
      })
      _.sort(function (C, A) {
        return C.id - A.id
      }),
        n.history.push({ x: p[0].slice(), fx: p[0].fx, simplex: _ })
    }
    for (h = 0, v = 0; v < d; ++v) h = Math.max(h, Math.abs(p[0][v] - p[1][v]))
    if (Math.abs(p[0].fx - p[d].fx) < o && h < s) break
    for (v = 0; v < d; ++v) {
      b[v] = 0
      for (var M = 0; M < d; ++M) b[v] += p[M][v]
      b[v] /= d
    }
    var E = p[d]
    if ((yr(x, 1 + c, b, -c, E), (x.fx = t(x)), x.fx < p[0].fx))
      yr(O, 1 + l, b, -l, E), (O.fx = t(O)), O.fx < x.fx ? y(O) : y(x)
    else if (x.fx >= p[d - 1].fx) {
      var T = !1
      if (
        (x.fx > E.fx
          ? (yr(w, 1 + u, b, -u, E), (w.fx = t(w)), w.fx < E.fx ? y(w) : (T = !0))
          : (yr(w, 1 - u * c, b, u * c, E), (w.fx = t(w)), w.fx < x.fx ? y(w) : (T = !0)),
        T)
      ) {
        if (f >= 1) break
        for (v = 1; v < p.length; ++v) yr(p[v], 1 - f, p[0], f, p[v]), (p[v].fx = t(p[v]))
      }
    } else y(x)
  }
  return p.sort(m), { fx: p[0].fx, x: p[0] }
}
function g$(t, e, n, r, i, a, o) {
  var s = n.fx,
    c = xa(n.fxprime, e),
    l = s,
    u = s,
    f = c,
    h = 0
  ;(i = i || 1), (a = a || 1e-6), (o = o || 0.1)
  function d(v, g, y) {
    for (var m = 0; m < 16; ++m)
      if (
        ((i = (v + g) / 2),
        yr(r.x, 1, n.x, i, e),
        (l = r.fx = t(r.x, r.fxprime)),
        (f = xa(r.fxprime, e)),
        l > s + a * i * c || l >= y)
      )
        g = i
      else {
        if (Math.abs(f) <= -o * c) return i
        f * (g - v) >= 0 && (g = v), (v = i), (y = l)
      }
    return 0
  }
  for (var p = 0; p < 10; ++p) {
    if (
      (yr(r.x, 1, n.x, i, e),
      (l = r.fx = t(r.x, r.fxprime)),
      (f = xa(r.fxprime, e)),
      l > s + a * i * c || (p && l >= u))
    )
      return d(h, i, u)
    if (Math.abs(f) <= -o * c) return i
    if (f >= 0) return d(i, h, l)
    ;(u = l), (h = i), (i *= 2)
  }
  return i
}
function y$(t, e, n) {
  var r = { x: e.slice(), fx: 0, fxprime: e.slice() },
    i = { x: e.slice(), fx: 0, fxprime: e.slice() },
    a = e.slice(),
    o,
    s,
    c = 1,
    l
  ;(n = n || {}),
    (l = n.maxIterations || e.length * 20),
    (r.fx = t(r.x, r.fxprime)),
    (o = r.fxprime.slice()),
    Zh(o, r.fxprime, -1)
  for (var u = 0; u < l; ++u) {
    if (
      ((c = g$(t, o, r, i, c)),
      n.history &&
        n.history.push({ x: r.x.slice(), fx: r.fx, fxprime: r.fxprime.slice(), alpha: c }),
      !c)
    )
      Zh(o, r.fxprime, -1)
    else {
      yr(a, 1, i.fxprime, -1, r.fxprime)
      var f = xa(r.fxprime, r.fxprime),
        h = Math.max(0, xa(a, i.fxprime) / f)
      yr(o, h, o, -1, i.fxprime), (s = r), (r = i), (i = s)
    }
    if (Kh(r.fxprime) <= 1e-5) break
  }
  return (
    n.history && n.history.push({ x: r.x.slice(), fx: r.fx, fxprime: r.fxprime.slice(), alpha: c }),
    r
  )
}
const C_ = 1e-10
function L_(t, e) {
  const n = b$(t),
    r = n.filter(function (c) {
      return m$(c, t)
    })
  let i = 0,
    a = 0,
    o
  const s = []
  if (r.length > 1) {
    const c = x$(r)
    for (o = 0; o < r.length; ++o) {
      const u = r[o]
      u.angle = Math.atan2(u.x - c.x, u.y - c.y)
    }
    r.sort(function (u, f) {
      return f.angle - u.angle
    })
    let l = r[r.length - 1]
    for (o = 0; o < r.length; ++o) {
      const u = r[o]
      a += (l.x + u.x) * (u.y - l.y)
      const f = { x: (u.x + l.x) / 2, y: (u.y + l.y) / 2 }
      let h = null
      for (let d = 0; d < u.parentIndex.length; ++d)
        if (l.parentIndex.indexOf(u.parentIndex[d]) > -1) {
          const p = t[u.parentIndex[d]],
            v = Math.atan2(u.x - p.x, u.y - p.y),
            g = Math.atan2(l.x - p.x, l.y - p.y)
          let y = g - v
          y < 0 && (y += 2 * Math.PI)
          const m = g - y / 2
          let b = us(f, { x: p.x + p.radius * Math.sin(m), y: p.y + p.radius * Math.cos(m) })
          b > p.radius * 2 && (b = p.radius * 2),
            (h === null || h.width > b) && (h = { circle: p, width: b, p1: u, p2: l })
        }
      h !== null && (s.push(h), (i += Qh(h.circle.radius, h.width)), (l = u))
    }
  } else {
    let c = t[0]
    for (o = 1; o < t.length; ++o) t[o].radius < c.radius && (c = t[o])
    let l = !1
    for (o = 0; o < t.length; ++o)
      if (us(t[o], c) > Math.abs(c.radius - t[o].radius)) {
        l = !0
        break
      }
    l
      ? (i = a = 0)
      : ((i = c.radius * c.radius * Math.PI),
        s.push({
          circle: c,
          p1: { x: c.x, y: c.y + c.radius },
          p2: { x: c.x - C_, y: c.y + c.radius },
          width: c.radius * 2
        }))
  }
  return (
    (a /= 2),
    e &&
      ((e.area = i + a),
      (e.arcArea = i),
      (e.polygonArea = a),
      (e.arcs = s),
      (e.innerPoints = r),
      (e.intersectionPoints = n)),
    i + a
  )
}
function m$(t, e) {
  for (let n = 0; n < e.length; ++n) if (us(t, e[n]) > e[n].radius + C_) return !1
  return !0
}
function b$(t) {
  const e = []
  for (let n = 0; n < t.length; ++n)
    for (let r = n + 1; r < t.length; ++r) {
      const i = R_(t[n], t[r])
      for (let a = 0; a < i.length; ++a) {
        const o = i[a]
        ;(o.parentIndex = [n, r]), e.push(o)
      }
    }
  return e
}
function Qh(t, e) {
  return t * t * Math.acos(1 - e / t) - (t - e) * Math.sqrt(e * (2 * t - e))
}
function us(t, e) {
  return Math.sqrt((t.x - e.x) * (t.x - e.x) + (t.y - e.y) * (t.y - e.y))
}
function N_(t, e, n) {
  if (n >= t + e) return 0
  if (n <= Math.abs(t - e)) return Math.PI * Math.min(t, e) * Math.min(t, e)
  const r = t - (n * n - e * e + t * t) / (2 * n),
    i = e - (n * n - t * t + e * e) / (2 * n)
  return Qh(t, r) + Qh(e, i)
}
function R_(t, e) {
  const n = us(t, e),
    r = t.radius,
    i = e.radius
  if (n >= r + i || n <= Math.abs(r - i)) return []
  const a = (r * r - i * i + n * n) / (2 * n),
    o = Math.sqrt(r * r - a * a),
    s = t.x + (a * (e.x - t.x)) / n,
    c = t.y + (a * (e.y - t.y)) / n,
    l = -(e.y - t.y) * (o / n),
    u = -(e.x - t.x) * (o / n)
  return [
    { x: s + l, y: c - u },
    { x: s - l, y: c + u }
  ]
}
function x$(t) {
  const e = { x: 0, y: 0 }
  for (let n = 0; n < t.length; ++n) (e.x += t[n].x), (e.y += t[n].y)
  return (e.x /= t.length), (e.y /= t.length), e
}
function w$(t, e) {
  ;(e = e || {}), (e.maxIterations = e.maxIterations || 500)
  const n = e.initialLayout || M$,
    r = e.lossFunction || o0
  t = O$(t)
  const i = n(t, e),
    a = [],
    o = []
  let s
  for (s in i) i.hasOwnProperty(s) && (a.push(i[s].x), a.push(i[s].y), o.push(s))
  const l = v$(
    function (u) {
      const f = {}
      for (let h = 0; h < o.length; ++h) {
        const d = o[h]
        f[d] = { x: u[2 * h], y: u[2 * h + 1], radius: i[d].radius }
      }
      return r(f, t)
    },
    a,
    e
  ).x
  for (let u = 0; u < o.length; ++u) (s = o[u]), (i[s].x = l[2 * u]), (i[s].y = l[2 * u + 1])
  return i
}
const I_ = 1e-10
function Jh(t, e, n) {
  return Math.min(t, e) * Math.min(t, e) * Math.PI <= n + I_
    ? Math.abs(t - e)
    : p$(
        function (r) {
          return N_(t, e, r) - n
        },
        0,
        t + e
      )
}
function O$(t) {
  t = t.slice()
  const e = [],
    n = {}
  let r, i, a, o
  for (r = 0; r < t.length; ++r) {
    const s = t[r]
    s.sets.length == 1
      ? e.push(s.sets[0])
      : s.sets.length == 2 && ((a = s.sets[0]), (o = s.sets[1]), (n[[a, o]] = !0), (n[[o, a]] = !0))
  }
  for (e.sort((s, c) => (s > c ? 1 : -1)), r = 0; r < e.length; ++r)
    for (a = e[r], i = r + 1; i < e.length; ++i)
      (o = e[i]), [a, o] in n || t.push({ sets: [a, o], size: 0 })
  return t
}
function S$(t, e, n) {
  const r = am(e.length, e.length),
    i = am(e.length, e.length)
  return (
    t
      .filter(function (a) {
        return a.sets.length == 2
      })
      .map(function (a) {
        const o = n[a.sets[0]],
          s = n[a.sets[1]],
          c = Math.sqrt(e[o].size / Math.PI),
          l = Math.sqrt(e[s].size / Math.PI),
          u = Jh(c, l, a.size)
        r[o][s] = r[s][o] = u
        let f = 0
        a.size + 1e-10 >= Math.min(e[o].size, e[s].size) ? (f = 1) : a.size <= 1e-10 && (f = -1),
          (i[o][s] = i[s][o] = f)
      }),
    { distances: r, constraints: i }
  )
}
function _$(t, e, n, r) {
  let i = 0,
    a
  for (a = 0; a < e.length; ++a) e[a] = 0
  for (a = 0; a < n.length; ++a) {
    const o = t[2 * a],
      s = t[2 * a + 1]
    for (let c = a + 1; c < n.length; ++c) {
      const l = t[2 * c],
        u = t[2 * c + 1],
        f = n[a][c],
        h = r[a][c],
        d = (l - o) * (l - o) + (u - s) * (u - s),
        p = Math.sqrt(d),
        v = d - f * f
      ;(h > 0 && p <= f) ||
        (h < 0 && p >= f) ||
        ((i += 2 * v * v),
        (e[2 * a] += 4 * v * (o - l)),
        (e[2 * a + 1] += 4 * v * (s - u)),
        (e[2 * c] += 4 * v * (l - o)),
        (e[2 * c + 1] += 4 * v * (u - s)))
    }
  }
  return i
}
function M$(t, e) {
  let n = T$(t, e)
  const r = e.lossFunction || o0
  if (t.length >= 8) {
    const i = E$(t, e),
      a = r(i, t),
      o = r(n, t)
    a + 1e-8 < o && (n = i)
  }
  return n
}
function E$(t, e) {
  e = e || {}
  const n = e.restarts || 10,
    r = [],
    i = {}
  let a
  for (a = 0; a < t.length; ++a) {
    const v = t[a]
    v.sets.length == 1 && ((i[v.sets[0]] = r.length), r.push(v))
  }
  const o = S$(t, r, i)
  let s = o.distances
  const c = o.constraints,
    l = Kh(s.map(Kh)) / s.length
  s = s.map(function (v) {
    return v.map(function (g) {
      return g / l
    })
  })
  const u = function (v, g) {
    return _$(v, g, s, c)
  }
  let f, h
  for (a = 0; a < n; ++a) {
    const v = qh(s.length * 2).map(Math.random)
    ;(h = y$(u, v, e)), (!f || h.fx < f.fx) && (f = h)
  }
  const d = f.x,
    p = {}
  for (a = 0; a < r.length; ++a) {
    const v = r[a]
    p[v.sets[0]] = { x: d[2 * a] * l, y: d[2 * a + 1] * l, radius: Math.sqrt(v.size / Math.PI) }
  }
  if (e.history) for (a = 0; a < e.history.length; ++a) Zh(e.history[a].x, l)
  return p
}
function T$(t, e) {
  const n = e && e.lossFunction ? e.lossFunction : o0,
    r = {},
    i = {}
  let a
  for (let f = 0; f < t.length; ++f) {
    const h = t[f]
    h.sets.length == 1 &&
      ((a = h.sets[0]),
      (r[a] = {
        x: 1e10,
        y: 1e10,
        rowid: Object.keys(r).length,
        size: h.size,
        radius: Math.sqrt(h.size / Math.PI)
      }),
      (i[a] = []))
  }
  t = t.filter(function (f) {
    return f.sets.length == 2
  })
  for (let f = 0; f < t.length; ++f) {
    const h = t[f]
    let d = h.hasOwnProperty('weight') ? h.weight : 1
    const p = h.sets[0],
      v = h.sets[1]
    h.size + I_ >= Math.min(r[p].size, r[v].size) && (d = 0),
      i[p].push({ set: v, size: h.size, weight: d }),
      i[v].push({ set: p, size: h.size, weight: d })
  }
  const o = []
  for (a in i)
    if (i.hasOwnProperty(a)) {
      let f = 0
      for (let h = 0; h < i[a].length; ++h) f += i[a][h].size * i[a][h].weight
      o.push({ set: a, size: f })
    }
  function s(f, h) {
    return h.size - f.size
  }
  o.sort(s)
  const c = {}
  function l(f) {
    return f.set in c
  }
  function u(f, h) {
    ;(r[h].x = f.x), (r[h].y = f.y), (c[h] = !0)
  }
  u({ x: 0, y: 0 }, o[0].set)
  for (let f = 1; f < o.length; ++f) {
    const h = o[f].set,
      d = i[h].filter(l)
    if (((a = r[h]), d.sort(s), d.length === 0)) throw 'ERROR: missing pairwise overlap information'
    const p = []
    for (let y = 0; y < d.length; ++y) {
      const m = r[d[y].set],
        b = Jh(a.radius, m.radius, d[y].size)
      p.push({ x: m.x + b, y: m.y }),
        p.push({ x: m.x - b, y: m.y }),
        p.push({ y: m.y + b, x: m.x }),
        p.push({ y: m.y - b, x: m.x })
      for (let x = y + 1; x < d.length; ++x) {
        const w = r[d[x].set],
          O = Jh(a.radius, w.radius, d[x].size),
          S = R_({ x: m.x, y: m.y, radius: b }, { x: w.x, y: w.y, radius: O })
        for (let _ = 0; _ < S.length; ++_) p.push(S[_])
      }
    }
    let v = 1e50,
      g = p[0]
    for (let y = 0; y < p.length; ++y) {
      ;(r[h].x = p[y].x), (r[h].y = p[y].y)
      const m = n(r, t)
      m < v && ((v = m), (g = p[y]))
    }
    u(g, h)
  }
  return r
}
function o0(t, e) {
  let n = 0
  function r(i) {
    return i.map(function (a) {
      return t[a]
    })
  }
  for (let i = 0; i < e.length; ++i) {
    const a = e[i]
    let o
    if (a.sets.length == 1) continue
    if (a.sets.length == 2) {
      const c = t[a.sets[0]],
        l = t[a.sets[1]]
      o = N_(c.radius, l.radius, us(c, l))
    } else o = L_(r(a.sets))
    const s = a.hasOwnProperty('weight') ? a.weight : 1
    n += s * (o - a.size) * (o - a.size)
  }
  return n
}
function P$(t) {
  const e = function (n) {
    const r = Math.max.apply(
        null,
        t.map(function (a) {
          return a[n] + a.radius
        })
      ),
      i = Math.min.apply(
        null,
        t.map(function (a) {
          return a[n] - a.radius
        })
      )
    return { max: r, min: i }
  }
  return { xRange: e('x'), yRange: e('y') }
}
function A$(t, e, n, r) {
  const i = [],
    a = []
  for (const v in t) t.hasOwnProperty(v) && (a.push(v), i.push(t[v]))
  ;(e -= 2 * r), (n -= 2 * r)
  const o = P$(i),
    s = o.xRange,
    c = o.yRange
  if (s.max == s.min || c.max == c.min)
    return console.log('not scaling solution: zero size detected'), t
  const l = e / (s.max - s.min),
    u = n / (c.max - c.min),
    f = Math.min(u, l),
    h = (e - (s.max - s.min) * f) / 2,
    d = (n - (c.max - c.min) * f) / 2,
    p = {}
  for (let v = 0; v < i.length; ++v) {
    const g = i[v]
    p[a[v]] = { radius: f * g.radius, x: r + h + (g.x - s.min) * f, y: r + d + (g.y - c.min) * f }
  }
  return p
}
function k$(t, e, n) {
  const r = [],
    i = t - n,
    a = e
  return (
    r.push('M', i, a),
    r.push('A', n, n, 0, 1, 0, i + 2 * n, a),
    r.push('A', n, n, 0, 1, 0, i, a),
    r.join(' ')
  )
}
function C$(t) {
  const e = {}
  L_(t, e)
  const n = e.arcs
  if (n.length === 0) return 'M 0 0'
  if (n.length == 1) {
    const r = n[0].circle
    return k$(r.x, r.y, r.radius)
  } else {
    const r = [
      `
M`,
      n[0].p2.x,
      n[0].p2.y
    ]
    for (let i = 0; i < n.length; ++i) {
      const a = n[i],
        o = a.circle.radius,
        s = a.width > o
      r.push(
        `
A`,
        o,
        o,
        0,
        s ? 1 : 0,
        1,
        a.p1.x,
        a.p1.y
      )
    }
    return r.join(' ')
  }
}
const j_ = (t) => {
  const { sets: e = 'sets', size: n = 'size', as: r = ['key', 'path'], padding: i = 0 } = t,
    [a, o] = r
  return (s) => {
    const c = s.map((f) =>
      Object.assign(Object.assign({}, f), { sets: f[e], size: f[n], [a]: f.sets.join('&') })
    )
    c.sort((f, h) => f.sets.length - h.sets.length)
    const l = w$(c)
    let u
    return c.map((f) => {
      const h = f[e],
        d = ({ width: p, height: v }) => {
          u = u || A$(l, p, v, i)
          const g = h.map((m) => u[m])
          let y = C$(g)
          return /[zZ]$/.test(y) || (y += ' Z'), y
        }
      return Object.assign(Object.assign({}, f), { [o]: d })
    })
  }
}
j_.props = {}
const D_ = () => (t) => (console.log('G2 data section:', t), t)
D_.props = {}
var L$ =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, r) {
      function i(a) {
        return a instanceof n
          ? a
          : new n(function (o) {
              o(a)
            })
      }
      return new (n || (n = Promise))(function (a, o) {
        function s(u) {
          try {
            l(r.next(u))
          } catch (f) {
            o(f)
          }
        }
        function c(u) {
          try {
            l(r.throw(u))
          } catch (f) {
            o(f)
          }
        }
        function l(u) {
          u.done ? a(u.value) : i(u.value).then(s, c)
        }
        l((r = r.apply(t, e || [])).next())
      })
    },
  N$ =
    (globalThis && globalThis.__rest) ||
    function (t, e) {
      var n = {}
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
      if (t != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          e.indexOf(r[i]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
            (n[r[i]] = t[r[i]])
      return n
    }
function R$(t, e) {
  const { text: n = 'text', value: r = 'value' } = e
  return t.map((i) => Object.assign(Object.assign({}, i), { text: i[n], value: i[r] }))
}
const I$ = (t, e) => ({ size: [t, e] }),
  j$ = (t, e) => ({
    axis: !1,
    type: 'text',
    encode: { x: 'x', y: 'y', text: 'text', rotate: 'rotate', fontSize: 'size' },
    scale: {
      x: { domain: [0, t], range: [0, 1] },
      y: { domain: [0, e], range: [0, 1] },
      fontSize: { type: 'identity' },
      rotate: { type: 'identity' }
    },
    style: { textAlign: 'center' }
  }),
  $_ = (t, e) =>
    L$(void 0, void 0, void 0, function* () {
      const { width: n, height: r } = e,
        { data: i, encode: a = {}, scale: o, style: s = {}, layout: c = {} } = t,
        l = N$(t, ['data', 'encode', 'scale', 'style', 'layout']),
        u = R$(i, a),
        f = yield M_(Object.assign(Object.assign({}, I$(n, r)), c))(u)
      return X(
        {},
        j$(n, r),
        Object.assign(Object.assign({ data: f, encode: a, scale: o, style: s }, l), { axis: !1 })
      )
    })
$_.props = {}
var Hc =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const D$ = (t, e) => {
    const { shape: n, radius: r } = t,
      i = Hc(t, ['shape', 'radius']),
      a = et(i, 'pointer'),
      o = et(i, 'pin'),
      { shape: s } = a,
      c = Hc(a, ['shape']),
      { shape: l } = o,
      u = Hc(o, ['shape']),
      { coordinate: f, theme: h } = e
    return (d, p) => {
      const v = d.map((P) => f.invert(P)),
        [g, y, m] = AC(f, 'polar'),
        b = f.clone(),
        { color: x } = p,
        w = Rd({ startAngle: g, endAngle: y, innerRadius: m, outerRadius: r })
      w.push(['cartesian']), b.update({ transformations: w })
      const O = v.map((P) => b.map(P)),
        [S, _] = dw(O),
        [M, E] = f.getCenter(),
        T = Object.assign(Object.assign({ x1: S, y1: _, x2: M, y2: E, stroke: x }, c), i),
        C = Object.assign(Object.assign({ cx: M, cy: E, stroke: x }, u), i),
        A = ot(new je())
      return (
        Er(s) ||
          (typeof s == 'function'
            ? A.append(() => s(O, p, b, h))
            : A.append('line').call(at, T).node()),
        Er(l) ||
          (typeof l == 'function'
            ? A.append(() => l(O, p, b, h))
            : A.append('circle').call(at, C).node()),
        A.node()
      )
    }
  },
  om = {
    coordinate: {
      type: 'radial',
      innerRadius: 0.9,
      outerRadius: 1,
      startAngle: (-11 / 10) * Math.PI,
      endAngle: (1 / 10) * Math.PI
    },
    axis: { x: !1 },
    legend: !1,
    tooltip: !1,
    encode: { x: 'x', y: 'y', color: 'color' },
    scale: { color: { range: ['#30BF78', '#D0D0D0'] } }
  },
  $$ = {
    style: {
      shape: D$,
      lineWidth: 4,
      pointerLineCap: 'round',
      pinR: 10,
      pinFill: '#fff',
      radius: 0.6
    }
  },
  B$ = {
    type: 'text',
    style: {
      x: '50%',
      y: '60%',
      textAlign: 'center',
      textBaseline: 'middle',
      fontSize: 20,
      fontWeight: 800,
      fill: '#888'
    }
  }
function F$(t) {
  if (ve(t)) {
    const e = Math.max(0, Math.min(t, 1))
    return { percent: e, target: e, total: 1 }
  }
  return t
}
function z$(t, e) {
  const { name: n = 'score', target: r, total: i, percent: a, thresholds: o = [] } = F$(t),
    s = a || r,
    c = a ? 1 : i,
    l = Object.assign({ y: { domain: [0, c] } }, e)
  return o.length
    ? {
        targetData: [{ x: n, y: s, color: 'target' }],
        totalData: o.map((u, f) => ({ x: n, y: f >= 1 ? u - o[f - 1] : u, color: f })),
        target: s,
        total: c,
        scale: l
      }
    : {
        targetData: [{ x: n, y: s, color: 'target' }],
        totalData: [
          { x: n, y: s, color: 'target' },
          { x: n, y: c - s, color: 'total' }
        ],
        target: s,
        total: c,
        scale: l
      }
}
function G$(t, { target: e, total: n }) {
  const { content: r } = t
  return r ? r(e, n) : e.toString()
}
const B_ = (t) => {
  const { data: e = {}, scale: n = {}, style: r = {}, animate: i = {}, transform: a = [] } = t,
    o = Hc(t, ['data', 'scale', 'style', 'animate', 'transform']),
    { targetData: s, totalData: c, target: l, total: u, scale: f } = z$(e, n),
    h = et(r, 'text'),
    d = Gk(r, ['pointer', 'pin'])
  return [
    X(
      {},
      om,
      Object.assign(
        {
          type: 'interval',
          transform: [{ type: 'stackY' }],
          data: c,
          scale: f,
          style: et(r, 'arc'),
          animate: typeof i == 'object' ? et(i, 'arc') : i
        },
        o
      )
    ),
    X(
      {},
      om,
      $$,
      Object.assign(
        {
          type: 'point',
          data: s,
          scale: f,
          style: d,
          animate: typeof i == 'object' ? et(i, 'indicator') : i
        },
        o
      )
    ),
    X({}, B$, {
      style: Object.assign({ text: G$(h, { target: l, total: u }) }, h),
      animate: typeof i == 'object' ? et(i, 'text') : i
    })
  ]
}
B_.props = {}
const sm = { density: SS },
  F_ = () => (t, e, n, r) => {
    const { x: i, series: a } = n,
      o = Object.entries(n)
        .filter(([f]) => f.startsWith('y'))
        .map(([, f]) => f),
      s = Object.entries(n)
        .filter(([f]) => f.startsWith('size'))
        .map(([, f]) => f)
    if (i === void 0 || o === void 0 || s === void 0)
      throw new Error('Missing encode for x or y or size channel.')
    const c = e.x,
      l = e.series,
      u = Array.from(t, (f) => {
        const h = c.getBandWidth(c.invert(+i[f])),
          d = l ? l.getBandWidth(l.invert(+(a == null ? void 0 : a[f]))) : 1,
          p = h * d,
          v = (+(a == null ? void 0 : a[f]) || 0) * h,
          g = +i[f] + v + p / 2
        return [
          ...o.map((m, b) => [g + +s[b][f] / t.length, +o[b][f]]),
          ...o.map((m, b) => [g - +s[b][f] / t.length, +o[b][f]]).reverse()
        ].map((m) => r.map(m))
      })
    return [t, u]
  }
F_.props = {
  defaultShape: 'density',
  defaultLabelShape: 'label',
  composite: !1,
  shape: sm,
  channels: [
    ...Ye({ shapes: Object.keys(sm) }),
    { name: 'x', scale: 'band', required: !0 },
    { name: 'y', required: !0 },
    { name: 'size', required: !0 },
    { name: 'series', scale: 'band' },
    { name: 'size', required: !0, scale: 'identity' }
  ],
  preInference: [...de(), { type: Os }, { type: Hi }],
  postInference: [...ge(), ...to()],
  interaction: { shareTooltip: !0 }
}
const cm = { heatmap: _S },
  z_ = (t) => (e, n, r, i) => {
    const { x: a, y: o, size: s, color: c } = r,
      l = Array.from(e, (u) => {
        const f = s ? +s[u] : 40
        return [...i.map([+a[u], +o[u]]), c[u], f]
      })
    return [[0], [l]]
  }
z_.props = {
  defaultShape: 'heatmap',
  defaultLabelShape: 'label',
  composite: !1,
  shape: cm,
  channels: [
    ...Ye({ shapes: Object.keys(cm) }),
    { name: 'x', required: !0 },
    { name: 'y', required: !0 },
    { name: 'color', scale: 'identity', required: !0 },
    { name: 'size' }
  ],
  preInference: [...de(), { type: Hi }, { type: Zl }],
  postInference: [...ge(), ...ci()]
}
var W$ =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const Y$ = {
    axis: { x: !1, y: !1 },
    legend: !1,
    tooltip: !1,
    encode: { x: 'type', y: 'percent' },
    scale: { y: { domain: [0, 1] } },
    style: { shape: ES },
    animate: { enter: { type: 'fadeIn' } }
  },
  H$ = {
    type: 'text',
    style: {
      x: '50%',
      y: '50%',
      textAlign: 'center',
      textBaseline: 'middle',
      fontSize: 20,
      fontWeight: 800,
      fill: '#888'
    },
    animate: { enter: { type: 'fadeIn' } }
  },
  G_ = (t) => {
    const { data: e = {}, style: n = {}, animate: r } = t,
      i = W$(t, ['data', 'style', 'animate']),
      a = Math.max(0, ve(e) ? e : e == null ? void 0 : e.percent),
      o = [{ percent: a, type: 'liquid' }],
      s = et(n, 'text'),
      c = et(n, 'outline'),
      l = et(n, 'wave'),
      u = et(n, 'background')
    return [
      X(
        {},
        Y$,
        Object.assign(
          {
            type: 'interval',
            data: o,
            style: {
              liquidOptions: { percent: a, liquidShape: n == null ? void 0 : n.shape },
              styleOptions: Object.assign(Object.assign({}, n), {
                outline: c,
                wave: l,
                background: u
              })
            },
            animate: r
          },
          i
        )
      ),
      X({}, H$, { style: Object.assign({ text: `${a * 100} %` }, s), animate: r })
    ]
  }
G_.props = {}
const W_ = () => [
  '#5B8FF9',
  '#5AD8A6',
  '#5D7092',
  '#F6BD16',
  '#6F5EF9',
  '#6DC8EC',
  '#945FB9',
  '#FF9845',
  '#1E9493',
  '#FF99C3'
]
W_.props = {}
const Y_ = () => [
  '#5B8FF9',
  '#CDDDFD',
  '#5AD8A6',
  '#CDF3E4',
  '#5D7092',
  '#CED4DE',
  '#F6BD16',
  '#FCEBB9',
  '#6F5EF9',
  '#D3CEFD',
  '#6DC8EC',
  '#D3EEF9',
  '#945FB9',
  '#DECFEA',
  '#FF9845',
  '#FFE0C7',
  '#1E9493',
  '#BBDEDE',
  '#FF99C3',
  '#FFE0ED'
]
Y_.props = {}
const H_ = (t) => new ka(t)
H_.props = {}
const V_ = (t) => new Ft(t)
V_.props = {}
const X_ = (t) => new yx(t)
X_.props = {}
const U_ = (t) => new wx(t)
U_.props = {}
const q_ = (t) => new _x(t)
q_.props = {}
const K_ = (t) => new A3(t)
K_.props = {}
const Z_ = (t) => new g3(t)
Z_.props = {}
const Q_ = (t) => new Ex(t)
Q_.props = {}
const J_ = (t) => new ru(t)
J_.props = {}
const tM = (t) => new Nx(t)
tM.props = {}
const eM = (t) => new Cx(t)
eM.props = {}
const nM = (t) => new p3(t)
nM.props = {}
const rM = (t) => new fh(t)
rM.props = {}
const iM = (t) => new np(t)
iM.props = {}
function s0({
  colorDefault: t,
  colorBlack: e,
  colorWhite: n,
  colorStroke: r,
  colorBackground: i,
  padding1: a,
  padding2: o,
  padding3: s,
  alpha90: c,
  alpha65: l,
  alpha45: u,
  alpha25: f,
  alpha10: h,
  category10: d,
  category20: p,
  sizeDefault: v = 1,
  padding: g = 'auto',
  margin: y = 16
}) {
  return {
    padding: g,
    margin: y,
    size: v,
    color: t,
    category10: d,
    category20: p,
    enter: { duration: 300, fill: 'both', delay: 0 },
    update: { duration: 300, fill: 'both', delay: 0 },
    exit: { duration: 300, fill: 'both', delay: 0 },
    view: {
      viewFill: i,
      plotFill: 'transparent',
      mainFill: 'transparent',
      contentFill: 'transparent'
    },
    line: { line: { fill: '', strokeOpacity: 1, lineWidth: 1 } },
    point: {
      point: { r: 3, fillOpacity: 0.95, lineWidth: 0 },
      hollow: { r: 3, strokeOpacity: 0.95, lineWidth: 1 },
      plus: { r: 3, strokeOpacity: 0.95, lineWidth: 3 },
      diamond: { r: 3, strokeOpacity: 0.95, lineWidth: 1 }
    },
    interval: { rect: { fillOpacity: 0.95 }, hollow: { fill: '', strokeOpacity: 1, lineWidth: 2 } },
    area: { area: { fillOpacity: 0.85, lineWidth: 0 } },
    polygon: { polygon: { fillOpacity: 0.95 } },
    cell: { cell: { fillOpacity: 0.95 }, hollow: { fill: '', strokeOpacity: 1, lineWidth: 2 } },
    rect: { rect: { fillOpacity: 0.95 }, hollow: { fill: '', strokeOpacity: 1, lineWidth: 2 } },
    link: { link: { fill: '', strokeOpacity: 1 } },
    vector: { vector: { fillOpacity: 1 } },
    box: { box: { fillOpacity: 0.95, stroke: e, lineWidth: 1 } },
    text: {
      text: {
        fill: '#1D2129',
        fontSize: 12,
        strokeWidth: 0,
        connectorStroke: r,
        connectorStrokeOpacity: 0.45,
        connectorLineWidth: 1,
        backgroundFill: r,
        backgroundFillOpacity: 0.15,
        backgroundPadding: [2, 4],
        startMarkerSymbol: 'circle',
        startMarkerSize: 4,
        endMarkerSymbol: 'circle',
        endMarkerSize: 4
      },
      badge: {
        fill: '#1D2129',
        fillOpacity: 0.65,
        strokeWidth: 0,
        fontSize: 10,
        textAlign: 'center',
        textBaseline: 'middle',
        markerFill: r,
        markerFillOpacity: 0.25,
        markerStrokeOpacity: 0
      }
    },
    lineX: { line: { stroke: r, strokeOpacity: 0.45, lineWidth: 1 } },
    lineY: { line: { stroke: r, strokeOpacity: 0.45, lineWidth: 1 } },
    rangeX: { range: { fill: r, fillOpacity: 0.15, lineWidth: 0 } },
    rangeY: { range: { fill: r, fillOpacity: 0.15, lineWidth: 0 } },
    connector: {
      connector: {
        stroke: r,
        strokeOpacity: 0.45,
        lineWidth: 1,
        connectLength1: 12,
        endMarker: !0,
        endMarkerSize: 6,
        endMarkerFill: r,
        endMarkerFillOpacity: 0.95
      }
    },
    axis: {
      arrow: !1,
      gridLineDash: [3, 4],
      gridLineWidth: 0.5,
      gridStroke: e,
      gridStrokeOpacity: h,
      labelAlign: 'horizontal',
      labelFill: e,
      labelOpacity: u,
      labelFontSize: 12,
      labelFontWeight: 'normal',
      labelSpacing: a,
      line: !1,
      lineLineWidth: 0.5,
      lineStroke: e,
      lineStrokeOpacity: u,
      tickLength: 4,
      tickLineWidth: 1,
      tickStroke: e,
      tickOpacity: u,
      titleFill: e,
      titleOpacity: c,
      titleFontSize: 12,
      titleFontWeight: 'normal',
      titleSpacing: 12,
      titleTransformOrigin: 'center',
      lineArrowOffset: 6,
      lineArrowSize: 6
    },
    axisTop: {
      gridDirection: 'positive',
      labelDirection: 'negative',
      tickDirection: 'negative',
      titlePosition: 'top',
      titleSpacing: 12,
      labelSpacing: 4,
      titleTextBaseline: 'middle'
    },
    axisBottom: {
      gridDirection: 'negative',
      labelDirection: 'positive',
      tickDirection: 'positive',
      titlePosition: 'bottom',
      titleSpacing: 12,
      labelSpacing: 4,
      titleTextBaseline: 'bottom'
    },
    axisLeft: {
      gridDirection: 'positive',
      labelDirection: 'negative',
      labelSpacing: 4,
      tickDirection: 'negative',
      titlePosition: 'left',
      titleSpacing: 12,
      titleTextBaseline: 'middle',
      titleDirection: 'vertical',
      titleTransformOrigin: 'center'
    },
    axisRight: {
      gridDirection: 'negative',
      labelDirection: 'positive',
      labelSpacing: 4,
      tickDirection: 'positive',
      titlePosition: 'right',
      titleSpacing: 12,
      titleTextBaseline: 'top',
      titleDirection: 'vertical',
      titleTransformOrigin: 'center'
    },
    axisLinear: {
      girdClosed: !0,
      gridConnect: 'arc',
      gridDirection: 'negative',
      gridType: 'surround',
      titlePosition: 'top',
      titleSpacing: 0
    },
    axisArc: { title: !1, titlePosition: 'inner', line: !1, tick: !0, labelSpacing: 4 },
    axisRadar: {
      girdClosed: !0,
      gridStrokeOpacity: 0.3,
      gridType: 'surround',
      label: !1,
      tick: !1,
      titlePosition: 'start'
    },
    legendCategory: {
      backgroundFill: 'transparent',
      itemBackgroundFill: 'transparent',
      itemLabelFill: e,
      itemLabelFillOpacity: c,
      itemLabelFontSize: 12,
      itemLabelFontWeight: 'normal',
      itemMarkerFillOpacity: 1,
      itemMarkerSize: 8,
      itemSpacing: [a, a],
      itemValueFill: e,
      itemValueFillOpacity: 0.65,
      itemValueFontSize: 12,
      itemValueFontWeight: 'normal',
      navButtonFill: e,
      navButtonFillOpacity: 0.65,
      navPageNumFill: e,
      navPageNumFillOpacity: 0.45,
      navPageNumFontSize: 12,
      padding: 8,
      title: !1,
      titleFill: e,
      titleFillOpacity: 0.65,
      titleFontSize: 12,
      titleFontWeight: 'normal',
      titleSpacing: 4,
      tickStroke: e,
      tickStrokeOpacity: 0.25,
      rowPadding: a,
      colPadding: o,
      maxRows: 3,
      maxCols: 3
    },
    legendContinuous: {
      handleHeight: 12,
      handleLabelFill: e,
      handleLabelFillOpacity: u,
      handleLabelFontSize: 12,
      handleLabelFontWeight: 'normal',
      handleMarkerFill: e,
      handleMarkerFillOpacity: 0.6,
      handleMarkerLineWidth: 1,
      handleMarkerStroke: e,
      handleMarkerStrokeOpacity: 0.25,
      handleWidth: 10,
      labelFill: e,
      labelFillOpacity: u,
      labelFontSize: 12,
      labelFontWeight: 'normal',
      labelSpacing: 3,
      tick: !0,
      tickLength: 12,
      ribbonSize: 12,
      ribbonFill: '#aaa',
      handle: !0,
      handleLabel: !1,
      handleShape: 'slider',
      handleIconSize: 12 / 1.8,
      indicator: !1,
      titleFontSize: 12,
      titleSpacing: 4,
      titleFontWeight: 'normal',
      titleFillOpacity: c,
      tickStroke: e,
      tickStrokeOpacity: u
    },
    label: {
      fill: e,
      fillOpacity: 0.65,
      fontSize: 12,
      fontWeight: 'normal',
      stroke: void 0,
      offset: 12,
      connectorStroke: e,
      connectorStrokeOpacity: 0.45,
      connectorLineWidth: 1,
      connectorLength: 12,
      connectorLength2: 8,
      connectorDistance: 4
    },
    innerLabel: {
      fill: n,
      fontSize: 12,
      fillOpacity: 0.85,
      fontWeight: 'normal',
      stroke: void 0,
      offset: 0
    },
    htmlLabel: { fontSize: 12, opacity: 0.65, color: e, fontWeight: 'normal' },
    slider: {
      trackSize: 16,
      trackFill: r,
      trackFillOpacity: 1,
      selectionFill: t,
      selectionFillOpacity: 0.15,
      handleIconSize: 10,
      handleIconFill: '#f7f7f7',
      handleIconFillOpacity: 1,
      handleIconStroke: e,
      handleIconStrokeOpacity: 0.25,
      handleIconLineWidth: 1,
      handleIconRadius: 2,
      handleLabelFill: e,
      handleLabelFillOpacity: 0.45,
      handleLabelFontSize: 12,
      handleLabelFontWeight: 'normal'
    },
    scrollbar: {
      padding: [0, 0, 0, 0],
      trackSize: 6,
      isRound: !0,
      slidable: !0,
      scrollable: !0,
      trackFill: '#e5e5e5',
      trackFillOpacity: 0,
      thumbFill: '#000',
      thumbFillOpacity: 0.15,
      thumbHighlightedFillOpacity: 0.2
    },
    title: {
      spacing: 8,
      titleFill: e,
      titleFillOpacity: c,
      titleFontSize: 16,
      titleFontWeight: 'bold',
      titleTextBaseline: 'top',
      subtitleFill: e,
      subtitleFillOpacity: l,
      subtitleFontSize: 12,
      subtitleFontWeight: 'normal',
      subtitleTextBaseline: 'top'
    }
  }
}
const V$ = {
    colorBlack: '#1D2129',
    colorWhite: '#ffffff',
    colorStroke: '#416180',
    colorDefault: '#1783FF',
    colorBackground: 'transparent',
    category10: [
      '#1783FF',
      '#00C9C9',
      '#F0884D',
      '#D580FF',
      '#7863FF',
      '#60C42D',
      '#BD8F24',
      '#FF80CA',
      '#2491B3',
      '#17C76F'
    ],
    category20: [
      '#1783FF',
      '#00C9C9',
      '#F0884D',
      '#D580FF',
      '#7863FF',
      '#60C42D',
      '#BD8F24',
      '#FF80CA',
      '#2491B3',
      '#17C76F',
      '#AABA01',
      '#BC7CFC',
      '#237CBC',
      '#2DE379',
      '#CE8032',
      '#FF7AF4',
      '#545FD3',
      '#AFE410',
      '#D8C608',
      '#FFA1E0'
    ],
    padding1: 8,
    padding2: 12,
    padding3: 20,
    alpha90: 0.9,
    alpha65: 0.65,
    alpha45: 0.45,
    alpha25: 0.25,
    alpha10: 0.1
  },
  X$ = s0(V$),
  c0 = (t) => X({}, X$, t)
c0.props = {}
const aM = (t) => X({}, c0(), { category10: 'category10', category20: 'category20' }, t)
aM.props = {}
const U$ = {
    colorBlack: '#fff',
    colorWhite: '#000',
    colorStroke: '#416180',
    colorDefault: '#1783FF',
    colorBackground: '#141414',
    category10: [
      '#1783FF',
      '#00C9C9',
      '#F0884D',
      '#D580FF',
      '#7863FF',
      '#60C42D',
      '#BD8F24',
      '#FF80CA',
      '#2491B3',
      '#17C76F'
    ],
    category20: [
      '#1783FF',
      '#00C9C9',
      '#F0884D',
      '#D580FF',
      '#7863FF',
      '#60C42D',
      '#BD8F24',
      '#FF80CA',
      '#2491B3',
      '#17C76F',
      '#AABA01',
      '#BC7CFC',
      '#237CBC',
      '#2DE379',
      '#CE8032',
      '#FF7AF4',
      '#545FD3',
      '#AFE410',
      '#D8C608',
      '#FFA1E0'
    ],
    padding1: 8,
    padding2: 12,
    padding3: 20,
    alpha90: 0.9,
    alpha65: 0.65,
    alpha45: 0.45,
    alpha25: 0.25,
    alpha10: 0.25
  },
  q$ = s0(U$),
  oM = (t) =>
    X(
      {},
      q$,
      {
        tooltip: {
          crosshairsStroke: '#fff',
          crosshairsLineWidth: 1,
          crosshairsStrokeOpacity: 0.25,
          css: {
            '.g2-tooltip': { background: '#1f1f1f', opacity: 0.95 },
            '.g2-tooltip-title': { color: '#A6A6A6' },
            '.g2-tooltip-list-item-name-label': { color: '#A6A6A6' },
            '.g2-tooltip-list-item-value': { color: '#A6A6A6' }
          }
        }
      },
      t
    ),
  sM = (t) => Object.assign({}, oM(), { category10: 'category10', category20: 'category20' }, t)
sM.props = {}
const K$ = {
    colorBlack: '#000',
    colorWhite: '#fff',
    colorStroke: '#888',
    colorDefault: '#4e79a7',
    colorBackground: 'transparent',
    category10: [
      '#4e79a7',
      '#f28e2c',
      '#e15759',
      '#76b7b2',
      '#59a14f',
      '#edc949',
      '#af7aa1',
      '#ff9da7',
      '#9c755f',
      '#bab0ab'
    ],
    category20: [
      '#4e79a7',
      '#f28e2c',
      '#e15759',
      '#76b7b2',
      '#59a14f',
      '#edc949',
      '#af7aa1',
      '#ff9da7',
      '#9c755f',
      '#bab0ab'
    ],
    padding1: 8,
    padding2: 12,
    padding3: 20,
    alpha90: 0.9,
    alpha65: 0.65,
    alpha45: 0.45,
    alpha25: 0.25,
    alpha10: 0.1
  },
  Z$ = s0(K$),
  cM = (t) =>
    X(
      {},
      Z$,
      {
        text: { text: { fontSize: 10 } },
        axis: {
          gridLineDash: [0, 0],
          gridLineWidth: 1,
          gridStroke: '#ddd',
          gridStrokeOpacity: 1,
          labelOpacity: 1,
          labelStrokeOpacity: 1,
          labelFontSize: 10,
          line: !0,
          lineLineWidth: 1,
          lineStroke: '#888',
          lineStrokeOpacity: 1,
          tickLength: 5,
          tickStrokeOpacity: 1,
          titleOpacity: 1,
          titleStrokeOpacity: 1,
          titleFillOpacity: 1,
          titleFontSize: 11,
          titleFontWeight: 'bold'
        },
        axisLeft: { gridFilter: (e, n) => n !== 0 },
        axisRight: { gridFilter: (e, n) => n !== 0 },
        legendCategory: {
          itemLabelFillOpacity: 1,
          itemLabelFontSize: 10,
          itemValueFillOpacity: 1,
          itemValueFontSize: 10,
          titleFillOpacity: 1,
          titleFontSize: 11,
          titleFontWeight: 'bold'
        },
        legendContinuous: { handleLabelFontSize: 10, labelFillOpacity: 0.45, labelFontSize: 10 },
        label: { fontSize: 10 },
        innerLabel: { fontSize: 10 },
        htmlLabel: { fontSize: 10 },
        slider: { handleLabelFontSize: 10, trackFillOpacity: 0.05 }
      },
      t
    )
cM.props = {}
function Q$(t) {
  return Math.abs((t = Math.round(t))) >= 1e21
    ? t.toLocaleString('en').replace(/,/g, '')
    : t.toString(10)
}
function _l(t, e) {
  if ((n = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf('e')) < 0) return null
  var n,
    r = t.slice(0, n)
  return [r.length > 1 ? r[0] + r.slice(2) : r, +t.slice(n + 1)]
}
function J$(t) {
  return (t = _l(Math.abs(t))), t ? t[1] : NaN
}
function tB(t, e) {
  return function (n, r) {
    for (
      var i = n.length, a = [], o = 0, s = t[0], c = 0;
      i > 0 &&
      s > 0 &&
      (c + s + 1 > r && (s = Math.max(1, r - c)),
      a.push(n.substring((i -= s), i + s)),
      !((c += s + 1) > r));

    )
      s = t[(o = (o + 1) % t.length)]
    return a.reverse().join(e)
  }
}
function eB(t) {
  return function (e) {
    return e.replace(/[0-9]/g, function (n) {
      return t[+n]
    })
  }
}
var nB = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i
function td(t) {
  if (!(e = nB.exec(t))) throw new Error('invalid format: ' + t)
  var e
  return new l0({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  })
}
td.prototype = l0.prototype
function l0(t) {
  ;(this.fill = t.fill === void 0 ? ' ' : t.fill + ''),
    (this.align = t.align === void 0 ? '>' : t.align + ''),
    (this.sign = t.sign === void 0 ? '-' : t.sign + ''),
    (this.symbol = t.symbol === void 0 ? '' : t.symbol + ''),
    (this.zero = !!t.zero),
    (this.width = t.width === void 0 ? void 0 : +t.width),
    (this.comma = !!t.comma),
    (this.precision = t.precision === void 0 ? void 0 : +t.precision),
    (this.trim = !!t.trim),
    (this.type = t.type === void 0 ? '' : t.type + '')
}
l0.prototype.toString = function () {
  return (
    this.fill +
    this.align +
    this.sign +
    this.symbol +
    (this.zero ? '0' : '') +
    (this.width === void 0 ? '' : Math.max(1, this.width | 0)) +
    (this.comma ? ',' : '') +
    (this.precision === void 0 ? '' : '.' + Math.max(0, this.precision | 0)) +
    (this.trim ? '~' : '') +
    this.type
  )
}
function rB(t) {
  t: for (var e = t.length, n = 1, r = -1, i; n < e; ++n)
    switch (t[n]) {
      case '.':
        r = i = n
        break
      case '0':
        r === 0 && (r = n), (i = n)
        break
      default:
        if (!+t[n]) break t
        r > 0 && (r = 0)
        break
    }
  return r > 0 ? t.slice(0, r) + t.slice(i + 1) : t
}
var lM
function iB(t, e) {
  var n = _l(t, e)
  if (!n) return t + ''
  var r = n[0],
    i = n[1],
    a = i - (lM = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1,
    o = r.length
  return a === o
    ? r
    : a > o
    ? r + new Array(a - o + 1).join('0')
    : a > 0
    ? r.slice(0, a) + '.' + r.slice(a)
    : '0.' + new Array(1 - a).join('0') + _l(t, Math.max(0, e + a - 1))[0]
}
function lm(t, e) {
  var n = _l(t, e)
  if (!n) return t + ''
  var r = n[0],
    i = n[1]
  return i < 0
    ? '0.' + new Array(-i).join('0') + r
    : r.length > i + 1
    ? r.slice(0, i + 1) + '.' + r.slice(i + 1)
    : r + new Array(i - r.length + 2).join('0')
}
const um = {
  '%': (t, e) => (t * 100).toFixed(e),
  b: (t) => Math.round(t).toString(2),
  c: (t) => t + '',
  d: Q$,
  e: (t, e) => t.toExponential(e),
  f: (t, e) => t.toFixed(e),
  g: (t, e) => t.toPrecision(e),
  o: (t) => Math.round(t).toString(8),
  p: (t, e) => lm(t * 100, e),
  r: lm,
  s: iB,
  X: (t) => Math.round(t).toString(16).toUpperCase(),
  x: (t) => Math.round(t).toString(16)
}
function fm(t) {
  return t
}
var hm = Array.prototype.map,
  dm = ['y', 'z', 'a', 'f', 'p', 'n', 'µ', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']
function aB(t) {
  var e =
      t.grouping === void 0 || t.thousands === void 0
        ? fm
        : tB(hm.call(t.grouping, Number), t.thousands + ''),
    n = t.currency === void 0 ? '' : t.currency[0] + '',
    r = t.currency === void 0 ? '' : t.currency[1] + '',
    i = t.decimal === void 0 ? '.' : t.decimal + '',
    a = t.numerals === void 0 ? fm : eB(hm.call(t.numerals, String)),
    o = t.percent === void 0 ? '%' : t.percent + '',
    s = t.minus === void 0 ? '−' : t.minus + '',
    c = t.nan === void 0 ? 'NaN' : t.nan + ''
  function l(f) {
    f = td(f)
    var h = f.fill,
      d = f.align,
      p = f.sign,
      v = f.symbol,
      g = f.zero,
      y = f.width,
      m = f.comma,
      b = f.precision,
      x = f.trim,
      w = f.type
    w === 'n' ? ((m = !0), (w = 'g')) : um[w] || (b === void 0 && (b = 12), (x = !0), (w = 'g')),
      (g || (h === '0' && d === '=')) && ((g = !0), (h = '0'), (d = '='))
    var O = v === '$' ? n : v === '#' && /[boxX]/.test(w) ? '0' + w.toLowerCase() : '',
      S = v === '$' ? r : /[%p]/.test(w) ? o : '',
      _ = um[w],
      M = /[defgprs%]/.test(w)
    b =
      b === void 0
        ? 6
        : /[gprs]/.test(w)
        ? Math.max(1, Math.min(21, b))
        : Math.max(0, Math.min(20, b))
    function E(T) {
      var C = O,
        A = S,
        P,
        k,
        L
      if (w === 'c') (A = _(T) + A), (T = '')
      else {
        T = +T
        var R = T < 0 || 1 / T < 0
        if (
          ((T = isNaN(T) ? c : _(Math.abs(T), b)),
          x && (T = rB(T)),
          R && +T == 0 && p !== '+' && (R = !1),
          (C = (R ? (p === '(' ? p : s) : p === '-' || p === '(' ? '' : p) + C),
          (A = (w === 's' ? dm[8 + lM / 3] : '') + A + (R && p === '(' ? ')' : '')),
          M)
        ) {
          for (P = -1, k = T.length; ++P < k; )
            if (((L = T.charCodeAt(P)), 48 > L || L > 57)) {
              ;(A = (L === 46 ? i + T.slice(P + 1) : T.slice(P)) + A), (T = T.slice(0, P))
              break
            }
        }
      }
      m && !g && (T = e(T, 1 / 0))
      var j = C.length + T.length + A.length,
        I = j < y ? new Array(y - j + 1).join(h) : ''
      switch ((m && g && ((T = e(I + T, I.length ? y - A.length : 1 / 0)), (I = '')), d)) {
        case '<':
          T = C + T + A + I
          break
        case '=':
          T = C + I + T + A
          break
        case '^':
          T = I.slice(0, (j = I.length >> 1)) + C + T + A + I.slice(j)
          break
        default:
          T = I + C + T + A
          break
      }
      return a(T)
    }
    return (
      (E.toString = function () {
        return f + ''
      }),
      E
    )
  }
  function u(f, h) {
    var d = l(((f = td(f)), (f.type = 'f'), f)),
      p = Math.max(-8, Math.min(8, Math.floor(J$(h) / 3))) * 3,
      v = Math.pow(10, -p),
      g = dm[8 + p / 3]
    return function (y) {
      return d(v * y) + g
    }
  }
  return { format: l, formatPrefix: u }
}
var wc, li
oB({ thousands: ',', grouping: [3], currency: ['$', ''] })
function oB(t) {
  return (wc = aB(t)), (li = wc.format), wc.formatPrefix, wc
}
var sB =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function cB(t) {
  return class extends Sp {
    constructor(e) {
      super(e), (this.descriptor = t)
    }
    connectedCallback() {
      var e, n
      ;(n = (e = this.descriptor).render) === null ||
        n === void 0 ||
        n.call(e, this.attributes, this)
    }
    update(e = {}) {
      var n, r
      this.attr(X({}, this.attributes, e)),
        (r = (n = this.descriptor).render) === null ||
          r === void 0 ||
          r.call(n, this.attributes, this)
    }
  }
}
function pm(t, e, n) {
  return t.querySelector(e) ? ot(t).select(e) : ot(t).append(n)
}
function Pu(t) {
  return Array.isArray(t) ? t.join(', ') : `${t || ''}`
}
function uM(t, e) {
  const n = {
    display: 'flex',
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center'
  }
  let { flexDirection: r, justifyContent: i, alignItems: a } = n
  const o = {
    top: ['row', 'flex-start', 'center'],
    bottom: ['row', 'flex-start', 'center'],
    left: ['column', 'center', 'center'],
    right: ['column', 'center', 'center'],
    center: ['column', 'center', 'center']
  }
  return (
    t in o && ([r, i, a] = o[t]),
    Object.assign({ display: 'flex', flexDirection: r, justifyContent: i, alignItems: a }, e)
  )
}
class fM extends YI {
  get child() {
    var e
    return (e = this.children) === null || e === void 0 ? void 0 : e[0]
  }
  update(e) {
    var n
    this.attr(e)
    const { subOptions: r } = e
    ;(n = this.child) === null || n === void 0 || n.update(r)
  }
}
class lB extends fM {
  update(e) {
    var n
    const { subOptions: r } = e
    this.attr(e), (n = this.child) === null || n === void 0 || n.update(r)
  }
}
function ar(t, e) {
  var n
  return (n = t.filter((r) => r.getOptions().name === e)) === null || n === void 0 ? void 0 : n[0]
}
function uB(t) {
  return t === 'horizontal' || t === 0
}
function fB(t) {
  return t === 'vertical' || t === -Math.PI / 2
}
function hM(t, e, n) {
  const { bbox: r } = t,
    { position: i = 'top', size: a, length: o } = e,
    s = ['top', 'bottom', 'center'].includes(i),
    [c, l] = s ? [r.height, r.width] : [r.width, r.height],
    { defaultSize: u, defaultLength: f } = n.props,
    h = a || u || c,
    d = o || f || l,
    p = s ? 'horizontal' : 'vertical',
    [v, g] = s ? [d, h] : [h, d]
  return { orientation: p, width: v, height: g, size: h, length: d }
}
function hB(t) {
  return t.find((e) => e.getOptions().domain.length > 0).getOptions().domain
}
function Au(t) {
  const e = [
      'arrow',
      'crosshairs',
      'grid',
      'handle',
      'handleLabel',
      'indicator',
      'label',
      'line',
      'tick',
      'tip',
      'title',
      'trunc'
    ],
    { style: n } = t,
    r = sB(t, ['style']),
    i = {}
  return (
    Object.entries(r).forEach(([a, o]) => {
      e.includes(a) ? (i[`show${ni(a)}`] = o) : (i[a] = o)
    }),
    Object.assign(Object.assign({}, i), n)
  )
}
var dM =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function pM(t, e) {
  const { eulerAngles: n, origin: r } = e
  r && t.setOrigin(r), n && t.rotate(n[0], n[1], n[2])
}
function vM(t) {
  const { innerWidth: e, innerHeight: n, depth: r } = t.getOptions()
  return [e, n, r]
}
function dB(t, e) {
  const { width: n, height: r } = e.getOptions()
  return (i) => {
    if (!O2(e)) return i
    const a = t === 'bottom' ? [i, 1] : [0, i],
      o = e.map(a)
    if (t === 'bottom') {
      const s = o[0]
      return new Ft({ domain: [0, n], range: [0, 1] }).map(s)
    } else if (t === 'left') {
      const s = o[1]
      return new Ft({ domain: [0, r], range: [0, 1] }).map(s)
    }
    return i
  }
}
function pB(t, e, n) {
  if (t.getTicks) return t.getTicks()
  if (!n) return e
  const [r, i] = br(e, (o) => +o),
    { tickCount: a } = t.getOptions()
  return n(r, i, a)
}
function vm(t) {
  return typeof t != 'number' || Math.abs(t) < 1e-15 ? t : parseFloat(t.toFixed(15))
}
function vB(t, e) {
  if (Zt(e)) return (d) => d
  const n = e.getOptions(),
    { innerWidth: r, innerHeight: i, insetTop: a, insetBottom: o, insetLeft: s, insetRight: c } = n,
    [l, u, f] = t === 'left' || t === 'right' ? [a, o, i] : [s, c, r],
    h = new Ft({ domain: [0, 1], range: [l / f, 1 - u / f] })
  return (d) => h.map(d)
}
function gM(t, e, n, r, i, a, o, s) {
  var c
  ;(n !== void 0 || a !== void 0) &&
    t.update(Object.assign(Object.assign({}, n && { tickCount: n }), a && { tickMethod: a }))
  const l = pB(t, e, a),
    u = i ? l.filter(i) : l,
    f = (y) => (y instanceof Date ? String(y) : typeof y == 'object' && y ? y : String(y)),
    h = r || ((c = t.getFormatter) === null || c === void 0 ? void 0 : c.call(t)) || f,
    d = vB(o, s),
    p = dB(o, s),
    v = (y) => ['top', 'bottom', 'center', 'outer'].includes(y),
    g = (y) => ['left', 'right'].includes(y)
  return Zt(s) || ce(s)
    ? u.map((y, m, b) => {
        var x, w
        const O = ((x = t.getBandWidth) === null || x === void 0 ? void 0 : x.call(t, y)) / 2 || 0,
          S = d(t.map(y) + O)
        return {
          value:
            (su(s) && o === 'center') ||
            (ce(s) && ((w = t.getTicks) === null || w === void 0 ? void 0 : w.call(t)) && v(o)) ||
            (ce(s) && g(o))
              ? 1 - S
              : S,
          label: f(h(vm(y), m, b)),
          id: String(m)
        }
      })
    : u.map((y, m, b) => {
        var x
        const w = ((x = t.getBandWidth) === null || x === void 0 ? void 0 : x.call(t, y)) / 2 || 0,
          O = p(d(t.map(y) + w))
        return { value: g(o) ? 1 - O : O, label: f(h(vm(y), m, b)), id: String(m) }
      })
}
function gB(t, e, n = 'xy') {
  const [r, i, a] = vM(e)
  return n === 'xy'
    ? t.includes('bottom') || t.includes('top')
      ? i
      : r
    : n === 'xz'
    ? t.includes('bottom') || t.includes('top')
      ? a
      : r
    : t.includes('bottom') || t.includes('top')
    ? i
    : a
}
function yB(t = [], e) {
  if (t.length > 0) return t
  const { labelAutoRotate: n, labelAutoHide: r, labelAutoEllipsis: i, labelAutoWrap: a } = e,
    o = [],
    s = (c, l) => {
      l && o.push(Object.assign(Object.assign({}, c), l))
    }
  return (
    s({ type: 'rotate', optionalAngles: [0, 15, 30, 45, 60, 90] }, n),
    s({ type: 'ellipsis', minLength: 20 }, i),
    s({ type: 'hide' }, r),
    s({ type: 'wrap', wordWrapWidth: 100, maxLines: 3, recoveryWhenFail: !0 }, a),
    o
  )
}
function mB(t, e, n, r, i) {
  const { x: a, y: o, width: s, height: c } = e,
    l = [a + s / 2, o + c / 2],
    u = Math.min(s, c) / 2,
    [f, h] = pp(i),
    [d, p] = vM(i),
    v = Math.min(d, p) / 2,
    g = { center: l, radius: u, startAngle: f, endAngle: h, gridLength: (r - n) * v }
  if (t === 'inner') {
    const { insetLeft: y, insetTop: m } = i.getOptions()
    return Object.assign(Object.assign({}, g), {
      center: [l[0] - y, l[1] - m],
      labelAlign: 'perpendicular',
      labelDirection: 'positive',
      tickDirection: 'positive',
      gridDirection: 'negative'
    })
  }
  return Object.assign(Object.assign({}, g), {
    labelAlign: 'parallel',
    labelDirection: 'negative',
    tickDirection: 'negative',
    gridDirection: 'positive'
  })
}
function bB(t, e, n) {
  return TC(e) || cu(e) ? !1 : t === void 0 ? !!n.getTicks : t
}
function xB(t) {
  const { depth: e } = t.getOptions()
  return e
    ? {
        tickIsBillboard: !0,
        lineIsBillboard: !0,
        labelIsBillboard: !0,
        titleIsBillboard: !0,
        gridIsBillboard: !0
      }
    : {}
}
function wB(t, e, n, r) {
  const { x: i, y: a, width: o, height: s } = n
  if (t === 'bottom') return { startPos: [i, a], endPos: [i + o, a] }
  if (t === 'left') return { startPos: [i + o, a + s], endPos: [i + o, a] }
  if (t === 'right') return { startPos: [i, a + s], endPos: [i, a] }
  if (t === 'top') return { startPos: [i, a + s], endPos: [i + o, a + s] }
  if (t === 'center') {
    if (e === 'vertical') return { startPos: [i, a], endPos: [i, a + s] }
    if (e === 'horizontal') return { startPos: [i, a], endPos: [i + o, a] }
    if (typeof e == 'number') {
      const [c, l] = r.getCenter(),
        [u, f] = lu(r),
        [h, d] = pp(r),
        p = Math.min(o, s) / 2,
        { insetLeft: v, insetTop: g } = r.getOptions(),
        y = u * p,
        m = f * p,
        [b, x] = [c + i - v, l + a - g],
        [w, O] = [Math.cos(e), Math.sin(e)],
        S = [b + m * w, x + m * O],
        _ = [b + y * w, x + y * O]
      return {
        startPos: S,
        endPos: _,
        gridClosed: d - h === 360,
        gridCenter: [b, x],
        gridControlAngles: new Array(3).fill(0).map((M, E, T) => ((d - h) / (T.length - 1)) * E)
      }
    }
  }
  return {}
}
const OB = (t) => {
  const {
      order: e,
      size: n,
      position: r,
      orientation: i,
      labelFormatter: a,
      tickFilter: o,
      tickCount: s,
      tickMethod: c,
      important: l = {},
      style: u = {},
      indexBBox: f,
      title: h,
      grid: d = !1
    } = t,
    p = dM(t, [
      'order',
      'size',
      'position',
      'orientation',
      'labelFormatter',
      'tickFilter',
      'tickCount',
      'tickMethod',
      'important',
      'style',
      'indexBBox',
      'title',
      'grid'
    ])
  return ({ scales: [v], value: g, coordinate: y, theme: m }) => {
    const { bbox: b } = g,
      { domain: x } = v.getOptions(),
      w = gM(v, x, s, a, o, c, r, y),
      O = f
        ? w.map((A, P) => {
            const k = f.get(P)
            return !k || k[0] !== A.label ? A : Object.assign(Object.assign({}, A), { bbox: k[1] })
          })
        : w,
      [S, _] = lu(y),
      M = mB(r, b, S, _, y),
      { axis: E, axisArc: T = {} } = m,
      C = Au(
        X(
          {},
          E,
          T,
          M,
          Object.assign(Object.assign({ type: 'arc', data: O, titleText: Pu(h), grid: d }, p), l)
        )
      )
    return new Up({ style: rb(C, ['transform']) })
  }
}
function SB(t, e, n, r, i, a) {
  const o = n.axis,
    s = ['top', 'right', 'bottom', 'left'].includes(i) ? n[`axis${qd(i)}`] : n.axisLinear,
    c = t.getOptions().name,
    l = n[`axis${ni(c)}`] || {}
  return Object.assign({}, o, s, l)
}
function _B(t, e, n, r, i, a) {
  const o = SB(t, e, n, r, i)
  return i === 'center'
    ? Object.assign(
        Object.assign(
          Object.assign(Object.assign({}, o), {
            labelDirection: r === 'right' ? 'negative' : 'positive'
          }),
          r === 'center' ? { labelTransform: 'translate(50%,0)' } : null
        ),
        {
          tickDirection: r === 'right' ? 'negative' : 'positive',
          labelSpacing: r === 'center' ? 0 : 4,
          titleSpacing: fB(a) ? 10 : 0,
          tick: r === 'center' ? !1 : void 0
        }
      )
    : o
}
const MB = (t) => {
    const {
        direction: e = 'left',
        important: n = {},
        labelFormatter: r,
        order: i,
        orientation: a,
        actualPosition: o,
        position: s,
        size: c,
        style: l = {},
        title: u,
        tickCount: f,
        tickFilter: h,
        tickMethod: d,
        transform: p,
        indexBBox: v
      } = t,
      g = dM(t, [
        'direction',
        'important',
        'labelFormatter',
        'order',
        'orientation',
        'actualPosition',
        'position',
        'size',
        'style',
        'title',
        'tickCount',
        'tickFilter',
        'tickMethod',
        'transform',
        'indexBBox'
      ])
    return ({ scales: [y], value: m, coordinate: b, theme: x }) => {
      const { bbox: w } = m,
        { domain: O } = y.getOptions(),
        S = _B(y, b, x, e, s, a),
        _ = Object.assign(Object.assign(Object.assign({}, S), l), g),
        M = gB(o || s, b, t.plane),
        E = wB(s, a, w, b),
        T = xB(b),
        C = gM(y, O, f, r, h, d, s, b),
        A = v
          ? C.map((L, R) => {
              const j = v.get(R)
              return !j || j[0] !== L.label
                ? L
                : Object.assign(Object.assign({}, L), { bbox: j[1] })
            })
          : C,
        P = Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(Object.assign({}, _), {
                  type: 'linear',
                  data: A,
                  crossSize: c,
                  titleText: Pu(u),
                  labelOverlap: yB(p, _),
                  grid: bB(_.grid, b, y),
                  gridLength: M,
                  line: !0,
                  indexBBox: v
                }),
                _.line ? null : { lineOpacity: 0 }
              ),
              E
            ),
            T
          ),
          n
        )
      return (
        P.labelOverlap.find((L) => L.type === 'hide') && (P.crossSize = !1),
        new Up({ className: 'axis', style: Au(P) })
      )
    }
  },
  yM = (t) => (e) => {
    const { labelFormatter: n, labelFilter: r = () => !0 } = e
    return (i) => {
      var a
      const {
          scales: [o]
        } = i,
        s =
          ((a = o.getTicks) === null || a === void 0 ? void 0 : a.call(o)) || o.getOptions().domain,
        c = typeof n == 'string' ? li(n) : n,
        l = (f, h, d) => r(s[h], h, s),
        u = Object.assign(Object.assign({}, e), { labelFormatter: c, labelFilter: l, scale: o })
      return t(u)(i)
    }
  },
  ui = yM(MB),
  mM = yM(OB)
ui.props = {
  defaultPosition: 'center',
  defaultSize: 45,
  defaultOrder: 0,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
}
mM.props = {
  defaultPosition: 'outer',
  defaultOrientation: 'vertical',
  defaultSize: 45,
  defaultOrder: 0,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
}
const bM =
  (t) =>
  (...e) => {
    const n = ui(Object.assign({}, { crossPadding: 50 }, t))(...e)
    return pM(n, t), n
  }
bM.props = Object.assign(Object.assign({}, ui.props), { defaultPosition: 'bottom' })
const xM =
  (t) =>
  (...e) => {
    const n = ui(Object.assign({}, { crossPadding: 10 }, t))(...e)
    return pM(n, t), n
  }
xM.props = Object.assign(Object.assign({}, ui.props), { defaultPosition: 'left' })
var EB =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function TB(t) {
  const e = t % (Math.PI * 2)
  return e === Math.PI / 2
    ? { titleTransform: 'translate(0, 50%)' }
    : e > -Math.PI / 2 && e < Math.PI / 2
    ? { titleTransform: 'translate(50%, 0)' }
    : e > Math.PI / 2 && e < (Math.PI * 3) / 2
    ? { titleTransform: 'translate(-50%, 0)' }
    : {}
}
function PB(t, e, n, r) {
  const { radar: i } = t,
    [a] = r,
    o = a.getOptions().name,
    [s, c] = pp(n),
    { axisRadar: l = {} } = e
  return Object.assign(Object.assign({}, l), {
    grid: o === 'position',
    gridConnect: 'line',
    gridControlAngles: new Array(i.count).fill(0).map((u, f) => ((c - s) / i.count) * f)
  })
}
const wM = (t) => {
  const { important: e = {} } = t,
    n = EB(t, ['important'])
  return (r) => {
    const { theme: i, coordinate: a, scales: o } = r
    return ui(
      Object.assign(Object.assign(Object.assign({}, n), TB(t.orientation)), {
        important: Object.assign(Object.assign({}, PB(t, i, a, o)), e)
      })
    )(r)
  }
}
wM.props = Object.assign(Object.assign({}, ui.props), { defaultPosition: 'center' })
var AB =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function kB(t, e) {
  const n = ar(t, 'shape'),
    r = ar(t, 'color'),
    i = n ? n.clone() : null,
    a = []
  for (const [s, c] of e) {
    const l = s.type,
      f = (
        (r == null ? void 0 : r.getOptions().domain.length) > 0
          ? r == null
            ? void 0
            : r.getOptions().domain
          : c.data
      ).map((h, d) => {
        var p
        return i
          ? i.map(h || 'point')
          : ((p = s == null ? void 0 : s.style) === null || p === void 0 ? void 0 : p.shape) ||
              c.defaultShape ||
              'point'
      })
    typeof l == 'string' && a.push([l, f])
  }
  if (a.length === 0) return ['point', ['point']]
  if (a.length === 1 || !n) return a[0]
  const { range: o } = n.getOptions()
  return a
    .map(([s, c]) => {
      let l = 0
      for (let u = 0; u < a.length; u++) {
        const f = o[u % o.length]
        c[u] === f && l++
      }
      return [l / c.length, [s, c]]
    })
    .sort((s, c) => c[0] - s[0])[0][1]
}
function CB(t, e) {
  const { scales: n, library: r, markState: i } = e,
    [a, o] = kB(n, i),
    { itemMarker: s, itemMarkerSize: c } = t,
    l = (h, d) => {
      var p, v, g
      const y =
          ((g =
            (v = (p = r[`mark.${a}`]) === null || p === void 0 ? void 0 : p.props) === null ||
            v === void 0
              ? void 0
              : v.shape[h]) === null || g === void 0
            ? void 0
            : g.props.defaultMarker) || SP(h.split('.')),
        m = typeof c == 'function' ? c(d) : c
      return () => n6(y, { color: d.color })(0, 0, m)
    },
    u = (h) => `${o[h]}`
  return ar(n, 'shape') && !s
    ? (h, d) => l(u(d), h)
    : typeof s == 'function'
    ? (h, d) => {
        const p = s(h.id, d)
        return typeof p == 'string' ? l(p, h) : p
      }
    : (h, d) => l(s || u(d), h)
}
function LB(t) {
  const e = ar(t, 'opacity')
  if (e) {
    const { range: n } = e.getOptions()
    return (r, i) => n[i]
  }
}
function NB(t, e) {
  const n = ar(t, 'size')
  return n instanceof wx ? n.map(NaN) * 2 : e
}
function RB(t, e) {
  const { labelFormatter: n = (h) => `${h}` } = t,
    { scales: r, theme: i } = e,
    a = i.legendCategory.itemMarkerSize,
    o = NB(r, a),
    s = {
      itemMarker: CB(Object.assign(Object.assign({}, t), { itemMarkerSize: o }), e),
      itemMarkerSize: o,
      itemMarkerOpacity: LB(r)
    },
    c = typeof n == 'string' ? li(n) : n,
    l = ar(r, 'color'),
    u = hB(r),
    f = l ? (h) => l.map(h) : () => e.theme.color
  return Object.assign(Object.assign({}, s), {
    data: u.map((h) => ({ id: h, label: c(h), color: f(h) }))
  })
}
function IB(t, e, n) {
  const { position: r } = e
  if (r === 'center') {
    const { bbox: o } = t,
      { width: s, height: c } = o
    return { width: s, height: c }
  }
  const { width: i, height: a } = hM(t, e, n)
  return { width: i, height: a }
}
const u0 = (t) => {
  const {
      labelFormatter: e,
      layout: n,
      order: r,
      orientation: i,
      position: a,
      size: o,
      title: s,
      cols: c,
      itemMarker: l
    } = t,
    u = AB(t, [
      'labelFormatter',
      'layout',
      'order',
      'orientation',
      'position',
      'size',
      'title',
      'cols',
      'itemMarker'
    ]),
    { gridRow: f } = u
  return (h) => {
    const { value: d, theme: p } = h,
      { bbox: v } = d,
      { width: g, height: y } = IB(d, t, u0),
      m = uM(a, n),
      b = Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {
                orientation: ['right', 'left', 'center'].includes(a) ? 'vertical' : 'horizontal',
                width: g,
                height: y,
                layout: c !== void 0 ? 'grid' : 'flex'
              },
              c !== void 0 && { gridCol: c }
            ),
            f !== void 0 && { gridRow: f }
          ),
          { titleText: Pu(s) }
        ),
        RB(t, h)
      ),
      { legendCategory: x = {} } = p,
      w = Au(Object.assign({}, x, b, u)),
      O = new lB({
        style: Object.assign(
          Object.assign({ x: v.x, y: v.y, width: v.width, height: v.height }, m),
          { subOptions: w }
        )
      })
    return O.appendChild(new AI({ className: 'legend-category', style: w })), O
  }
}
u0.props = {
  defaultPosition: 'top',
  defaultOrder: 1,
  defaultSize: 40,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
}
var jB =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function DB(t, e, n) {
  return (t.size = e), uB(n) ? (t.height = e) : (t.width = e), t
}
function $B(t, e, n) {
  const { size: r } = e,
    i = hM(t, e, n)
  return DB(i, r, i.orientation)
}
function BB(t) {
  return (e) => ({ value: e / t, label: String(e) })
}
function FB(t, e, n, r, i) {
  const a = e.thresholds,
    o = BB(r)
  return Object.assign(Object.assign({}, t), { color: i, data: [n, ...a, r].map(o) })
}
function zB(t, e, n) {
  const i = [-1 / 0, ...e.thresholds, 1 / 0].map((a, o) => ({ value: o, label: a }))
  return Object.assign(Object.assign({}, t), {
    data: i,
    color: n,
    labelFilter: (a, o) => o > 0 && o < i.length - 1
  })
}
function ed(t) {
  const { domain: e } = t.getOptions(),
    [n, r] = [e[0], Nb(e)]
  return [n, r]
}
function GB(t, e) {
  const n = t.getOptions(),
    r = t.clone()
  return r.update(Object.assign(Object.assign({}, n), { range: [Or(e).toString()] })), r
}
function WB(t, e, n, r, i, a) {
  const { length: o } = t,
    s = n || r,
    c = i.color ? a.legendContinuous.ribbonFill || 'black' : a.color,
    l = e || GB(s, c),
    [u, f] = ed(l),
    [h, d] = ed([e, n, r].filter((p) => p !== void 0).find((p) => !(p instanceof np)))
  return Object.assign(Object.assign({}, t), {
    domain: [h, d],
    data: l.getTicks().map((p) => ({ value: p })),
    color: new Array(Math.floor(o)).fill(0).map((p, v) => {
      const g = ((f - u) / (o - 1)) * v + u,
        y = l.map(g),
        m = r ? r.map(g) : 1
      return y.replace(
        /rgb[a]*\(([\d]{1,3}) *, *([\d]{1,3}) *, *([\d]{1,3})[\S\s]*\)/,
        (b, x, w, O) => `rgba(${x}, ${w}, ${O}, ${m})`
      )
    })
  })
}
function YB(t, e, n, r, i, a) {
  const o = ar(t, 'color'),
    s = $B(n, r, i)
  if (o instanceof ru) {
    const { range: u } = o.getOptions(),
      [f, h] = ed(o)
    return o instanceof Cx || o instanceof Nx ? FB(s, o, f, h, u) : zB(s, o, u)
  }
  const c = ar(t, 'size'),
    l = ar(t, 'opacity')
  return WB(s, o, c, l, e, a)
}
const fi = (t) => {
  const {
      labelFormatter: e,
      layout: n,
      order: r,
      orientation: i,
      position: a,
      size: o,
      title: s,
      style: c,
      crossPadding: l,
      padding: u
    } = t,
    f = jB(t, [
      'labelFormatter',
      'layout',
      'order',
      'orientation',
      'position',
      'size',
      'title',
      'style',
      'crossPadding',
      'padding'
    ])
  return ({ scales: h, value: d, theme: p, scale: v }) => {
    const { bbox: g } = d,
      { x: y, y: m, width: b, height: x } = g,
      w = uM(a, n),
      { legendContinuous: O = {} } = p,
      S = Au(
        Object.assign(
          {},
          O,
          Object.assign(
            Object.assign(
              {
                titleText: Pu(s),
                labelAlign: 'value',
                labelFormatter: typeof e == 'string' ? (M) => li(e)(M.label) : e
              },
              YB(h, v, d, t, fi, p)
            ),
            c
          ),
          f
        )
      ),
      _ = new fM({
        style: Object.assign(Object.assign({ x: y, y: m, width: b, height: x }, w), {
          subOptions: S
        })
      })
    return _.appendChild(new zI({ className: 'legend-continuous', style: S })), _
  }
}
fi.props = {
  defaultPosition: 'top',
  defaultOrientation: 'vertical',
  defaultOrder: 1,
  defaultSize: 60,
  defaultLength: 200,
  defaultLegendSize: 60,
  defaultPadding: [20, 10],
  defaultCrossPadding: [12, 12]
}
const OM =
  (t) =>
  (...e) =>
    fi(Object.assign({}, { block: !0 }, t))(...e)
OM.props = Object.assign(Object.assign({}, fi.props), {
  defaultPosition: 'top',
  defaultOrientation: 'horizontal'
})
const f0 = (t) => (e) => {
  const { scales: n } = e,
    r = ar(n, 'size')
  return fi(
    Object.assign(
      {},
      { type: 'size', data: r.getTicks().map((i, a) => ({ value: i, label: String(i) })) },
      t
    )
  )(e)
}
f0.props = Object.assign(Object.assign({}, fi.props), {
  defaultPosition: 'top',
  defaultOrientation: 'horizontal'
})
const SM = (t) => f0(Object.assign({}, { block: !0 }, t))
SM.props = Object.assign(Object.assign({}, fi.props), {
  defaultPosition: 'top',
  defaultOrientation: 'horizontal'
})
var HB =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function gm(t, e, n, r) {
  switch (r) {
    case 'center':
      return { x: t + n / 2, y: e, textAlign: 'middle' }
    case 'right':
      return { x: t + n, y: e, textAlign: 'right' }
    default:
      return { x: t, y: e, textAlign: 'left' }
  }
}
const VB = cB({
    render(t, e) {
      const { width: n, title: r, subtitle: i, spacing: a = 2, align: o = 'left' } = t,
        s = HB(t, ['width', 'title', 'subtitle', 'spacing', 'align']),
        c = et(s, 'title'),
        l = et(s, 'subtitle'),
        f = pm(e, '.title', 'text')
          .attr('className', 'title')
          .call(
            at,
            Object.assign(
              Object.assign(Object.assign({}, gm(0, 0, n, o)), {
                fontSize: 14,
                textBaseline: 'top',
                text: r
              }),
              c
            )
          )
          .node()
          .getLocalBounds()
      pm(e, '.sub-title', 'text')
        .attr('className', 'sub-title')
        .call((h) => {
          if (!i) return h.node().remove()
          h.node().attr(
            Object.assign(
              Object.assign(Object.assign({}, gm(0, f.max[1] + a, n, o)), {
                fontSize: 12,
                textBaseline: 'top',
                text: i
              }),
              l
            )
          )
        })
    }
  }),
  _M =
    (t) =>
    ({ value: e, theme: n }) => {
      const { x: r, y: i, width: a, height: o } = e.bbox
      return new VB({
        style: X({}, n.title, Object.assign({ x: r, y: i, width: a, height: o }, t))
      })
    }
_M.props = {
  defaultPosition: 'top',
  defaultOrder: 2,
  defaultSize: 36,
  defaultCrossPadding: [20, 20],
  defaultPadding: [12, 12]
}
function XB(t, e, n) {
  return Math.min(n, Math.max(e, t))
}
function Do(t) {
  return !!t.getBandWidth
}
function Fa(t, e, n) {
  if (!Do(t)) return t.invert(e)
  const { adjustedRange: r } = t,
    { domain: i } = t.getOptions(),
    a = n ? -1 : 0,
    o = t.getStep(),
    s = n ? r : r.map((u) => u + o),
    c = pk(s, e),
    l = XB(c + a, 0, i.length - 1)
  return i[l]
}
function Fr(t, e, n) {
  if (!e) return t.getOptions().domain
  if (!Do(t)) {
    const c = xr(e)
    if (!n) return c
    const [l] = c,
      { range: u } = t.getOptions(),
      [f, h] = u,
      d = f > h ? -1 : 1,
      p = t.invert(t.map(l) + d * n)
    return [l, p]
  }
  const { domain: r } = t.getOptions(),
    i = e[0],
    a = r.indexOf(i)
  if (n) {
    const c = a + Math.round(r.length * n)
    return r.slice(a, c)
  }
  const o = e[e.length - 1],
    s = r.indexOf(o)
  return r.slice(a, s + 1)
}
function Vc(t, e, n, r, i, a) {
  const { x: o, y: s } = i,
    c = (d, p) => {
      const [v, g] = a.invert(d)
      return [Fa(o, v, p), Fa(s, g, p)]
    },
    l = c([t, e], !0),
    u = c([n, r], !1),
    f = Fr(o, [l[0], u[0]]),
    h = Fr(s, [l[1], u[1]])
  return [f, h]
}
function Ml(t, e) {
  const [n, r] = t,
    i = (a) => (a.getStep ? a.getStep() : 0)
  return [e.map(n), e.map(r) + i(e)]
}
function UB(t, e, n) {
  const { x: r, y: i } = e,
    [a, o] = t,
    s = Ml(a, r),
    c = Ml(o, i),
    l = [s[0], c[0]],
    u = [s[1], c[1]],
    [f, h] = n.map(l),
    [d, p] = n.map(u)
  return [f, h, d, p]
}
var qB =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function KB(t, e, n) {
  const { x: r, y: i, width: a, height: o } = t
  if (e === 'left') return [r + a - n, i]
  if (e === 'right') return [r, i]
  if (e === 'bottom') return [r, i]
  if (e === 'top') return [r, i + o - n]
}
const Bs = (t) => {
  const { orientation: e, labelFormatter: n, size: r, style: i = {}, position: a } = t,
    o = qB(t, ['orientation', 'labelFormatter', 'size', 'style', 'position'])
  return ({ scales: [s], value: c, theme: l, coordinate: u }) => {
    var f
    const { bbox: h } = c,
      { width: d, height: p } = h,
      { slider: v = {} } = l,
      g =
        ((f = s.getFormatter) === null || f === void 0 ? void 0 : f.call(s)) ||
        ((S) => S.toString()),
      y = typeof n == 'string' ? li(n) : n,
      m = e === 'horizontal',
      b = ce(u) && m,
      { trackSize: x = v.trackSize } = i,
      [w, O] = KB(h, a, x)
    return new SO({
      className: 'slider',
      style: Object.assign(
        {},
        v,
        Object.assign(
          Object.assign(
            {
              x: w,
              y: O,
              trackLength: m ? d : p,
              orientation: e,
              formatter: (S) => {
                const _ = y || g,
                  M = b ? 1 - S : S,
                  E = Fa(s, M, !0)
                return _(E)
              }
            },
            i
          ),
          o
        )
      )
    })
  }
}
Bs.props = {
  defaultPosition: 'bottom',
  defaultSize: 24,
  defaultOrder: 1,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
}
const MM = (t) => Bs(Object.assign(Object.assign({}, t), { orientation: 'horizontal' }))
MM.props = Object.assign(Object.assign({}, Bs.props), { defaultPosition: 'bottom' })
const EM = (t) => Bs(Object.assign(Object.assign({}, t), { orientation: 'vertical' }))
EM.props = Object.assign(Object.assign({}, Bs.props), { defaultPosition: 'left' })
var ZB =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const Fs = (t) => {
  const { orientation: e, labelFormatter: n, style: r } = t,
    i = ZB(t, ['orientation', 'labelFormatter', 'style'])
  return ({ scales: [a], value: o, theme: s }) => {
    const { bbox: c } = o,
      { x: l, y: u, width: f, height: h } = c,
      { scrollbar: d = {} } = s,
      { ratio: p, range: v } = a.getOptions(),
      g = e === 'horizontal' ? f : h,
      y = g / p,
      [m, b] = v,
      x = b > m ? 0 : 1
    return new v8({
      className: 'g2-scrollbar',
      style: Object.assign(
        {},
        d,
        Object.assign(
          Object.assign(
            Object.assign(Object.assign({}, r), { x: l, y: u, trackLength: g, value: x }),
            i
          ),
          { orientation: e, contentLength: y, viewportLength: g }
        )
      )
    })
  }
}
Fs.props = {
  defaultPosition: 'bottom',
  defaultSize: 24,
  defaultOrder: 1,
  defaultCrossPadding: [12, 12],
  defaultPadding: [12, 12]
}
const TM = (t) => Fs(Object.assign(Object.assign({}, t), { orientation: 'horizontal' }))
TM.props = Object.assign(Object.assign({}, Fs.props), { defaultPosition: 'bottom' })
const PM = (t) => Fs(Object.assign(Object.assign({}, t), { orientation: 'vertical' }))
PM.props = Object.assign(Object.assign({}, Fs.props), { defaultPosition: 'left' })
const AM = (t) => () => new je()
AM.props = {}
const h0 = (t, e) => {
    const { coordinate: r } = e
    return (i, a, o) => {
      const [s] = i,
        { height: c } = s.getBoundingClientRect(),
        { transform: l = '', fillOpacity: u = 1, strokeOpacity: f = 1, opacity: h = 1 } = s.style,
        [d, p] = ce(r) ? [[0, c], `scale(1, ${1e-4})`] : [[0, 0], `scale(${1e-4}, 1)`],
        v = [
          { transform: `${l} ${p}`.trimStart(), fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
          {
            transform: `${l} ${p}`.trimStart(),
            fillOpacity: u,
            strokeOpacity: f,
            opacity: h,
            offset: 0.01
          },
          {
            transform: `${l} scale(1, 1)`.trimStart(),
            fillOpacity: u,
            strokeOpacity: f,
            opacity: h
          }
        ]
      s.setOrigin(d)
      const g = s.animate(v, Object.assign(Object.assign({}, o), t))
      return g.finished.then(() => s.setOrigin(0, 0)), g
    }
  },
  QB = (t, e) => {
    const { coordinate: r } = e
    return (i, a, o) => {
      const [s] = i,
        { height: c } = s.getBoundingClientRect(),
        { transform: l = '', fillOpacity: u = 1, strokeOpacity: f = 1, opacity: h = 1 } = s.style,
        [d, p] = ce(r) ? [[0, c], `scale(1, ${1e-4})`] : [[0, 0], `scale(${1e-4}, 1)`],
        v = [
          { transform: `${l} scale(1, 1)`.trimStart() },
          {
            transform: `${l} ${p}`.trimStart(),
            fillOpacity: u,
            strokeOpacity: f,
            opacity: h,
            offset: 0.99
          },
          { transform: `${l} ${p}`.trimStart(), fillOpacity: 0, strokeOpacity: 0, opacity: 0 }
        ]
      s.setOrigin(d)
      const g = s.animate(v, Object.assign(Object.assign({}, o), t))
      return g.finished.then(() => s.setOrigin(0, 0)), g
    }
  },
  kM = (t, e) => {
    const { coordinate: r } = e
    return (i, a, o) => {
      const [s] = i,
        { height: c } = s.getBoundingClientRect(),
        { transform: l = '', fillOpacity: u = 1, strokeOpacity: f = 1, opacity: h = 1 } = s.style,
        [d, p] = ce(r) ? [[0, 0], `scale(${1e-4}, 1)`] : [[0, c], `scale(1, ${1e-4})`],
        v = [
          { transform: `${l} ${p}`.trimStart(), fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
          {
            transform: `${l} ${p}`.trimStart(),
            fillOpacity: u,
            strokeOpacity: f,
            opacity: h,
            offset: 0.01
          },
          {
            transform: `${l} scale(1, 1)`.trimStart(),
            fillOpacity: u,
            strokeOpacity: f,
            opacity: h
          }
        ]
      s.setOrigin(d)
      const g = s.animate(v, Object.assign(Object.assign({}, o), t))
      return g.finished.then(() => s.setOrigin(0, 0)), g
    }
  },
  JB = (t, e) => {
    const { coordinate: r } = e
    return (i, a, o) => {
      const [s] = i,
        { height: c } = s.getBoundingClientRect(),
        { transform: l = '', fillOpacity: u = 1, strokeOpacity: f = 1, opacity: h = 1 } = s.style,
        [d, p] = ce(r) ? [[0, 0], `scale(${1e-4}, 1)`] : [[0, c], `scale(1, ${1e-4})`],
        v = [
          { transform: `${l} scale(1, 1)`.trimStart() },
          {
            transform: `${l} ${p}`.trimStart(),
            fillOpacity: u,
            strokeOpacity: f,
            opacity: h,
            offset: 0.99
          },
          { transform: `${l} ${p}`.trimStart(), fillOpacity: 0, strokeOpacity: 0, opacity: 0 }
        ]
      s.setOrigin(d)
      const g = s.animate(v, Object.assign(Object.assign({}, o), t))
      return g.finished.then(() => s.setOrigin(0, 0)), g
    }
  },
  CM = (t) => (e, n, r) => {
    const [i] = e,
      { fillOpacity: a = 1, strokeOpacity: o = 1, opacity: s = 1 } = i.style,
      c = [
        { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
        { fillOpacity: a, strokeOpacity: o, opacity: s }
      ]
    return i.animate(c, Object.assign(Object.assign({}, r), t))
  }
CM.props = {}
const LM = (t) => (e, n, r) => {
  const [i] = e,
    { fillOpacity: a = 1, strokeOpacity: o = 1, opacity: s = 1 } = i.style,
    c = [
      { fillOpacity: a, strokeOpacity: o, opacity: s },
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 }
    ]
  return i.animate(c, Object.assign(Object.assign({}, r), t))
}
LM.props = {}
function za(t, e) {
  const n = {}
  for (const r of e) {
    const i = t.style[r]
    i && (n[r] = i)
  }
  return n
}
const Ga = ['fill', 'stroke', 'fillOpacity', 'strokeOpacity', 'opacity', 'lineWidth']
function nd(t) {
  const { min: e, max: n } = t.getLocalBounds(),
    [r, i] = e,
    [a, o] = n,
    s = o - i,
    c = a - r
  return [r, i, c, s]
}
function tF(t) {
  const [e, n, r, i] = t
  return `
    M ${e} ${n}
    L ${e + r} ${n}
    L ${e + r} ${n + i}
    L ${e} ${n + i}
    Z
  `
}
function eF(t, e) {
  const [n, r, i, a] = nd(t),
    o = a / i,
    s = Math.ceil(Math.sqrt(e / o)),
    c = Math.ceil(e / s),
    l = [],
    u = a / c
  let f = 0,
    h = e
  for (; h > 0; ) {
    const d = Math.min(h, s),
      p = i / d
    for (let v = 0; v < d; v++) {
      const g = n + v * p,
        y = r + f * u
      l.push(tF([g, y, p, u]))
    }
    ;(h -= d), (f += 1)
  }
  return l
}
function nF(t = 'pack') {
  return typeof t == 'function' ? t : eF
}
function rF(t, e, n) {
  const [r, i, a, o] = nd(t),
    { transform: s } = t.style,
    { transform: c } = e.style
  NM(e, t)
  const [l, u, f, h] = nd(e),
    d = r - l,
    p = i - u,
    v = a / f,
    g = o / h,
    y = [
      Object.assign(
        { transform: `${s ? s + ' ' : ''}translate(${d}, ${p}) scale(${v}, ${g})` },
        za(t, Ga)
      ),
      Object.assign({ transform: `${c ? c + ' ' : ''}translate(0, 0) scale(1, 1)` }, za(e, Ga))
    ]
  return e.animate(y, n)
}
function NM(t, e) {
  ;(t.__data__ = e.__data__),
    (t.className = e.className),
    (t.markType = e.markType),
    e.parentNode.replaceChild(t, e)
}
function iF(t, e) {
  const { nodeName: n } = t
  if (n === 'path') return t
  const r = new rn({ style: Object.assign(Object.assign({}, za(t, Ga)), { d: e }) })
  return NM(r, t), r
}
function ym(t, e) {
  const n = t.indexOf(e),
    r = t.lastIndexOf(e)
  return n === r
}
function aF(t) {
  return !ym(t, 'm') || !ym(t, 'M')
}
function mm(t) {
  const e = z2(t)
  if (e && !aF(e)) return e
}
function d0(t, e, n, r) {
  const { nodeName: i } = e,
    { nodeName: a } = n,
    o = mm(e),
    s = mm(n)
  if ((i === a && i !== 'path') || o === void 0 || s === void 0) return rF(e, n, r)
  const u = iF(t, o),
    f = [Object.assign({ path: o }, za(e, Ga)), Object.assign({ path: s }, za(n, Ga))],
    h = u.animate(f, r)
  return (
    (h.onfinish = () => {
      ;(u.style.transform = 'none'), Kd(u, n)
    }),
    (u.style.transform = 'none'),
    h
  )
}
function oF(t, e, n, r) {
  t.style.visibility = 'hidden'
  const i = r(t, e.length)
  return e.map((a, o) => {
    const s = new rn({ style: Object.assign({ path: i[o] }, za(t, Ga)) })
    return d0(a, s, a, n)
  })
}
function sF(t, e, n, r) {
  const i = r(e, t.length),
    { fillOpacity: a = 1, strokeOpacity: o = 1, opacity: s = 1 } = e.style,
    c = [
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0, offset: 0.99 },
      { fillOpacity: a, strokeOpacity: o, opacity: s }
    ],
    l = e.animate(c, n)
  return [
    ...t.map((f, h) => {
      const d = new rn({ style: { path: i[h], fill: e.style.fill } })
      return d0(f, f, d, n)
    }),
    l
  ]
}
const RM = (t) => (e, n, r) => {
  const i = nF(t.split),
    a = Object.assign(Object.assign({}, r), t),
    { length: o } = e,
    { length: s } = n
  if ((o === 1 && s === 1) || (o > 1 && s > 1)) {
    const [c] = e,
      [l] = n
    return d0(c, c, l, a)
  }
  if (o === 1 && s > 1) {
    const [c] = e
    return oF(c, n, a, i)
  }
  if (o > 1 && s === 1) {
    const [c] = n
    return sF(e, c, a, i)
  }
  return null
}
RM.props = {}
const IM = (t, e) => {
  V4.registerProperty({
    name: 'waveInArcAngle',
    inherits: !1,
    initialValue: '',
    interpolable: !0,
    syntax: J.NUMBER
  })
  const { coordinate: r } = e
  return (i, a, o) => {
    const [s] = i
    if (!Zt(r)) return h0(t, e)(i, a, o)
    const c = r.getCenter(),
      { __data__: l, style: u } = s,
      { radius: f = 0, inset: h = 0, fillOpacity: d = 1, strokeOpacity: p = 1, opacity: v = 1 } = u,
      { points: g, y, y1: m } = l,
      b = lp()
        .cornerRadius(f)
        .padAngle((h * Math.PI) / 180),
      x = Qa(r, g, [y, m]),
      { startAngle: w, endAngle: O } = x,
      S = new rn({}),
      _ = (T) => {
        S.attr({ d: b(T), transform: `translate(${c[0]}, ${c[1]})` })
        const C = z2(S)
        return (S.style.transform = ''), C
      },
      M = [
        { waveInArcAngle: w + 1e-4, fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
        { waveInArcAngle: w + 1e-4, fillOpacity: d, strokeOpacity: p, opacity: v, offset: 0.01 },
        { waveInArcAngle: O, fillOpacity: d, strokeOpacity: p, opacity: v }
      ],
      E = s.animate(M, Object.assign(Object.assign({}, o), t))
    return (
      (E.onframe = function () {
        s.style.path = _(
          Object.assign(Object.assign({}, x), { endAngle: Number(s.style.waveInArcAngle) })
        )
      }),
      (E.onfinish = function () {
        s.style.path = _(Object.assign(Object.assign({}, x), { endAngle: O }))
      }),
      E
    )
  }
}
IM.props = {}
const cF = (t) => (n, r, i) => {
    const [a] = n,
      { transform: o = '', fillOpacity: s = 1, strokeOpacity: c = 1, opacity: l = 1 } = a.style,
      u = [
        {
          transform: `${o} scale(${1e-4})`.trimStart(),
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          transform: `${o} scale(${1e-4})`.trimStart(),
          fillOpacity: s,
          strokeOpacity: c,
          opacity: l,
          offset: 0.01
        },
        { transform: `${o} scale(1)`.trimStart(), fillOpacity: s, strokeOpacity: c, opacity: l }
      ],
      { width: f, height: h } = a.getBoundingClientRect()
    a.setOrigin([f / 2, h / 2])
    const d = a.animate(u, Object.assign(Object.assign({}, i), t))
    return d.finished.then(() => a.setOrigin(0, 0)), d
  },
  lF = (t) => (n, r, i) => {
    const [a] = n,
      { transform: o = '', fillOpacity: s = 1, strokeOpacity: c = 1, opacity: l = 1 } = a.style,
      u = [
        { transform: `${o} scale(1)`.trimStart() },
        {
          transform: `${o} scale(${1e-4})`.trimStart(),
          fillOpacity: s,
          strokeOpacity: c,
          opacity: l,
          offset: 0.99
        },
        {
          transform: `${o} scale(${1e-4})`.trimStart(),
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        }
      ],
      { width: f, height: h } = a.getBoundingClientRect()
    a.setOrigin([f / 2, h / 2])
    const d = a.animate(u, Object.assign(Object.assign({}, i), t))
    return d.finished.then(() => a.setOrigin(0, 0)), d
  },
  jM = (t) => (e, n, r) => {
    var i, a
    const [o] = e,
      s = ((a = (i = o).getTotalLength) === null || a === void 0 ? void 0 : a.call(i)) || 0,
      c = [{ lineDash: [0, s] }, { lineDash: [s, 0] }]
    return o.animate(c, Object.assign(Object.assign({}, r), t))
  }
jM.props = {}
const DM = (t, e) => (n, r, i) => {
  const [a] = n,
    { height: o, width: s } = a.getBoundingClientRect(),
    c = new rn({ style: { path: `M0,0L${s},0L${s},${o}L0,${o}Z` } })
  a.appendChild(c), (a.style.clipPath = c)
  const l = h0(t, e)([c], r, i)
  return (
    l.finished.then(() => {
      c.remove(), (a.style.clipPath = null)
    }),
    l
  )
}
DM.props = {}
const $M = (t, e) => (n, r, i) => {
  const [a] = n,
    { height: o, width: s } = a.getBoundingClientRect(),
    c = new rn({ style: { path: `M0,0L${s},0L${s},${o}L0,${o}Z` } })
  a.appendChild(c), (a.style.clipPath = c)
  const l = kM(t, e)([c], r, i)
  return (
    l.finished.then(() => {
      c.remove(), (a.style.clipPath = null)
    }),
    l
  )
}
$M.props = {}
const bm = 'main-layer',
  rd = 'label-layer',
  pr = 'element',
  id = 'view',
  ad = 'plot',
  xm = 'component',
  od = 'label',
  wm = 'area'
function uF(t, e) {
  var n = e.r
  t.arc(n, n, n, 0, Math.PI * 2, !1)
}
function fF(t, e) {
  var n = e.rx,
    r = e.ry,
    i = n,
    a = r
  if (t.ellipse) t.ellipse(i, a, i, a, 0, 0, Math.PI * 2, !1)
  else {
    var o = i > a ? i : a,
      s = i > a ? 1 : i / a,
      c = i > a ? a / i : 1
    t.save(), t.scale(s, c), t.arc(o, o, o, 0, Math.PI * 2)
  }
}
function hF(t, e) {
  var n = e.x1,
    r = e.y1,
    i = e.x2,
    a = e.y2,
    o = e.defX,
    s = o === void 0 ? 0 : o,
    c = e.defY,
    l = c === void 0 ? 0 : c,
    u = e.markerStart,
    f = e.markerEnd,
    h = e.markerStartOffset,
    d = e.markerEndOffset,
    p = 0,
    v = 0,
    g = 0,
    y = 0,
    m = 0,
    b,
    x
  u &&
    _t(u) &&
    h &&
    ((b = i - n),
    (x = a - r),
    (m = Math.atan2(x, b)),
    (p = Math.cos(m) * (h || 0)),
    (v = Math.sin(m) * (h || 0))),
    f &&
      _t(f) &&
      d &&
      ((b = n - i),
      (x = r - a),
      (m = Math.atan2(x, b)),
      (g = Math.cos(m) * (d || 0)),
      (y = Math.sin(m) * (d || 0))),
    t.moveTo(n - s + p, r - l + v),
    t.lineTo(i - s + g, a - l + y)
}
function dF(t, e) {
  var n = e.defX,
    r = n === void 0 ? 0 : n,
    i = e.defY,
    a = i === void 0 ? 0 : i,
    o = e.markerStart,
    s = e.markerEnd,
    c = e.markerStartOffset,
    l = e.markerEndOffset,
    u = e.path,
    f = u.absolutePath,
    h = u.segments,
    d = 0,
    p = 0,
    v = 0,
    g = 0,
    y = 0,
    m,
    b
  if (o && _t(o) && c) {
    var x = N(o.parentNode.getStartTangent(), 2),
      w = x[0],
      O = x[1]
    ;(m = w[0] - O[0]),
      (b = w[1] - O[1]),
      (y = Math.atan2(b, m)),
      (d = Math.cos(y) * (c || 0)),
      (p = Math.sin(y) * (c || 0))
  }
  if (s && _t(s) && l) {
    var S = N(s.parentNode.getEndTangent(), 2),
      w = S[0],
      O = S[1]
    ;(m = w[0] - O[0]),
      (b = w[1] - O[1]),
      (y = Math.atan2(b, m)),
      (v = Math.cos(y) * (l || 0)),
      (g = Math.sin(y) * (l || 0))
  }
  for (var _ = 0; _ < f.length; _++) {
    var M = f[_],
      E = M[0],
      T = f[_ + 1],
      C = _ === 0 && (d !== 0 || p !== 0),
      A = (_ === f.length - 1 || (T && (T[0] === 'M' || T[0] === 'Z'))) && v !== 0 && g !== 0
    switch (E) {
      case 'M':
        C
          ? (t.moveTo(M[1] - r + d, M[2] - a + p), t.lineTo(M[1] - r, M[2] - a))
          : t.moveTo(M[1] - r, M[2] - a)
        break
      case 'L':
        A ? t.lineTo(M[1] - r + v, M[2] - a + g) : t.lineTo(M[1] - r, M[2] - a)
        break
      case 'Q':
        t.quadraticCurveTo(M[1] - r, M[2] - a, M[3] - r, M[4] - a),
          A && t.lineTo(M[3] - r + v, M[4] - a + g)
        break
      case 'C':
        t.bezierCurveTo(M[1] - r, M[2] - a, M[3] - r, M[4] - a, M[5] - r, M[6] - a),
          A && t.lineTo(M[5] - r + v, M[6] - a + g)
        break
      case 'A': {
        var P = h[_].arcParams,
          k = P.cx,
          L = P.cy,
          R = P.rx,
          j = P.ry,
          I = P.startAngle,
          D = P.endAngle,
          $ = P.xRotation,
          B = P.sweepFlag
        if (t.ellipse) t.ellipse(k - r, L - a, R, j, $, I, D, !!(1 - B))
        else {
          var F = R > j ? R : j,
            W = R > j ? 1 : R / j,
            U = R > j ? j / R : 1
          t.translate(k - r, L - a),
            t.rotate($),
            t.scale(W, U),
            t.arc(0, 0, F, I, D, !!(1 - B)),
            t.scale(1 / W, 1 / U),
            t.rotate(-$),
            t.translate(-(k - r), -(L - a))
        }
        A && t.lineTo(M[6] - r + v, M[7] - a + g)
        break
      }
      case 'Z':
        t.closePath()
        break
    }
  }
}
function pF(t, e) {
  var n = e.defX,
    r = n === void 0 ? 0 : n,
    i = e.defY,
    a = i === void 0 ? 0 : i,
    o = e.markerStart,
    s = e.markerEnd,
    c = e.markerStartOffset,
    l = e.markerEndOffset,
    u = e.points.points,
    f = u.length,
    h = u[0][0] - r,
    d = u[0][1] - a,
    p = u[f - 1][0] - r,
    v = u[f - 1][1] - a,
    g = 0,
    y = 0,
    m = 0,
    b = 0,
    x = 0,
    w,
    O
  o &&
    _t(o) &&
    c &&
    ((w = u[1][0] - u[0][0]),
    (O = u[1][1] - u[0][1]),
    (x = Math.atan2(O, w)),
    (g = Math.cos(x) * (c || 0)),
    (y = Math.sin(x) * (c || 0))),
    s &&
      _t(s) &&
      l &&
      ((w = u[f - 1][0] - u[0][0]),
      (O = u[f - 1][1] - u[0][1]),
      (x = Math.atan2(O, w)),
      (m = Math.cos(x) * (l || 0)),
      (b = Math.sin(x) * (l || 0))),
    t.moveTo(h + (g || m), d + (y || b))
  for (var S = 1; S < f - 1; S++) {
    var _ = u[S]
    t.lineTo(_[0] - r, _[1] - a)
  }
  t.lineTo(p, v)
}
function vF(t, e) {
  var n = e.defX,
    r = n === void 0 ? 0 : n,
    i = e.defY,
    a = i === void 0 ? 0 : i,
    o = e.markerStart,
    s = e.markerEnd,
    c = e.markerStartOffset,
    l = e.markerEndOffset,
    u = e.points.points,
    f = u.length,
    h = u[0][0] - r,
    d = u[0][1] - a,
    p = u[f - 1][0] - r,
    v = u[f - 1][1] - a,
    g = 0,
    y = 0,
    m = 0,
    b = 0,
    x = 0,
    w,
    O
  o &&
    _t(o) &&
    c &&
    ((w = u[1][0] - u[0][0]),
    (O = u[1][1] - u[0][1]),
    (x = Math.atan2(O, w)),
    (g = Math.cos(x) * (c || 0)),
    (y = Math.sin(x) * (c || 0))),
    s &&
      _t(s) &&
      l &&
      ((w = u[f - 2][0] - u[f - 1][0]),
      (O = u[f - 2][1] - u[f - 1][1]),
      (x = Math.atan2(O, w)),
      (m = Math.cos(x) * (l || 0)),
      (b = Math.sin(x) * (l || 0))),
    t.moveTo(h + g, d + y)
  for (var S = 1; S < f - 1; S++) {
    var _ = u[S]
    t.lineTo(_[0] - r, _[1] - a)
  }
  t.lineTo(p + m, v + b)
}
function gF(t, e) {
  var n = e.radius,
    r = e.width,
    i = e.height,
    a = r,
    o = i,
    s =
      n &&
      n.some(function (g) {
        return g !== 0
      })
  if (!s) t.rect(0, 0, a, o)
  else {
    var c = r > 0 ? 1 : -1,
      l = i > 0 ? 1 : -1,
      u = c + l === 0,
      f = N(
        n.map(function (g) {
          return se(g, 0, Math.min(Math.abs(a) / 2, Math.abs(o) / 2))
        }),
        4
      ),
      h = f[0],
      d = f[1],
      p = f[2],
      v = f[3]
    t.moveTo(c * h, 0),
      t.lineTo(a - c * d, 0),
      d !== 0 && t.arc(a - c * d, l * d, d, (-l * Math.PI) / 2, c > 0 ? 0 : Math.PI, u),
      t.lineTo(a, o - l * p),
      p !== 0 &&
        t.arc(a - c * p, o - l * p, p, c > 0 ? 0 : Math.PI, l > 0 ? Math.PI / 2 : 1.5 * Math.PI, u),
      t.lineTo(c * v, o),
      v !== 0 &&
        t.arc(c * v, o - l * v, v, l > 0 ? Math.PI / 2 : -Math.PI / 2, c > 0 ? Math.PI : 0, u),
      t.lineTo(0, l * h),
      h !== 0 && t.arc(c * h, l * h, h, c > 0 ? Math.PI : 0, l > 0 ? Math.PI * 1.5 : Math.PI / 2, u)
  }
}
var yF = (function (t) {
    rt(e, t)
    function e() {
      var n = (t !== null && t.apply(this, arguments)) || this
      return (n.name = 'canvas-path-generator'), n
    }
    return (
      (e.prototype.init = function () {
        var n,
          r =
            ((n = {}),
            (n[G.CIRCLE] = uF),
            (n[G.ELLIPSE] = fF),
            (n[G.RECT] = gF),
            (n[G.LINE] = hF),
            (n[G.POLYLINE] = vF),
            (n[G.POLYGON] = pF),
            (n[G.PATH] = dF),
            (n[G.TEXT] = void 0),
            (n[G.GROUP] = void 0),
            (n[G.IMAGE] = void 0),
            (n[G.HTML] = void 0),
            (n[G.MESH] = void 0),
            n)
        this.context.pathGeneratorFactory = r
      }),
      (e.prototype.destroy = function () {
        delete this.context.pathGeneratorFactory
      }),
      e
    )
  })(oi),
  mF = yt(),
  bF = yt(),
  xF = yt(),
  wF = Nt(),
  OF = (function () {
    function t() {
      var e = this
      ;(this.isHit = function (n, r, i, a) {
        var o = e.context.pointInPathPickerFactory[n.nodeName]
        if (o) {
          var s = zn(wF, i),
            c = be(bF, $n(xF, r[0], r[1], 0), s),
            l = n.getGeometryBounds().halfExtents,
            u = n.parsedStyle.anchor
          if (
            ((c[0] += ((u && u[0]) || 0) * l[0] * 2),
            (c[1] += ((u && u[1]) || 0) * l[1] * 2),
            o(n, new Ee(c[0], c[1]), a, e.isPointInPath, e.context, e.runtime))
          )
            return !0
        }
        return !1
      }),
        (this.isPointInPath = function (n, r) {
          var i = e.runtime.offscreenCanvasCreator.getOrCreateContext(
              e.context.config.offscreenCanvas
            ),
            a = e.context.pathGeneratorFactory[n.nodeName]
          return a && (i.beginPath(), a(i, n.parsedStyle), i.closePath()), i.isPointInPath(r.x, r.y)
        })
    }
    return (
      (t.prototype.apply = function (e, n) {
        var r = this,
          i,
          a = e.renderingService,
          o = e.renderingContext
        ;(this.context = e), (this.runtime = n)
        var s = (i = o.root) === null || i === void 0 ? void 0 : i.ownerDocument
        a.hooks.pick.tapPromise(t.tag, function (c) {
          return Ea(r, void 0, void 0, function () {
            return Ta(this, function (l) {
              return [2, this.pick(s, c)]
            })
          })
        }),
          a.hooks.pickSync.tap(t.tag, function (c) {
            return r.pick(s, c)
          })
      }),
      (t.prototype.pick = function (e, n) {
        var r,
          i,
          a = n.topmost,
          o = n.position,
          s = o.x,
          c = o.y,
          l = $n(mF, s, c, 0),
          u = e.elementsFromBBox(l[0], l[1], l[0], l[1]),
          f = []
        try {
          for (var h = hn(u), d = h.next(); !d.done; d = h.next()) {
            var p = d.value,
              v = p.getWorldTransform(),
              g = this.isHit(p, l, v, !1)
            if (g) {
              var y = V2(p)
              if (y) {
                var m = y.parsedStyle.clipPath,
                  b = this.isHit(m, l, m.getWorldTransform(), !0)
                if (b) {
                  if (a) return (n.picked = [p]), n
                  f.push(p)
                }
              } else {
                if (a) return (n.picked = [p]), n
                f.push(p)
              }
            }
          }
        } catch (x) {
          r = { error: x }
        } finally {
          try {
            d && !d.done && (i = h.return) && i.call(h)
          } finally {
            if (r) throw r.error
          }
        }
        return (n.picked = f), n
      }),
      (t.tag = 'CanvasPicker'),
      t
    )
  })()
function SF(t, e, n) {
  var r = t.parsedStyle,
    i = r.r,
    a = r.fill,
    o = r.stroke,
    s = r.lineWidth,
    c = r.increasedLineWidthForHitTesting,
    l = r.pointerEvents,
    u = ((s || 0) + (c || 0)) / 2,
    f = wr(i, i, e.x, e.y),
    h = N(Vi(l, a, o), 2),
    d = h[0],
    p = h[1]
  return (d && p) || n ? f <= i + u : d ? f <= i : p ? f >= i - u && f <= i + u : !1
}
function Oc(t, e, n, r) {
  return t / (n * n) + e / (r * r)
}
function _F(t, e, n) {
  var r = t.parsedStyle,
    i = r.rx,
    a = r.ry,
    o = r.fill,
    s = r.stroke,
    c = r.lineWidth,
    l = r.increasedLineWidthForHitTesting,
    u = r.pointerEvents,
    f = e.x,
    h = e.y,
    d = N(Vi(u, o, s), 2),
    p = d[0],
    v = d[1],
    g = ((c || 0) + (l || 0)) / 2,
    y = (f - i) * (f - i),
    m = (h - a) * (h - a)
  return (p && v) || n
    ? Oc(y, m, i + g, a + g) <= 1
    : p
    ? Oc(y, m, i, a) <= 1
    : v
    ? Oc(y, m, i - g, a - g) >= 1 && Oc(y, m, i + g, a + g) <= 1
    : !1
}
function Si(t, e, n, r, i, a) {
  return i >= t && i <= t + n && a >= e && a <= e + r
}
function MF(t, e, n, r, i, a, o) {
  var s = i / 2
  return (
    Si(t - s, e - s, n, i, a, o) ||
    Si(t + n - s, e - s, i, r, a, o) ||
    Si(t + s, e + r - s, n, i, a, o) ||
    Si(t - s, e + s, i, r, a, o)
  )
}
function Sc(t, e, n, r, i, a, o, s) {
  var c = (Math.atan2(s - e, o - t) + Math.PI * 2) % (Math.PI * 2),
    l = { x: t + n * Math.cos(c), y: e + n * Math.sin(c) }
  return wr(l.x, l.y, o, s) <= a / 2
}
function zr(t, e, n, r, i, a, o) {
  var s = Math.min(t, n),
    c = Math.max(t, n),
    l = Math.min(e, r),
    u = Math.max(e, r),
    f = i / 2
  return a >= s - f && a <= c + f && o >= l - f && o <= u + f ? UC(t, e, n, r, a, o) <= i / 2 : !1
}
function BM(t, e, n, r, i) {
  var a = t.length
  if (a < 2) return !1
  for (var o = 0; o < a - 1; o++) {
    var s = t[o][0],
      c = t[o][1],
      l = t[o + 1][0],
      u = t[o + 1][1]
    if (zr(s, c, l, u, e, n, r)) return !0
  }
  if (i) {
    var f = t[0],
      h = t[a - 1]
    if (zr(f[0], f[1], h[0], h[1], e, n, r)) return !0
  }
  return !1
}
var EF = 1e-6
function Cf(t) {
  return Math.abs(t) < EF ? 0 : t < 0 ? -1 : 1
}
function TF(t, e, n) {
  return (
    (n[0] - t[0]) * (e[1] - t[1]) === (e[0] - t[0]) * (n[1] - t[1]) &&
    Math.min(t[0], e[0]) <= n[0] &&
    n[0] <= Math.max(t[0], e[0]) &&
    Math.min(t[1], e[1]) <= n[1] &&
    n[1] <= Math.max(t[1], e[1])
  )
}
function FM(t, e, n) {
  var r = !1,
    i = t.length
  if (i <= 2) return !1
  for (var a = 0; a < i; a++) {
    var o = t[a],
      s = t[(a + 1) % i]
    if (TF(o, s, [e, n])) return !0
    Cf(o[1] - n) > 0 != Cf(s[1] - n) > 0 &&
      Cf(e - ((n - o[1]) * (o[0] - s[0])) / (o[1] - s[1]) - o[0]) < 0 &&
      (r = !r)
  }
  return r
}
function Om(t, e, n) {
  for (var r = !1, i = 0; i < t.length; i++) {
    var a = t[i]
    if (((r = FM(a, e, n)), r)) break
  }
  return r
}
function PF(t, e, n) {
  var r = t.parsedStyle,
    i = r.x1,
    a = r.y1,
    o = r.x2,
    s = r.y2,
    c = r.lineWidth,
    l = r.increasedLineWidthForHitTesting,
    u = r.defX,
    f = u === void 0 ? 0 : u,
    h = r.defY,
    d = h === void 0 ? 0 : h,
    p = r.pointerEvents,
    v = r.fill,
    g = r.stroke,
    y = N(Vi(p, v, g), 2),
    m = y[1]
  return (!m && !n) || !c ? !1 : zr(i, a, o, s, (c || 0) + (l || 0), e.x + f, e.y + d)
}
function AF(t, e, n, r, i) {
  for (var a = !1, o = e / 2, s = 0; s < t.length; s++) {
    var c = t[s],
      l = c.currentPoint,
      u = c.params,
      f = c.prePoint,
      h = c.box
    if (!(h && !Si(h.x - o, h.y - o, h.width + e, h.height + e, n, r)))
      switch (c.command) {
        case 'L':
        case 'Z':
          if (((a = zr(f[0], f[1], l[0], l[1], e, n, r)), a)) return !0
          break
        case 'Q':
          var d = eL(f[0], f[1], u[1], u[2], u[3], u[4], n, r)
          if (((a = d <= e / 2), a)) return !0
          break
        case 'C':
          var p = qv(f[0], f[1], u[1], u[2], u[3], u[4], u[5], u[6], n, r, i)
          if (((a = p <= e / 2), a)) return !0
          break
        case 'A':
          c.cubicParams ||
            (c.cubicParams = Gd(f[0], f[1], u[1], u[2], u[3], u[4], u[5], u[6], u[7], void 0))
          for (var v = c.cubicParams, g = f, y = 0; y < v.length; y += 6) {
            var m = qv(g[0], g[1], v[y], v[y + 1], v[y + 2], v[y + 3], v[y + 4], v[y + 5], n, r, i)
            if (((g = [v[y + 4], v[y + 5]]), (a = m <= e / 2), a)) return !0
          }
          break
      }
  }
  return a
}
function kF(t, e, n, r, i, a) {
  var o = t.parsedStyle,
    s = o.lineWidth,
    c = o.increasedLineWidthForHitTesting,
    l = o.stroke,
    u = o.fill,
    f = o.defX,
    h = f === void 0 ? 0 : f,
    d = o.defY,
    p = d === void 0 ? 0 : d,
    v = o.path,
    g = o.pointerEvents,
    y = v.segments,
    m = v.hasArc,
    b = v.polylines,
    x = v.polygons,
    w = N(Vi(g, (x == null ? void 0 : x.length) && u, l), 2),
    O = w[0],
    S = w[1],
    _ = Ah(t),
    M = !1
  return O || n
    ? (m ? (M = r(t, e)) : (M = Om(x, e.x + h, e.y + p) || Om(b, e.x + h, e.y + p)), M)
    : ((S || n) && (M = AF(y, (s || 0) + (c || 0), e.x + h, e.y + p, _)), M)
}
function CF(t, e, n) {
  var r = t.parsedStyle,
    i = r.stroke,
    a = r.fill,
    o = r.lineWidth,
    s = r.increasedLineWidthForHitTesting,
    c = r.points,
    l = r.defX,
    u = l === void 0 ? 0 : l,
    f = r.defY,
    h = f === void 0 ? 0 : f,
    d = r.pointerEvents,
    p = N(Vi(d, a, i), 2),
    v = p[0],
    g = p[1],
    y = !1
  return (
    (g || n) && (y = BM(c.points, (o || 0) + (s || 0), e.x + u, e.y + h, !0)),
    !y && (v || n) && (y = FM(c.points, e.x + u, e.y + h)),
    y
  )
}
function LF(t, e, n) {
  var r = t.parsedStyle,
    i = r.lineWidth,
    a = r.increasedLineWidthForHitTesting,
    o = r.points,
    s = r.defX,
    c = s === void 0 ? 0 : s,
    l = r.defY,
    u = l === void 0 ? 0 : l,
    f = r.pointerEvents,
    h = r.fill,
    d = r.stroke,
    p = N(Vi(f, h, d), 2),
    v = p[1]
  return (!v && !n) || !i ? !1 : BM(o.points, (i || 0) + (a || 0), e.x + c, e.y + u, !1)
}
function NF(t, e, n, r, i) {
  var a = t.parsedStyle,
    o = a.radius,
    s = a.fill,
    c = a.stroke,
    l = a.lineWidth,
    u = a.increasedLineWidthForHitTesting,
    f = a.width,
    h = a.height,
    d = a.pointerEvents,
    p = N(Vi(d, s, c), 2),
    v = p[0],
    g = p[1],
    y =
      o &&
      o.some(function (w) {
        return w !== 0
      }),
    m = (l || 0) + (u || 0)
  if (y) {
    var x = !1
    return (
      (g || n) &&
        (x = RF(
          0,
          0,
          f,
          h,
          o.map(function (w) {
            return se(w, 0, Math.min(Math.abs(f) / 2, Math.abs(h) / 2))
          }),
          m,
          e.x,
          e.y
        )),
      !x && (v || n) && (x = r(t, e)),
      x
    )
  } else {
    var b = m / 2
    if ((v && g) || n) return Si(0 - b, 0 - b, f + b, h + b, e.x, e.y)
    if (v) return Si(0, 0, f, h, e.x, e.y)
    if (g) return MF(0, 0, f, h, m, e.x, e.y)
  }
  return !1
}
function RF(t, e, n, r, i, a, o, s) {
  var c = N(i, 4),
    l = c[0],
    u = c[1],
    f = c[2],
    h = c[3]
  return (
    zr(t + l, e, t + n - u, e, a, o, s) ||
    zr(t + n, e + u, t + n, e + r - f, a, o, s) ||
    zr(t + n - f, e + r, t + h, e + r, a, o, s) ||
    zr(t, e + r - h, t, e + l, a, o, s) ||
    Sc(t + n - u, e + u, u, 1.5 * Math.PI, 2 * Math.PI, a, o, s) ||
    Sc(t + n - f, e + r - f, f, 0, 0.5 * Math.PI, a, o, s) ||
    Sc(t + h, e + r - h, h, 0.5 * Math.PI, Math.PI, a, o, s) ||
    Sc(t + l, e + l, l, Math.PI, 1.5 * Math.PI, a, o, s)
  )
}
function IF(t, e, n, r, i, a) {
  var o = t.parsedStyle,
    s = o.pointerEvents,
    c = o.width,
    l = o.height
  if (s === 'non-transparent-pixel') {
    var u = i.config.offscreenCanvas,
      f = a.offscreenCanvasCreator.getOrCreateCanvas(u),
      h = a.offscreenCanvasCreator.getOrCreateContext(u, { willReadFrequently: !0 })
    ;(f.width = c),
      (f.height = l),
      i.defaultStyleRendererFactory[G.IMAGE].render(h, t.parsedStyle, t, void 0, void 0, void 0)
    var d = h.getImageData(e.x, e.y, 1, 1).data
    return d.every(function (p) {
      return p !== 0
    })
  }
  return !0
}
var jF = (function (t) {
    rt(e, t)
    function e() {
      var n = (t !== null && t.apply(this, arguments)) || this
      return (n.name = 'canvas-picker'), n
    }
    return (
      (e.prototype.init = function () {
        var n,
          r = function () {
            return !0
          },
          i =
            ((n = {}),
            (n[G.CIRCLE] = SF),
            (n[G.ELLIPSE] = _F),
            (n[G.RECT] = NF),
            (n[G.LINE] = PF),
            (n[G.POLYLINE] = LF),
            (n[G.POLYGON] = CF),
            (n[G.PATH] = kF),
            (n[G.TEXT] = r),
            (n[G.GROUP] = null),
            (n[G.IMAGE] = IF),
            (n[G.HTML] = null),
            (n[G.MESH] = null),
            n)
        ;(this.context.pointInPathPickerFactory = i), this.addRenderingPlugin(new OF())
      }),
      (e.prototype.destroy = function () {
        delete this.context.pointInPathPickerFactory, this.removeAllRenderingPlugins()
      }),
      e
    )
  })(oi),
  DF = (function () {
    function t(e) {
      ;(this.canvasRendererPluginOptions = e),
        (this.removedRBushNodeAABBs = []),
        (this.renderQueue = []),
        (this.restoreStack = []),
        (this.clearFullScreen = !1),
        (this.vpMatrix = Nt()),
        (this.dprMatrix = Nt()),
        (this.tmpMat4 = Nt()),
        (this.vec3a = yt()),
        (this.vec3b = yt()),
        (this.vec3c = yt()),
        (this.vec3d = yt())
    }
    return (
      (t.prototype.apply = function (e, n) {
        var r = this
        this.context = e
        var i = e.config,
          a = e.camera,
          o = e.renderingService,
          s = e.renderingContext,
          c = e.rBushRoot,
          l = e.pathGeneratorFactory
        ;(this.rBush = c), (this.pathGeneratorFactory = l)
        var u = e.contextService,
          f = s.root.ownerDocument.defaultView,
          h = function (v) {
            var g = v.target,
              y = g.rBushNode
            y.aabb && r.removedRBushNodeAABBs.push(y.aabb)
          },
          d = function (v) {
            var g = v.target,
              y = g.rBushNode
            y.aabb && r.removedRBushNodeAABBs.push(y.aabb)
          }
        o.hooks.init.tap(t.tag, function () {
          f.addEventListener(dt.UNMOUNTED, h), f.addEventListener(dt.CULLED, d)
          var v = u.getDPR(),
            g = i.width,
            y = i.height,
            m = u.getContext()
          r.clearRect(m, 0, 0, g * v, y * v, i.background)
        }),
          o.hooks.destroy.tap(t.tag, function () {
            f.removeEventListener(dt.UNMOUNTED, h),
              f.removeEventListener(dt.CULLED, d),
              (r.renderQueue = []),
              (r.removedRBushNodeAABBs = []),
              (r.restoreStack = [])
          }),
          o.hooks.beginFrame.tap(t.tag, function () {
            var v = u.getContext(),
              g = u.getDPR(),
              y = i.width,
              m = i.height,
              b = r.canvasRendererPluginOptions,
              x = b.dirtyObjectNumThreshold,
              w = b.dirtyObjectRatioThreshold,
              O = o.getStats(),
              S = O.total,
              _ = O.rendered,
              M = _ / S
            ;(r.clearFullScreen = o.disableDirtyRectangleRendering() || (_ > x && M > w)),
              v &&
                (v.resetTransform ? v.resetTransform() : v.setTransform(1, 0, 0, 1, 0, 0),
                r.clearFullScreen && r.clearRect(v, 0, 0, y * g, m * g, i.background))
          })
        var p = function (v, g) {
          v.isVisible() &&
            !v.isCulled() &&
            (r.renderDisplayObject(v, g, r.context, r.restoreStack, n), r.saveDirtyAABB(v))
          var y = v.sortable.sorted || v.childNodes
          y.forEach(function (m) {
            p(m, g)
          })
        }
        o.hooks.endFrame.tap(t.tag, function () {
          var v = u.getContext(),
            g = u.getDPR()
          if (
            (Fd(r.dprMatrix, [g, g, 1]),
            Re(r.vpMatrix, r.dprMatrix, a.getOrthoMatrix()),
            r.clearFullScreen)
          )
            p(s.root, v)
          else {
            var y = r.safeMergeAABB.apply(
              r,
              q(
                [r.mergeDirtyAABBs(r.renderQueue)],
                N(
                  r.removedRBushNodeAABBs.map(function ($) {
                    var B = $.minX,
                      F = $.minY,
                      W = $.maxX,
                      U = $.maxY,
                      K = new me()
                    return K.setMinMax([B, F, 0], [W, U, 0]), K
                  })
                ),
                !1
              )
            )
            if (((r.removedRBushNodeAABBs = []), me.isEmpty(y))) {
              r.renderQueue = []
              return
            }
            var m = r.convertAABB2Rect(y),
              b = m.x,
              x = m.y,
              w = m.width,
              O = m.height,
              S = be(r.vec3a, [b, x, 0], r.vpMatrix),
              _ = be(r.vec3b, [b + w, x, 0], r.vpMatrix),
              M = be(r.vec3c, [b, x + O, 0], r.vpMatrix),
              E = be(r.vec3d, [b + w, x + O, 0], r.vpMatrix),
              T = Math.min(S[0], _[0], E[0], M[0]),
              C = Math.min(S[1], _[1], E[1], M[1]),
              A = Math.max(S[0], _[0], E[0], M[0]),
              P = Math.max(S[1], _[1], E[1], M[1]),
              k = Math.floor(T),
              L = Math.floor(C),
              R = Math.ceil(A - T),
              j = Math.ceil(P - C)
            v.save(),
              r.clearRect(v, k, L, R, j, i.background),
              v.beginPath(),
              v.rect(k, L, R, j),
              v.clip(),
              v.setTransform(
                r.vpMatrix[0],
                r.vpMatrix[1],
                r.vpMatrix[4],
                r.vpMatrix[5],
                r.vpMatrix[12],
                r.vpMatrix[13]
              )
            var I = i.renderer.getConfig().enableDirtyRectangleRenderingDebug
            I &&
              f.dispatchEvent(
                new Bt(Je.DIRTY_RECTANGLE, { dirtyRect: { x: k, y: L, width: R, height: j } })
              )
            var D = r.searchDirtyObjects(y)
            D.sort(function ($, B) {
              return $.sortable.renderOrder - B.sortable.renderOrder
            }).forEach(function ($) {
              $ &&
                $.isVisible() &&
                !$.isCulled() &&
                r.renderDisplayObject($, v, r.context, r.restoreStack, n)
            }),
              v.restore(),
              r.renderQueue.forEach(function ($) {
                r.saveDirtyAABB($)
              }),
              (r.renderQueue = [])
          }
          r.restoreStack.forEach(function () {
            v.restore()
          }),
            (r.restoreStack = [])
        }),
          o.hooks.render.tap(t.tag, function (v) {
            r.clearFullScreen || r.renderQueue.push(v)
          })
      }),
      (t.prototype.clearRect = function (e, n, r, i, a, o) {
        e.clearRect(n, r, i, a), o && ((e.fillStyle = o), e.fillRect(n, r, i, a))
      }),
      (t.prototype.renderDisplayObject = function (e, n, r, i, a) {
        var o = e.nodeName,
          s = i[i.length - 1]
        s &&
          !(e.compareDocumentPosition(s) & Se.DOCUMENT_POSITION_CONTAINS) &&
          (n.restore(), i.pop())
        var c = this.context.styleRendererFactory[o],
          l = this.pathGeneratorFactory[o],
          u = e.parsedStyle.clipPath
        if (u) {
          this.applyWorldTransform(n, u)
          var f = this.pathGeneratorFactory[u.nodeName]
          f && (n.save(), i.push(e), n.beginPath(), f(n, u.parsedStyle), n.closePath(), n.clip())
        }
        c && (this.applyWorldTransform(n, e), n.save(), this.applyAttributesToContext(n, e)),
          l &&
            (n.beginPath(),
            l(n, e.parsedStyle),
            e.nodeName !== G.LINE &&
              e.nodeName !== G.PATH &&
              e.nodeName !== G.POLYLINE &&
              n.closePath()),
          c && (c.render(n, e.parsedStyle, e, r, this, a), n.restore()),
          (e.renderable.dirty = !1)
      }),
      (t.prototype.convertAABB2Rect = function (e) {
        var n = e.getMin(),
          r = e.getMax(),
          i = Math.floor(n[0]),
          a = Math.floor(n[1]),
          o = Math.ceil(r[0]),
          s = Math.ceil(r[1]),
          c = o - i,
          l = s - a
        return { x: i, y: a, width: c, height: l }
      }),
      (t.prototype.mergeDirtyAABBs = function (e) {
        var n = new me()
        return (
          e.forEach(function (r) {
            var i = r.getRenderBounds()
            n.add(i)
            var a = r.renderable.dirtyRenderBounds
            a && n.add(a)
          }),
          n
        )
      }),
      (t.prototype.searchDirtyObjects = function (e) {
        var n = N(e.getMin(), 2),
          r = n[0],
          i = n[1],
          a = N(e.getMax(), 2),
          o = a[0],
          s = a[1],
          c = this.rBush.search({ minX: r, minY: i, maxX: o, maxY: s })
        return c.map(function (l) {
          var u = l.displayObject
          return u
        })
      }),
      (t.prototype.saveDirtyAABB = function (e) {
        var n = e.renderable
        n.dirtyRenderBounds || (n.dirtyRenderBounds = new me())
        var r = e.getRenderBounds()
        r && n.dirtyRenderBounds.update(r.center, r.halfExtents)
      }),
      (t.prototype.applyAttributesToContext = function (e, n) {
        var r = n.parsedStyle,
          i = r.stroke,
          a = r.fill,
          o = r.opacity,
          s = r.lineDash,
          c = r.lineDashOffset
        s && e.setLineDash(s),
          nt(c) || (e.lineDashOffset = c),
          nt(o) || (e.globalAlpha *= o),
          !nt(i) && !Array.isArray(i) && !i.isNone && (e.strokeStyle = n.attributes.stroke),
          !nt(a) && !Array.isArray(a) && !a.isNone && (e.fillStyle = n.attributes.fill)
      }),
      (t.prototype.applyWorldTransform = function (e, n, r) {
        var i = 0,
          a = 0,
          o = (n.parsedStyle || {}).anchor,
          s = (o && o[0]) || 0,
          c = (o && o[1]) || 0
        if (s !== 0 || c !== 0) {
          var l = n.geometry.contentBounds,
            u = (l && l.halfExtents[0] * 2) || 0,
            f = (l && l.halfExtents[1] * 2) || 0
          ;(i = -(s * u)), (a = -(c * f))
        }
        r
          ? (Li(this.tmpMat4, n.getLocalTransform()),
            (this.vec3a[0] = i),
            (this.vec3a[1] = a),
            (this.vec3a[2] = 0),
            Gr(this.tmpMat4, this.tmpMat4, this.vec3a),
            Re(this.tmpMat4, r, this.tmpMat4),
            Re(this.tmpMat4, this.vpMatrix, this.tmpMat4))
          : (Li(this.tmpMat4, n.getWorldTransform()),
            (this.vec3a[0] = i),
            (this.vec3a[1] = a),
            (this.vec3a[2] = 0),
            Gr(this.tmpMat4, this.tmpMat4, this.vec3a),
            Re(this.tmpMat4, this.vpMatrix, this.tmpMat4)),
          e.setTransform(
            this.tmpMat4[0],
            this.tmpMat4[1],
            this.tmpMat4[4],
            this.tmpMat4[5],
            this.tmpMat4[12],
            this.tmpMat4[13]
          )
      }),
      (t.prototype.safeMergeAABB = function () {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n]
        var r = new me()
        return (
          e.forEach(function (i) {
            r.add(i)
          }),
          r
        )
      }),
      (t.tag = 'CanvasRenderer'),
      t
    )
  })(),
  hi = (function () {
    function t(e) {
      this.imagePool = e
    }
    return (
      (t.prototype.render = function (e, n, r, i, a, o) {
        var s = n.fill,
          c = n.fillRule,
          l = n.opacity,
          u = n.fillOpacity,
          f = n.stroke,
          h = n.strokeOpacity,
          d = n.lineWidth,
          p = n.lineCap,
          v = n.lineJoin,
          g = n.shadowType,
          y = n.shadowColor,
          m = n.shadowBlur,
          b = n.filter,
          x = n.miterLimit,
          w = !nt(s) && !s.isNone,
          O = !nt(f) && !f.isNone && d > 0,
          S = s.alpha === 0,
          _ = !!(b && b.length),
          M = !nt(y) && m > 0,
          E = r.nodeName,
          T = g === 'inner',
          C = O && M && (E === G.PATH || E === G.LINE || E === G.POLYLINE || S || T)
        w &&
          ((e.globalAlpha = l * u),
          C || El(r, e, M),
          this.fill(e, r, s, c, i, a, o),
          C || this.clearShadowAndFilter(e, _, M)),
          O &&
            ((e.globalAlpha = l * h),
            (e.lineWidth = d),
            nt(x) || (e.miterLimit = x),
            nt(p) || (e.lineCap = p),
            nt(v) || (e.lineJoin = v),
            C &&
              (T && (e.globalCompositeOperation = 'source-atop'),
              El(r, e, !0),
              T &&
                (this.stroke(e, r, f, i, a, o),
                (e.globalCompositeOperation = 'source-over'),
                this.clearShadowAndFilter(e, _, !0))),
            this.stroke(e, r, f, i, a, o))
      }),
      (t.prototype.clearShadowAndFilter = function (e, n, r) {
        if ((r && ((e.shadowColor = 'transparent'), (e.shadowBlur = 0)), n)) {
          var i = e.filter
          !nt(i) &&
            i.indexOf('drop-shadow') > -1 &&
            (e.filter = i.replace(/drop-shadow\([^)]*\)/, '').trim() || 'none')
        }
      }),
      (t.prototype.fill = function (e, n, r, i, a, o, s) {
        var c = this
        Array.isArray(r)
          ? r.forEach(function (l) {
              ;(e.fillStyle = c.getColor(l, n, e)), i ? e.fill(i) : e.fill()
            })
          : (rs(r) && (e.fillStyle = this.getPattern(r, n, e, a, o, s)), i ? e.fill(i) : e.fill())
      }),
      (t.prototype.stroke = function (e, n, r, i, a, o) {
        var s = this
        Array.isArray(r)
          ? r.forEach(function (c) {
              ;(e.strokeStyle = s.getColor(c, n, e)), e.stroke()
            })
          : (rs(r) && (e.strokeStyle = this.getPattern(r, n, e, i, a, o)), e.stroke())
      }),
      (t.prototype.getPattern = function (e, n, r, i, a, o) {
        var s, c
        if (e.image.nodeName === 'rect') {
          var l = e.image.parsedStyle,
            u = l.width,
            f = l.height
          c = i.contextService.getDPR()
          var h = i.config.offscreenCanvas
          ;(s = o.offscreenCanvasCreator.getOrCreateCanvas(h)),
            (s.width = u * c),
            (s.height = f * c)
          var d = o.offscreenCanvasCreator.getOrCreateContext(h),
            p = []
          e.image.forEach(function (g) {
            a.renderDisplayObject(g, d, i, p, o)
          }),
            p.forEach(function () {
              d.restore()
            })
        }
        var v = this.imagePool.getOrCreatePatternSync(e, r, s, c, function () {
          ;(n.renderable.dirty = !0), i.renderingService.dirtify()
        })
        return v
      }),
      (t.prototype.getColor = function (e, n, r) {
        var i
        if (e.type === tr.LinearGradient || e.type === tr.RadialGradient) {
          var a = n.getGeometryBounds(),
            o = (a && a.halfExtents[0] * 2) || 1,
            s = (a && a.halfExtents[1] * 2) || 1
          i = this.imagePool.getOrCreateGradient(
            z(z({ type: e.type }, e.value), { width: o, height: s }),
            r
          )
        }
        return i
      }),
      t
    )
  })()
function El(t, e, n) {
  var r = t.parsedStyle,
    i = r.filter,
    a = r.shadowColor,
    o = r.shadowBlur,
    s = r.shadowOffsetX,
    c = r.shadowOffsetY
  i && i.length && (e.filter = t.style.filter),
    n &&
      ((e.shadowColor = a.toString()),
      (e.shadowBlur = o || 0),
      (e.shadowOffsetX = s || 0),
      (e.shadowOffsetY = c || 0))
}
var $F = (function () {
    function t(e) {
      this.imagePool = e
    }
    return (
      (t.prototype.render = function (e, n, r) {
        var i = n.width,
          a = n.height,
          o = n.img,
          s = n.shadowColor,
          c = n.shadowBlur,
          l,
          u = i,
          f = a
        if (
          (ne(o)
            ? (l = this.imagePool.getImageSync(o))
            : (u || (u = o.width), f || (f = o.height), (l = o)),
          l)
        ) {
          var h = !nt(s) && c > 0
          El(r, e, h)
          try {
            e.drawImage(l, 0, 0, u, f)
          } catch {}
        }
      }),
      t
    )
  })(),
  BF = (function () {
    function t() {}
    return (
      (t.prototype.render = function (e, n, r, i, a, o) {
        var s = n,
          c = s.lineWidth,
          l = s.textAlign,
          u = s.textBaseline,
          f = s.lineJoin,
          h = s.miterLimit,
          d = s.letterSpacing,
          p = s.stroke,
          v = s.fill,
          g = s.fillOpacity,
          y = s.strokeOpacity,
          m = s.opacity,
          b = s.metrics,
          x = s.dx,
          w = s.dy,
          O = s.shadowColor,
          S = s.shadowBlur,
          _ = b.font,
          M = b.lines,
          E = b.height,
          T = b.lineHeight,
          C = b.lineMetrics
        ;(e.font = _), (e.lineWidth = c), (e.textAlign = l === 'middle' ? 'center' : l)
        var A = u
        !o.enableCSSParsing && A === 'alphabetic' && (A = 'bottom'),
          (e.lineJoin = f),
          nt(h) || (e.miterLimit = h)
        var P = 0
        u === 'middle'
          ? (P = -E / 2 - T / 2)
          : u === 'bottom' || u === 'alphabetic' || u === 'ideographic'
          ? (P = -E)
          : (u === 'top' || u === 'hanging') && (P = -T)
        var k = x || 0
        ;(P += w || 0),
          M.length === 1 &&
            (A === 'bottom'
              ? ((A = 'middle'), (P -= 0.5 * E))
              : A === 'top' && ((A = 'middle'), (P += 0.5 * E))),
          (e.textBaseline = A)
        var L = !nt(O) && S > 0
        El(r, e, L)
        for (var R = 0; R < M.length; R++) {
          var j = c / 2 + k
          ;(P += T),
            !nt(p) &&
              !p.isNone &&
              c &&
              this.drawLetterSpacing(e, M[R], C[R], l, j, P, d, g, y, m, !0),
            nt(v) || this.drawLetterSpacing(e, M[R], C[R], l, j, P, d, g, y, m)
        }
      }),
      (t.prototype.drawLetterSpacing = function (e, n, r, i, a, o, s, c, l, u, f) {
        if ((f === void 0 && (f = !1), s === 0)) {
          f ? this.strokeText(e, n, a, o, l) : this.fillText(e, n, a, o, c, u)
          return
        }
        var h = e.textAlign
        e.textAlign = 'left'
        var d = a
        i === 'center' || i === 'middle'
          ? (d = a - r.width / 2)
          : (i === 'right' || i === 'end') && (d = a - r.width)
        for (var p = Array.from(n), v = e.measureText(n).width, g = 0, y = 0; y < p.length; ++y) {
          var m = p[y]
          f ? this.strokeText(e, m, d, o, l) : this.fillText(e, m, d, o, c, u),
            (g = e.measureText(n.substring(y + 1)).width),
            (d += v - g + s),
            (v = g)
        }
        e.textAlign = h
      }),
      (t.prototype.fillText = function (e, n, r, i, a, o) {
        var s,
          c = !nt(a) && a !== 1
        c && ((s = e.globalAlpha), (e.globalAlpha = a * o)),
          e.fillText(n, r, i),
          c && (e.globalAlpha = s)
      }),
      (t.prototype.strokeText = function (e, n, r, i, a) {
        var o,
          s = !nt(a) && a !== 1
        s && ((o = e.globalAlpha), (e.globalAlpha = a)),
          e.strokeText(n, r, i),
          s && (e.globalAlpha = o)
      }),
      t
    )
  })()
;(function (t) {
  rt(e, t)
  function e() {
    return (t !== null && t.apply(this, arguments)) || this
  }
  return e
})(hi)
;(function (t) {
  rt(e, t)
  function e() {
    return (t !== null && t.apply(this, arguments)) || this
  }
  return e
})(hi)
;(function (t) {
  rt(e, t)
  function e() {
    return (t !== null && t.apply(this, arguments)) || this
  }
  return e
})(hi)
;(function (t) {
  rt(e, t)
  function e() {
    return (t !== null && t.apply(this, arguments)) || this
  }
  return e
})(hi)
;(function (t) {
  rt(e, t)
  function e() {
    return (t !== null && t.apply(this, arguments)) || this
  }
  return e
})(hi)
;(function (t) {
  rt(e, t)
  function e() {
    return (t !== null && t.apply(this, arguments)) || this
  }
  return e
})(hi)
;(function (t) {
  rt(e, t)
  function e() {
    return (t !== null && t.apply(this, arguments)) || this
  }
  return e
})(hi)
var FF = (function (t) {
    rt(e, t)
    function e(n) {
      n === void 0 && (n = {})
      var r = t.call(this) || this
      return (r.options = n), (r.name = 'canvas-renderer'), r
    }
    return (
      (e.prototype.init = function () {
        var n,
          r = z({ dirtyObjectNumThreshold: 500, dirtyObjectRatioThreshold: 0.8 }, this.options),
          i = this.context.imagePool,
          a = new hi(i),
          o =
            ((n = {}),
            (n[G.CIRCLE] = a),
            (n[G.ELLIPSE] = a),
            (n[G.RECT] = a),
            (n[G.IMAGE] = new $F(i)),
            (n[G.TEXT] = new BF()),
            (n[G.LINE] = a),
            (n[G.POLYLINE] = a),
            (n[G.POLYGON] = a),
            (n[G.PATH] = a),
            (n[G.GROUP] = void 0),
            (n[G.HTML] = void 0),
            (n[G.MESH] = void 0),
            n)
        ;(this.context.defaultStyleRendererFactory = o),
          (this.context.styleRendererFactory = o),
          this.addRenderingPlugin(new DF(r))
      }),
      (e.prototype.destroy = function () {
        this.removeAllRenderingPlugins(),
          delete this.context.defaultStyleRendererFactory,
          delete this.context.styleRendererFactory
      }),
      e
    )
  })(oi),
  zF = (function () {
    function t() {}
    return (
      (t.prototype.apply = function (e, n) {
        var r = this,
          i = e.renderingService,
          a = e.renderingContext,
          o = e.config
        this.context = e
        var s = a.root.ownerDocument.defaultView,
          c = function (O) {
            i.hooks.pointerMove.call(O)
          },
          l = function (O) {
            i.hooks.pointerUp.call(O)
          },
          u = function (O) {
            i.hooks.pointerDown.call(O)
          },
          f = function (O) {
            i.hooks.pointerOver.call(O)
          },
          h = function (O) {
            i.hooks.pointerOut.call(O)
          },
          d = function (O) {
            i.hooks.pointerCancel.call(O)
          },
          p = function (O) {
            i.hooks.pointerWheel.call(O)
          },
          v = function (O) {
            i.hooks.click.call(O)
          },
          g = function (O) {
            n.globalThis.document.addEventListener('pointermove', c, !0),
              O.addEventListener('pointerdown', u, !0),
              O.addEventListener('pointerleave', h, !0),
              O.addEventListener('pointerover', f, !0),
              n.globalThis.addEventListener('pointerup', l, !0),
              n.globalThis.addEventListener('pointercancel', d, !0)
          },
          y = function (O) {
            O.addEventListener('touchstart', u, !0),
              O.addEventListener('touchend', l, !0),
              O.addEventListener('touchmove', c, !0),
              O.addEventListener('touchcancel', d, !0)
          },
          m = function (O) {
            n.globalThis.document.addEventListener('mousemove', c, !0),
              O.addEventListener('mousedown', u, !0),
              O.addEventListener('mouseout', h, !0),
              O.addEventListener('mouseover', f, !0),
              n.globalThis.addEventListener('mouseup', l, !0)
          },
          b = function (O) {
            n.globalThis.document.removeEventListener('pointermove', c, !0),
              O.removeEventListener('pointerdown', u, !0),
              O.removeEventListener('pointerleave', h, !0),
              O.removeEventListener('pointerover', f, !0),
              n.globalThis.removeEventListener('pointerup', l, !0)
          },
          x = function (O) {
            O.removeEventListener('touchstart', u, !0),
              O.removeEventListener('touchend', l, !0),
              O.removeEventListener('touchmove', c, !0),
              O.removeEventListener('touchcancel', d, !0)
          },
          w = function (O) {
            n.globalThis.document.removeEventListener('mousemove', c, !0),
              O.removeEventListener('mousedown', u, !0),
              O.removeEventListener('mouseout', h, !0),
              O.removeEventListener('mouseover', f, !0),
              n.globalThis.removeEventListener('mouseup', l, !0)
          }
        i.hooks.init.tap(t.tag, function () {
          var O = r.context.contextService.getDomElement()
          n.globalThis.navigator.msPointerEnabled
            ? ((O.style.msContentZooming = 'none'), (O.style.msTouchAction = 'none'))
            : s.supportsPointerEvents && (O.style.touchAction = 'none'),
            s.supportsPointerEvents ? g(O) : m(O),
            s.supportsTouchEvents && y(O),
            o.useNativeClickEvent && O.addEventListener('click', v, !0),
            O.addEventListener('wheel', p, { passive: !0, capture: !0 })
        }),
          i.hooks.destroy.tap(t.tag, function () {
            var O = r.context.contextService.getDomElement()
            n.globalThis.navigator.msPointerEnabled
              ? ((O.style.msContentZooming = ''), (O.style.msTouchAction = ''))
              : s.supportsPointerEvents && (O.style.touchAction = ''),
              s.supportsPointerEvents ? b(O) : w(O),
              s.supportsTouchEvents && x(O),
              o.useNativeClickEvent && O.removeEventListener('click', v, !0),
              O.removeEventListener('wheel', p, !0)
          })
      }),
      (t.tag = 'DOMInteraction'),
      t
    )
  })(),
  GF = (function (t) {
    rt(e, t)
    function e() {
      var n = (t !== null && t.apply(this, arguments)) || this
      return (n.name = 'dom-interaction'), n
    }
    return (
      (e.prototype.init = function () {
        this.addRenderingPlugin(new zF())
      }),
      (e.prototype.destroy = function () {
        this.removeAllRenderingPlugins()
      }),
      e
    )
  })(oi),
  WF = 'g-canvas-camera',
  YF = (function () {
    function t() {
      this.displayObjectHTMLElementMap = new WeakMap()
    }
    return (
      (t.prototype.joinTransformMatrix = function (e) {
        return 'matrix('.concat([e[0], e[1], e[4], e[5], e[12], e[13]].join(','), ')')
      }),
      (t.prototype.apply = function (e, n) {
        var r = this,
          i = e.camera,
          a = e.renderingContext,
          o = e.renderingService
        this.context = e
        var s = a.root.ownerDocument.defaultView,
          c = function (p, v) {
            v.style.transform = r.joinTransformMatrix(p.getWorldTransform())
          },
          l = function (p) {
            var v = p.target
            if (v.nodeName === G.HTML) {
              r.$camera || (r.$camera = r.createCamera(i))
              var g = r.getOrCreateEl(v)
              if ((r.$camera.appendChild(g), n.enableCSSParsing)) {
                var y = v.ownerDocument.documentElement.attributes
                Object.keys(y).forEach(function (m) {
                  g.style[m] = y[m]
                })
              }
              Object.keys(v.attributes).forEach(function (m) {
                r.updateAttribute(m, v)
              }),
                c(v, g),
                r.context.nativeHTMLMap.set(g, v)
            }
          },
          u = function (p) {
            var v = p.target
            if (v.nodeName === G.HTML && r.$camera) {
              var g = r.getOrCreateEl(v)
              g && (g.remove(), r.context.nativeHTMLMap.delete(g))
            }
          },
          f = function (p) {
            var v = p.target
            if (v.nodeName === G.HTML) {
              var g = p.attrName
              r.updateAttribute(g, v)
            }
          },
          h = function (p) {
            var v = p.target
            if (v.nodeName === G.HTML) {
              var g = r.getOrCreateEl(v)
              c(v, g)
            }
          },
          d = function () {
            if (r.$camera) {
              var p = r.context.config,
                v = p.width,
                g = p.height
              ;(r.$camera.style.width = ''.concat(v || 0, 'px')),
                (r.$camera.style.height = ''.concat(g || 0, 'px'))
            }
          }
        o.hooks.init.tap(t.tag, function () {
          s.addEventListener(Je.RESIZE, d),
            s.addEventListener(dt.MOUNTED, l),
            s.addEventListener(dt.UNMOUNTED, u),
            s.addEventListener(dt.ATTR_MODIFIED, f),
            s.addEventListener(dt.BOUNDS_CHANGED, h)
        }),
          o.hooks.endFrame.tap(t.tag, function () {
            r.$camera &&
              a.renderReasons.has(Vr.CAMERA_CHANGED) &&
              (r.$camera.style.transform = r.joinTransformMatrix(i.getOrthoMatrix()))
          }),
          o.hooks.destroy.tap(t.tag, function () {
            r.$camera && r.$camera.remove(),
              s.removeEventListener(Je.RESIZE, d),
              s.removeEventListener(dt.MOUNTED, l),
              s.removeEventListener(dt.UNMOUNTED, u),
              s.removeEventListener(dt.ATTR_MODIFIED, f),
              s.removeEventListener(dt.BOUNDS_CHANGED, h)
          })
      }),
      (t.prototype.createCamera = function (e) {
        var n = this.context.config,
          r = n.document,
          i = n.width,
          a = n.height,
          o = this.context.contextService.getDomElement(),
          s = o.parentNode
        if (s) {
          var c = WF,
            l = s.querySelector('#' + c)
          if (!l) {
            var u = (r || document).createElement('div')
            ;(l = u),
              (u.id = c),
              (u.style.position = 'absolute'),
              (u.style.left = ''.concat(o.offsetLeft || 0, 'px')),
              (u.style.top = ''.concat(o.offsetTop || 0, 'px')),
              (u.style.transformOrigin = 'left top'),
              (u.style.transform = this.joinTransformMatrix(e.getOrthoMatrix())),
              (u.style.overflow = 'hidden'),
              (u.style.pointerEvents = 'none'),
              (u.style.width = ''.concat(i || 0, 'px')),
              (u.style.height = ''.concat(a || 0, 'px')),
              s.appendChild(u)
          }
          return l
        }
        return null
      }),
      (t.prototype.getOrCreateEl = function (e) {
        var n = this.context.config.document,
          r = this.displayObjectHTMLElementMap.get(e)
        return (
          r ||
            ((r = (n || document).createElement('div')),
            (e.parsedStyle.$el = r),
            this.displayObjectHTMLElementMap.set(e, r),
            e.id && (r.id = e.id),
            e.name && r.setAttribute('name', e.name),
            e.className && (r.className = e.className),
            (r.style.position = 'absolute'),
            (r.style.left = '0px'),
            (r.style.top = '0px'),
            (r.style['will-change'] = 'transform'),
            (r.style.transform = this.joinTransformMatrix(e.getWorldTransform()))),
          r
        )
      }),
      (t.prototype.updateAttribute = function (e, n) {
        var r = this.getOrCreateEl(n)
        switch (e) {
          case 'innerHTML':
            var i = n.parsedStyle.innerHTML
            ne(i) ? (r.innerHTML = i) : ((r.innerHTML = ''), r.appendChild(i))
            break
          case 'transformOrigin':
            var a = n.parsedStyle.transformOrigin
            r.style['transform-origin'] = ''.concat(a[0].value, ' ').concat(a[1].value)
            break
          case 'width':
            if (this.context.enableCSSParsing) {
              var o = n.computedStyleMap().get('width')
              r.style.width = o.toString()
            } else {
              var o = n.parsedStyle.width
              r.style.width = ve(o) ? ''.concat(o, 'px') : o.toString()
            }
            break
          case 'height':
            if (this.context.enableCSSParsing) {
              var s = n.computedStyleMap().get('height')
              r.style.height = s.toString()
            } else {
              var s = n.parsedStyle.height
              r.style.height = ve(s) ? ''.concat(s, 'px') : s.toString()
            }
            break
          case 'zIndex':
            var c = n.parsedStyle.zIndex
            r.style['z-index'] = ''.concat(c)
            break
          case 'visibility':
            var l = n.parsedStyle.visibility
            r.style.visibility = l
            break
          case 'pointerEvents':
            var u = n.parsedStyle.pointerEvents
            r.style.pointerEvents = u
            break
          case 'opacity':
            var f = n.parsedStyle.opacity
            r.style.opacity = ''.concat(f)
            break
          case 'fill':
            var h = n.parsedStyle.fill,
              d = ''
            ll(h)
              ? h.isNone
                ? (d = 'transparent')
                : (d = n.getAttribute('fill'))
              : Array.isArray(h)
              ? (d = n.getAttribute('fill'))
              : rs(h),
              (r.style.background = d)
            break
          case 'stroke':
            var p = n.parsedStyle.stroke,
              v = ''
            ll(p)
              ? p.isNone
                ? (v = 'transparent')
                : (v = n.getAttribute('stroke'))
              : Array.isArray(p)
              ? (v = n.getAttribute('stroke'))
              : rs(p),
              (r.style['border-color'] = v),
              (r.style['border-style'] = 'solid')
            break
          case 'lineWidth':
            var g = n.parsedStyle.lineWidth
            r.style['border-width'] = ''.concat(g || 0, 'px')
            break
          case 'lineDash':
            r.style['border-style'] = 'dashed'
            break
          case 'filter':
            var y = n.style.filter
            r.style.filter = y
            break
          default:
            e !== 'x' &&
              e !== 'y' &&
              !nt(n.style[e]) &&
              n.style[e] !== '' &&
              (r.style[e] = n.style[e])
        }
      }),
      (t.tag = 'HTMLRendering'),
      t
    )
  })(),
  HF = (function (t) {
    rt(e, t)
    function e() {
      var n = (t !== null && t.apply(this, arguments)) || this
      return (n.name = 'html-renderer'), n
    }
    return (
      (e.prototype.init = function () {
        this.addRenderingPlugin(new YF())
      }),
      (e.prototype.destroy = function () {
        this.removeAllRenderingPlugins()
      }),
      e
    )
  })(oi),
  VF = (function () {
    function t(e) {
      ;(this.canvasConfig = e),
        (this.imageCache = {}),
        (this.gradientCache = {}),
        (this.patternCache = {})
    }
    return (
      (t.prototype.getImageSync = function (e, n) {
        return (
          this.imageCache[e]
            ? n && n()
            : this.getOrCreateImage(e).then(function () {
                n && n()
              }),
          this.imageCache[e]
        )
      }),
      (t.prototype.getOrCreateImage = function (e) {
        var n = this
        if (this.imageCache[e]) return Promise.resolve(this.imageCache[e])
        var r = this.canvasConfig.createImage
        return new Promise(function (i, a) {
          var o
          r ? (o = r(e)) : Ls && (o = new window.Image()),
            o &&
              ((o.onload = function () {
                ;(n.imageCache[e] = o), i(o)
              }),
              (o.onerror = function (s) {
                a(s)
              }),
              (o.crossOrigin = 'Anonymous'),
              (o.src = e))
        })
      }),
      (t.prototype.getOrCreatePatternSync = function (e, n, r, i, a) {
        var o = this.generatePatternKey(e)
        if (o && this.patternCache[o]) return this.patternCache[o]
        var s = e.image,
          c = e.repetition,
          l = e.transform,
          u,
          f = !1
        ne(s) ? (u = this.getImageSync(s, a)) : r ? ((u = r), (f = !0)) : (u = s)
        var h = u && n.createPattern(u, c)
        if (h) {
          var d = void 0
          l ? (d = Op(fl(l), new Be({}))) : (d = ws(Nt())),
            f && Zc(d, d, [1 / i, 1 / i, 1]),
            h.setTransform({ a: d[0], b: d[1], c: d[4], d: d[5], e: d[12], f: d[13] })
        }
        return o && h && (this.patternCache[o] = h), h
      }),
      (t.prototype.getOrCreateGradient = function (e, n) {
        var r = this.generateGradientKey(e),
          i = e.type,
          a = e.steps,
          o = e.width,
          s = e.height,
          c = e.angle,
          l = e.cx,
          u = e.cy,
          f = e.size
        if (this.gradientCache[r]) return this.gradientCache[r]
        var h = null
        if (i === tr.LinearGradient) {
          var d = RL(o, s, c),
            p = d.x1,
            v = d.y1,
            g = d.x2,
            y = d.y2
          h = n.createLinearGradient(p, v, g, y)
        } else if (i === tr.RadialGradient) {
          var m = IL(o, s, l, u, f),
            b = m.x,
            x = m.y,
            w = m.r
          h = n.createRadialGradient(b, x, 0, b, x, w)
        }
        return (
          h &&
            (a.forEach(function (O) {
              var S = O.offset,
                _ = O.color
              S.unit === Z.kPercentage && (h == null || h.addColorStop(S.value / 100, _.toString()))
            }),
            (this.gradientCache[r] = h)),
          this.gradientCache[r]
        )
      }),
      (t.prototype.generateGradientKey = function (e) {
        var n = e.type,
          r = e.width,
          i = e.height,
          a = e.steps,
          o = e.angle,
          s = e.cx,
          c = e.cy,
          l = e.size
        return 'gradient-'
          .concat(n, '-')
          .concat((o == null ? void 0 : o.toString()) || 0, '-')
          .concat((s == null ? void 0 : s.toString()) || 0, '-')
          .concat((c == null ? void 0 : c.toString()) || 0, '-')
          .concat((l == null ? void 0 : l.toString()) || 0, '-')
          .concat(r, '-')
          .concat(i, '-')
          .concat(
            a
              .map(function (u) {
                var f = u.offset,
                  h = u.color
                return ''.concat(f).concat(h)
              })
              .join('-')
          )
      }),
      (t.prototype.generatePatternKey = function (e) {
        var n = e.image,
          r = e.repetition
        if (ne(n)) return 'pattern-'.concat(n, '-').concat(r)
        if (n.nodeName === 'rect') return 'pattern-'.concat(n.entity, '-').concat(r)
      }),
      t
    )
  })(),
  XF = (function () {
    function t() {}
    return (
      (t.prototype.apply = function (e) {
        var n = e.renderingService,
          r = e.renderingContext,
          i = e.imagePool,
          a = r.root.ownerDocument.defaultView,
          o = function (c) {
            var l = c.target,
              u = l.nodeName,
              f = l.attributes
            if (u === G.IMAGE) {
              var h = f.img
              ne(h) &&
                i.getImageSync(h, function () {
                  ;(l.renderable.dirty = !0), n.dirtify()
                })
            }
          },
          s = function (c) {
            var l = c.target,
              u = c.attrName,
              f = c.newValue
            l.nodeName === G.IMAGE &&
              u === 'img' &&
              ne(f) &&
              i.getOrCreateImage(f).then(function () {
                ;(l.renderable.dirty = !0), n.dirtify()
              })
          }
        n.hooks.init.tap(t.tag, function () {
          a.addEventListener(dt.MOUNTED, o), a.addEventListener(dt.ATTR_MODIFIED, s)
        }),
          n.hooks.destroy.tap(t.tag, function () {
            a.removeEventListener(dt.MOUNTED, o), a.removeEventListener(dt.ATTR_MODIFIED, s)
          })
      }),
      (t.tag = 'LoadImage'),
      t
    )
  })(),
  UF = (function (t) {
    rt(e, t)
    function e() {
      var n = (t !== null && t.apply(this, arguments)) || this
      return (n.name = 'image-loader'), n
    }
    return (
      (e.prototype.init = function () {
        ;(this.context.imagePool = new VF(this.context.config)), this.addRenderingPlugin(new XF())
      }),
      (e.prototype.destroy = function () {
        this.removeAllRenderingPlugins()
      }),
      e
    )
  })(oi),
  qF = (function () {
    function t(e) {
      ;(this.renderingContext = e.renderingContext), (this.canvasConfig = e.config)
    }
    return (
      (t.prototype.init = function () {
        var e = this.canvasConfig,
          n = e.container,
          r = e.canvas
        if (r)
          (this.$canvas = r),
            n && r.parentElement !== n && n.appendChild(r),
            (this.$container = r.parentElement),
            (this.canvasConfig.container = this.$container)
        else if (
          n &&
          ((this.$container = ne(n) ? document.getElementById(n) : n), this.$container)
        ) {
          var i = document.createElement('canvas')
          this.$container.appendChild(i),
            this.$container.style.position || (this.$container.style.position = 'relative'),
            (this.$canvas = i)
        }
        ;(this.context = this.$canvas.getContext('2d')),
          this.resize(this.canvasConfig.width, this.canvasConfig.height)
      }),
      (t.prototype.getContext = function () {
        return this.context
      }),
      (t.prototype.getDomElement = function () {
        return this.$canvas
      }),
      (t.prototype.getDPR = function () {
        return this.dpr
      }),
      (t.prototype.getBoundingClientRect = function () {
        if (this.$canvas.getBoundingClientRect) return this.$canvas.getBoundingClientRect()
      }),
      (t.prototype.destroy = function () {
        this.$container &&
          this.$canvas &&
          this.$canvas.parentNode &&
          this.$container.removeChild(this.$canvas)
      }),
      (t.prototype.resize = function (e, n) {
        var r = this.canvasConfig.devicePixelRatio,
          i = r || (Ls && window.devicePixelRatio) || 1
        ;(i = i >= 1 ? Math.ceil(i) : 1),
          (this.dpr = i),
          this.$canvas &&
            ((this.$canvas.width = this.dpr * e),
            (this.$canvas.height = this.dpr * n),
            zN(this.$canvas, e, n)),
          this.renderingContext.renderReasons.add(Vr.CAMERA_CHANGED)
      }),
      (t.prototype.applyCursorStyle = function (e) {
        this.$container && this.$container.style && (this.$container.style.cursor = e)
      }),
      (t.prototype.toDataURL = function (e) {
        return (
          e === void 0 && (e = {}),
          Ea(this, void 0, void 0, function () {
            var n, r
            return Ta(this, function (i) {
              return (n = e.type), (r = e.encoderOptions), [2, this.context.canvas.toDataURL(n, r)]
            })
          })
        )
      }),
      t
    )
  })(),
  KF = (function (t) {
    rt(e, t)
    function e() {
      var n = (t !== null && t.apply(this, arguments)) || this
      return (n.name = 'canvas-context-register'), n
    }
    return (
      (e.prototype.init = function () {
        this.context.ContextService = qF
      }),
      (e.prototype.destroy = function () {
        delete this.context.ContextService
      }),
      e
    )
  })(oi),
  zM = (function (t) {
    rt(e, t)
    function e(n) {
      var r = t.call(this, n) || this
      return (
        r.registerPlugin(new KF()),
        r.registerPlugin(new UF()),
        r.registerPlugin(new yF()),
        r.registerPlugin(new FF()),
        r.registerPlugin(new GF()),
        r.registerPlugin(new jF()),
        r.registerPlugin(new HF()),
        r
      )
    }
    return e
  })(iL),
  ZF = (function () {
    function t(e) {
      this.dragndropPluginOptions = e
    }
    return (
      (t.prototype.apply = function (e) {
        var n = this,
          r = e.renderingService,
          i = e.renderingContext,
          a = i.root.ownerDocument,
          o = a.defaultView,
          s = function (c) {
            var l = c.target,
              u = l === a,
              f =
                u && n.dragndropPluginOptions.isDocumentDraggable
                  ? a
                  : l.closest && l.closest('[draggable=true]')
            if (f) {
              var h = !1,
                d = c.timeStamp,
                p = [c.clientX, c.clientY],
                v = null,
                g = [c.clientX, c.clientY],
                y = function (b) {
                  return Ea(n, void 0, void 0, function () {
                    var x, w, O, S, _, M
                    return Ta(this, function (E) {
                      switch (E.label) {
                        case 0:
                          if (!h) {
                            if (
                              ((x = b.timeStamp - d),
                              (w = Ze([b.clientX, b.clientY], p)),
                              x <= this.dragndropPluginOptions.dragstartTimeThreshold ||
                                w <= this.dragndropPluginOptions.dragstartDistanceThreshold)
                            )
                              return [2]
                            ;(b.type = 'dragstart'), f.dispatchEvent(b), (h = !0)
                          }
                          return (
                            (b.type = 'drag'),
                            (b.dx = b.clientX - g[0]),
                            (b.dy = b.clientY - g[1]),
                            f.dispatchEvent(b),
                            (g = [b.clientX, b.clientY]),
                            u
                              ? [3, 2]
                              : ((O =
                                  this.dragndropPluginOptions.overlap === 'pointer'
                                    ? [b.canvasX, b.canvasY]
                                    : l.getBounds().center),
                                [4, a.elementsFromPoint(O[0], O[1])])
                          )
                        case 1:
                          ;(S = E.sent()),
                            (_ = S[S.indexOf(l) + 1]),
                            (M =
                              (_ == null ? void 0 : _.closest('[droppable=true]')) ||
                              (this.dragndropPluginOptions.isDocumentDroppable ? a : null)),
                            v !== M &&
                              (v && ((b.type = 'dragleave'), (b.target = v), v.dispatchEvent(b)),
                              M && ((b.type = 'dragenter'), (b.target = M), M.dispatchEvent(b)),
                              (v = M),
                              v && ((b.type = 'dragover'), (b.target = v), v.dispatchEvent(b))),
                            (E.label = 2)
                        case 2:
                          return [2]
                      }
                    })
                  })
                }
              o.addEventListener('pointermove', y)
              var m = function (b) {
                if (h) {
                  b.detail = { preventClick: !0 }
                  var x = b.clone()
                  v && ((x.type = 'drop'), (x.target = v), v.dispatchEvent(x)),
                    (x.type = 'dragend'),
                    f.dispatchEvent(x),
                    (h = !1)
                }
                o.removeEventListener('pointermove', y)
              }
              l.addEventListener('pointerup', m, { once: !0 }),
                l.addEventListener('pointerupoutside', m, { once: !0 })
            }
          }
        r.hooks.init.tap(t.tag, function () {
          o.addEventListener('pointerdown', s)
        }),
          r.hooks.destroy.tap(t.tag, function () {
            o.removeEventListener('pointerdown', s)
          })
      }),
      (t.tag = 'Dragndrop'),
      t
    )
  })(),
  GM = (function (t) {
    rt(e, t)
    function e(n) {
      n === void 0 && (n = {})
      var r = t.call(this) || this
      return (r.options = n), (r.name = 'dragndrop'), r
    }
    return (
      (e.prototype.init = function () {
        this.addRenderingPlugin(
          new ZF(
            z(
              {
                overlap: 'pointer',
                isDocumentDraggable: !1,
                isDocumentDroppable: !1,
                dragstartDistanceThreshold: 0,
                dragstartTimeThreshold: 0
              },
              this.options
            )
          )
        )
      }),
      (e.prototype.destroy = function () {
        this.removeAllRenderingPlugins()
      }),
      (e.prototype.setOptions = function (n) {
        Object.assign(this.plugins[0].dragndropPluginOptions, n)
      }),
      e
    )
  })(oi),
  QF = '*',
  WM = (function () {
    function t() {
      this._events = {}
    }
    return (
      (t.prototype.on = function (e, n, r) {
        return (
          this._events[e] || (this._events[e] = []),
          this._events[e].push({ callback: n, once: !!r }),
          this
        )
      }),
      (t.prototype.once = function (e, n) {
        return this.on(e, n, !0)
      }),
      (t.prototype.emit = function (e) {
        for (var n = this, r = [], i = 1; i < arguments.length; i++) r[i - 1] = arguments[i]
        var a = this._events[e] || [],
          o = this._events[QF] || [],
          s = function (c) {
            for (var l = c.length, u = 0; u < l; u++)
              if (c[u]) {
                var f = c[u],
                  h = f.callback,
                  d = f.once
                d && (c.splice(u, 1), c.length === 0 && delete n._events[e], l--, u--),
                  h.apply(n, r)
              }
          }
        s(a), s(o)
      }),
      (t.prototype.off = function (e, n) {
        if (!e) this._events = {}
        else if (!n) delete this._events[e]
        else {
          for (var r = this._events[e] || [], i = r.length, a = 0; a < i; a++)
            r[a].callback === n && (r.splice(a, 1), i--, a--)
          r.length === 0 && delete this._events[e]
        }
        return this
      }),
      (t.prototype.getEvents = function () {
        return this._events
      }),
      t
    )
  })()
const Lt = {
    BEFORE_RENDER: 'beforerender',
    AFTER_RENDER: 'afterrender',
    BEFORE_PAINT: 'beforepaint',
    AFTER_PAINT: 'afterpaint',
    BEFORE_CHANGE_DATA: 'beforechangedata',
    AFTER_CHANGE_DATA: 'afterchangedata',
    BEFORE_CLEAR: 'beforeclear',
    AFTER_CLEAR: 'afterclear',
    BEFORE_DESTROY: 'beforedestroy',
    AFTER_DESTROY: 'afterdestroy',
    BEFORE_CHANGE_SIZE: 'beforechangesize',
    AFTER_CHANGE_SIZE: 'afterchangesize',
    POINTER_TAP: 'pointertap',
    POINTER_DOWN: 'pointerdown',
    POINTER_UP: 'pointerup',
    POINTER_OVER: 'pointerover',
    POINTER_OUT: 'pointerout',
    POINTER_MOVE: 'pointermove',
    POINTER_ENTER: 'pointerenter',
    POINTER_LEAVE: 'pointerleave',
    POINTER_UPOUTSIDE: 'pointerupoutside',
    DRAG_START: 'dragstart',
    DRAG: 'drag',
    DRAG_END: 'dragend',
    DRAG_ENTER: 'dragenter',
    DRAG_LEAVE: 'dragleave',
    DRAG_OVER: 'dragover',
    DROP: 'DROP',
    CLICK: 'click',
    DBLCLICK: 'dblclick'
  },
  JF = [
    [
      'legendCategory',
      [
        [
          ['color', 'discrete'],
          ['opacity', 'discrete'],
          ['shape', 'discrete'],
          ['size', 'constant']
        ],
        [
          ['color', 'discrete'],
          ['opacity', 'constant'],
          ['shape', 'discrete'],
          ['size', 'constant']
        ],
        [
          ['color', 'discrete'],
          ['opacity', 'discrete'],
          ['shape', 'constant'],
          ['size', 'constant']
        ],
        [
          ['color', 'discrete'],
          ['opacity', 'constant'],
          ['shape', 'constant'],
          ['size', 'constant']
        ],
        [
          ['color', 'constant'],
          ['opacity', 'discrete'],
          ['shape', 'discrete'],
          ['size', 'constant']
        ],
        [
          ['color', 'constant'],
          ['opacity', 'constant'],
          ['shape', 'discrete'],
          ['size', 'constant']
        ],
        [
          ['color', 'constant'],
          ['opacity', 'discrete'],
          ['shape', 'constant'],
          ['size', 'constant']
        ],
        [
          ['color', 'discrete'],
          ['shape', 'discrete'],
          ['size', 'constant']
        ],
        [
          ['color', 'discrete'],
          ['opacity', 'discrete'],
          ['shape', 'discrete']
        ],
        [
          ['color', 'discrete'],
          ['opacity', 'discrete'],
          ['size', 'constant']
        ],
        [
          ['color', 'discrete'],
          ['opacity', 'constant'],
          ['shape', 'discrete']
        ],
        [
          ['color', 'discrete'],
          ['opacity', 'constant'],
          ['size', 'constant']
        ],
        [
          ['color', 'discrete'],
          ['shape', 'constant'],
          ['size', 'constant']
        ],
        [
          ['color', 'discrete'],
          ['opacity', 'discrete'],
          ['shape', 'constant']
        ],
        [
          ['color', 'discrete'],
          ['opacity', 'constant'],
          ['shape', 'constant']
        ],
        [
          ['color', 'constant'],
          ['shape', 'discrete'],
          ['size', 'constant']
        ],
        [
          ['color', 'constant'],
          ['opacity', 'discrete'],
          ['shape', 'discrete']
        ],
        [
          ['color', 'constant'],
          ['opacity', 'discrete'],
          ['size', 'constant']
        ],
        [
          ['color', 'constant'],
          ['opacity', 'constant'],
          ['shape', 'discrete']
        ],
        [
          ['color', 'constant'],
          ['opacity', 'discrete'],
          ['shape', 'constant']
        ],
        [
          ['color', 'discrete'],
          ['shape', 'discrete']
        ],
        [
          ['color', 'discrete'],
          ['size', 'constant']
        ],
        [
          ['color', 'discrete'],
          ['opacity', 'discrete']
        ],
        [
          ['color', 'discrete'],
          ['opacity', 'constant']
        ],
        [
          ['color', 'discrete'],
          ['shape', 'constant']
        ],
        [
          ['color', 'constant'],
          ['shape', 'discrete']
        ],
        [
          ['color', 'constant'],
          ['size', 'constant']
        ],
        [
          ['color', 'constant'],
          ['opacity', 'discrete']
        ],
        [['color', 'discrete']]
      ]
    ],
    [
      'legendContinuousSize',
      [
        [
          ['color', 'continuous'],
          ['opacity', 'continuous'],
          ['size', 'continuous']
        ],
        [
          ['color', 'constant'],
          ['opacity', 'continuous'],
          ['size', 'continuous']
        ],
        [
          ['color', 'continuous'],
          ['size', 'continuous']
        ],
        [
          ['color', 'constant'],
          ['size', 'continuous']
        ],
        [
          ['size', 'continuous'],
          ['opacity', 'continuous']
        ],
        [['size', 'continuous']]
      ]
    ],
    [
      'legendContinuousBlockSize',
      [
        [
          ['color', 'distribution'],
          ['opacity', 'distribution'],
          ['size', 'distribution']
        ],
        [
          ['color', 'distribution'],
          ['size', 'distribution']
        ]
      ]
    ],
    [
      'legendContinuousBlock',
      [
        [
          ['color', 'distribution'],
          ['opacity', 'continuous']
        ],
        [['color', 'distribution']]
      ]
    ],
    [
      'legendContinuous',
      [
        [
          ['color', 'continuous'],
          ['opacity', 'continuous']
        ],
        [['color', 'continuous']],
        [['opacity', 'continuous']]
      ]
    ]
  ]
function YM(t) {
  for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n]
  return t
    ? e.reduce(function (r, i) {
        return function (a) {
          return i(r(a))
        }
      }, t)
    : Wn
}
function HM(t) {
  return t instanceof Float32Array || t instanceof Array
}
var VM =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  XM =
    (globalThis && globalThis.__spreadArray) ||
    function (t, e, n) {
      if (n || arguments.length === 2)
        for (var r = 0, i = e.length, a; r < i; r++)
          (a || !(r in e)) && (a || (a = Array.prototype.slice.call(e, 0, r)), (a[r] = e[r]))
      return t.concat(a || Array.prototype.slice.call(e))
    }
function tz(t) {
  return function (e) {
    for (var n = [], r = 0; r < e.length - 1; r += 2) {
      var i = [e[r], e[r + 1]],
        a = t(i)
      n.push.apply(n, XM([], VM(a), !1))
    }
    return n
  }
}
function ez(t) {
  return function (e) {
    for (var n = [], r = 0; r < e.length - 1; r += 3) {
      var i = [e[r], e[r + 1], e[r + 2]],
        a = t(i)
      n.push.apply(n, XM([], VM(a), !1))
    }
    return n
  }
}
function UM(t, e, n) {
  for (; t < e; ) t += Math.PI * 2
  for (; t > n; ) t -= Math.PI * 2
  return t
}
var nz =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  rz = function (t, e, n, r, i) {
    var a = nz(t, 2),
      o = a[0],
      s = a[1],
      c = Ua()
    return HP(c, [o, s])
  },
  Sm =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  iz = function (t, e, n, r, i) {
    var a = new Ft({ range: [e, e + r] }),
      o = new Ft({ range: [n, n + i] })
    return {
      transform: function (s) {
        var c = Sm(s, 2),
          l = c[0],
          u = c[1]
        return [a.map(l), o.map(u)]
      },
      untransform: function (s) {
        var c = Sm(s, 2),
          l = c[0],
          u = c[1]
        return [a.invert(l), o.invert(u)]
      }
    }
  },
  az =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  oz = function (t, e, n, r, i) {
    var a = az(t, 1),
      o = a[0]
    return o(e, n, r, i)
  },
  sz =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  cz = function (t, e, n, r, i) {
    var a = sz(t, 1),
      o = a[0]
    return o
  },
  Lf =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  lz = function (t, e, n, r, i) {
    var a = Lf(t, 4),
      o = a[0],
      s = a[1],
      c = a[2],
      l = a[3],
      u = new Ft({ range: [c, l] }),
      f = new Ft({ range: [o, s] }),
      h = i / r,
      d = h > 1 ? 1 : h,
      p = h > 1 ? 1 / h : 1
    return {
      transform: function (v) {
        var g = Lf(v, 2),
          y = g[0],
          m = g[1],
          b = f.map(y),
          x = u.map(m),
          w = x * Math.cos(b) * d,
          O = x * Math.sin(b) * p,
          S = w * 0.5 + 0.5,
          _ = O * 0.5 + 0.5
        return [S, _]
      },
      untransform: function (v) {
        var g = Lf(v, 2),
          y = g[0],
          m = g[1],
          b = ((y - 0.5) * 2) / d,
          x = ((m - 0.5) * 2) / p,
          w = Math.sqrt(Math.pow(b, 2) + Math.pow(x, 2)),
          O = Math.atan2(x, b),
          S = UM(O, o, s),
          _ = f.invert(S),
          M = u.invert(w)
        return [_, M]
      }
    }
  },
  _m =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  uz = function (t, e, n, r, i) {
    return {
      transform: function (a) {
        var o = _m(a, 2),
          s = o[0],
          c = o[1]
        return [c, s]
      },
      untransform: function (a) {
        var o = _m(a, 2),
          s = o[0],
          c = o[1]
        return [c, s]
      }
    }
  },
  fz =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  ku = function (t, e, n, r, i) {
    var a = fz(t, 2),
      o = a[0],
      s = a[1],
      c = Ua()
    return XP(c, [o, s])
  },
  p0 =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  v0 =
    (globalThis && globalThis.__spreadArray) ||
    function (t, e, n) {
      if (n || arguments.length === 2)
        for (var r = 0, i = e.length, a; r < i; r++)
          (a || !(r in e)) && (a || (a = Array.prototype.slice.call(e, 0, r)), (a[r] = e[r]))
      return t.concat(a || Array.prototype.slice.call(e))
    },
  hz = function (t) {
    for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n]
    return ku.apply(void 0, v0([[-1, -1]], p0(e), !1))
  },
  dz = function (t) {
    for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n]
    return ku.apply(void 0, v0([[-1, 1]], p0(e), !1))
  },
  pz = function (t) {
    for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n]
    return ku.apply(void 0, v0([[1, -1]], p0(e), !1))
  },
  vz =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  gz = function (t, e, n, r, i) {
    var a = vz(t, 1),
      o = a[0],
      s = Ua()
    return VP(s, o)
  },
  Nf =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  yz = function (t, e, n, r, i) {
    var a = Nf(t, 4),
      o = a[0],
      s = a[1],
      c = a[2],
      l = a[3],
      u = (s - 0) / (2 * Math.PI) + 1,
      f = (l - c) / u,
      h = f / (Math.PI * 2),
      d = new Ft({ range: [c, c + f * 0.99] }),
      p = new Ft({ range: [o, s] }),
      v = i / r,
      g = v > 1 ? 1 : v,
      y = v > 1 ? 1 / v : 1
    return {
      transform: function (m) {
        var b = Nf(m, 2),
          x = b[0],
          w = b[1],
          O = p.map(x),
          S = d.map(w),
          _ = Math.cos(O) * (h * O + S) * g,
          M = Math.sin(O) * (h * O + S) * y,
          E = _ * 0.5 + 0.5,
          T = M * 0.5 + 0.5
        return [E, T]
      },
      untransform: function (m) {
        var b = Nf(m, 2),
          x = b[0],
          w = b[1],
          O = ((x - 0.5) * 2) / g,
          S = ((w - 0.5) * 2) / y,
          _ = Math.sqrt(Math.pow(O, 2) + Math.pow(S, 2)),
          M = Math.atan2(S, O) + Math.floor(_ / f) * Math.PI * 2,
          E = UM(M, o, s),
          T = _ - h * E,
          C = p.invert(E),
          A = d.invert(T)
        return [C, A]
      }
    }
  },
  mz =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  bz = function (t, e, n, r, i) {
    var a = mz(t, 4),
      o = a[0],
      s = a[1],
      c = a[2],
      l = a[3],
      u = new Ft({ range: [c, l] })
    return {
      transform: function (f) {
        for (
          var h = [],
            d = f.length,
            p = new _x({
              domain: new Array(d).fill(0).map(function (b, x) {
                return x
              }),
              range: [o, s]
            }),
            v = 0;
          v < d;
          v++
        ) {
          var g = f[v],
            y = p.map(v),
            m = u.map(g)
          h.push(y, m)
        }
        return h
      },
      untransform: function (f) {
        for (var h = [], d = 0; d < f.length; d += 2) {
          var p = f[d + 1]
          h.push(u.invert(p))
        }
        return h
      }
    }
  },
  wa =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    }
function qM(t) {
  return 1 / Math.tan(t)
}
var xz = function (t, e, n, r, i) {
    var a = wa(t, 1),
      o = a[0],
      s = qM(o)
    return {
      transform: function (c) {
        var l = wa(c, 2),
          u = l[0],
          f = l[1],
          h = u + f * s
        return [h, f]
      },
      untransform: function (c) {
        var l = wa(c, 2),
          u = l[0],
          f = l[1],
          h = u - f * s
        return [h, f]
      }
    }
  },
  wz = function (t, e, n, r, i) {
    var a = wa(t, 1),
      o = a[0],
      s = qM(o)
    return {
      transform: function (c) {
        var l = wa(c, 2),
          u = l[0],
          f = l[1],
          h = f + u * s
        return [u, h]
      },
      untransform: function (c) {
        var l = wa(c, 2),
          u = l[0],
          f = l[1],
          h = f - u * s
        return [u, h]
      }
    }
  },
  An =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    }
function fs(t, e, n, r, i) {
  var a = t < e,
    o = (a ? e - r : i - e) || i - r,
    s = a ? -1 : 1
  return (s * o * (n + 1)) / (n + o / ((t - e) * s)) + e
}
function hs(t, e, n, r, i) {
  var a = t < e,
    o = (a ? e - r : i - e) || i - r,
    s = a ? -1 : 1
  return o / ((o * (n + 1)) / (t - e) - n * s) + e
}
function Tl(t, e, n) {
  if (!n) return t
  var r = new Ft({ range: [0, 1], domain: [0, e] })
  return r.map(t)
}
var Oz = function (t, e, n, r, i) {
    var a = An(t, 3),
      o = a[0],
      s = a[1],
      c = a[2],
      l = c === void 0 ? !1 : c,
      u = Tl(o, r, l)
    return {
      transform: function (f) {
        var h = An(f, 2),
          d = h[0],
          p = h[1],
          v = fs(d, u, s, 0, 1)
        return [v, p]
      },
      untransform: function (f) {
        var h = An(f, 2),
          d = h[0],
          p = h[1],
          v = hs(d, u, s, 0, 1)
        return [v, p]
      }
    }
  },
  Sz = function (t, e, n, r, i) {
    var a = An(t, 3),
      o = a[0],
      s = a[1],
      c = a[2],
      l = c === void 0 ? !1 : c,
      u = Tl(o, i, l)
    return {
      transform: function (f) {
        var h = An(f, 2),
          d = h[0],
          p = h[1],
          v = fs(p, u, s, 0, 1)
        return [d, v]
      },
      untransform: function (f) {
        var h = An(f, 2),
          d = h[0],
          p = h[1],
          v = hs(p, u, s, 0, 1)
        return [d, v]
      }
    }
  },
  _z = function (t, e, n, r, i) {
    var a = An(t, 5),
      o = a[0],
      s = a[1],
      c = a[2],
      l = a[3],
      u = a[4],
      f = u === void 0 ? !1 : u,
      h = Tl(o, r, f),
      d = Tl(s, i, f)
    return {
      transform: function (p) {
        var v = An(p, 2),
          g = v[0],
          y = v[1],
          m = fs(g, h, c, 0, 1),
          b = fs(y, d, l, 0, 1)
        return [m, b]
      },
      untransform: function (p) {
        var v = An(p, 2),
          g = v[0],
          y = v[1],
          m = hs(g, h, c, 0, 1),
          b = hs(y, d, l, 0, 1)
        return [m, b]
      }
    }
  },
  Mz = function (t, e, n, r, i) {
    var a = An(t, 5),
      o = a[0],
      s = a[1],
      c = a[2],
      l = a[3],
      u = a[4],
      f = u === void 0 ? !1 : u,
      h = new Ft({ range: [0, r] }),
      d = new Ft({ range: [0, i] }),
      p = f ? o : h.map(o),
      v = f ? s : d.map(s)
    return {
      transform: function (g) {
        var y = An(g, 2),
          m = y[0],
          b = y[1],
          x = h.map(m) - p,
          w = d.map(b) - v,
          O = Math.sqrt(x * x + w * w)
        if (O > c) return [m, b]
        var S = fs(O, 0, l, 0, c),
          _ = Math.atan2(w, x),
          M = p + S * Math.cos(_),
          E = v + S * Math.sin(_)
        return [h.invert(M), d.invert(E)]
      },
      untransform: function (g) {
        var y = An(g, 2),
          m = y[0],
          b = y[1],
          x = h.map(m) - p,
          w = d.map(b) - v,
          O = Math.sqrt(x * x + w * w)
        if (O > c) return [m, b]
        var S = hs(O, 0, l, 0, c),
          _ = Math.atan2(w, x),
          M = p + S * Math.cos(_),
          E = v + S * Math.sin(_)
        return [h.invert(M), d.invert(E)]
      }
    }
  },
  Mm =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  Ez = function (t, e, n, r, i, a, o) {
    var s = new Ft({ range: [e, e + i] }),
      c = new Ft({ range: [n, n + a] }),
      l = new Ft({ range: [r, r + o] })
    return {
      transform: function (u) {
        var f = Mm(u, 3),
          h = f[0],
          d = f[1],
          p = f[2]
        return [s.map(h), c.map(d), l.map(p)]
      },
      untransform: function (u) {
        var f = Mm(u, 3),
          h = f[0],
          d = f[1],
          p = f[2]
        return [s.invert(h), c.invert(d), l.invert(p)]
      }
    }
  },
  Tz =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  Pz = function (t, e, n, r, i, a, o) {
    var s = Tz(t, 3),
      c = s[0],
      l = s[1],
      u = s[2]
    return Bd(Nt(), [c, l, u])
  },
  Az =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  kz = function (t, e, n, r, i, a, o) {
    var s = Az(t, 3),
      c = s[0],
      l = s[1],
      u = s[2]
    return Fd(Nt(), [c, l, u])
  },
  ta =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  ea =
    (globalThis && globalThis.__spreadArray) ||
    function (t, e, n) {
      if (n || arguments.length === 2)
        for (var r = 0, i = e.length, a; r < i; r++)
          (a || !(r in e)) && (a || (a = Array.prototype.slice.call(e, 0, r)), (a[r] = e[r]))
      return t.concat(a || Array.prototype.slice.call(e))
    },
  Cz =
    (globalThis && globalThis.__values) ||
    function (t) {
      var e = typeof Symbol == 'function' && Symbol.iterator,
        n = e && t[e],
        r = 0
      if (n) return n.call(t)
      if (t && typeof t.length == 'number')
        return {
          next: function () {
            return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          }
        }
      throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
    },
  Lz = (function () {
    function t(e) {
      ;(this.options = { x: 0, y: 0, width: 300, height: 150, transformations: [] }),
        (this.transformers = {
          cartesian: iz,
          translate: rz,
          custom: oz,
          matrix: cz,
          polar: lz,
          transpose: uz,
          scale: ku,
          'shear.x': xz,
          'shear.y': wz,
          reflect: hz,
          'reflect.x': dz,
          'reflect.y': pz,
          rotate: gz,
          helix: yz,
          parallel: bz,
          fisheye: _z,
          'fisheye.x': Oz,
          'fisheye.y': Sz,
          'fisheye.circular': Mz
        }),
        this.update(e)
    }
    return (
      (t.prototype.update = function (e) {
        ;(this.options = il({}, this.options, e)), this.recoordinate()
      }),
      (t.prototype.clone = function () {
        return new t(this.options)
      }),
      (t.prototype.getOptions = function () {
        return this.options
      }),
      (t.prototype.clear = function () {
        this.update({ transformations: [] })
      }),
      (t.prototype.getSize = function () {
        var e = this.options,
          n = e.width,
          r = e.height
        return [n, r]
      }),
      (t.prototype.getCenter = function () {
        var e = this.options,
          n = e.x,
          r = e.y,
          i = e.width,
          a = e.height
        return [(n * 2 + i) / 2, (r * 2 + a) / 2]
      }),
      (t.prototype.transform = function () {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n]
        var r = this.options.transformations
        return (
          this.update({ transformations: ea(ea([], ta(r), !1), [ea([], ta(e), !1)], !1) }), this
        )
      }),
      (t.prototype.map = function (e) {
        return this.output(e)
      }),
      (t.prototype.invert = function (e) {
        return this.input(e)
      }),
      (t.prototype.recoordinate = function () {
        ;(this.output = this.compose()), (this.input = this.compose(!0))
      }),
      (t.prototype.compose = function (e) {
        var n, r
        e === void 0 && (e = !1)
        var i = e
            ? ea([], ta(this.options.transformations), !1).reverse()
            : this.options.transformations,
          a = e
            ? function (S) {
                return S.untransform
              }
            : function (S) {
                return S.transform
              },
          o = [],
          s = [],
          c = function (S, _) {
            return _ === void 0 && (_ = !0), s.push(_ ? tz(S) : S)
          }
        try {
          for (var l = Cz(i), u = l.next(); !u.done; u = l.next()) {
            var f = ta(u.value),
              h = f[0],
              d = f.slice(1),
              p = this.transformers[h]
            if (p) {
              var v = this.options,
                g = v.x,
                y = v.y,
                m = v.width,
                b = v.height,
                x = p(ea([], ta(d), !1), g, y, m, b)
              if (HM(x)) o.push(x)
              else {
                if (o.length) {
                  var w = this.createMatrixTransform(o, e)
                  c(w), o.splice(0, o.length)
                }
                var O = a(x) || Wn
                c(O, h !== 'parallel')
              }
            }
          }
        } catch (S) {
          n = { error: S }
        } finally {
          try {
            u && !u.done && (r = l.return) && r.call(l)
          } finally {
            if (n) throw n.error
          }
        }
        if (o.length) {
          var O = this.createMatrixTransform(o, e)
          c(O)
        }
        return YM.apply(void 0, ea([], ta(s), !1))
      }),
      (t.prototype.createMatrixTransform = function (e, n) {
        var r = Ua()
        return (
          n && e.reverse(),
          e.forEach(function (i) {
            return UP(r, r, i)
          }),
          n && WP(r, zP(r)),
          function (i) {
            var a = [i[0], i[1], 1]
            return gb(a, a, r), [a[0], a[1]]
          }
        )
      }),
      t
    )
  })(),
  na =
    (globalThis && globalThis.__read) ||
    function (t, e) {
      var n = typeof Symbol == 'function' && t[Symbol.iterator]
      if (!n) return t
      var r = n.call(t),
        i,
        a = [],
        o
      try {
        for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) a.push(i.value)
      } catch (s) {
        o = { error: s }
      } finally {
        try {
          i && !i.done && (n = r.return) && n.call(r)
        } finally {
          if (o) throw o.error
        }
      }
      return a
    },
  ra =
    (globalThis && globalThis.__spreadArray) ||
    function (t, e, n) {
      if (n || arguments.length === 2)
        for (var r = 0, i = e.length, a; r < i; r++)
          (a || !(r in e)) && (a || (a = Array.prototype.slice.call(e, 0, r)), (a[r] = e[r]))
      return t.concat(a || Array.prototype.slice.call(e))
    },
  Nz =
    (globalThis && globalThis.__values) ||
    function (t) {
      var e = typeof Symbol == 'function' && Symbol.iterator,
        n = e && t[e],
        r = 0
      if (n) return n.call(t)
      if (t && typeof t.length == 'number')
        return {
          next: function () {
            return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t }
          }
        }
      throw new TypeError(e ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
    },
  Rz = (function () {
    function t(e) {
      ;(this.options = {
        x: 0,
        y: 0,
        z: 0,
        width: 300,
        height: 150,
        depth: 150,
        transformations: []
      }),
        (this.transformers = { cartesian3D: Ez, translate3D: Pz, scale3D: kz }),
        this.update(e)
    }
    return (
      (t.prototype.update = function (e) {
        ;(this.options = il({}, this.options, e)), this.recoordinate()
      }),
      (t.prototype.clone = function () {
        return new t(this.options)
      }),
      (t.prototype.getOptions = function () {
        return this.options
      }),
      (t.prototype.clear = function () {
        this.update({ transformations: [] })
      }),
      (t.prototype.getSize = function () {
        var e = this.options,
          n = e.width,
          r = e.height,
          i = e.depth
        return [n, r, i]
      }),
      (t.prototype.getCenter = function () {
        var e = this.options,
          n = e.x,
          r = e.y,
          i = e.z,
          a = e.width,
          o = e.height,
          s = e.depth
        return [(n * 2 + a) / 2, (r * 2 + o) / 2, (i * 2 + s) / 2]
      }),
      (t.prototype.transform = function () {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n]
        var r = this.options.transformations
        return (
          this.update({ transformations: ra(ra([], na(r), !1), [ra([], na(e), !1)], !1) }), this
        )
      }),
      (t.prototype.map = function (e) {
        return this.output(e)
      }),
      (t.prototype.invert = function (e) {
        return this.input(e)
      }),
      (t.prototype.recoordinate = function () {
        ;(this.output = this.compose()), (this.input = this.compose(!0))
      }),
      (t.prototype.compose = function (e) {
        var n, r
        e === void 0 && (e = !1)
        var i = e
            ? ra([], na(this.options.transformations), !1).reverse()
            : this.options.transformations,
          a = e
            ? function (M) {
                return M.untransform
              }
            : function (M) {
                return M.transform
              },
          o = [],
          s = [],
          c = function (M, E) {
            return E === void 0 && (E = !0), s.push(E ? ez(M) : M)
          }
        try {
          for (var l = Nz(i), u = l.next(); !u.done; u = l.next()) {
            var f = na(u.value),
              h = f[0],
              d = f.slice(1),
              p = this.transformers[h]
            if (p) {
              var v = this.options,
                g = v.x,
                y = v.y,
                m = v.z,
                b = v.width,
                x = v.height,
                w = v.depth,
                O = p(ra([], na(d), !1), g, y, m, b, x, w)
              if (HM(O)) o.push(O)
              else {
                if (o.length) {
                  var S = this.createMatrixTransform(o, e)
                  c(S), o.splice(0, o.length)
                }
                var _ = a(O) || Wn
                c(_, !0)
              }
            }
          }
        } catch (M) {
          n = { error: M }
        } finally {
          try {
            u && !u.done && (r = l.return) && r.call(l)
          } finally {
            if (n) throw n.error
          }
        }
        if (o.length) {
          var _ = this.createMatrixTransform(o, e)
          c(_)
        }
        return YM.apply(void 0, ra([], na(s), !1))
      }),
      (t.prototype.createMatrixTransform = function (e, n) {
        var r = Nt()
        return (
          n && e.reverse(),
          e.forEach(function (i) {
            return vb(r, r, i)
          }),
          n && zn(r, $d(r)),
          function (i) {
            var a = [i[0], i[1], i[2], 1]
            return la(a, a, r), [a[0], a[1], a[2]]
          }
        )
      }),
      t
    )
  })(),
  Iz =
    (globalThis && globalThis.__rest) ||
    function (t, e) {
      var n = {}
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
      if (t != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          e.indexOf(r[i]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
            (n[r[i]] = t[r[i]])
      return n
    }
function no(t) {
  return (e, ...n) => X({}, t(e, ...n), e)
}
function ro(t) {
  return (e, ...n) => X({}, e, t(e, ...n))
}
function g0(t, e) {
  if (!t) return e
  if (Array.isArray(t)) return t
  const { value: n = e } = t,
    r = Iz(t, ['value'])
  return Object.assign(Object.assign({}, r), { value: n })
}
var jz =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const KM = () => (t) => {
  const { children: e } = t
  if (!Array.isArray(e)) return []
  const { x: n = 0, y: r = 0, width: i, height: a, data: o } = t
  return e.map((s) => {
    var { data: c, x: l, y: u, width: f, height: h } = s,
      d = jz(s, ['data', 'x', 'y', 'width', 'height'])
    return Object.assign(Object.assign({}, d), {
      data: g0(c, o),
      x: l ?? n,
      y: u ?? r,
      width: f ?? i,
      height: h ?? a
    })
  })
}
KM.props = {}
var Dz =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const ZM = () => (t) => {
  const { children: e } = t
  if (!Array.isArray(e)) return []
  const { direction: n = 'row', ratio: r = e.map(() => 1), padding: i = 0, data: a } = t,
    [o, s, c, l] = n === 'col' ? ['y', 'height', 'width', 'x'] : ['x', 'width', 'height', 'y'],
    u = r.reduce((v, g) => v + g),
    f = t[s] - i * (e.length - 1),
    h = r.map((v) => f * (v / u)),
    d = []
  let p = t[o] || 0
  for (let v = 0; v < h.length; v += 1) {
    const g = e[v],
      { data: y } = g,
      m = Dz(g, ['data']),
      b = g0(y, a)
    d.push(Object.assign({ [o]: p, [s]: h[v], [l]: t[l] || 0, [c]: t[c], data: b }, m)),
      (p += h[v] + i)
  }
  return d
}
ZM.props = {}
var Rf =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const QM = () => (t) => {
  const { children: e } = t,
    n = Rf(t, ['children'])
  if (!Array.isArray(e)) return []
  const {
      data: r,
      scale: i = {},
      axis: a = {},
      legend: o = {},
      encode: s = {},
      transform: c = []
    } = n,
    l = Rf(n, ['data', 'scale', 'axis', 'legend', 'encode', 'transform']),
    u = e.map((f) => {
      var {
          data: h,
          scale: d = {},
          axis: p = {},
          legend: v = {},
          encode: g = {},
          transform: y = []
        } = f,
        m = Rf(f, ['data', 'scale', 'axis', 'legend', 'encode', 'transform'])
      return Object.assign(
        {
          data: g0(h, r),
          scale: X({}, i, d),
          encode: X({}, s, g),
          transform: [...c, ...y],
          axis: p && a ? X({}, a, p) : !1,
          legend: v && o ? X({}, o, v) : !1
        },
        m
      )
    })
  return [Object.assign(Object.assign({}, l), { marks: u, type: 'standardView' })]
}
QM.props = {}
var $z =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const JM =
  ({ static: t = !1 } = {}) =>
  (e) => {
    const {
        width: n,
        height: r,
        depth: i,
        paddingLeft: a,
        paddingRight: o,
        paddingTop: s,
        paddingBottom: c,
        padding: l,
        inset: u,
        insetLeft: f,
        insetTop: h,
        insetRight: d,
        insetBottom: p,
        margin: v,
        marginLeft: g,
        marginBottom: y,
        marginTop: m,
        marginRight: b,
        data: x,
        coordinate: w,
        theme: O,
        component: S,
        interaction: _,
        x: M,
        y: E,
        z: T,
        key: C,
        frame: A,
        labelTransform: P,
        parentKey: k,
        clip: L,
        viewStyle: R,
        title: j
      } = e,
      I = $z(e, [
        'width',
        'height',
        'depth',
        'paddingLeft',
        'paddingRight',
        'paddingTop',
        'paddingBottom',
        'padding',
        'inset',
        'insetLeft',
        'insetTop',
        'insetRight',
        'insetBottom',
        'margin',
        'marginLeft',
        'marginBottom',
        'marginTop',
        'marginRight',
        'data',
        'coordinate',
        'theme',
        'component',
        'interaction',
        'x',
        'y',
        'z',
        'key',
        'frame',
        'labelTransform',
        'parentKey',
        'clip',
        'viewStyle',
        'title'
      ])
    return [
      Object.assign(
        Object.assign(
          {
            type: 'standardView',
            x: M,
            y: E,
            z: T,
            key: C,
            width: n,
            height: r,
            depth: i,
            padding: l,
            paddingLeft: a,
            paddingRight: o,
            paddingTop: s,
            inset: u,
            insetLeft: f,
            insetTop: h,
            insetRight: d,
            insetBottom: p,
            paddingBottom: c,
            theme: O,
            coordinate: w,
            component: S,
            interaction: _,
            frame: A,
            labelTransform: P,
            margin: v,
            marginLeft: g,
            marginBottom: y,
            marginTop: m,
            marginRight: b,
            parentKey: k,
            clip: L,
            style: R
          },
          !t && { title: j }
        ),
        {
          marks: [
            Object.assign(
              Object.assign(Object.assign({}, I), { key: `${C}-0`, data: x }),
              t && { title: j }
            )
          ]
        }
      )
    ]
  }
JM.props = {}
class zs {
  constructor(e) {
    this.$value = e
  }
  static of(e) {
    return new zs(e)
  }
  call(e, ...n) {
    return (this.$value = e(this.$value, ...n)), this
  }
  value() {
    return this.$value
  }
}
var Bz =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const Fz = no((t) => {
    const { encode: e, data: n, scale: r, shareSize: i = !1 } = t,
      { x: a, y: o } = e,
      s = (c, l) => {
        var u
        if (c === void 0 || !i) return {}
        const f = qt(n, (p) => p[c]),
          h =
            ((u = r == null ? void 0 : r[l]) === null || u === void 0 ? void 0 : u.domain) ||
            Array.from(f.keys()),
          d = h.map((p) => (f.has(p) ? f.get(p).length : 1))
        return { domain: h, flex: d }
      }
    return {
      scale: {
        x: Object.assign(
          Object.assign(
            {
              paddingOuter: 0,
              paddingInner: 0.1,
              guide: a === void 0 ? null : { position: 'top' }
            },
            a === void 0 && { paddingInner: 0 }
          ),
          s(a, 'x')
        ),
        y: Object.assign(
          Object.assign(
            {
              range: [0, 1],
              paddingOuter: 0,
              paddingInner: 0.1,
              guide: o === void 0 ? null : { position: 'right' }
            },
            o === void 0 && { paddingInner: 0 }
          ),
          s(o, 'y')
        )
      }
    }
  }),
  y0 = no((t) => {
    const { data: e, scale: n } = t,
      r = [t]
    let i, a, o
    for (; r.length; ) {
      const f = r.shift(),
        { children: h, encode: d = {}, scale: p = {}, legend: v = {} } = f,
        { color: g } = d,
        { color: y } = p,
        { color: m } = v
      g !== void 0 && (i = g),
        y !== void 0 && (a = y),
        m !== void 0 && (o = m),
        Array.isArray(h) && r.push(...h)
    }
    const s = () => {
        var f
        const h = (f = n == null ? void 0 : n.color) === null || f === void 0 ? void 0 : f.domain
        if (h !== void 0) return [h]
        if (i === void 0) return [void 0]
        const d = typeof i == 'function' ? i : (v) => v[i],
          p = e.map(d)
        return p.some((v) => typeof v == 'number') ? [br(p)] : [Array.from(new Set(p)), 'ordinal']
      },
      c = typeof i == 'string' ? i : '',
      [l, u] = s()
    return {
      encode: { color: i },
      scale: { color: X({}, a, { domain: l, type: u }) },
      legend: { color: X({ title: c }, o) }
    }
  }),
  m0 = no(() => ({ animate: { enterType: 'fadeIn' } })),
  b0 = ro(() => ({ frame: !1, encode: { shape: 'hollow' }, style: { lineWidth: 0 } })),
  x0 = ro(() => ({ type: 'cell' })),
  tE = ro((t) => {
    const { data: e } = t
    return {
      data: {
        type: 'inline',
        value: e,
        transform: [
          {
            type: 'custom',
            callback: () => {
              const { data: r, encode: i } = t,
                { x: a, y: o } = i,
                s = a ? Array.from(new Set(r.map((u) => u[a]))) : [],
                c = o ? Array.from(new Set(r.map((u) => u[o]))) : []
              return (() => {
                if (s.length && c.length) {
                  const u = []
                  for (const f of s) for (const h of c) u.push({ [a]: f, [o]: h })
                  return u
                }
                if (s.length) return s.map((u) => ({ [a]: u }))
                if (c.length) return c.map((u) => ({ [o]: u }))
              })()
            }
          }
        ]
      }
    }
  }),
  eE = ro((t, e = zz, n = Gz, r = Wz, i = {}) => {
    const {
        data: a,
        encode: o,
        children: s,
        scale: c,
        x: l = 0,
        y: u = 0,
        shareData: f = !1,
        key: h
      } = t,
      { value: d } = a,
      { x: p, y: v } = o,
      { color: g } = c,
      { domain: y } = g
    return {
      children: (b, x, w) => {
        const { x: O, y: S } = x,
          { paddingLeft: _, paddingTop: M, marginLeft: E, marginTop: T } = w,
          { domain: C } = O.getOptions(),
          { domain: A } = S.getOptions(),
          P = Yi(b),
          k = b.map(e),
          L = b.map(({ x: B, y: F }) => [O.invert(B), S.invert(F)]),
          j = L.map(([B, F]) => (W) => {
            const { [p]: U, [v]: K } = W
            return (p !== void 0 ? U === B : !0) && (v !== void 0 ? K === F : !0)
          }).map((B) => d.filter(B)),
          I = f ? Ct(j, (B) => B.length) : void 0,
          D = L.map(([B, F]) => ({
            columnField: p,
            columnIndex: C.indexOf(B),
            columnValue: B,
            columnValuesLength: C.length,
            rowField: v,
            rowIndex: A.indexOf(F),
            rowValue: F,
            rowValuesLength: A.length
          })),
          $ = D.map((B) => (Array.isArray(s) ? s : [s(B)].flat(1)))
        return P.flatMap((B) => {
          const [F, W, U, K] = k[B],
            V = D[B],
            H = j[B]
          return $[B].map((tt) => {
            var it,
              ut,
              { scale: st, key: ht, facet: Ot = !0, axis: Mt = {}, legend: Yt = {} } = tt,
              le = Bz(tt, ['scale', 'key', 'facet', 'axis', 'legend'])
            const Ve =
                ((it = st == null ? void 0 : st.y) === null || it === void 0 ? void 0 : it.guide) ||
                Mt.y,
              lr =
                ((ut = st == null ? void 0 : st.x) === null || ut === void 0 ? void 0 : ut.guide) ||
                Mt.x,
              pi = { x: { tickCount: p ? 5 : void 0 }, y: { tickCount: v ? 5 : void 0 } },
              Fe = Ot ? H : H.length === 0 ? [] : d,
              xn = { color: { domain: y } },
              Pt = { x: Em(lr, n)(V, Fe), y: Em(Ve, r)(V, Fe) }
            return Object.assign(
              Object.assign(
                {
                  key: `${ht}-${B}`,
                  data: Fe,
                  margin: 0,
                  x: F + _ + l + E,
                  y: W + M + u + T,
                  parentKey: h,
                  width: U,
                  height: K,
                  paddingLeft: 0,
                  paddingRight: 0,
                  paddingTop: 0,
                  paddingBottom: 0,
                  frame: !!Fe.length,
                  dataDomain: I,
                  scale: X(pi, st, xn),
                  axis: X({}, Mt, Pt),
                  legend: !1
                },
                le
              ),
              i
            )
          })
        })
      }
    }
  })
function zz(t) {
  const { points: e } = t
  return ap(e)
}
function Cu(t, e) {
  return e.length
    ? X({ title: !1, tick: null, label: null }, t)
    : X({ title: !1, tick: null, label: null, grid: null }, t)
}
function Gz(t) {
  return (e, n) => {
    const { rowIndex: r, rowValuesLength: i, columnIndex: a, columnValuesLength: o } = e
    if (r !== i - 1) return Cu(t, n)
    const s = a !== o - 1 ? !1 : void 0,
      c = n.length ? void 0 : null
    return X({ title: s, grid: c }, t)
  }
}
function Wz(t) {
  return (e, n) => {
    const { rowIndex: r, columnIndex: i } = e
    if (i !== 0) return Cu(t, n)
    const a = r !== 0 ? !1 : void 0,
      o = n.length ? void 0 : null
    return X({ title: a, grid: o }, t)
  }
}
function Em(t, e) {
  return typeof t == 'function' ? t : t === null || t === !1 ? () => null : e(t)
}
const nE = () => (t) =>
  [zs.of(t).call(x0).call(y0).call(m0).call(Fz).call(b0).call(tE).call(eE).value()]
nE.props = {}
var sd =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const Yz = no((t) => ({
    scale: {
      x: { guide: null, paddingOuter: 0, paddingInner: 0.1 },
      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
    }
  })),
  Hz = ro((t) => {
    const { data: e, children: n, x: r = 0, y: i = 0, key: a } = t
    return {
      children: (s, c, l) => {
        const { x: u, y: f } = c,
          { paddingLeft: h, paddingTop: d, marginLeft: p, marginTop: v } = l,
          { domain: g } = u.getOptions(),
          { domain: y } = f.getOptions(),
          m = Yi(s),
          b = s.map(({ points: S }) => ap(S)),
          x = s.map(({ x: S, y: _ }) => [u.invert(S), f.invert(_)]),
          w = x.map(([S, _]) => ({
            columnField: S,
            columnIndex: g.indexOf(S),
            columnValue: S,
            columnValuesLength: g.length,
            rowField: _,
            rowIndex: y.indexOf(_),
            rowValue: _,
            rowValuesLength: y.length
          })),
          O = w.map((S) => (Array.isArray(n) ? n : [n(S)].flat(1)))
        return m.flatMap((S) => {
          const [_, M, E, T] = b[S],
            [C, A] = x[S],
            P = w[S]
          return O[S].map((L) => {
            var R, j
            const { scale: I, key: D, encode: $, axis: B, interaction: F } = L,
              W = sd(L, ['scale', 'key', 'encode', 'axis', 'interaction']),
              U = (R = I == null ? void 0 : I.y) === null || R === void 0 ? void 0 : R.guide,
              K = (j = I == null ? void 0 : I.x) === null || j === void 0 ? void 0 : j.guide,
              V = { x: { facet: !1 }, y: { facet: !1 } },
              H = { x: Xz(K)(P, e), y: Uz(U)(P, e) },
              Q = { x: { tickCount: 5 }, y: { tickCount: 5 } }
            return Object.assign(
              {
                data: e,
                parentKey: a,
                key: `${D}-${S}`,
                x: _ + h + r + p,
                y: M + d + i + v,
                width: E,
                height: T,
                margin: 0,
                paddingLeft: 0,
                paddingRight: 0,
                paddingTop: 0,
                paddingBottom: 0,
                frame: !0,
                scale: X(V, I),
                axis: X(Q, B, H),
                legend: !1,
                encode: X({}, $, { x: C, y: A }),
                interaction: X({}, F, { legendFilter: !1 })
              },
              W
            )
          })
        })
      }
    }
  }),
  Vz = ro((t) => {
    const { encode: e } = t,
      n = sd(t, ['encode']),
      { position: r = [], x: i = r, y: a = [...r].reverse() } = e,
      o = sd(e, ['position', 'x', 'y']),
      s = []
    for (const c of [i].flat(1)) for (const l of [a].flat(1)) s.push({ $x: c, $y: l })
    return Object.assign(Object.assign({}, n), {
      data: s,
      encode: Object.assign(Object.assign({}, o), { x: '$x', y: '$y' }),
      scale: Object.assign(
        Object.assign({}, [i].flat(1).length === 1 && { x: { paddingInner: 0 } }),
        [a].flat(1).length === 1 && { y: { paddingInner: 0 } }
      )
    })
  })
function Xz(t) {
  return typeof t == 'function'
    ? t
    : t === null
    ? () => null
    : (e, n) => {
        const { rowIndex: r, rowValuesLength: i } = e
        if (r !== i - 1) return Cu(t, n)
      }
}
function Uz(t) {
  return typeof t == 'function'
    ? t
    : t === null
    ? () => null
    : (e, n) => {
        const { columnIndex: r } = e
        if (r !== 0) return Cu(t, n)
      }
}
const qz = () => (t) =>
  [zs.of(t).call(x0).call(y0).call(Hz).call(Vz).call(m0).call(b0).call(Yz).value()]
var Kz =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const Zz = no((t) => ({
    scale: {
      x: { guide: { type: 'axisArc' }, paddingOuter: 0, paddingInner: 0.1 },
      y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
    }
  })),
  Qz = no((t) => ({ coordinate: { type: 'polar' } })),
  Jz = (t) => {
    const { encode: e } = t,
      n = Kz(t, ['encode']),
      { position: r } = e
    return Object.assign(Object.assign({}, n), { encode: { x: r } })
  }
function Tm(t) {
  return (e) => null
}
function tG(t) {
  const { points: e } = t,
    [n, r, i, a] = e,
    o = Ut(n, a),
    s = oe(n, a),
    c = oe(r, i),
    l = Jx(s, c),
    u = 1 / Math.sin(l / 2),
    f = o / (1 + u),
    h = f * Math.sqrt(2),
    [d, p] = i,
    g = Ca(s) + l / 2,
    y = f * u,
    m = d + y * Math.sin(g),
    b = p + y * Math.cos(g)
  return [m - h / 2, b - h / 2, h, h]
}
const eG = () => (t) =>
  [
    zs
      .of(t)
      .call(x0)
      .call(Jz)
      .call(y0)
      .call(Qz)
      .call(tE)
      .call(eE, tG, Tm, Tm, { frame: !1 })
      .call(m0)
      .call(b0)
      .call(Zz)
      .value()
  ]
function nG(t, e, n) {
  const i = n,
    a = [0, i],
    o = [-i + 1, -0 + 1]
  if (t === 'normal') return a
  if (t === 'reverse') return o
  if (t === 'alternate') return e % 2 === 0 ? a : o
  if (t === 'reverse-alternate') return e % 2 === 0 ? o : a
}
function rG(t, e, n) {
  const r = [t]
  for (; r.length; ) {
    const i = r.pop()
    i.animate = X(
      {
        enter: { duration: e },
        update: { duration: e, easing: n, type: 'morphing', fill: 'both' },
        exit: { type: 'fadeOut', duration: e }
      },
      i.animate || {}
    )
    const { children: a } = i
    Array.isArray(a) && r.push(...a)
  }
  return t
}
const rE = () => (t) => {
  const {
      children: e = [],
      duration: n = 1e3,
      iterationCount: r = 1,
      direction: i = 'normal',
      easing: a = 'ease-in-out-sine'
    } = t,
    o = e.length
  if (!Array.isArray(e) || o === 0) return []
  const { key: s } = e[0],
    c = e.map((l) => Object.assign(Object.assign({}, l), { key: s })).map((l) => rG(l, n, a))
  return function* () {
    let l = 0,
      u
    for (; r === 'infinite' || l < r; ) {
      const [f, h] = nG(i, l, o)
      for (let d = f; d < h; d += 1) {
        const p = Math.abs(d)
        u !== p && (yield c[p]), (u = p)
      }
      l++
    }
  }
}
rE.props = {}
var iG =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const iE = () => (t) => {
  const { type: e, data: n, scale: r, encode: i, style: a, animate: o, key: s, state: c } = t,
    l = iG(t, ['type', 'data', 'scale', 'encode', 'style', 'animate', 'key', 'state'])
  return [
    Object.assign(Object.assign({ type: 'geoView' }, l), {
      children: [
        {
          type: 'geoPath',
          key: `${s}-0`,
          data: { value: n },
          scale: r,
          encode: i,
          style: a,
          animate: o,
          state: c
        }
      ]
    })
  ]
}
iE.props = {}
var ct = 1e-6,
  aE = 1e-12,
  xt = Math.PI,
  ue = xt / 2,
  Pm = xt / 4,
  yn = xt * 2,
  Ne = 180 / xt,
  ie = xt / 180,
  Tt = Math.abs,
  io = Math.atan,
  Ar = Math.atan2,
  mt = Math.cos,
  _c = Math.ceil,
  oE = Math.exp,
  Pl = Math.log,
  If = Math.pow,
  pt = Math.sin,
  En =
    Math.sign ||
    function (t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0
    },
  nn = Math.sqrt,
  w0 = Math.tan
function sE(t) {
  return t > 1 ? 0 : t < -1 ? xt : Math.acos(t)
}
function Ln(t) {
  return t > 1 ? ue : t < -1 ? -ue : Math.asin(t)
}
function Tn() {}
function Al(t, e) {
  t && km.hasOwnProperty(t.type) && km[t.type](t, e)
}
var Am = {
    Feature: function (t, e) {
      Al(t.geometry, e)
    },
    FeatureCollection: function (t, e) {
      for (var n = t.features, r = -1, i = n.length; ++r < i; ) Al(n[r].geometry, e)
    }
  },
  km = {
    Sphere: function (t, e) {
      e.sphere()
    },
    Point: function (t, e) {
      ;(t = t.coordinates), e.point(t[0], t[1], t[2])
    },
    MultiPoint: function (t, e) {
      for (var n = t.coordinates, r = -1, i = n.length; ++r < i; )
        (t = n[r]), e.point(t[0], t[1], t[2])
    },
    LineString: function (t, e) {
      cd(t.coordinates, e, 0)
    },
    MultiLineString: function (t, e) {
      for (var n = t.coordinates, r = -1, i = n.length; ++r < i; ) cd(n[r], e, 0)
    },
    Polygon: function (t, e) {
      Cm(t.coordinates, e)
    },
    MultiPolygon: function (t, e) {
      for (var n = t.coordinates, r = -1, i = n.length; ++r < i; ) Cm(n[r], e)
    },
    GeometryCollection: function (t, e) {
      for (var n = t.geometries, r = -1, i = n.length; ++r < i; ) Al(n[r], e)
    }
  }
function cd(t, e, n) {
  var r = -1,
    i = t.length - n,
    a
  for (e.lineStart(); ++r < i; ) (a = t[r]), e.point(a[0], a[1], a[2])
  e.lineEnd()
}
function Cm(t, e) {
  var n = -1,
    r = t.length
  for (e.polygonStart(); ++n < r; ) cd(t[n], e, 1)
  e.polygonEnd()
}
function sa(t, e) {
  t && Am.hasOwnProperty(t.type) ? Am[t.type](t, e) : Al(t, e)
}
function ld(t) {
  return [Ar(t[1], t[0]), Ln(t[2])]
}
function Wa(t) {
  var e = t[0],
    n = t[1],
    r = mt(n)
  return [r * mt(e), r * pt(e), pt(n)]
}
function Mc(t, e) {
  return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
}
function kl(t, e) {
  return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]]
}
function jf(t, e) {
  ;(t[0] += e[0]), (t[1] += e[1]), (t[2] += e[2])
}
function Ec(t, e) {
  return [t[0] * e, t[1] * e, t[2] * e]
}
function ud(t) {
  var e = nn(t[0] * t[0] + t[1] * t[1] + t[2] * t[2])
  ;(t[0] /= e), (t[1] /= e), (t[2] /= e)
}
function fd(t, e) {
  function n(r, i) {
    return (r = t(r, i)), e(r[0], r[1])
  }
  return (
    t.invert &&
      e.invert &&
      (n.invert = function (r, i) {
        return (r = e.invert(r, i)), r && t.invert(r[0], r[1])
      }),
    n
  )
}
function hd(t, e) {
  return Tt(t) > xt && (t -= Math.round(t / yn) * yn), [t, e]
}
hd.invert = hd
function cE(t, e, n) {
  return (t %= yn) ? (e || n ? fd(Nm(t), Rm(e, n)) : Nm(t)) : e || n ? Rm(e, n) : hd
}
function Lm(t) {
  return function (e, n) {
    return (e += t), Tt(e) > xt && (e -= Math.round(e / yn) * yn), [e, n]
  }
}
function Nm(t) {
  var e = Lm(t)
  return (e.invert = Lm(-t)), e
}
function Rm(t, e) {
  var n = mt(t),
    r = pt(t),
    i = mt(e),
    a = pt(e)
  function o(s, c) {
    var l = mt(c),
      u = mt(s) * l,
      f = pt(s) * l,
      h = pt(c),
      d = h * n + u * r
    return [Ar(f * i - d * a, u * n - h * r), Ln(d * i + f * a)]
  }
  return (
    (o.invert = function (s, c) {
      var l = mt(c),
        u = mt(s) * l,
        f = pt(s) * l,
        h = pt(c),
        d = h * i - f * a
      return [Ar(f * i + h * a, u * n + d * r), Ln(d * n - u * r)]
    }),
    o
  )
}
function aG(t) {
  t = cE(t[0] * ie, t[1] * ie, t.length > 2 ? t[2] * ie : 0)
  function e(n) {
    return (n = t(n[0] * ie, n[1] * ie)), (n[0] *= Ne), (n[1] *= Ne), n
  }
  return (
    (e.invert = function (n) {
      return (n = t.invert(n[0] * ie, n[1] * ie)), (n[0] *= Ne), (n[1] *= Ne), n
    }),
    e
  )
}
function oG(t, e, n, r, i, a) {
  if (n) {
    var o = mt(e),
      s = pt(e),
      c = r * n
    i == null
      ? ((i = e + r * yn), (a = e - c / 2))
      : ((i = Im(o, i)), (a = Im(o, a)), (r > 0 ? i < a : i > a) && (i += r * yn))
    for (var l, u = i; r > 0 ? u > a : u < a; u -= c)
      (l = ld([o, -s * mt(u), -s * pt(u)])), t.point(l[0], l[1])
  }
}
function Im(t, e) {
  ;(e = Wa(e)), (e[0] -= t), ud(e)
  var n = sE(-e[1])
  return ((-e[2] < 0 ? -n : n) + yn - ct) % yn
}
function lE() {
  var t = [],
    e
  return {
    point: function (n, r, i) {
      e.push([n, r, i])
    },
    lineStart: function () {
      t.push((e = []))
    },
    lineEnd: Tn,
    rejoin: function () {
      t.length > 1 && t.push(t.pop().concat(t.shift()))
    },
    result: function () {
      var n = t
      return (t = []), (e = null), n
    }
  }
}
function Xc(t, e) {
  return Tt(t[0] - e[0]) < ct && Tt(t[1] - e[1]) < ct
}
function Tc(t, e, n, r) {
  ;(this.x = t), (this.z = e), (this.o = n), (this.e = r), (this.v = !1), (this.n = this.p = null)
}
function uE(t, e, n, r, i) {
  var a = [],
    o = [],
    s,
    c
  if (
    (t.forEach(function (p) {
      if (!((v = p.length - 1) <= 0)) {
        var v,
          g = p[0],
          y = p[v],
          m
        if (Xc(g, y)) {
          if (!g[2] && !y[2]) {
            for (i.lineStart(), s = 0; s < v; ++s) i.point((g = p[s])[0], g[1])
            i.lineEnd()
            return
          }
          y[0] += 2 * ct
        }
        a.push((m = new Tc(g, p, null, !0))),
          o.push((m.o = new Tc(g, null, m, !1))),
          a.push((m = new Tc(y, p, null, !1))),
          o.push((m.o = new Tc(y, null, m, !0)))
      }
    }),
    !!a.length)
  ) {
    for (o.sort(e), jm(a), jm(o), s = 0, c = o.length; s < c; ++s) o[s].e = n = !n
    for (var l = a[0], u, f; ; ) {
      for (var h = l, d = !0; h.v; ) if ((h = h.n) === l) return
      ;(u = h.z), i.lineStart()
      do {
        if (((h.v = h.o.v = !0), h.e)) {
          if (d) for (s = 0, c = u.length; s < c; ++s) i.point((f = u[s])[0], f[1])
          else r(h.x, h.n.x, 1, i)
          h = h.n
        } else {
          if (d) for (u = h.p.z, s = u.length - 1; s >= 0; --s) i.point((f = u[s])[0], f[1])
          else r(h.x, h.p.x, -1, i)
          h = h.p
        }
        ;(h = h.o), (u = h.z), (d = !d)
      } while (!h.v)
      i.lineEnd()
    }
  }
}
function jm(t) {
  if ((e = t.length)) {
    for (var e, n = 0, r = t[0], i; ++n < e; ) (r.n = i = t[n]), (i.p = r), (r = i)
    ;(r.n = i = t[0]), (i.p = r)
  }
}
function Df(t) {
  return Tt(t[0]) <= xt ? t[0] : En(t[0]) * (((Tt(t[0]) + xt) % yn) - xt)
}
function sG(t, e) {
  var n = Df(e),
    r = e[1],
    i = pt(r),
    a = [pt(n), -mt(n), 0],
    o = 0,
    s = 0,
    c = new Ni()
  i === 1 ? (r = ue + ct) : i === -1 && (r = -ue - ct)
  for (var l = 0, u = t.length; l < u; ++l)
    if ((h = (f = t[l]).length))
      for (
        var f, h, d = f[h - 1], p = Df(d), v = d[1] / 2 + Pm, g = pt(v), y = mt(v), m = 0;
        m < h;
        ++m, p = x, g = O, y = S, d = b
      ) {
        var b = f[m],
          x = Df(b),
          w = b[1] / 2 + Pm,
          O = pt(w),
          S = mt(w),
          _ = x - p,
          M = _ >= 0 ? 1 : -1,
          E = M * _,
          T = E > xt,
          C = g * O
        if (
          (c.add(Ar(C * M * pt(E), y * S + C * mt(E))),
          (o += T ? _ + M * yn : _),
          T ^ (p >= n) ^ (x >= n))
        ) {
          var A = kl(Wa(d), Wa(b))
          ud(A)
          var P = kl(a, A)
          ud(P)
          var k = (T ^ (_ >= 0) ? -1 : 1) * Ln(P[2])
          ;(r > k || (r === k && (A[0] || A[1]))) && (s += T ^ (_ >= 0) ? 1 : -1)
        }
      }
  return (o < -ct || (o < ct && c < -aE)) ^ (s & 1)
}
function fE(t, e, n, r) {
  return function (i) {
    var a = e(i),
      o = lE(),
      s = e(o),
      c = !1,
      l,
      u,
      f,
      h = {
        point: d,
        lineStart: v,
        lineEnd: g,
        polygonStart: function () {
          ;(h.point = y), (h.lineStart = m), (h.lineEnd = b), (u = []), (l = [])
        },
        polygonEnd: function () {
          ;(h.point = d), (h.lineStart = v), (h.lineEnd = g), (u = kb(u))
          var x = sG(l, r)
          u.length
            ? (c || (i.polygonStart(), (c = !0)), uE(u, lG, x, n, i))
            : x &&
              (c || (i.polygonStart(), (c = !0)), i.lineStart(), n(null, null, 1, i), i.lineEnd()),
            c && (i.polygonEnd(), (c = !1)),
            (u = l = null)
        },
        sphere: function () {
          i.polygonStart(), i.lineStart(), n(null, null, 1, i), i.lineEnd(), i.polygonEnd()
        }
      }
    function d(x, w) {
      t(x, w) && i.point(x, w)
    }
    function p(x, w) {
      a.point(x, w)
    }
    function v() {
      ;(h.point = p), a.lineStart()
    }
    function g() {
      ;(h.point = d), a.lineEnd()
    }
    function y(x, w) {
      f.push([x, w]), s.point(x, w)
    }
    function m() {
      s.lineStart(), (f = [])
    }
    function b() {
      y(f[0][0], f[0][1]), s.lineEnd()
      var x = s.clean(),
        w = o.result(),
        O,
        S = w.length,
        _,
        M,
        E
      if ((f.pop(), l.push(f), (f = null), !!S)) {
        if (x & 1) {
          if (((M = w[0]), (_ = M.length - 1) > 0)) {
            for (c || (i.polygonStart(), (c = !0)), i.lineStart(), O = 0; O < _; ++O)
              i.point((E = M[O])[0], E[1])
            i.lineEnd()
          }
          return
        }
        S > 1 && x & 2 && w.push(w.pop().concat(w.shift())), u.push(w.filter(cG))
      }
    }
    return h
  }
}
function cG(t) {
  return t.length > 1
}
function lG(t, e) {
  return (
    ((t = t.x)[0] < 0 ? t[1] - ue - ct : ue - t[1]) -
    ((e = e.x)[0] < 0 ? e[1] - ue - ct : ue - e[1])
  )
}
const Dm = fE(
  function () {
    return !0
  },
  uG,
  hG,
  [-xt, -ue]
)
function uG(t) {
  var e = NaN,
    n = NaN,
    r = NaN,
    i
  return {
    lineStart: function () {
      t.lineStart(), (i = 1)
    },
    point: function (a, o) {
      var s = a > 0 ? xt : -xt,
        c = Tt(a - e)
      Tt(c - xt) < ct
        ? (t.point(e, (n = (n + o) / 2 > 0 ? ue : -ue)),
          t.point(r, n),
          t.lineEnd(),
          t.lineStart(),
          t.point(s, n),
          t.point(a, n),
          (i = 0))
        : r !== s &&
          c >= xt &&
          (Tt(e - r) < ct && (e -= r * ct),
          Tt(a - s) < ct && (a -= s * ct),
          (n = fG(e, n, a, o)),
          t.point(r, n),
          t.lineEnd(),
          t.lineStart(),
          t.point(s, n),
          (i = 0)),
        t.point((e = a), (n = o)),
        (r = s)
    },
    lineEnd: function () {
      t.lineEnd(), (e = n = NaN)
    },
    clean: function () {
      return 2 - i
    }
  }
}
function fG(t, e, n, r) {
  var i,
    a,
    o = pt(t - n)
  return Tt(o) > ct
    ? io((pt(e) * (a = mt(r)) * pt(n) - pt(r) * (i = mt(e)) * pt(t)) / (i * a * o))
    : (e + r) / 2
}
function hG(t, e, n, r) {
  var i
  if (t == null)
    (i = n * ue),
      r.point(-xt, i),
      r.point(0, i),
      r.point(xt, i),
      r.point(xt, 0),
      r.point(xt, -i),
      r.point(0, -i),
      r.point(-xt, -i),
      r.point(-xt, 0),
      r.point(-xt, i)
  else if (Tt(t[0] - e[0]) > ct) {
    var a = t[0] < e[0] ? xt : -xt
    ;(i = (n * a) / 2), r.point(-a, i), r.point(0, i), r.point(a, i)
  } else r.point(e[0], e[1])
}
function dG(t) {
  var e = mt(t),
    n = 6 * ie,
    r = e > 0,
    i = Tt(e) > ct
  function a(u, f, h, d) {
    oG(d, t, n, h, u, f)
  }
  function o(u, f) {
    return mt(u) * mt(f) > e
  }
  function s(u) {
    var f, h, d, p, v
    return {
      lineStart: function () {
        ;(p = d = !1), (v = 1)
      },
      point: function (g, y) {
        var m = [g, y],
          b,
          x = o(g, y),
          w = r ? (x ? 0 : l(g, y)) : x ? l(g + (g < 0 ? xt : -xt), y) : 0
        if (
          (!f && (p = d = x) && u.lineStart(),
          x !== d && ((b = c(f, m)), (!b || Xc(f, b) || Xc(m, b)) && (m[2] = 1)),
          x !== d)
        )
          (v = 0),
            x
              ? (u.lineStart(), (b = c(m, f)), u.point(b[0], b[1]))
              : ((b = c(f, m)), u.point(b[0], b[1], 2), u.lineEnd()),
            (f = b)
        else if (i && f && r ^ x) {
          var O
          !(w & h) &&
            (O = c(m, f, !0)) &&
            ((v = 0),
            r
              ? (u.lineStart(), u.point(O[0][0], O[0][1]), u.point(O[1][0], O[1][1]), u.lineEnd())
              : (u.point(O[1][0], O[1][1]),
                u.lineEnd(),
                u.lineStart(),
                u.point(O[0][0], O[0][1], 3)))
        }
        x && (!f || !Xc(f, m)) && u.point(m[0], m[1]), (f = m), (d = x), (h = w)
      },
      lineEnd: function () {
        d && u.lineEnd(), (f = null)
      },
      clean: function () {
        return v | ((p && d) << 1)
      }
    }
  }
  function c(u, f, h) {
    var d = Wa(u),
      p = Wa(f),
      v = [1, 0, 0],
      g = kl(d, p),
      y = Mc(g, g),
      m = g[0],
      b = y - m * m
    if (!b) return !h && u
    var x = (e * y) / b,
      w = (-e * m) / b,
      O = kl(v, g),
      S = Ec(v, x),
      _ = Ec(g, w)
    jf(S, _)
    var M = O,
      E = Mc(S, M),
      T = Mc(M, M),
      C = E * E - T * (Mc(S, S) - 1)
    if (!(C < 0)) {
      var A = nn(C),
        P = Ec(M, (-E - A) / T)
      if ((jf(P, S), (P = ld(P)), !h)) return P
      var k = u[0],
        L = f[0],
        R = u[1],
        j = f[1],
        I
      L < k && ((I = k), (k = L), (L = I))
      var D = L - k,
        $ = Tt(D - xt) < ct,
        B = $ || D < ct
      if (
        (!$ && j < R && ((I = R), (R = j), (j = I)),
        B
          ? $
            ? (R + j > 0) ^ (P[1] < (Tt(P[0] - k) < ct ? R : j))
            : R <= P[1] && P[1] <= j
          : (D > xt) ^ (k <= P[0] && P[0] <= L))
      ) {
        var F = Ec(M, (-E + A) / T)
        return jf(F, S), [P, ld(F)]
      }
    }
  }
  function l(u, f) {
    var h = r ? t : xt - t,
      d = 0
    return u < -h ? (d |= 1) : u > h && (d |= 2), f < -h ? (d |= 4) : f > h && (d |= 8), d
  }
  return fE(o, s, a, r ? [0, -t] : [-xt, t - xt])
}
function pG(t, e, n, r, i, a) {
  var o = t[0],
    s = t[1],
    c = e[0],
    l = e[1],
    u = 0,
    f = 1,
    h = c - o,
    d = l - s,
    p
  if (((p = n - o), !(!h && p > 0))) {
    if (((p /= h), h < 0)) {
      if (p < u) return
      p < f && (f = p)
    } else if (h > 0) {
      if (p > f) return
      p > u && (u = p)
    }
    if (((p = i - o), !(!h && p < 0))) {
      if (((p /= h), h < 0)) {
        if (p > f) return
        p > u && (u = p)
      } else if (h > 0) {
        if (p < u) return
        p < f && (f = p)
      }
      if (((p = r - s), !(!d && p > 0))) {
        if (((p /= d), d < 0)) {
          if (p < u) return
          p < f && (f = p)
        } else if (d > 0) {
          if (p > f) return
          p > u && (u = p)
        }
        if (((p = a - s), !(!d && p < 0))) {
          if (((p /= d), d < 0)) {
            if (p > f) return
            p > u && (u = p)
          } else if (d > 0) {
            if (p < u) return
            p < f && (f = p)
          }
          return (
            u > 0 && ((t[0] = o + u * h), (t[1] = s + u * d)),
            f < 1 && ((e[0] = o + f * h), (e[1] = s + f * d)),
            !0
          )
        }
      }
    }
  }
}
var Po = 1e9,
  Pc = -Po
function hE(t, e, n, r) {
  function i(l, u) {
    return t <= l && l <= n && e <= u && u <= r
  }
  function a(l, u, f, h) {
    var d = 0,
      p = 0
    if (l == null || (d = o(l, f)) !== (p = o(u, f)) || (c(l, u) < 0) ^ (f > 0))
      do h.point(d === 0 || d === 3 ? t : n, d > 1 ? r : e)
      while ((d = (d + f + 4) % 4) !== p)
    else h.point(u[0], u[1])
  }
  function o(l, u) {
    return Tt(l[0] - t) < ct
      ? u > 0
        ? 0
        : 3
      : Tt(l[0] - n) < ct
      ? u > 0
        ? 2
        : 1
      : Tt(l[1] - e) < ct
      ? u > 0
        ? 1
        : 0
      : u > 0
      ? 3
      : 2
  }
  function s(l, u) {
    return c(l.x, u.x)
  }
  function c(l, u) {
    var f = o(l, 1),
      h = o(u, 1)
    return f !== h
      ? f - h
      : f === 0
      ? u[1] - l[1]
      : f === 1
      ? l[0] - u[0]
      : f === 2
      ? l[1] - u[1]
      : u[0] - l[0]
  }
  return function (l) {
    var u = l,
      f = lE(),
      h,
      d,
      p,
      v,
      g,
      y,
      m,
      b,
      x,
      w,
      O,
      S = { point: _, lineStart: C, lineEnd: A, polygonStart: E, polygonEnd: T }
    function _(k, L) {
      i(k, L) && u.point(k, L)
    }
    function M() {
      for (var k = 0, L = 0, R = d.length; L < R; ++L)
        for (var j = d[L], I = 1, D = j.length, $ = j[0], B, F, W = $[0], U = $[1]; I < D; ++I)
          (B = W),
            (F = U),
            ($ = j[I]),
            (W = $[0]),
            (U = $[1]),
            F <= r
              ? U > r && (W - B) * (r - F) > (U - F) * (t - B) && ++k
              : U <= r && (W - B) * (r - F) < (U - F) * (t - B) && --k
      return k
    }
    function E() {
      ;(u = f), (h = []), (d = []), (O = !0)
    }
    function T() {
      var k = M(),
        L = O && k,
        R = (h = kb(h)).length
      ;(L || R) &&
        (l.polygonStart(),
        L && (l.lineStart(), a(null, null, 1, l), l.lineEnd()),
        R && uE(h, s, k, a, l),
        l.polygonEnd()),
        (u = l),
        (h = d = p = null)
    }
    function C() {
      ;(S.point = P), d && d.push((p = [])), (w = !0), (x = !1), (m = b = NaN)
    }
    function A() {
      h && (P(v, g), y && x && f.rejoin(), h.push(f.result())), (S.point = _), x && u.lineEnd()
    }
    function P(k, L) {
      var R = i(k, L)
      if ((d && p.push([k, L]), w))
        (v = k), (g = L), (y = R), (w = !1), R && (u.lineStart(), u.point(k, L))
      else if (R && x) u.point(k, L)
      else {
        var j = [(m = Math.max(Pc, Math.min(Po, m))), (b = Math.max(Pc, Math.min(Po, b)))],
          I = [(k = Math.max(Pc, Math.min(Po, k))), (L = Math.max(Pc, Math.min(Po, L)))]
        pG(j, I, t, e, n, r)
          ? (x || (u.lineStart(), u.point(j[0], j[1])),
            u.point(I[0], I[1]),
            R || u.lineEnd(),
            (O = !1))
          : R && (u.lineStart(), u.point(k, L), (O = !1))
      }
      ;(m = k), (b = L), (x = R)
    }
    return S
  }
}
function $m(t, e, n) {
  var r = ua(t, e - ct, n).concat(e)
  return function (i) {
    return r.map(function (a) {
      return [i, a]
    })
  }
}
function Bm(t, e, n) {
  var r = ua(t, e - ct, n).concat(e)
  return function (i) {
    return r.map(function (a) {
      return [a, i]
    })
  }
}
function vG() {
  var t,
    e,
    n,
    r,
    i,
    a,
    o,
    s,
    c = 10,
    l = c,
    u = 90,
    f = 360,
    h,
    d,
    p,
    v,
    g = 2.5
  function y() {
    return { type: 'MultiLineString', coordinates: m() }
  }
  function m() {
    return ua(_c(r / u) * u, n, u)
      .map(p)
      .concat(ua(_c(s / f) * f, o, f).map(v))
      .concat(
        ua(_c(e / c) * c, t, c)
          .filter(function (b) {
            return Tt(b % u) > ct
          })
          .map(h)
      )
      .concat(
        ua(_c(a / l) * l, i, l)
          .filter(function (b) {
            return Tt(b % f) > ct
          })
          .map(d)
      )
  }
  return (
    (y.lines = function () {
      return m().map(function (b) {
        return { type: 'LineString', coordinates: b }
      })
    }),
    (y.outline = function () {
      return {
        type: 'Polygon',
        coordinates: [p(r).concat(v(o).slice(1), p(n).reverse().slice(1), v(s).reverse().slice(1))]
      }
    }),
    (y.extent = function (b) {
      return arguments.length ? y.extentMajor(b).extentMinor(b) : y.extentMinor()
    }),
    (y.extentMajor = function (b) {
      return arguments.length
        ? ((r = +b[0][0]),
          (n = +b[1][0]),
          (s = +b[0][1]),
          (o = +b[1][1]),
          r > n && ((b = r), (r = n), (n = b)),
          s > o && ((b = s), (s = o), (o = b)),
          y.precision(g))
        : [
            [r, s],
            [n, o]
          ]
    }),
    (y.extentMinor = function (b) {
      return arguments.length
        ? ((e = +b[0][0]),
          (t = +b[1][0]),
          (a = +b[0][1]),
          (i = +b[1][1]),
          e > t && ((b = e), (e = t), (t = b)),
          a > i && ((b = a), (a = i), (i = b)),
          y.precision(g))
        : [
            [e, a],
            [t, i]
          ]
    }),
    (y.step = function (b) {
      return arguments.length ? y.stepMajor(b).stepMinor(b) : y.stepMinor()
    }),
    (y.stepMajor = function (b) {
      return arguments.length ? ((u = +b[0]), (f = +b[1]), y) : [u, f]
    }),
    (y.stepMinor = function (b) {
      return arguments.length ? ((c = +b[0]), (l = +b[1]), y) : [c, l]
    }),
    (y.precision = function (b) {
      return arguments.length
        ? ((g = +b),
          (h = $m(a, i, 90)),
          (d = Bm(e, t, g)),
          (p = $m(s, o, 90)),
          (v = Bm(r, n, g)),
          y)
        : g
    }),
    y
      .extentMajor([
        [-180, -90 + ct],
        [180, 90 - ct]
      ])
      .extentMinor([
        [-180, -80 - ct],
        [180, 80 + ct]
      ])
  )
}
function gG() {
  return vG()()
}
const ds = (t) => t
var $f = new Ni(),
  dd = new Ni(),
  dE,
  pE,
  pd,
  vd,
  Dr = {
    point: Tn,
    lineStart: Tn,
    lineEnd: Tn,
    polygonStart: function () {
      ;(Dr.lineStart = yG), (Dr.lineEnd = bG)
    },
    polygonEnd: function () {
      ;(Dr.lineStart = Dr.lineEnd = Dr.point = Tn), $f.add(Tt(dd)), (dd = new Ni())
    },
    result: function () {
      var t = $f / 2
      return ($f = new Ni()), t
    }
  }
function yG() {
  Dr.point = mG
}
function mG(t, e) {
  ;(Dr.point = vE), (dE = pd = t), (pE = vd = e)
}
function vE(t, e) {
  dd.add(vd * t - pd * e), (pd = t), (vd = e)
}
function bG() {
  vE(dE, pE)
}
const Fm = Dr
var Ya = 1 / 0,
  Cl = Ya,
  ps = -Ya,
  Ll = ps,
  xG = {
    point: wG,
    lineStart: Tn,
    lineEnd: Tn,
    polygonStart: Tn,
    polygonEnd: Tn,
    result: function () {
      var t = [
        [Ya, Cl],
        [ps, Ll]
      ]
      return (ps = Ll = -(Cl = Ya = 1 / 0)), t
    }
  }
function wG(t, e) {
  t < Ya && (Ya = t), t > ps && (ps = t), e < Cl && (Cl = e), e > Ll && (Ll = e)
}
const Nl = xG
var gd = 0,
  yd = 0,
  Ao = 0,
  Rl = 0,
  Il = 0,
  pa = 0,
  md = 0,
  bd = 0,
  ko = 0,
  gE,
  yE,
  Zn,
  Qn,
  Bn = {
    point: zi,
    lineStart: zm,
    lineEnd: Gm,
    polygonStart: function () {
      ;(Bn.lineStart = _G), (Bn.lineEnd = MG)
    },
    polygonEnd: function () {
      ;(Bn.point = zi), (Bn.lineStart = zm), (Bn.lineEnd = Gm)
    },
    result: function () {
      var t = ko
        ? [md / ko, bd / ko]
        : pa
        ? [Rl / pa, Il / pa]
        : Ao
        ? [gd / Ao, yd / Ao]
        : [NaN, NaN]
      return (gd = yd = Ao = Rl = Il = pa = md = bd = ko = 0), t
    }
  }
function zi(t, e) {
  ;(gd += t), (yd += e), ++Ao
}
function zm() {
  Bn.point = OG
}
function OG(t, e) {
  ;(Bn.point = SG), zi((Zn = t), (Qn = e))
}
function SG(t, e) {
  var n = t - Zn,
    r = e - Qn,
    i = nn(n * n + r * r)
  ;(Rl += (i * (Zn + t)) / 2), (Il += (i * (Qn + e)) / 2), (pa += i), zi((Zn = t), (Qn = e))
}
function Gm() {
  Bn.point = zi
}
function _G() {
  Bn.point = EG
}
function MG() {
  mE(gE, yE)
}
function EG(t, e) {
  ;(Bn.point = mE), zi((gE = Zn = t), (yE = Qn = e))
}
function mE(t, e) {
  var n = t - Zn,
    r = e - Qn,
    i = nn(n * n + r * r)
  ;(Rl += (i * (Zn + t)) / 2),
    (Il += (i * (Qn + e)) / 2),
    (pa += i),
    (i = Qn * t - Zn * e),
    (md += i * (Zn + t)),
    (bd += i * (Qn + e)),
    (ko += i * 3),
    zi((Zn = t), (Qn = e))
}
const Wm = Bn
function bE(t) {
  this._context = t
}
bE.prototype = {
  _radius: 4.5,
  pointRadius: function (t) {
    return (this._radius = t), this
  },
  polygonStart: function () {
    this._line = 0
  },
  polygonEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    this._point = 0
  },
  lineEnd: function () {
    this._line === 0 && this._context.closePath(), (this._point = NaN)
  },
  point: function (t, e) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(t, e), (this._point = 1)
        break
      }
      case 1: {
        this._context.lineTo(t, e)
        break
      }
      default: {
        this._context.moveTo(t + this._radius, e), this._context.arc(t, e, this._radius, 0, yn)
        break
      }
    }
  },
  result: Tn
}
var xd = new Ni(),
  Bf,
  xE,
  wE,
  Co,
  Lo,
  jl = {
    point: Tn,
    lineStart: function () {
      jl.point = TG
    },
    lineEnd: function () {
      Bf && OE(xE, wE), (jl.point = Tn)
    },
    polygonStart: function () {
      Bf = !0
    },
    polygonEnd: function () {
      Bf = null
    },
    result: function () {
      var t = +xd
      return (xd = new Ni()), t
    }
  }
function TG(t, e) {
  ;(jl.point = OE), (xE = Co = t), (wE = Lo = e)
}
function OE(t, e) {
  ;(Co -= t), (Lo -= e), xd.add(nn(Co * Co + Lo * Lo)), (Co = t), (Lo = e)
}
const Ym = jl
let Hm, Dl, Vm, Xm
class Um {
  constructor(e) {
    ;(this._append = e == null ? SE : PG(e)), (this._radius = 4.5), (this._ = '')
  }
  pointRadius(e) {
    return (this._radius = +e), this
  }
  polygonStart() {
    this._line = 0
  }
  polygonEnd() {
    this._line = NaN
  }
  lineStart() {
    this._point = 0
  }
  lineEnd() {
    this._line === 0 && (this._ += 'Z'), (this._point = NaN)
  }
  point(e, n) {
    switch (this._point) {
      case 0: {
        this._append`M${e},${n}`, (this._point = 1)
        break
      }
      case 1: {
        this._append`L${e},${n}`
        break
      }
      default: {
        if ((this._append`M${e},${n}`, this._radius !== Vm || this._append !== Dl)) {
          const r = this._radius,
            i = this._
          ;(this._ = ''),
            this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`,
            (Vm = r),
            (Dl = this._append),
            (Xm = this._),
            (this._ = i)
        }
        this._ += Xm
        break
      }
    }
  }
  result() {
    const e = this._
    return (this._ = ''), e.length ? e : null
  }
}
function SE(t) {
  let e = 1
  this._ += t[0]
  for (const n = t.length; e < n; ++e) this._ += arguments[e] + t[e]
}
function PG(t) {
  const e = Math.floor(t)
  if (!(e >= 0)) throw new RangeError(`invalid digits: ${t}`)
  if (e > 15) return SE
  if (e !== Hm) {
    const n = 10 ** e
    ;(Hm = e),
      (Dl = function (i) {
        let a = 1
        this._ += i[0]
        for (const o = i.length; a < o; ++a) this._ += Math.round(arguments[a] * n) / n + i[a]
      })
  }
  return Dl
}
function _E(t, e) {
  let n = 3,
    r = 4.5,
    i,
    a
  function o(s) {
    return (
      s && (typeof r == 'function' && a.pointRadius(+r.apply(this, arguments)), sa(s, i(a))),
      a.result()
    )
  }
  return (
    (o.area = function (s) {
      return sa(s, i(Fm)), Fm.result()
    }),
    (o.measure = function (s) {
      return sa(s, i(Ym)), Ym.result()
    }),
    (o.bounds = function (s) {
      return sa(s, i(Nl)), Nl.result()
    }),
    (o.centroid = function (s) {
      return sa(s, i(Wm)), Wm.result()
    }),
    (o.projection = function (s) {
      return arguments.length ? ((i = s == null ? ((t = null), ds) : (t = s).stream), o) : t
    }),
    (o.context = function (s) {
      return arguments.length
        ? ((a = s == null ? ((e = null), new Um(n)) : new bE((e = s))),
          typeof r != 'function' && a.pointRadius(r),
          o)
        : e
    }),
    (o.pointRadius = function (s) {
      return arguments.length ? ((r = typeof s == 'function' ? s : (a.pointRadius(+s), +s)), o) : r
    }),
    (o.digits = function (s) {
      if (!arguments.length) return n
      if (s == null) n = null
      else {
        const c = Math.floor(s)
        if (!(c >= 0)) throw new RangeError(`invalid digits: ${s}`)
        n = c
      }
      return e === null && (a = new Um(n)), o
    }),
    o.projection(t).digits(n).context(e)
  )
}
function Lu(t) {
  return function (e) {
    var n = new wd()
    for (var r in t) n[r] = t[r]
    return (n.stream = e), n
  }
}
function wd() {}
wd.prototype = {
  constructor: wd,
  point: function (t, e) {
    this.stream.point(t, e)
  },
  sphere: function () {
    this.stream.sphere()
  },
  lineStart: function () {
    this.stream.lineStart()
  },
  lineEnd: function () {
    this.stream.lineEnd()
  },
  polygonStart: function () {
    this.stream.polygonStart()
  },
  polygonEnd: function () {
    this.stream.polygonEnd()
  }
}
function O0(t, e, n) {
  var r = t.clipExtent && t.clipExtent()
  return (
    t.scale(150).translate([0, 0]),
    r != null && t.clipExtent(null),
    sa(n, t.stream(Nl)),
    e(Nl.result()),
    r != null && t.clipExtent(r),
    t
  )
}
function Nu(t, e, n) {
  return O0(
    t,
    function (r) {
      var i = e[1][0] - e[0][0],
        a = e[1][1] - e[0][1],
        o = Math.min(i / (r[1][0] - r[0][0]), a / (r[1][1] - r[0][1])),
        s = +e[0][0] + (i - o * (r[1][0] + r[0][0])) / 2,
        c = +e[0][1] + (a - o * (r[1][1] + r[0][1])) / 2
      t.scale(150 * o).translate([s, c])
    },
    n
  )
}
function S0(t, e, n) {
  return Nu(t, [[0, 0], e], n)
}
function _0(t, e, n) {
  return O0(
    t,
    function (r) {
      var i = +e,
        a = i / (r[1][0] - r[0][0]),
        o = (i - a * (r[1][0] + r[0][0])) / 2,
        s = -a * r[0][1]
      t.scale(150 * a).translate([o, s])
    },
    n
  )
}
function M0(t, e, n) {
  return O0(
    t,
    function (r) {
      var i = +e,
        a = i / (r[1][1] - r[0][1]),
        o = -a * r[0][0],
        s = (i - a * (r[1][1] + r[0][1])) / 2
      t.scale(150 * a).translate([o, s])
    },
    n
  )
}
var qm = 16,
  AG = mt(30 * ie)
function Km(t, e) {
  return +e ? CG(t, e) : kG(t)
}
function kG(t) {
  return Lu({
    point: function (e, n) {
      ;(e = t(e, n)), this.stream.point(e[0], e[1])
    }
  })
}
function CG(t, e) {
  function n(r, i, a, o, s, c, l, u, f, h, d, p, v, g) {
    var y = l - r,
      m = u - i,
      b = y * y + m * m
    if (b > 4 * e && v--) {
      var x = o + h,
        w = s + d,
        O = c + p,
        S = nn(x * x + w * w + O * O),
        _ = Ln((O /= S)),
        M = Tt(Tt(O) - 1) < ct || Tt(a - f) < ct ? (a + f) / 2 : Ar(w, x),
        E = t(M, _),
        T = E[0],
        C = E[1],
        A = T - r,
        P = C - i,
        k = m * A - y * P
      ;((k * k) / b > e || Tt((y * A + m * P) / b - 0.5) > 0.3 || o * h + s * d + c * p < AG) &&
        (n(r, i, a, o, s, c, T, C, M, (x /= S), (w /= S), O, v, g),
        g.point(T, C),
        n(T, C, M, x, w, O, l, u, f, h, d, p, v, g))
    }
  }
  return function (r) {
    var i,
      a,
      o,
      s,
      c,
      l,
      u,
      f,
      h,
      d,
      p,
      v,
      g = {
        point: y,
        lineStart: m,
        lineEnd: x,
        polygonStart: function () {
          r.polygonStart(), (g.lineStart = w)
        },
        polygonEnd: function () {
          r.polygonEnd(), (g.lineStart = m)
        }
      }
    function y(_, M) {
      ;(_ = t(_, M)), r.point(_[0], _[1])
    }
    function m() {
      ;(f = NaN), (g.point = b), r.lineStart()
    }
    function b(_, M) {
      var E = Wa([_, M]),
        T = t(_, M)
      n(
        f,
        h,
        u,
        d,
        p,
        v,
        (f = T[0]),
        (h = T[1]),
        (u = _),
        (d = E[0]),
        (p = E[1]),
        (v = E[2]),
        qm,
        r
      ),
        r.point(f, h)
    }
    function x() {
      ;(g.point = y), r.lineEnd()
    }
    function w() {
      m(), (g.point = O), (g.lineEnd = S)
    }
    function O(_, M) {
      b((i = _), M), (a = f), (o = h), (s = d), (c = p), (l = v), (g.point = b)
    }
    function S() {
      n(f, h, u, d, p, v, a, o, i, s, c, l, qm, r), (g.lineEnd = x), x()
    }
    return g
  }
}
var LG = Lu({
  point: function (t, e) {
    this.stream.point(t * ie, e * ie)
  }
})
function NG(t) {
  return Lu({
    point: function (e, n) {
      var r = t(e, n)
      return this.stream.point(r[0], r[1])
    }
  })
}
function RG(t, e, n, r, i) {
  function a(o, s) {
    return (o *= r), (s *= i), [e + t * o, n - t * s]
  }
  return (
    (a.invert = function (o, s) {
      return [((o - e) / t) * r, ((n - s) / t) * i]
    }),
    a
  )
}
function Zm(t, e, n, r, i, a) {
  if (!a) return RG(t, e, n, r, i)
  var o = mt(a),
    s = pt(a),
    c = o * t,
    l = s * t,
    u = o / t,
    f = s / t,
    h = (s * n - o * e) / t,
    d = (s * e + o * n) / t
  function p(v, g) {
    return (v *= r), (g *= i), [c * v - l * g + e, n - l * v - c * g]
  }
  return (
    (p.invert = function (v, g) {
      return [r * (u * v - f * g + h), i * (d - f * v - u * g)]
    }),
    p
  )
}
function cr(t) {
  return E0(function () {
    return t
  })()
}
function E0(t) {
  var e,
    n = 150,
    r = 480,
    i = 250,
    a = 0,
    o = 0,
    s = 0,
    c = 0,
    l = 0,
    u,
    f = 0,
    h = 1,
    d = 1,
    p = null,
    v = Dm,
    g = null,
    y,
    m,
    b,
    x = ds,
    w = 0.5,
    O,
    S,
    _,
    M,
    E
  function T(k) {
    return _(k[0] * ie, k[1] * ie)
  }
  function C(k) {
    return (k = _.invert(k[0], k[1])), k && [k[0] * Ne, k[1] * Ne]
  }
  ;(T.stream = function (k) {
    return M && E === k ? M : (M = LG(NG(u)(v(O(x((E = k)))))))
  }),
    (T.preclip = function (k) {
      return arguments.length ? ((v = k), (p = void 0), P()) : v
    }),
    (T.postclip = function (k) {
      return arguments.length ? ((x = k), (g = y = m = b = null), P()) : x
    }),
    (T.clipAngle = function (k) {
      return arguments.length ? ((v = +k ? dG((p = k * ie)) : ((p = null), Dm)), P()) : p * Ne
    }),
    (T.clipExtent = function (k) {
      return arguments.length
        ? ((x =
            k == null
              ? ((g = y = m = b = null), ds)
              : hE((g = +k[0][0]), (y = +k[0][1]), (m = +k[1][0]), (b = +k[1][1]))),
          P())
        : g == null
        ? null
        : [
            [g, y],
            [m, b]
          ]
    }),
    (T.scale = function (k) {
      return arguments.length ? ((n = +k), A()) : n
    }),
    (T.translate = function (k) {
      return arguments.length ? ((r = +k[0]), (i = +k[1]), A()) : [r, i]
    }),
    (T.center = function (k) {
      return arguments.length
        ? ((a = (k[0] % 360) * ie), (o = (k[1] % 360) * ie), A())
        : [a * Ne, o * Ne]
    }),
    (T.rotate = function (k) {
      return arguments.length
        ? ((s = (k[0] % 360) * ie),
          (c = (k[1] % 360) * ie),
          (l = k.length > 2 ? (k[2] % 360) * ie : 0),
          A())
        : [s * Ne, c * Ne, l * Ne]
    }),
    (T.angle = function (k) {
      return arguments.length ? ((f = (k % 360) * ie), A()) : f * Ne
    }),
    (T.reflectX = function (k) {
      return arguments.length ? ((h = k ? -1 : 1), A()) : h < 0
    }),
    (T.reflectY = function (k) {
      return arguments.length ? ((d = k ? -1 : 1), A()) : d < 0
    }),
    (T.precision = function (k) {
      return arguments.length ? ((O = Km(S, (w = k * k))), P()) : nn(w)
    }),
    (T.fitExtent = function (k, L) {
      return Nu(T, k, L)
    }),
    (T.fitSize = function (k, L) {
      return S0(T, k, L)
    }),
    (T.fitWidth = function (k, L) {
      return _0(T, k, L)
    }),
    (T.fitHeight = function (k, L) {
      return M0(T, k, L)
    })
  function A() {
    var k = Zm(n, 0, 0, h, d, f).apply(null, e(a, o)),
      L = Zm(n, r - k[0], i - k[1], h, d, f)
    return (u = cE(s, c, l)), (S = fd(e, L)), (_ = fd(u, S)), (O = Km(S, w)), P()
  }
  function P() {
    return (M = E = null), T
  }
  return function () {
    return (e = t.apply(this, arguments)), (T.invert = e.invert && C), A()
  }
}
function T0(t) {
  var e = 0,
    n = xt / 3,
    r = E0(t),
    i = r(e, n)
  return (
    (i.parallels = function (a) {
      return arguments.length ? r((e = a[0] * ie), (n = a[1] * ie)) : [e * Ne, n * Ne]
    }),
    i
  )
}
function IG(t) {
  var e = mt(t)
  function n(r, i) {
    return [r * e, pt(i) / e]
  }
  return (
    (n.invert = function (r, i) {
      return [r / e, Ln(i * e)]
    }),
    n
  )
}
function ME(t, e) {
  var n = pt(t),
    r = (n + pt(e)) / 2
  if (Tt(r) < ct) return IG(t)
  var i = 1 + n * (2 * r - n),
    a = nn(i) / r
  function o(s, c) {
    var l = nn(i - 2 * r * pt(c)) / r
    return [l * pt((s *= r)), a - l * mt(s)]
  }
  return (
    (o.invert = function (s, c) {
      var l = a - c,
        u = Ar(s, Tt(l)) * En(l)
      return (
        l * r < 0 && (u -= xt * En(s) * En(l)), [u / r, Ln((i - (s * s + l * l) * r * r) / (2 * r))]
      )
    }),
    o
  )
}
function $l() {
  return T0(ME).scale(155.424).center([0, 33.6442])
}
function EE() {
  return $l()
    .parallels([29.5, 45.5])
    .scale(1070)
    .translate([480, 250])
    .rotate([96, 0])
    .center([-0.6, 38.7])
}
function jG(t) {
  var e = t.length
  return {
    point: function (n, r) {
      for (var i = -1; ++i < e; ) t[i].point(n, r)
    },
    sphere: function () {
      for (var n = -1; ++n < e; ) t[n].sphere()
    },
    lineStart: function () {
      for (var n = -1; ++n < e; ) t[n].lineStart()
    },
    lineEnd: function () {
      for (var n = -1; ++n < e; ) t[n].lineEnd()
    },
    polygonStart: function () {
      for (var n = -1; ++n < e; ) t[n].polygonStart()
    },
    polygonEnd: function () {
      for (var n = -1; ++n < e; ) t[n].polygonEnd()
    }
  }
}
function DG() {
  var t,
    e,
    n = EE(),
    r,
    i = $l().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
    a,
    o = $l().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
    s,
    c,
    l = {
      point: function (h, d) {
        c = [h, d]
      }
    }
  function u(h) {
    var d = h[0],
      p = h[1]
    return (c = null), r.point(d, p), c || (a.point(d, p), c) || (s.point(d, p), c)
  }
  ;(u.invert = function (h) {
    var d = n.scale(),
      p = n.translate(),
      v = (h[0] - p[0]) / d,
      g = (h[1] - p[1]) / d
    return (
      g >= 0.12 && g < 0.234 && v >= -0.425 && v < -0.214
        ? i
        : g >= 0.166 && g < 0.234 && v >= -0.214 && v < -0.115
        ? o
        : n
    ).invert(h)
  }),
    (u.stream = function (h) {
      return t && e === h ? t : (t = jG([n.stream((e = h)), i.stream(h), o.stream(h)]))
    }),
    (u.precision = function (h) {
      return arguments.length
        ? (n.precision(h), i.precision(h), o.precision(h), f())
        : n.precision()
    }),
    (u.scale = function (h) {
      return arguments.length
        ? (n.scale(h), i.scale(h * 0.35), o.scale(h), u.translate(n.translate()))
        : n.scale()
    }),
    (u.translate = function (h) {
      if (!arguments.length) return n.translate()
      var d = n.scale(),
        p = +h[0],
        v = +h[1]
      return (
        (r = n
          .translate(h)
          .clipExtent([
            [p - 0.455 * d, v - 0.238 * d],
            [p + 0.455 * d, v + 0.238 * d]
          ])
          .stream(l)),
        (a = i
          .translate([p - 0.307 * d, v + 0.201 * d])
          .clipExtent([
            [p - 0.425 * d + ct, v + 0.12 * d + ct],
            [p - 0.214 * d - ct, v + 0.234 * d - ct]
          ])
          .stream(l)),
        (s = o
          .translate([p - 0.205 * d, v + 0.212 * d])
          .clipExtent([
            [p - 0.214 * d + ct, v + 0.166 * d + ct],
            [p - 0.115 * d - ct, v + 0.234 * d - ct]
          ])
          .stream(l)),
        f()
      )
    }),
    (u.fitExtent = function (h, d) {
      return Nu(u, h, d)
    }),
    (u.fitSize = function (h, d) {
      return S0(u, h, d)
    }),
    (u.fitWidth = function (h, d) {
      return _0(u, h, d)
    }),
    (u.fitHeight = function (h, d) {
      return M0(u, h, d)
    })
  function f() {
    return (t = e = null), u
  }
  return u.scale(1070)
}
function TE(t) {
  return function (e, n) {
    var r = mt(e),
      i = mt(n),
      a = t(r * i)
    return a === 1 / 0 ? [2, 0] : [a * i * pt(e), a * pt(n)]
  }
}
function Gs(t) {
  return function (e, n) {
    var r = nn(e * e + n * n),
      i = t(r),
      a = pt(i),
      o = mt(i)
    return [Ar(e * a, r * o), Ln(r && (n * a) / r)]
  }
}
var P0 = TE(function (t) {
  return nn(2 / (1 + t))
})
P0.invert = Gs(function (t) {
  return 2 * Ln(t / 2)
})
function $G() {
  return cr(P0)
    .scale(124.75)
    .clipAngle(180 - 0.001)
}
var A0 = TE(function (t) {
  return (t = sE(t)) && t / pt(t)
})
A0.invert = Gs(function (t) {
  return t
})
function BG() {
  return cr(A0)
    .scale(79.4188)
    .clipAngle(180 - 0.001)
}
function Ws(t, e) {
  return [t, Pl(w0((ue + e) / 2))]
}
Ws.invert = function (t, e) {
  return [t, 2 * io(oE(e)) - ue]
}
function FG() {
  return PE(Ws).scale(961 / yn)
}
function PE(t) {
  var e = cr(t),
    n = e.center,
    r = e.scale,
    i = e.translate,
    a = e.clipExtent,
    o = null,
    s,
    c,
    l
  ;(e.scale = function (f) {
    return arguments.length ? (r(f), u()) : r()
  }),
    (e.translate = function (f) {
      return arguments.length ? (i(f), u()) : i()
    }),
    (e.center = function (f) {
      return arguments.length ? (n(f), u()) : n()
    }),
    (e.clipExtent = function (f) {
      return arguments.length
        ? (f == null
            ? (o = s = c = l = null)
            : ((o = +f[0][0]), (s = +f[0][1]), (c = +f[1][0]), (l = +f[1][1])),
          u())
        : o == null
        ? null
        : [
            [o, s],
            [c, l]
          ]
    })
  function u() {
    var f = xt * r(),
      h = e(aG(e.rotate()).invert([0, 0]))
    return a(
      o == null
        ? [
            [h[0] - f, h[1] - f],
            [h[0] + f, h[1] + f]
          ]
        : t === Ws
        ? [
            [Math.max(h[0] - f, o), s],
            [Math.min(h[0] + f, c), l]
          ]
        : [
            [o, Math.max(h[1] - f, s)],
            [c, Math.min(h[1] + f, l)]
          ]
    )
  }
  return u()
}
function Ac(t) {
  return w0((ue + t) / 2)
}
function AE(t, e) {
  var n = mt(t),
    r = t === e ? pt(t) : Pl(n / mt(e)) / Pl(Ac(e) / Ac(t)),
    i = (n * If(Ac(t), r)) / r
  if (!r) return Ws
  function a(o, s) {
    i > 0 ? s < -ue + ct && (s = -ue + ct) : s > ue - ct && (s = ue - ct)
    var c = i / If(Ac(s), r)
    return [c * pt(r * o), i - c * mt(r * o)]
  }
  return (
    (a.invert = function (o, s) {
      var c = i - s,
        l = En(r) * nn(o * o + c * c),
        u = Ar(o, Tt(c)) * En(c)
      return c * r < 0 && (u -= xt * En(o) * En(c)), [u / r, 2 * io(If(i / l, 1 / r)) - ue]
    }),
    a
  )
}
function zG() {
  return T0(AE).scale(109.5).parallels([30, 30])
}
function vs(t, e) {
  return [t, e]
}
vs.invert = vs
function GG() {
  return cr(vs).scale(152.63)
}
function kE(t, e) {
  var n = mt(t),
    r = t === e ? pt(t) : (n - mt(e)) / (e - t),
    i = n / r + t
  if (Tt(r) < ct) return vs
  function a(o, s) {
    var c = i - s,
      l = r * o
    return [c * pt(l), i - c * mt(l)]
  }
  return (
    (a.invert = function (o, s) {
      var c = i - s,
        l = Ar(o, Tt(c)) * En(c)
      return c * r < 0 && (l -= xt * En(o) * En(c)), [l / r, i - En(r) * nn(o * o + c * c)]
    }),
    a
  )
}
function WG() {
  return T0(kE).scale(131.154).center([0, 13.9389])
}
var $o = 1.340264,
  Bo = -0.081106,
  Fo = 893e-6,
  zo = 0.003796,
  Bl = nn(3) / 2,
  YG = 12
function k0(t, e) {
  var n = Ln(Bl * pt(e)),
    r = n * n,
    i = r * r * r
  return [
    (t * mt(n)) / (Bl * ($o + 3 * Bo * r + i * (7 * Fo + 9 * zo * r))),
    n * ($o + Bo * r + i * (Fo + zo * r))
  ]
}
k0.invert = function (t, e) {
  for (
    var n = e, r = n * n, i = r * r * r, a = 0, o, s, c;
    a < YG &&
    ((s = n * ($o + Bo * r + i * (Fo + zo * r)) - e),
    (c = $o + 3 * Bo * r + i * (7 * Fo + 9 * zo * r)),
    (n -= o = s / c),
    (r = n * n),
    (i = r * r * r),
    !(Tt(o) < aE));
    ++a
  );
  return [(Bl * t * ($o + 3 * Bo * r + i * (7 * Fo + 9 * zo * r))) / mt(n), Ln(pt(n) / Bl)]
}
function HG() {
  return cr(k0).scale(177.158)
}
function C0(t, e) {
  var n = mt(e),
    r = mt(t) * n
  return [(n * pt(t)) / r, pt(e) / r]
}
C0.invert = Gs(io)
function VG() {
  return cr(C0).scale(144.049).clipAngle(60)
}
function XG() {
  var t = 1,
    e = 0,
    n = 0,
    r = 1,
    i = 1,
    a = 0,
    o,
    s,
    c = null,
    l,
    u,
    f,
    h = 1,
    d = 1,
    p = Lu({
      point: function (x, w) {
        var O = b([x, w])
        this.stream.point(O[0], O[1])
      }
    }),
    v = ds,
    g,
    y
  function m() {
    return (h = t * r), (d = t * i), (g = y = null), b
  }
  function b(x) {
    var w = x[0] * h,
      O = x[1] * d
    if (a) {
      var S = O * o - w * s
      ;(w = w * o + O * s), (O = S)
    }
    return [w + e, O + n]
  }
  return (
    (b.invert = function (x) {
      var w = x[0] - e,
        O = x[1] - n
      if (a) {
        var S = O * o + w * s
        ;(w = w * o - O * s), (O = S)
      }
      return [w / h, O / d]
    }),
    (b.stream = function (x) {
      return g && y === x ? g : (g = p(v((y = x))))
    }),
    (b.postclip = function (x) {
      return arguments.length ? ((v = x), (c = l = u = f = null), m()) : v
    }),
    (b.clipExtent = function (x) {
      return arguments.length
        ? ((v =
            x == null
              ? ((c = l = u = f = null), ds)
              : hE((c = +x[0][0]), (l = +x[0][1]), (u = +x[1][0]), (f = +x[1][1]))),
          m())
        : c == null
        ? null
        : [
            [c, l],
            [u, f]
          ]
    }),
    (b.scale = function (x) {
      return arguments.length ? ((t = +x), m()) : t
    }),
    (b.translate = function (x) {
      return arguments.length ? ((e = +x[0]), (n = +x[1]), m()) : [e, n]
    }),
    (b.angle = function (x) {
      return arguments.length ? ((a = (x % 360) * ie), (s = pt(a)), (o = mt(a)), m()) : a * Ne
    }),
    (b.reflectX = function (x) {
      return arguments.length ? ((r = x ? -1 : 1), m()) : r < 0
    }),
    (b.reflectY = function (x) {
      return arguments.length ? ((i = x ? -1 : 1), m()) : i < 0
    }),
    (b.fitExtent = function (x, w) {
      return Nu(b, x, w)
    }),
    (b.fitSize = function (x, w) {
      return S0(b, x, w)
    }),
    (b.fitWidth = function (x, w) {
      return _0(b, x, w)
    }),
    (b.fitHeight = function (x, w) {
      return M0(b, x, w)
    }),
    b
  )
}
function L0(t, e) {
  var n = e * e,
    r = n * n
  return [
    t * (0.8707 - 0.131979 * n + r * (-0.013791 + r * (0.003971 * n - 0.001529 * r))),
    e * (1.007226 + n * (0.015085 + r * (-0.044475 + 0.028874 * n - 0.005916 * r)))
  ]
}
L0.invert = function (t, e) {
  var n = e,
    r = 25,
    i
  do {
    var a = n * n,
      o = a * a
    n -= i =
      (n * (1.007226 + a * (0.015085 + o * (-0.044475 + 0.028874 * a - 0.005916 * o))) - e) /
      (1.007226 + a * (0.015085 * 3 + o * (-0.044475 * 7 + 0.028874 * 9 * a - 0.005916 * 11 * o)))
  } while (Tt(i) > ct && --r > 0)
  return [
    t /
      (0.8707 +
        (a = n * n) * (-0.131979 + a * (-0.013791 + a * a * a * (0.003971 - 0.001529 * a)))),
    n
  ]
}
function UG() {
  return cr(L0).scale(175.295)
}
function N0(t, e) {
  return [mt(e) * pt(t), pt(e)]
}
N0.invert = Gs(Ln)
function qG() {
  return cr(N0)
    .scale(249.5)
    .clipAngle(90 + ct)
}
function R0(t, e) {
  var n = mt(e),
    r = 1 + mt(t) * n
  return [(n * pt(t)) / r, pt(e) / r]
}
R0.invert = Gs(function (t) {
  return 2 * io(t)
})
function KG() {
  return cr(R0).scale(250).clipAngle(142)
}
function I0(t, e) {
  return [Pl(w0((ue + e) / 2)), -t]
}
I0.invert = function (t, e) {
  return [-e, 2 * io(oE(t)) - ue]
}
function ZG() {
  var t = PE(I0),
    e = t.center,
    n = t.rotate
  return (
    (t.center = function (r) {
      return arguments.length ? e([-r[1], r[0]]) : ((r = e()), [r[1], -r[0]])
    }),
    (t.rotate = function (r) {
      return arguments.length
        ? n([r[0], r[1], r.length > 2 ? r[2] + 90 : 90])
        : ((r = n()), [r[0], r[1], r[2] - 90])
    }),
    n([0, 0, 90]).scale(159.155)
  )
}
const QG = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      geoAlbers: EE,
      geoAlbersUsa: DG,
      geoAzimuthalEqualArea: $G,
      geoAzimuthalEqualAreaRaw: P0,
      geoAzimuthalEquidistant: BG,
      geoAzimuthalEquidistantRaw: A0,
      geoConicConformal: zG,
      geoConicConformalRaw: AE,
      geoConicEqualArea: $l,
      geoConicEqualAreaRaw: ME,
      geoConicEquidistant: WG,
      geoConicEquidistantRaw: kE,
      geoEqualEarth: HG,
      geoEqualEarthRaw: k0,
      geoEquirectangular: GG,
      geoEquirectangularRaw: vs,
      geoGnomonic: VG,
      geoGnomonicRaw: C0,
      geoIdentity: XG,
      geoMercator: FG,
      geoMercatorRaw: Ws,
      geoNaturalEarth1: UG,
      geoNaturalEarth1Raw: L0,
      geoOrthographic: qG,
      geoOrthographicRaw: N0,
      geoProjection: cr,
      geoProjectionMutator: E0,
      geoStereographic: KG,
      geoStereographicRaw: R0,
      geoTransverseMercator: ZG,
      geoTransverseMercatorRaw: I0
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
var JG =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function tW(t) {
  if (typeof t == 'function') return t
  const e = `geo${ni(t)}`,
    n = QG[e]
  if (!n) throw new Error(`Unknown coordinate: ${t}`)
  return n
}
function eW(t) {
  return { type: 'FeatureCollection', features: t.flatMap((e) => nW(e).features) }
}
function nW(t) {
  const e = {
    Point: 'geometry',
    MultiPoint: 'geometry',
    LineString: 'geometry',
    MultiLineString: 'geometry',
    Polygon: 'geometry',
    MultiPolygon: 'geometry',
    GeometryCollection: 'geometry',
    Feature: 'feature',
    FeatureCollection: 'featureCollection'
  }
  if (!t || !t.type) return null
  const n = e[t.type]
  if (!n) return null
  if (n === 'geometry')
    return {
      type: 'FeatureCollection',
      features: [{ type: 'Feature', properties: {}, geometry: t }]
    }
  if (n === 'feature') return { type: 'FeatureCollection', features: [t] }
  if (n === 'featureCollection') return t
}
function rW(t, e) {
  var n
  for (const [r, i] of Object.entries(e)) (n = t[r]) === null || n === void 0 || n.call(t, i)
}
function iW(t, e, n, r) {
  const i = () => {
      const s = e.filter(CE)
      return s.find((l) => l.sphere)
        ? { type: 'Sphere' }
        : eW(s.filter((l) => !l.sphere).flatMap((l) => l.data.value))
    },
    { outline: a = i() } = r,
    { size: o = 'fitExtent' } = r
  if (o === 'fitExtent') return aW(t, a, n)
  if (o === 'fitWidth') return oW(t, a, n)
}
function aW(t, e, n) {
  const { x: r, y: i, width: a, height: o } = n
  t.fitExtent(
    [
      [r, i],
      [a, o]
    ],
    e
  )
}
function oW(t, e, n) {
  const { width: r, height: i } = n,
    [[a, o], [s, c]] = _E(t.fitWidth(r, e)).bounds(e),
    l = Math.ceil(c - o),
    u = Math.min(Math.ceil(s - a), l),
    f = (t.scale() * (u - 1)) / u,
    [h, d] = t.translate(),
    p = d + (i - l) / 2
  t.scale(f).translate([h, p]).precision(0.2)
}
function sW(t) {
  const { data: e } = t
  if (Array.isArray(e)) return Object.assign(Object.assign({}, t), { data: { value: e } })
  const { type: n } = e
  return n === 'graticule10'
    ? Object.assign(Object.assign({}, t), { data: { value: [gG()] } })
    : n === 'sphere'
    ? Object.assign(Object.assign({}, t), { sphere: !0, data: { value: [{ type: 'Sphere' }] } })
    : t
}
function CE(t) {
  return t.type === 'geoPath'
}
const LE = () => (t) => {
  const { children: e, coordinate: n = {} } = t
  if (!Array.isArray(e)) return []
  const { type: r = 'equalEarth' } = n,
    i = JG(n, ['type']),
    a = tW(r),
    o = e.map(sW)
  let s
  function c() {
    return [
      [
        'custom',
        (f, h, d, p) => {
          const v = a()
          iW(v, o, { x: f, y: h, width: d, height: p }, i), rW(v, i), (s = _E(v))
          const y = new Ft({ domain: [f, f + d] }),
            m = new Ft({ domain: [h, h + p] }),
            b = (w) => {
              const O = v(w)
              if (!O) return [null, null]
              const [S, _] = O
              return [y.map(S), m.map(_)]
            },
            x = (w) => {
              if (!w) return null
              const [O, S] = w,
                _ = [y.invert(O), m.invert(S)]
              return v.invert(_)
            }
          return { transform: (w) => b(w), untransform: (w) => x(w) }
        }
      ]
    ]
  }
  function l(f) {
    const { style: h, tooltip: d = {} } = f
    return Object.assign(Object.assign({}, f), {
      type: 'path',
      tooltip: n0(d, { title: 'id', items: [{ channel: 'color' }] }),
      style: Object.assign(Object.assign({}, h), { d: (p) => s(p) || [] })
    })
  }
  const u = (f) => (CE(f) ? l(f) : f)
  return [
    Object.assign(Object.assign({}, t), {
      type: 'view',
      scale: { x: { type: 'identity' }, y: { type: 'identity' } },
      axis: !1,
      coordinate: { type: c },
      children: o.flatMap(u)
    })
  ]
}
LE.props = {}
function NE(t, e) {
  const { __data__: n } = t,
    { markKey: r, index: i, seriesIndex: a } = n,
    { markState: o } = e,
    s = Array.from(o.keys()).find((c) => c.key === r)
  if (s) return a ? a.map((c) => s.data[c]) : s.data[i]
}
function RE(t, e) {
  if (e(t)) return t
  let n = t.parent
  for (; n && !e(n); ) n = n.parent
  return n
}
function cW(t) {
  return RE(t, (e) => e.className === 'component')
}
function lW(t) {
  return RE(t, (e) => e.className === 'element')
}
function Oe(t, e, n, r = (i) => !0) {
  return (i) => {
    if (!r(i)) return
    n.emit(`plot:${t}`, i)
    const { target: a } = i
    if (!a) return
    const { className: o } = a
    if (o === 'plot') return
    const s = lW(a),
      c = cW(a),
      l = s || c
    if (!l) return
    const { className: u, markType: f } = l
    if (u === 'element') {
      const h = Object.assign(Object.assign({}, i), { nativeEvent: !0, data: { data: NE(l, e) } })
      n.emit(`element:${t}`, h), n.emit(`${f}:${t}`, h)
    } else {
      const h = Object.assign(Object.assign({}, i), { nativeEvent: !0 })
      n.emit(`component:${t}`, h), n.emit(`${o}:${t}`, h)
    }
  }
}
function uW() {
  return (t, e, n) => {
    const { container: r, view: i } = t,
      a = Oe(Lt.CLICK, i, n, (S) => S.detail === 1),
      o = Oe(Lt.DBLCLICK, i, n, (S) => S.detail === 2),
      s = Oe(Lt.POINTER_TAP, i, n),
      c = Oe(Lt.POINTER_DOWN, i, n),
      l = Oe(Lt.POINTER_UP, i, n),
      u = Oe(Lt.POINTER_OVER, i, n),
      f = Oe(Lt.POINTER_OUT, i, n),
      h = Oe(Lt.POINTER_MOVE, i, n),
      d = Oe(Lt.POINTER_ENTER, i, n),
      p = Oe(Lt.POINTER_LEAVE, i, n),
      v = Oe(Lt.POINTER_UPOUTSIDE, i, n),
      g = Oe(Lt.DRAG_START, i, n),
      y = Oe(Lt.DRAG, i, n),
      m = Oe(Lt.DRAG_END, i, n),
      b = Oe(Lt.DRAG_ENTER, i, n),
      x = Oe(Lt.DRAG_LEAVE, i, n),
      w = Oe(Lt.DRAG_OVER, i, n),
      O = Oe(Lt.DROP, i, n)
    return (
      r.addEventListener('click', a),
      r.addEventListener('click', o),
      r.addEventListener('pointertap', s),
      r.addEventListener('pointerdown', c),
      r.addEventListener('pointerup', l),
      r.addEventListener('pointerover', u),
      r.addEventListener('pointerout', f),
      r.addEventListener('pointermove', h),
      r.addEventListener('pointerenter', d),
      r.addEventListener('pointerleave', p),
      r.addEventListener('pointerupoutside', v),
      r.addEventListener('dragstart', g),
      r.addEventListener('drag', y),
      r.addEventListener('dragend', m),
      r.addEventListener('dragenter', b),
      r.addEventListener('dragleave', x),
      r.addEventListener('dragover', w),
      r.addEventListener('drop', O),
      () => {
        r.removeEventListener('click', a),
          r.removeEventListener('click', o),
          r.removeEventListener('pointertap', s),
          r.removeEventListener('pointerdown', c),
          r.removeEventListener('pointerup', l),
          r.removeEventListener('pointerover', u),
          r.removeEventListener('pointerout', f),
          r.removeEventListener('pointermove', h),
          r.removeEventListener('pointerenter', d),
          r.removeEventListener('pointerleave', p),
          r.removeEventListener('pointerupoutside', v),
          r.removeEventListener('dragstart', g),
          r.removeEventListener('drag', y),
          r.removeEventListener('dragend', m),
          r.removeEventListener('dragenter', b),
          r.removeEventListener('dragleave', x),
          r.removeEventListener('dragover', w),
          r.removeEventListener('drop', O)
      }
    )
  }
}
function fW() {
  return {
    'component.axisRadar': wM,
    'component.axisLinear': ui,
    'component.axisArc': mM,
    'component.legendContinuousBlock': OM,
    'component.legendContinuousBlockSize': SM,
    'component.legendContinuousSize': f0,
    'interaction.event': uW,
    'composition.mark': JM,
    'composition.view': QM,
    'shape.label.label': xS
  }
}
var hW =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function Kt(t, e) {
  const n = Object.assign(Object.assign({}, fW()), e),
    r = (a) => {
      if (typeof a != 'string') return a
      const o = `${t}.${a}`
      return n[o] || ql(`Unknown Component: ${o}`)
    }
  return [
    (a, o) => {
      const { type: s } = a,
        c = hW(a, ['type'])
      return r(s)(c, o)
    },
    r
  ]
}
function IE(t) {
  const { canvas: e, group: n } = t
  return n ? n.ownerDocument : e.document
}
var Qm =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function dW(t, e, n) {
  const [r] = Kt('coordinate', n),
    { innerHeight: i, innerWidth: a, insetLeft: o, insetTop: s, insetRight: c, insetBottom: l } = t,
    { coordinates: u = [] } = e,
    f = bW(u),
    h = f[0].type === 'cartesian3D',
    d = Object.assign(Object.assign({}, t), {
      x: o,
      y: s,
      width: a - o - c,
      height: i - l - s,
      transformations: f.flatMap(r)
    })
  return h ? new Rz(d) : new Lz(d)
}
function jE(t, e) {
  const { coordinate: n = {} } = t,
    r = Qm(t, ['coordinate']),
    { type: i, transform: a = [] } = n,
    o = Qm(n, ['type', 'transform'])
  if (!i) return Object.assign(Object.assign({}, r), { coordinates: a })
  const [, s] = Kt('coordinate', e),
    { transform: c = !1 } = s(i).props || {}
  if (c) throw new Error(`Unknown coordinate: ${i}.`)
  return Object.assign(Object.assign({}, r), { coordinates: [Object.assign({ type: i }, o), ...a] })
}
function Yn(t, e) {
  return t.filter((n) => n.type === e)
}
function _i(t) {
  return Yn(t, 'polar').length > 0
}
function pW(t) {
  return Yn(t, 'helix').length > 0
}
function Oa(t) {
  return Yn(t, 'transpose').length % 2 === 1
}
function vW(t) {
  return Yn(t, 'parallel').length > 0
}
function DE(t) {
  return Yn(t, 'theta').length > 0
}
function gW(t) {
  return Yn(t, 'reflect').length > 0
}
function Go(t) {
  return Yn(t, 'radial').length > 0
}
function yW(t) {
  return Yn(t, 'radar').length > 0
}
function mW(t) {
  return Yn(t, 'reflectY').length > 0
}
function bW(t) {
  return t.find((e) => e.type === 'cartesian' || e.type === 'cartesian3D')
    ? t
    : [...t, { type: 'cartesian' }]
}
function gt(t) {
  for (var e = (t.length / 6) | 0, n = new Array(e), r = 0; r < e; )
    n[r] = '#' + t.slice(r * 6, ++r * 6)
  return n
}
const xW = gt('1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf'),
  wW = gt('7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666'),
  OW = gt('1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666'),
  SW = gt('a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928'),
  _W = gt('fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2'),
  MW = gt('b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc'),
  EW = gt('e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999'),
  TW = gt('66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3'),
  PW = gt('8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f'),
  AW = gt('4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab')
function Ru(t, e, n) {
  ;(t.prototype = e.prototype = n), (n.constructor = t)
}
function j0(t, e) {
  var n = Object.create(t.prototype)
  for (var r in e) n[r] = e[r]
  return n
}
function ao() {}
var Gi = 0.7,
  Ha = 1 / Gi,
  Sa = '\\s*([+-]?\\d+)\\s*',
  gs = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*',
  or = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*',
  kW = /^#([0-9a-f]{3,8})$/,
  CW = new RegExp(`^rgb\\(${Sa},${Sa},${Sa}\\)$`),
  LW = new RegExp(`^rgb\\(${or},${or},${or}\\)$`),
  NW = new RegExp(`^rgba\\(${Sa},${Sa},${Sa},${gs}\\)$`),
  RW = new RegExp(`^rgba\\(${or},${or},${or},${gs}\\)$`),
  IW = new RegExp(`^hsl\\(${gs},${or},${or}\\)$`),
  jW = new RegExp(`^hsla\\(${gs},${or},${or},${gs}\\)$`),
  Jm = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  }
Ru(ao, D0, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t)
  },
  displayable() {
    return this.rgb().displayable()
  },
  hex: t1,
  formatHex: t1,
  formatHex8: DW,
  formatHsl: $W,
  formatRgb: e1,
  toString: e1
})
function t1() {
  return this.rgb().formatHex()
}
function DW() {
  return this.rgb().formatHex8()
}
function $W() {
  return BE(this).formatHsl()
}
function e1() {
  return this.rgb().formatRgb()
}
function D0(t) {
  var e, n
  return (
    (t = (t + '').trim().toLowerCase()),
    (e = kW.exec(t))
      ? ((n = e[1].length),
        (e = parseInt(e[1], 16)),
        n === 6
          ? n1(e)
          : n === 3
          ? new Ie(
              ((e >> 8) & 15) | ((e >> 4) & 240),
              ((e >> 4) & 15) | (e & 240),
              ((e & 15) << 4) | (e & 15),
              1
            )
          : n === 8
          ? kc((e >> 24) & 255, (e >> 16) & 255, (e >> 8) & 255, (e & 255) / 255)
          : n === 4
          ? kc(
              ((e >> 12) & 15) | ((e >> 8) & 240),
              ((e >> 8) & 15) | ((e >> 4) & 240),
              ((e >> 4) & 15) | (e & 240),
              (((e & 15) << 4) | (e & 15)) / 255
            )
          : null)
      : (e = CW.exec(t))
      ? new Ie(e[1], e[2], e[3], 1)
      : (e = LW.exec(t))
      ? new Ie((e[1] * 255) / 100, (e[2] * 255) / 100, (e[3] * 255) / 100, 1)
      : (e = NW.exec(t))
      ? kc(e[1], e[2], e[3], e[4])
      : (e = RW.exec(t))
      ? kc((e[1] * 255) / 100, (e[2] * 255) / 100, (e[3] * 255) / 100, e[4])
      : (e = IW.exec(t))
      ? a1(e[1], e[2] / 100, e[3] / 100, 1)
      : (e = jW.exec(t))
      ? a1(e[1], e[2] / 100, e[3] / 100, e[4])
      : Jm.hasOwnProperty(t)
      ? n1(Jm[t])
      : t === 'transparent'
      ? new Ie(NaN, NaN, NaN, 0)
      : null
  )
}
function n1(t) {
  return new Ie((t >> 16) & 255, (t >> 8) & 255, t & 255, 1)
}
function kc(t, e, n, r) {
  return r <= 0 && (t = e = n = NaN), new Ie(t, e, n, r)
}
function $E(t) {
  return (
    t instanceof ao || (t = D0(t)), t ? ((t = t.rgb()), new Ie(t.r, t.g, t.b, t.opacity)) : new Ie()
  )
}
function ys(t, e, n, r) {
  return arguments.length === 1 ? $E(t) : new Ie(t, e, n, r ?? 1)
}
function Ie(t, e, n, r) {
  ;(this.r = +t), (this.g = +e), (this.b = +n), (this.opacity = +r)
}
Ru(
  Ie,
  ys,
  j0(ao, {
    brighter(t) {
      return (
        (t = t == null ? Ha : Math.pow(Ha, t)),
        new Ie(this.r * t, this.g * t, this.b * t, this.opacity)
      )
    },
    darker(t) {
      return (
        (t = t == null ? Gi : Math.pow(Gi, t)),
        new Ie(this.r * t, this.g * t, this.b * t, this.opacity)
      )
    },
    rgb() {
      return this
    },
    clamp() {
      return new Ie(Pi(this.r), Pi(this.g), Pi(this.b), Fl(this.opacity))
    },
    displayable() {
      return (
        -0.5 <= this.r &&
        this.r < 255.5 &&
        -0.5 <= this.g &&
        this.g < 255.5 &&
        -0.5 <= this.b &&
        this.b < 255.5 &&
        0 <= this.opacity &&
        this.opacity <= 1
      )
    },
    hex: r1,
    formatHex: r1,
    formatHex8: BW,
    formatRgb: i1,
    toString: i1
  })
)
function r1() {
  return `#${Mi(this.r)}${Mi(this.g)}${Mi(this.b)}`
}
function BW() {
  return `#${Mi(this.r)}${Mi(this.g)}${Mi(this.b)}${Mi(
    (isNaN(this.opacity) ? 1 : this.opacity) * 255
  )}`
}
function i1() {
  const t = Fl(this.opacity)
  return `${t === 1 ? 'rgb(' : 'rgba('}${Pi(this.r)}, ${Pi(this.g)}, ${Pi(this.b)}${
    t === 1 ? ')' : `, ${t})`
  }`
}
function Fl(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t))
}
function Pi(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0))
}
function Mi(t) {
  return (t = Pi(t)), (t < 16 ? '0' : '') + t.toString(16)
}
function a1(t, e, n, r) {
  return (
    r <= 0 ? (t = e = n = NaN) : n <= 0 || n >= 1 ? (t = e = NaN) : e <= 0 && (t = NaN),
    new Fn(t, e, n, r)
  )
}
function BE(t) {
  if (t instanceof Fn) return new Fn(t.h, t.s, t.l, t.opacity)
  if ((t instanceof ao || (t = D0(t)), !t)) return new Fn()
  if (t instanceof Fn) return t
  t = t.rgb()
  var e = t.r / 255,
    n = t.g / 255,
    r = t.b / 255,
    i = Math.min(e, n, r),
    a = Math.max(e, n, r),
    o = NaN,
    s = a - i,
    c = (a + i) / 2
  return (
    s
      ? (e === a
          ? (o = (n - r) / s + (n < r) * 6)
          : n === a
          ? (o = (r - e) / s + 2)
          : (o = (e - n) / s + 4),
        (s /= c < 0.5 ? a + i : 2 - a - i),
        (o *= 60))
      : (s = c > 0 && c < 1 ? 0 : o),
    new Fn(o, s, c, t.opacity)
  )
}
function FW(t, e, n, r) {
  return arguments.length === 1 ? BE(t) : new Fn(t, e, n, r ?? 1)
}
function Fn(t, e, n, r) {
  ;(this.h = +t), (this.s = +e), (this.l = +n), (this.opacity = +r)
}
Ru(
  Fn,
  FW,
  j0(ao, {
    brighter(t) {
      return (
        (t = t == null ? Ha : Math.pow(Ha, t)), new Fn(this.h, this.s, this.l * t, this.opacity)
      )
    },
    darker(t) {
      return (
        (t = t == null ? Gi : Math.pow(Gi, t)), new Fn(this.h, this.s, this.l * t, this.opacity)
      )
    },
    rgb() {
      var t = (this.h % 360) + (this.h < 0) * 360,
        e = isNaN(t) || isNaN(this.s) ? 0 : this.s,
        n = this.l,
        r = n + (n < 0.5 ? n : 1 - n) * e,
        i = 2 * n - r
      return new Ie(
        Ff(t >= 240 ? t - 240 : t + 120, i, r),
        Ff(t, i, r),
        Ff(t < 120 ? t + 240 : t - 120, i, r),
        this.opacity
      )
    },
    clamp() {
      return new Fn(o1(this.h), Cc(this.s), Cc(this.l), Fl(this.opacity))
    },
    displayable() {
      return (
        ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
        0 <= this.l &&
        this.l <= 1 &&
        0 <= this.opacity &&
        this.opacity <= 1
      )
    },
    formatHsl() {
      const t = Fl(this.opacity)
      return `${t === 1 ? 'hsl(' : 'hsla('}${o1(this.h)}, ${Cc(this.s) * 100}%, ${
        Cc(this.l) * 100
      }%${t === 1 ? ')' : `, ${t})`}`
    }
  })
)
function o1(t) {
  return (t = (t || 0) % 360), t < 0 ? t + 360 : t
}
function Cc(t) {
  return Math.max(0, Math.min(1, t || 0))
}
function Ff(t, e, n) {
  return (
    (t < 60 ? e + ((n - e) * t) / 60 : t < 180 ? n : t < 240 ? e + ((n - e) * (240 - t)) / 60 : e) *
    255
  )
}
const zW = Math.PI / 180,
  GW = 180 / Math.PI
var FE = -0.14861,
  $0 = 1.78277,
  B0 = -0.29227,
  Iu = -0.90649,
  ms = 1.97294,
  s1 = ms * Iu,
  c1 = ms * $0,
  l1 = $0 * B0 - Iu * FE
function WW(t) {
  if (t instanceof Ai) return new Ai(t.h, t.s, t.l, t.opacity)
  t instanceof Ie || (t = $E(t))
  var e = t.r / 255,
    n = t.g / 255,
    r = t.b / 255,
    i = (l1 * r + s1 * e - c1 * n) / (l1 + s1 - c1),
    a = r - i,
    o = (ms * (n - i) - B0 * a) / Iu,
    s = Math.sqrt(o * o + a * a) / (ms * i * (1 - i)),
    c = s ? Math.atan2(o, a) * GW - 120 : NaN
  return new Ai(c < 0 ? c + 360 : c, s, i, t.opacity)
}
function sr(t, e, n, r) {
  return arguments.length === 1 ? WW(t) : new Ai(t, e, n, r ?? 1)
}
function Ai(t, e, n, r) {
  ;(this.h = +t), (this.s = +e), (this.l = +n), (this.opacity = +r)
}
Ru(
  Ai,
  sr,
  j0(ao, {
    brighter(t) {
      return (
        (t = t == null ? Ha : Math.pow(Ha, t)), new Ai(this.h, this.s, this.l * t, this.opacity)
      )
    },
    darker(t) {
      return (
        (t = t == null ? Gi : Math.pow(Gi, t)), new Ai(this.h, this.s, this.l * t, this.opacity)
      )
    },
    rgb() {
      var t = isNaN(this.h) ? 0 : (this.h + 120) * zW,
        e = +this.l,
        n = isNaN(this.s) ? 0 : this.s * e * (1 - e),
        r = Math.cos(t),
        i = Math.sin(t)
      return new Ie(
        255 * (e + n * (FE * r + $0 * i)),
        255 * (e + n * (B0 * r + Iu * i)),
        255 * (e + n * (ms * r)),
        this.opacity
      )
    }
  })
)
function YW(t, e, n, r, i) {
  var a = t * t,
    o = a * t
  return (
    ((1 - 3 * t + 3 * a - o) * e +
      (4 - 6 * a + 3 * o) * n +
      (1 + 3 * t + 3 * a - 3 * o) * r +
      o * i) /
    6
  )
}
function HW(t) {
  var e = t.length - 1
  return function (n) {
    var r = n <= 0 ? (n = 0) : n >= 1 ? ((n = 1), e - 1) : Math.floor(n * e),
      i = t[r],
      a = t[r + 1],
      o = r > 0 ? t[r - 1] : 2 * i - a,
      s = r < e - 1 ? t[r + 2] : 2 * a - i
    return YW((n - r / e) * e, o, i, a, s)
  }
}
const F0 = (t) => () => t
function zE(t, e) {
  return function (n) {
    return t + n * e
  }
}
function VW(t, e, n) {
  return (
    (t = Math.pow(t, n)),
    (e = Math.pow(e, n) - t),
    (n = 1 / n),
    function (r) {
      return Math.pow(t + r * e, n)
    }
  )
}
function XW(t, e) {
  var n = e - t
  return n ? zE(t, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : F0(isNaN(t) ? e : t)
}
function UW(t) {
  return (t = +t) == 1
    ? _a
    : function (e, n) {
        return n - e ? VW(e, n, t) : F0(isNaN(e) ? n : e)
      }
}
function _a(t, e) {
  var n = e - t
  return n ? zE(t, n) : F0(isNaN(t) ? e : t)
}
;(function t(e) {
  var n = UW(e)
  function r(i, a) {
    var o = n((i = ys(i)).r, (a = ys(a)).r),
      s = n(i.g, a.g),
      c = n(i.b, a.b),
      l = _a(i.opacity, a.opacity)
    return function (u) {
      return (i.r = o(u)), (i.g = s(u)), (i.b = c(u)), (i.opacity = l(u)), i + ''
    }
  }
  return (r.gamma = t), r
})(1)
function qW(t) {
  return function (e) {
    var n = e.length,
      r = new Array(n),
      i = new Array(n),
      a = new Array(n),
      o,
      s
    for (o = 0; o < n; ++o) (s = ys(e[o])), (r[o] = s.r || 0), (i[o] = s.g || 0), (a[o] = s.b || 0)
    return (
      (r = t(r)),
      (i = t(i)),
      (a = t(a)),
      (s.opacity = 1),
      function (c) {
        return (s.r = r(c)), (s.g = i(c)), (s.b = a(c)), s + ''
      }
    )
  }
}
var KW = qW(HW)
function GE(t) {
  return (function e(n) {
    n = +n
    function r(i, a) {
      var o = t((i = sr(i)).h, (a = sr(a)).h),
        s = _a(i.s, a.s),
        c = _a(i.l, a.l),
        l = _a(i.opacity, a.opacity)
      return function (u) {
        return (i.h = o(u)), (i.s = s(u)), (i.l = c(Math.pow(u, n))), (i.opacity = l(u)), i + ''
      }
    }
    return (r.gamma = e), r
  })(1)
}
GE(XW)
var z0 = GE(_a)
const Wt = (t) => KW(t[t.length - 1])
var WE = new Array(3)
  .concat(
    'd8b365f5f5f55ab4ac',
    'a6611adfc27d80cdc1018571',
    'a6611adfc27df5f5f580cdc1018571',
    '8c510ad8b365f6e8c3c7eae55ab4ac01665e',
    '8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e',
    '8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e',
    '8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e',
    '5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30',
    '5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30'
  )
  .map(gt)
const ZW = Wt(WE)
var YE = new Array(3)
  .concat(
    'af8dc3f7f7f77fbf7b',
    '7b3294c2a5cfa6dba0008837',
    '7b3294c2a5cff7f7f7a6dba0008837',
    '762a83af8dc3e7d4e8d9f0d37fbf7b1b7837',
    '762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837',
    '762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837',
    '762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837',
    '40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b',
    '40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b'
  )
  .map(gt)
const QW = Wt(YE)
var HE = new Array(3)
  .concat(
    'e9a3c9f7f7f7a1d76a',
    'd01c8bf1b6dab8e1864dac26',
    'd01c8bf1b6daf7f7f7b8e1864dac26',
    'c51b7de9a3c9fde0efe6f5d0a1d76a4d9221',
    'c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221',
    'c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221',
    'c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221',
    '8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419',
    '8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419'
  )
  .map(gt)
const JW = Wt(HE)
var VE = new Array(3)
  .concat(
    '998ec3f7f7f7f1a340',
    '5e3c99b2abd2fdb863e66101',
    '5e3c99b2abd2f7f7f7fdb863e66101',
    '542788998ec3d8daebfee0b6f1a340b35806',
    '542788998ec3d8daebf7f7f7fee0b6f1a340b35806',
    '5427888073acb2abd2d8daebfee0b6fdb863e08214b35806',
    '5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806',
    '2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08',
    '2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08'
  )
  .map(gt)
const tY = Wt(VE)
var XE = new Array(3)
  .concat(
    'ef8a62f7f7f767a9cf',
    'ca0020f4a58292c5de0571b0',
    'ca0020f4a582f7f7f792c5de0571b0',
    'b2182bef8a62fddbc7d1e5f067a9cf2166ac',
    'b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac',
    'b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac',
    'b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac',
    '67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061',
    '67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061'
  )
  .map(gt)
const eY = Wt(XE)
var UE = new Array(3)
  .concat(
    'ef8a62ffffff999999',
    'ca0020f4a582bababa404040',
    'ca0020f4a582ffffffbababa404040',
    'b2182bef8a62fddbc7e0e0e09999994d4d4d',
    'b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d',
    'b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d',
    'b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d',
    '67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a',
    '67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a'
  )
  .map(gt)
const nY = Wt(UE)
var qE = new Array(3)
  .concat(
    'fc8d59ffffbf91bfdb',
    'd7191cfdae61abd9e92c7bb6',
    'd7191cfdae61ffffbfabd9e92c7bb6',
    'd73027fc8d59fee090e0f3f891bfdb4575b4',
    'd73027fc8d59fee090ffffbfe0f3f891bfdb4575b4',
    'd73027f46d43fdae61fee090e0f3f8abd9e974add14575b4',
    'd73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4',
    'a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695',
    'a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695'
  )
  .map(gt)
const rY = Wt(qE)
var KE = new Array(3)
  .concat(
    'fc8d59ffffbf91cf60',
    'd7191cfdae61a6d96a1a9641',
    'd7191cfdae61ffffbfa6d96a1a9641',
    'd73027fc8d59fee08bd9ef8b91cf601a9850',
    'd73027fc8d59fee08bffffbfd9ef8b91cf601a9850',
    'd73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850',
    'd73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850',
    'a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837',
    'a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837'
  )
  .map(gt)
const iY = Wt(KE)
var ZE = new Array(3)
  .concat(
    'fc8d59ffffbf99d594',
    'd7191cfdae61abdda42b83ba',
    'd7191cfdae61ffffbfabdda42b83ba',
    'd53e4ffc8d59fee08be6f59899d5943288bd',
    'd53e4ffc8d59fee08bffffbfe6f59899d5943288bd',
    'd53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd',
    'd53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd',
    '9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2',
    '9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2'
  )
  .map(gt)
const aY = Wt(ZE)
var QE = new Array(3)
  .concat(
    'e5f5f999d8c92ca25f',
    'edf8fbb2e2e266c2a4238b45',
    'edf8fbb2e2e266c2a42ca25f006d2c',
    'edf8fbccece699d8c966c2a42ca25f006d2c',
    'edf8fbccece699d8c966c2a441ae76238b45005824',
    'f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824',
    'f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b'
  )
  .map(gt)
const oY = Wt(QE)
var JE = new Array(3)
  .concat(
    'e0ecf49ebcda8856a7',
    'edf8fbb3cde38c96c688419d',
    'edf8fbb3cde38c96c68856a7810f7c',
    'edf8fbbfd3e69ebcda8c96c68856a7810f7c',
    'edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b',
    'f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b',
    'f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b'
  )
  .map(gt)
const sY = Wt(JE)
var tT = new Array(3)
  .concat(
    'e0f3dba8ddb543a2ca',
    'f0f9e8bae4bc7bccc42b8cbe',
    'f0f9e8bae4bc7bccc443a2ca0868ac',
    'f0f9e8ccebc5a8ddb57bccc443a2ca0868ac',
    'f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e',
    'f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e',
    'f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081'
  )
  .map(gt)
const cY = Wt(tT)
var eT = new Array(3)
  .concat(
    'fee8c8fdbb84e34a33',
    'fef0d9fdcc8afc8d59d7301f',
    'fef0d9fdcc8afc8d59e34a33b30000',
    'fef0d9fdd49efdbb84fc8d59e34a33b30000',
    'fef0d9fdd49efdbb84fc8d59ef6548d7301f990000',
    'fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000',
    'fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000'
  )
  .map(gt)
const lY = Wt(eT)
var nT = new Array(3)
  .concat(
    'ece2f0a6bddb1c9099',
    'f6eff7bdc9e167a9cf02818a',
    'f6eff7bdc9e167a9cf1c9099016c59',
    'f6eff7d0d1e6a6bddb67a9cf1c9099016c59',
    'f6eff7d0d1e6a6bddb67a9cf3690c002818a016450',
    'fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450',
    'fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636'
  )
  .map(gt)
const uY = Wt(nT)
var rT = new Array(3)
  .concat(
    'ece7f2a6bddb2b8cbe',
    'f1eef6bdc9e174a9cf0570b0',
    'f1eef6bdc9e174a9cf2b8cbe045a8d',
    'f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d',
    'f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b',
    'fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b',
    'fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858'
  )
  .map(gt)
const fY = Wt(rT)
var iT = new Array(3)
  .concat(
    'e7e1efc994c7dd1c77',
    'f1eef6d7b5d8df65b0ce1256',
    'f1eef6d7b5d8df65b0dd1c77980043',
    'f1eef6d4b9dac994c7df65b0dd1c77980043',
    'f1eef6d4b9dac994c7df65b0e7298ace125691003f',
    'f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f',
    'f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f'
  )
  .map(gt)
const hY = Wt(iT)
var aT = new Array(3)
  .concat(
    'fde0ddfa9fb5c51b8a',
    'feebe2fbb4b9f768a1ae017e',
    'feebe2fbb4b9f768a1c51b8a7a0177',
    'feebe2fcc5c0fa9fb5f768a1c51b8a7a0177',
    'feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177',
    'fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177',
    'fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a'
  )
  .map(gt)
const dY = Wt(aT)
var oT = new Array(3)
  .concat(
    'edf8b17fcdbb2c7fb8',
    'ffffcca1dab441b6c4225ea8',
    'ffffcca1dab441b6c42c7fb8253494',
    'ffffccc7e9b47fcdbb41b6c42c7fb8253494',
    'ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84',
    'ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84',
    'ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58'
  )
  .map(gt)
const pY = Wt(oT)
var sT = new Array(3)
  .concat(
    'f7fcb9addd8e31a354',
    'ffffccc2e69978c679238443',
    'ffffccc2e69978c67931a354006837',
    'ffffccd9f0a3addd8e78c67931a354006837',
    'ffffccd9f0a3addd8e78c67941ab5d238443005a32',
    'ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32',
    'ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529'
  )
  .map(gt)
const vY = Wt(sT)
var cT = new Array(3)
  .concat(
    'fff7bcfec44fd95f0e',
    'ffffd4fed98efe9929cc4c02',
    'ffffd4fed98efe9929d95f0e993404',
    'ffffd4fee391fec44ffe9929d95f0e993404',
    'ffffd4fee391fec44ffe9929ec7014cc4c028c2d04',
    'ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04',
    'ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506'
  )
  .map(gt)
const gY = Wt(cT)
var lT = new Array(3)
  .concat(
    'ffeda0feb24cf03b20',
    'ffffb2fecc5cfd8d3ce31a1c',
    'ffffb2fecc5cfd8d3cf03b20bd0026',
    'ffffb2fed976feb24cfd8d3cf03b20bd0026',
    'ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026',
    'ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026',
    'ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026'
  )
  .map(gt)
const yY = Wt(lT)
var uT = new Array(3)
  .concat(
    'deebf79ecae13182bd',
    'eff3ffbdd7e76baed62171b5',
    'eff3ffbdd7e76baed63182bd08519c',
    'eff3ffc6dbef9ecae16baed63182bd08519c',
    'eff3ffc6dbef9ecae16baed64292c62171b5084594',
    'f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594',
    'f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b'
  )
  .map(gt)
const mY = Wt(uT)
var fT = new Array(3)
  .concat(
    'e5f5e0a1d99b31a354',
    'edf8e9bae4b374c476238b45',
    'edf8e9bae4b374c47631a354006d2c',
    'edf8e9c7e9c0a1d99b74c47631a354006d2c',
    'edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32',
    'f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32',
    'f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b'
  )
  .map(gt)
const bY = Wt(fT)
var hT = new Array(3)
  .concat(
    'f0f0f0bdbdbd636363',
    'f7f7f7cccccc969696525252',
    'f7f7f7cccccc969696636363252525',
    'f7f7f7d9d9d9bdbdbd969696636363252525',
    'f7f7f7d9d9d9bdbdbd969696737373525252252525',
    'fffffff0f0f0d9d9d9bdbdbd969696737373525252252525',
    'fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000'
  )
  .map(gt)
const xY = Wt(hT)
var dT = new Array(3)
  .concat(
    'efedf5bcbddc756bb1',
    'f2f0f7cbc9e29e9ac86a51a3',
    'f2f0f7cbc9e29e9ac8756bb154278f',
    'f2f0f7dadaebbcbddc9e9ac8756bb154278f',
    'f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486',
    'fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486',
    'fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d'
  )
  .map(gt)
const wY = Wt(dT)
var pT = new Array(3)
  .concat(
    'fee0d2fc9272de2d26',
    'fee5d9fcae91fb6a4acb181d',
    'fee5d9fcae91fb6a4ade2d26a50f15',
    'fee5d9fcbba1fc9272fb6a4ade2d26a50f15',
    'fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d',
    'fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d',
    'fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d'
  )
  .map(gt)
const OY = Wt(pT)
var vT = new Array(3)
  .concat(
    'fee6cefdae6be6550d',
    'feeddefdbe85fd8d3cd94701',
    'feeddefdbe85fd8d3ce6550da63603',
    'feeddefdd0a2fdae6bfd8d3ce6550da63603',
    'feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04',
    'fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04',
    'fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704'
  )
  .map(gt)
const SY = Wt(vT)
function _Y(t) {
  return (
    (t = Math.max(0, Math.min(1, t))),
    'rgb(' +
      Math.max(
        0,
        Math.min(
          255,
          Math.round(
            -4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))
          )
        )
      ) +
      ', ' +
      Math.max(
        0,
        Math.min(
          255,
          Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37)))))
        )
      ) +
      ', ' +
      Math.max(
        0,
        Math.min(
          255,
          Math.round(
            81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))
          )
        )
      ) +
      ')'
  )
}
const MY = z0(sr(300, 0.5, 0), sr(-240, 0.5, 1))
var EY = z0(sr(-100, 0.75, 0.35), sr(80, 1.5, 0.8)),
  TY = z0(sr(260, 0.75, 0.35), sr(80, 1.5, 0.8)),
  Lc = sr()
function PY(t) {
  ;(t < 0 || t > 1) && (t -= Math.floor(t))
  var e = Math.abs(t - 0.5)
  return (Lc.h = 360 * t - 100), (Lc.s = 1.5 - 1.5 * e), (Lc.l = 0.8 - 0.9 * e), Lc + ''
}
var Nc = ys(),
  AY = Math.PI / 3,
  kY = (Math.PI * 2) / 3
function CY(t) {
  var e
  return (
    (t = (0.5 - t) * Math.PI),
    (Nc.r = 255 * (e = Math.sin(t)) * e),
    (Nc.g = 255 * (e = Math.sin(t + AY)) * e),
    (Nc.b = 255 * (e = Math.sin(t + kY)) * e),
    Nc + ''
  )
}
function LY(t) {
  return (
    (t = Math.max(0, Math.min(1, t))),
    'rgb(' +
      Math.max(
        0,
        Math.min(
          255,
          Math.round(
            34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))
          )
        )
      ) +
      ', ' +
      Math.max(
        0,
        Math.min(
          255,
          Math.round(
            23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))
          )
        )
      ) +
      ', ' +
      Math.max(
        0,
        Math.min(
          255,
          Math.round(
            27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))
          )
        )
      ) +
      ')'
  )
}
function ju(t) {
  var e = t.length
  return function (n) {
    return t[Math.max(0, Math.min(e - 1, Math.floor(n * e)))]
  }
}
const NY = ju(
  gt(
    '44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725'
  )
)
var RY = ju(
    gt(
      '00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf'
    )
  ),
  IY = ju(
    gt(
      '00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4'
    )
  ),
  jY = ju(
    gt(
      '0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921'
    )
  )
const Od = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      interpolateBlues: mY,
      interpolateBrBG: ZW,
      interpolateBuGn: oY,
      interpolateBuPu: sY,
      interpolateCividis: _Y,
      interpolateCool: TY,
      interpolateCubehelixDefault: MY,
      interpolateGnBu: cY,
      interpolateGreens: bY,
      interpolateGreys: xY,
      interpolateInferno: IY,
      interpolateMagma: RY,
      interpolateOrRd: lY,
      interpolateOranges: SY,
      interpolatePRGn: QW,
      interpolatePiYG: JW,
      interpolatePlasma: jY,
      interpolatePuBu: fY,
      interpolatePuBuGn: uY,
      interpolatePuOr: tY,
      interpolatePuRd: hY,
      interpolatePurples: wY,
      interpolateRainbow: PY,
      interpolateRdBu: eY,
      interpolateRdGy: nY,
      interpolateRdPu: dY,
      interpolateRdYlBu: rY,
      interpolateRdYlGn: iY,
      interpolateReds: OY,
      interpolateSinebow: CY,
      interpolateSpectral: aY,
      interpolateTurbo: LY,
      interpolateViridis: NY,
      interpolateWarm: EY,
      interpolateYlGn: vY,
      interpolateYlGnBu: pY,
      interpolateYlOrBr: gY,
      interpolateYlOrRd: yY,
      schemeAccent: wW,
      schemeBlues: uT,
      schemeBrBG: WE,
      schemeBuGn: QE,
      schemeBuPu: JE,
      schemeCategory10: xW,
      schemeDark2: OW,
      schemeGnBu: tT,
      schemeGreens: fT,
      schemeGreys: hT,
      schemeOrRd: eT,
      schemeOranges: vT,
      schemePRGn: YE,
      schemePaired: SW,
      schemePastel1: _W,
      schemePastel2: MW,
      schemePiYG: HE,
      schemePuBu: rT,
      schemePuBuGn: nT,
      schemePuOr: VE,
      schemePuRd: iT,
      schemePurples: dT,
      schemeRdBu: XE,
      schemeRdGy: UE,
      schemeRdPu: aT,
      schemeRdYlBu: qE,
      schemeRdYlGn: KE,
      schemeReds: pT,
      schemeSet1: EW,
      schemeSet2: TW,
      schemeSet3: PW,
      schemeSpectral: ZE,
      schemeTableau10: AW,
      schemeYlGn: sT,
      schemeYlGnBu: oT,
      schemeYlOrBr: cT,
      schemeYlOrRd: lT
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function DY(t, e, n, r, i, a) {
  const { guide: o = {} } = n,
    s = VY(t, e, n)
  if (typeof s != 'string') return n
  const c = XY(s, t, e, n),
    l = WY(s, c, n)
  return Object.assign(Object.assign(Object.assign({}, n), qY(s, t, e, n, r)), {
    domain: l,
    range: UY(s, t, e, n, l, i, a),
    expectedDomain: c,
    guide: o,
    name: t,
    type: s
  })
}
function $Y(t, e) {
  const n = {}
  for (const r of t) {
    const { values: i, name: a } = r,
      o = e[a]
    for (const s of i) {
      const { name: c, value: l } = s
      n[c] = l.map((u) => o.map(u))
    }
  }
  return n
}
function BY(t, e) {
  var n
  const { components: r = [] } = e,
    i = ['scale', 'encode', 'axis', 'legend', 'data', 'transform'],
    a = Array.from(new Set(t.flatMap((s) => s.channels.map((c) => c.scale)))),
    o = new Map(a.map((s) => [s.name, s]))
  for (const s of r) {
    const c = GY(s)
    for (const l of c) {
      const u = o.get(l),
        f = ((n = s.scale) === null || n === void 0 ? void 0 : n[l]) || {},
        { independent: h = !1 } = f
      if (u && !h) {
        const { guide: d } = u,
          p = typeof d == 'boolean' ? {} : d
        ;(u.guide = X({}, p, s)), Object.assign(u, f)
      } else {
        const d = Object.assign(Object.assign({}, f), {
          expectedDomain: f.domain,
          name: l,
          guide: rb(s, i)
        })
        a.push(d)
      }
    }
  }
  return a
}
function FY(t) {
  if (!t || !Array.isArray(t)) return [Ri, Ri]
  let e, n
  return [
    (a) => {
      var o
      ;(e = a.map.bind(a)), (n = (o = a.invert) === null || o === void 0 ? void 0 : o.bind(a))
      const s = t.filter(([h]) => typeof h == 'function'),
        c = t.filter(([h]) => typeof h != 'function'),
        l = new Map(c)
      if (
        ((a.map = (h) => {
          for (const [d, p] of s) if (d(h)) return p
          return l.has(h) ? l.get(h) : e(h)
        }),
        !n)
      )
        return a
      const u = new Map(c.map(([h, d]) => [d, h])),
        f = new Map(s.map(([h, d]) => [d, h]))
      return (a.invert = (h) => (f.has(h) ? h : u.has(h) ? u.get(h) : n(h))), a
    },
    (a) => (e !== null && (a.map = e), n !== null && (a.invert = n), a)
  ]
}
function u1(t, e) {
  const n = Object.keys(t)
  for (const r of Object.values(e)) {
    const { name: i, key: a } = r.getOptions()
    if (typeof a == 'string') a in t || (t[a] = r)
    else if (!(i in t)) t[i] = r
    else {
      const o = n.filter((l) => l.startsWith(i)).map((l) => +(l.replace(i, '') || 0)),
        s = Ct(o) + 1,
        c = `${i}${s}`
      ;(t[c] = r), (r.getOptions().key = c)
    }
  }
  return t
}
function f1(t, e) {
  const [n] = Kt('scale', e),
    { relations: r } = t,
    [i] = FY(r),
    a = n(t)
  return i(a)
}
function zY(t) {
  const e = t.flatMap((n) => Array.from(n.values())).flatMap((n) => n.channels.map((r) => r.scale))
  h1(e, 'x'), h1(e, 'y')
}
function GY(t) {
  const { channels: e = [], type: n, scale: r = {} } = t,
    i = ['shape', 'color', 'opacity', 'size']
  return e.length !== 0
    ? e
    : n === 'axisX'
    ? ['x']
    : n === 'axisY'
    ? ['y']
    : n === 'legends'
    ? Object.keys(r).filter((a) => i.includes(a))
    : []
}
function h1(t, e) {
  const n = t.filter(({ name: a, facet: o = !0 }) => o && a === e),
    r = n.flatMap((a) => a.domain),
    i = n.every(gT) ? br(r) : n.every(yT) ? Array.from(new Set(r)) : null
  if (i !== null) for (const a of n) a.domain = i
}
function WY(t, e, n) {
  const { ratio: r } = n
  return r == null ? e : gT({ type: t }) ? YY(e, r, t) : yT({ type: t }) ? HY(e, r) : e
}
function YY(t, e, n) {
  const r = t.map(Number),
    i = new Ft({ domain: r, range: [r[0], r[0] + (r[r.length - 1] - r[0]) * e] })
  return n === 'time' ? t.map((a) => new Date(i.map(a))) : t.map((a) => i.map(a))
}
function HY(t, e) {
  const n = Math.round(t.length * e)
  return t.slice(0, n)
}
function gT(t) {
  const { type: e } = t
  return typeof e != 'string' ? !1 : ['linear', 'log', 'pow', 'time'].includes(e)
}
function yT(t) {
  const { type: e } = t
  return typeof e != 'string' ? !1 : ['band', 'point', 'ordinal'].includes(e)
}
function VY(t, e, n) {
  const { type: r, domain: i, range: a, quantitative: o, ordinal: s } = n
  return r !== void 0
    ? r
    : oH(e)
    ? 'identity'
    : typeof a == 'string'
    ? 'linear'
    : (i || a || []).length > 2
    ? zf(t, s)
    : i !== void 0
    ? g1([i])
      ? zf(t, s)
      : y1(e)
      ? 'time'
      : p1(t, a, o)
    : g1(e)
    ? zf(t, s)
    : y1(e)
    ? 'time'
    : p1(t, a, o)
}
function XY(t, e, n, r) {
  const { domain: i } = r
  if (i !== void 0) return i
  switch (t) {
    case 'linear':
    case 'time':
    case 'log':
    case 'pow':
    case 'sqrt':
    case 'quantize':
    case 'threshold':
      return v1(nH(n, r), r)
    case 'band':
    case 'ordinal':
    case 'point':
      return mT(n)
    case 'quantile':
      return rH(n)
    case 'sequential':
      return v1(iH(n), r)
    default:
      return []
  }
}
function UY(t, e, n, r, i, a, o) {
  const { range: s } = r
  if (typeof s == 'string') return KY(s)
  if (s !== void 0) return s
  const { rangeMin: c, rangeMax: l } = r
  switch (t) {
    case 'linear':
    case 'time':
    case 'log':
    case 'pow':
    case 'sqrt': {
      const u = d1(n, r, i, a, o),
        [f, h] = aH(e, u)
      return [c || f, l || h]
    }
    case 'band':
    case 'point':
      return [c || (e === 'size' ? 5 : 0), l || (e === 'size' ? 10 : 1)]
    case 'ordinal':
      return d1(n, r, i, a, o)
    case 'sequential':
      return
    case 'constant':
      return [n[0][0]]
    default:
      return []
  }
}
function qY(t, e, n, r, i) {
  switch (t) {
    case 'linear':
    case 'time':
    case 'log':
    case 'pow':
    case 'sqrt':
      return JY(i, r)
    case 'band':
    case 'point':
      return tH(t, e, i, r)
    case 'sequential':
      return QY(r)
    default:
      return r
  }
}
function d1(t, e, n, r, i) {
  const [a] = Kt('palette', i),
    { category10: o, category20: s } = r,
    c = Yk(t.flat()).length <= o.length ? o : s,
    { palette: l = c, offset: u } = e
  if (Array.isArray(l)) return l
  try {
    return a({ type: l })
  } catch {
    const h = ZY(l, n, u)
    if (h) return h
    throw new Error(`Unknown Component: ${l} `)
  }
}
function KY(t) {
  return t.split('-')
}
function ZY(t, e, n = (r) => r) {
  if (!t) return null
  const r = ni(t),
    i = Od[`scheme${r}`],
    a = Od[`interpolate${r}`]
  if (!i && !a) return null
  if (i) {
    if (!i.some(Array.isArray)) return i
    const o = i[e.length]
    if (o) return o
  }
  return e.map((o, s) => a(n(s / e.length)))
}
function QY(t) {
  const { palette: e = 'ylGnBu', offset: n } = t,
    r = ni(e),
    i = Od[`interpolate${r}`]
  if (!i) throw new Error(`Unknown palette: ${r}`)
  return { interpolator: n ? (a) => i(n(a)) : i }
}
function JY(t, e) {
  const { interpolate: n = Es, nice: r = !1, tickCount: i = 5 } = e
  return Object.assign(Object.assign({}, e), { interpolate: n, nice: r, tickCount: i })
}
function tH(t, e, n, r) {
  if (r.padding !== void 0 || r.paddingInner !== void 0 || r.paddingOuter !== void 0)
    return Object.assign(Object.assign({}, r), { unknown: NaN })
  const i = eH(t, e, n),
    { paddingInner: a = i, paddingOuter: o = i } = r
  return Object.assign(Object.assign({}, r), {
    paddingInner: a,
    paddingOuter: o,
    padding: i,
    unknown: NaN
  })
}
function eH(t, e, n) {
  return e === 'enterDelay' || e === 'enterDuration' || e === 'size'
    ? 0
    : t === 'band'
    ? DE(n)
      ? 0
      : 0.1
    : t === 'point'
    ? 0.5
    : 0
}
function zf(t, e) {
  return e || (sH(t) ? 'point' : 'ordinal')
}
function p1(t, e, n) {
  return n || (t !== 'color' || e ? 'linear' : 'sequential')
}
function v1(t, e) {
  if (t.length === 0) return t
  const { domainMin: n, domainMax: r } = e,
    [i, a] = t
  return [n ?? i, r ?? a]
}
function nH(t, e) {
  const { zero: n = !1 } = e
  let r = 1 / 0,
    i = -1 / 0
  for (const a of t) for (const o of a) Gt(o) && ((r = Math.min(r, +o)), (i = Math.max(i, +o)))
  return r === 1 / 0 ? [] : n ? [Math.min(0, r), i] : [r, i]
}
function mT(t) {
  return Array.from(new Set(t.flat()))
}
function rH(t) {
  return mT(t).sort()
}
function iH(t) {
  let e = 1 / 0,
    n = -1 / 0
  for (const r of t) for (const i of r) Gt(i) && ((e = Math.min(e, +i)), (n = Math.max(n, +i)))
  return e === 1 / 0 ? [] : [e < 0 ? -n : e, n]
}
function aH(t, e) {
  return t === 'enterDelay'
    ? [0, 1e3]
    : t == 'enterDuration'
    ? [300, 1e3]
    : t.startsWith('y') || t.startsWith('position')
    ? [1, 0]
    : t === 'color'
    ? [Wk(e), Nb(e)]
    : t === 'opacity'
    ? [0, 1]
    : t === 'size'
    ? [1, 10]
    : [0, 1]
}
function g1(t) {
  return G0(t, (e) => {
    const n = typeof e
    return n === 'string' || n === 'boolean'
  })
}
function y1(t) {
  return G0(t, (e) => e instanceof Date)
}
function oH(t) {
  return G0(t, Uo)
}
function G0(t, e) {
  for (const n of t) if (n.some(e)) return !0
  return !1
}
function sH(t) {
  return t.startsWith('x') || t.startsWith('y') || t.startsWith('position') || t.startsWith('size')
}
function cH(t) {
  return (
    t.startsWith('x') ||
    t.startsWith('y') ||
    t.startsWith('position') ||
    t === 'enterDelay' ||
    t === 'enterDuration' ||
    t === 'updateDelay' ||
    t === 'updateDuration' ||
    t === 'exitDelay' ||
    t === 'exitDuration'
  )
}
function lH(t) {
  if (!t || !t.type) return !1
  if (typeof t.type == 'function') return !0
  const { type: e, domain: n, range: r, interpolator: i } = t,
    a = n && n.length > 0,
    o = r && r.length > 0
  return !!(
    ([
      'linear',
      'sqrt',
      'log',
      'time',
      'pow',
      'threshold',
      'quantize',
      'quantile',
      'ordinal',
      'band',
      'point'
    ].includes(e) &&
      a &&
      o) ||
    (['sequential'].includes(e) && a && (o || i)) ||
    (['constant', 'identity'].includes(e) && o)
  )
}
const uH = {
    linear: 'linear',
    identity: 'identity',
    log: 'log',
    pow: 'pow',
    sqrt: 'sqrt',
    sequential: 'sequential'
  },
  fH = { threshold: 'threshold', quantize: 'quantize', quantile: 'quantile' },
  hH = { ordinal: 'ordinal', band: 'band', point: 'point' },
  dH = { constant: 'constant' }
var di =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function pH(t, e, n) {
  const { coordinates: r = [], title: i } = e,
    [, a] = Kt('component', n),
    o = t.filter(({ guide: u }) => u !== null),
    s = [],
    c = _H(e, t, n)
  if ((s.push(...c), i)) {
    const { props: u } = a('title'),
      {
        defaultPosition: f,
        defaultOrientation: h,
        defaultOrder: d,
        defaultSize: p,
        defaultCrossPadding: v
      } = u,
      g = typeof i == 'string' ? { title: i } : i
    s.push(
      Object.assign(
        {
          type: 'title',
          position: f,
          orientation: h,
          order: d,
          crossPadding: v[0],
          defaultSize: p
        },
        g
      )
    )
  }
  return (
    bH(o, r).forEach(([u, f]) => {
      const { props: h } = a(u),
        {
          defaultPosition: d,
          defaultPlane: p = 'xy',
          defaultOrientation: v,
          defaultSize: g,
          defaultOrder: y,
          defaultLength: m,
          defaultPadding: b = [0, 0],
          defaultCrossPadding: x = [0, 0]
        } = h,
        w = X({}, ...f),
        { guide: O, field: S } = w,
        _ = Array.isArray(O) ? O : [O]
      for (const M of _) {
        const [E, T] = OH(u, d, v, M, f, o, r)
        if (!E && !T) continue
        const C = E === 'left' || E === 'right',
          A = C ? b[1] : b[0],
          P = C ? x[1] : x[0],
          { size: k, order: L = y, length: R = m, padding: j = A, crossPadding: I = P } = M
        s.push(
          Object.assign(Object.assign({ title: S }, M), {
            defaultSize: g,
            length: R,
            position: E,
            plane: p,
            orientation: T,
            padding: j,
            order: L,
            crossPadding: I,
            size: k,
            type: u,
            scales: f
          })
        )
      }
    }),
    s
  )
}
function m1(t, e, n, r, i) {
  const [a] = Kt('component', r),
    { scaleInstances: o, scale: s, bbox: c } = t,
    l = di(t, ['scaleInstances', 'scale', 'bbox']),
    u = { bbox: c, library: r }
  return a(l)({ coordinate: e, library: r, markState: i, scales: o, theme: n, value: u, scale: s })
}
function vH(t) {
  return t.map((e) => {
    const n = X(e, e.style)
    return delete n.style, n
  })
}
function bT(t, e) {
  const n = ['left', 'right', 'bottom', 'top']
  return Yd(t, ({ type: a, position: o, group: s }) =>
    n.includes(o)
      ? s === void 0
        ? a.startsWith('legend')
          ? `legend-${o}`
          : Symbol('independent')
        : s === 'independent'
        ? Symbol('independent')
        : s
      : Symbol('independent')
  ).flatMap(([, a]) => {
    if (a.length === 1) return a[0]
    if (e !== void 0) {
      const u = a.filter((v) => v.length !== void 0).map((v) => v.length),
        f = Pn(u)
      if (f > e) return a.forEach((v) => (v.group = Symbol('independent'))), a
      const h = e - f,
        d = a.length - u.length,
        p = h / d
      a.forEach((v) => {
        v.length === void 0 && (v.length = p)
      })
    }
    const o = Ct(a, (u) => u.size),
      s = Ct(a, (u) => u.order),
      c = Ct(a, (u) => u.crossPadding),
      l = a[0].position
    return { type: 'group', size: o, order: s, position: l, children: a, crossPadding: c }
  })
}
function gH(t, e) {
  const n = ['shape', 'size', 'color', 'opacity'],
    r = (h, d) => h === 'constant' && d === 'size',
    i = t.filter(({ type: h, name: d }) => typeof h == 'string' && n.includes(d) && !r(h, d)),
    a = i.filter(({ type: h }) => h === 'constant'),
    o = i.filter(({ type: h }) => h !== 'constant'),
    c = Yd(o, (h) => (h.field ? h.field : Symbol('independent')))
      .map(([h, d]) => [h, [...d, ...a]])
      .filter(([, h]) => h.some((d) => d.type !== 'constant')),
    l = new Map(c)
  if (l.size === 0) return []
  const u = (h) => h.sort(([d], [p]) => d.localeCompare(p))
  return Array.from(l)
    .map(([, h]) => {
      const p = Hk(h)
        .sort((v, g) => g.length - v.length)
        .map((v) => ({ combination: v, option: v.map((g) => [g.name, yH(g)]) }))
      for (const { option: v, combination: g } of p)
        if (
          !v.every((y) => y[1] === 'constant') &&
          v.every((y) => y[1] === 'discrete' || y[1] === 'constant')
        )
          return ['legendCategory', g]
      for (const [v, g] of JF)
        for (const { option: y, combination: m } of p)
          if (g.some((b) => eb(u(b), u(y)))) return [v, m]
      return null
    })
    .filter(Gt)
}
function yH(t) {
  const { type: e } = t
  return typeof e != 'string'
    ? null
    : e in uH
    ? 'continuous'
    : e in hH
    ? 'discrete'
    : e in fH
    ? 'distribution'
    : e in dH
    ? 'constant'
    : null
}
function mH(t, e) {
  return t
    .map((n) => {
      const { name: r } = n
      if (pW(e) || DE(e) || (Oa(e) && (_i(e) || Go(e)))) return null
      if (r.startsWith('x'))
        return _i(e)
          ? ['axisArc', [n]]
          : Go(e)
          ? ['axisLinear', [n]]
          : [Oa(e) ? 'axisY' : 'axisX', [n]]
      if (r.startsWith('y'))
        return _i(e)
          ? ['axisLinear', [n]]
          : Go(e)
          ? ['axisArc', [n]]
          : [Oa(e) ? 'axisX' : 'axisY', [n]]
      if (r.startsWith('z')) return ['axisZ', [n]]
      if (r.startsWith('position')) {
        if (yW(e)) return ['axisRadar', [n]]
        if (!_i(e)) return ['axisY', [n]]
      }
      return null
    })
    .filter(Gt)
}
function bH(t, e) {
  const n = t.filter((r) => lH(r))
  return [...gH(n), ...mH(n, e)]
}
function Sd(t) {
  const e = Yn(t, 'polar')
  if (e.length) {
    const r = e[e.length - 1],
      { startAngle: i, endAngle: a } = z1(r)
    return [i, a]
  }
  const n = Yn(t, 'radial')
  if (n.length) {
    const r = n[n.length - 1],
      { startAngle: i, endAngle: a } = W1(r)
    return [i, a]
  }
  return [-Math.PI / 2, (Math.PI / 2) * 3]
}
function xH(t) {
  const e = /position(\d*)/g.exec(t)
  return e ? +e[1] : null
}
function wH(t, e, n, r, i) {
  const { name: a } = n[0]
  if (t === 'axisRadar') {
    const o = r.filter((f) => f.name.startsWith('position')),
      s = xH(a)
    if (a === o.slice(-1)[0].name || s === null) return [null, null]
    const [c, l] = Sd(i)
    return ['center', ((l - c) / (o.length - 1)) * s + c]
  }
  if (t === 'axisY' && vW(i)) return Oa(i) ? ['center', 'horizontal'] : ['center', 'vertical']
  if (t === 'axisLinear') {
    const [o] = Sd(i)
    return ['center', o]
  }
  return t === 'axisArc'
    ? e[0] === 'inner'
      ? ['inner', null]
      : ['outer', null]
    : _i(i)
    ? ['center', null]
    : Go(i)
    ? ['center', null]
    : (t === 'axisX' && gW(i)) || (t === 'axisX' && mW(i))
    ? ['top', null]
    : e
}
function OH(t, e, n, r, i, a, o) {
  const [s] = Sd(o),
    c = [r.position || e, s ?? n]
  return typeof t == 'string' && t.startsWith('axis')
    ? wH(t, c, i, a, o)
    : typeof t == 'string' && t.startsWith('legend') && _i(o) && r.position === 'center'
    ? ['center', 'vertical']
    : c
}
function SH(t, e, n = []) {
  return t === 'x' ? (Oa(n) ? `${e}Y` : `${e}X`) : t === 'y' ? (Oa(n) ? `${e}X` : `${e}Y`) : null
}
function _H(t, e, n) {
  const [, r] = Kt('component', n),
    { coordinates: i } = t
  function a(o, s, c, l) {
    const u = SH(s, o, i)
    if (!l || !u) return
    const { props: f } = r(u),
      {
        defaultPosition: h,
        defaultSize: d,
        defaultOrder: p,
        defaultCrossPadding: [v]
      } = f
    return Object.assign(
      Object.assign({ position: h, defaultSize: d, order: p, type: u, crossPadding: v }, l),
      { scales: [c] }
    )
  }
  return e
    .filter((o) => o.slider || o.scrollbar)
    .flatMap((o) => {
      const { slider: s, scrollbar: c, name: l } = o
      return [a('slider', l, o, s), a('scrollbar', l, o, c)]
    })
    .filter((o) => !!o)
}
function xT(t, e, n, r, i, a) {
  const { type: o } = t
  if (!['left', 'right', 'bottom', 'top'].includes(r) || typeof o != 'string') return
  const c = o
  return (() =>
    c.startsWith('axis')
      ? AH
      : c.startsWith('group')
      ? MH
      : c.startsWith('legendContinuous')
      ? kH
      : c === 'legendCategory'
      ? CH
      : c.startsWith('slider')
      ? PH
      : c === 'title'
      ? TH
      : c.startsWith('scrollbar')
      ? EH
      : () => {})()(t, e, n, r, i, a)
}
function MH(t, e, n, r, i, a) {
  const { children: o } = t,
    s = Ct(o, (l) => l.crossPadding)
  o.forEach((l) => (l.crossPadding = s)), o.forEach((l) => xT(l, e, n, r, i, a))
  const c = Ct(o, (l) => l.size)
  ;(t.size = c), o.forEach((l) => (l.size = c))
}
function EH(t, e, n, r, i, a) {
  const { trackSize: o = 6 } = X({}, i.scrollbar, t)
  t.size = o
}
function TH(t, e, n, r, i, a) {
  const o = X({}, i.title, t),
    { title: s, subtitle: c, spacing: l = 0 } = o,
    u = di(o, ['title', 'subtitle', 'spacing'])
  if (s) {
    const f = et(u, 'title'),
      h = zl(s, f)
    t.size = h.height
  }
  if (c) {
    const f = et(u, 'subtitle'),
      h = zl(c, f)
    t.size += l + h.height
  }
}
function PH(t, e, n, r, i, a) {
  const o = () => {
      const { slider: u } = i
      return X({}, u, t)
    },
    { trackSize: s, handleIconSize: c } = o(),
    l = Math.max(s, c * 2.4)
  t.size = l
}
function AH(t, e, n, r, i, a) {
  t.transform = t.transform || [{ type: 'hide' }]
  const o = r === 'left' || r === 'right',
    s = wT(t, r, i),
    { tickLength: c = 0, labelSpacing: l = 0, titleSpacing: u = 0, labelAutoRotate: f } = s,
    h = di(s, ['tickLength', 'labelSpacing', 'titleSpacing', 'labelAutoRotate']),
    d = Du(t, a),
    p = $u(h, d),
    v = c + l
  if (p && p.length) {
    const y = Ct(p, (b) => b.width),
      m = Ct(p, (b) => b.height)
    if (o) t.size = y + v
    else {
      const { tickFilter: b, labelTransform: x } = t
      RH(d, p, e, n, b) && !x && f !== !1 && f !== null
        ? ((t.labelTransform = 'rotate(90)'), (t.size = y + v))
        : (t.size = m + v)
    }
  } else t.size = c
  const g = Bu(h)
  g && (o ? (t.size += u + g.width) : (t.size += u + g.height))
}
function kH(t, e, n, r, i, a) {
  const s = (() => {
      const { legendContinuous: x } = i
      return X({}, x, t)
    })(),
    { labelSpacing: c = 0, titleSpacing: l = 0 } = s,
    u = di(s, ['labelSpacing', 'titleSpacing']),
    f = r === 'left' || r === 'right',
    h = et(u, 'ribbon'),
    { size: d } = h,
    p = et(u, 'handleIcon'),
    { size: v } = p,
    g = Math.max(d, v * 2.4)
  t.size = g
  const y = Du(t, a),
    m = $u(u, y)
  if (m) {
    const x = f ? 'width' : 'height',
      w = Ct(m, (O) => O[x])
    t.size += w + c
  }
  const b = Bu(u)
  b && (f ? (t.size = Math.max(t.size, b.width)) : (t.size += l + b.height))
}
function CH(t, e, n, r, i, a) {
  const s = (() => {
      const { legendCategory: P } = i,
        { title: k } = t,
        [L, R] = Array.isArray(k) ? [k, void 0] : [void 0, k]
      return X({ title: L }, P, Object.assign(Object.assign({}, t), { title: R }))
    })(),
    {
      itemSpacing: c,
      itemMarkerSize: l,
      titleSpacing: u,
      rowPadding: f,
      colPadding: h,
      maxCols: d = 1 / 0,
      maxRows: p = 1 / 0
    } = s,
    v = di(s, [
      'itemSpacing',
      'itemMarkerSize',
      'titleSpacing',
      'rowPadding',
      'colPadding',
      'maxCols',
      'maxRows'
    ]),
    { cols: g, length: y } = t,
    m = (P) => Math.min(P, p),
    b = (P) => Math.min(P, d),
    x = r === 'left' || r === 'right',
    w = y === void 0 ? e + (x ? 0 : n[0] + n[1]) : y,
    O = Bu(v),
    S = Du(t, a),
    _ = $u(v, S, 'itemLabel'),
    M = Math.max(_[0].height, l) + f,
    E = (P, k = 0) => l + P + c[0] + k
  x
    ? (() => {
        let P = -1 / 0,
          k = 0,
          L = 1,
          R = 0,
          j = -1 / 0,
          I = -1 / 0
        const D = O ? O.height : 0,
          $ = w - D
        for (const { width: B } of _) {
          const F = E(B)
          ;(P = Math.max(P, F)),
            k + M > $
              ? (L++, (j = Math.max(j, R)), (I = Math.max(I, k)), (R = 1), (k = M))
              : ((k += M), R++)
        }
        L <= 1 && ((j = R), (I = k)),
          (t.size = P * b(L)),
          (t.length = I + D),
          X(t, { cols: b(L), gridRow: j })
      })()
    : typeof g == 'number'
    ? (() => {
        const P = Math.ceil(_.length / g),
          k = Ct(_, (L) => E(L.width)) * g
        ;(t.size = M * m(P) - f), (t.length = Math.min(k, w))
      })()
    : (() => {
        let P = 1,
          k = 0,
          L = -1 / 0
        for (const { width: R } of _) {
          const j = E(R, h)
          k + j > w ? ((L = Math.max(L, k)), (k = j), P++) : (k += j)
        }
        P === 1 && (L = k), (t.size = M * m(P) - f), (t.length = L)
      })(),
    O && (x ? (t.size = Math.max(t.size, O.width)) : (t.size += u + O.height))
}
function Du(t, e) {
  const [n] = Kt('scale', e),
    { scales: r, tickCount: i, tickMethod: a } = t,
    o = r.find((s) => s.type !== 'constant' && s.type !== 'identity')
  return i !== void 0 && (o.tickCount = i), a !== void 0 && (o.tickMethod = a), n(o)
}
function $u(t, e, n = 'label') {
  const { labelFormatter: r, tickFilter: i, label: a = !0 } = t,
    o = di(t, ['labelFormatter', 'tickFilter', 'label'])
  if (!a) return null
  const s = LH(e, r, i),
    c = et(o, n),
    l = s.map((h, d) =>
      Object.fromEntries(
        Object.entries(c).map(([p, v]) => [p, typeof v == 'function' ? v(h, d) : v])
      )
    ),
    u = s.map((h, d) => {
      const p = l[d]
      return zl(h, p)
    })
  if (!l.some((h) => h.transform)) {
    const h = s.map((d, p) => p)
    t.indexBBox = new Map(h.map((d) => [d, [s[d], u[d]]]))
  }
  return u
}
function Bu(t) {
  const e = (l) => l === !1 || l === null,
    { title: n } = t,
    r = di(t, ['title'])
  if (e(n) || n === void 0) return null
  const i = et(r, 'title'),
    { direction: a, transform: o } = i,
    s = Array.isArray(n) ? n.join(',') : n
  return typeof s != 'string'
    ? null
    : zl(
        s,
        Object.assign(Object.assign({}, i), {
          transform: o || (a === 'vertical' ? 'rotate(-90)' : '')
        })
      )
}
function wT(t, e, n) {
  const { title: r } = t,
    [i, a] = Array.isArray(r) ? [r, void 0] : [void 0, r],
    { axis: o, [`axis${qd(e)}`]: s } = n
  return X({ title: i }, o, s, Object.assign(Object.assign({}, t), { title: a }))
}
function OT(t, e) {
  const n = t.getTicks ? t.getTicks() : t.getOptions().domain
  return e ? n.filter(e) : n
}
function LH(t, e, n) {
  const i = OT(t, n).map((o) => (typeof o == 'number' ? jH(o) : o)),
    a = e ? (typeof e == 'string' ? li(e) : e) : t.getFormatter ? t.getFormatter() : (o) => `${o}`
  return i.map(a)
}
function NH(t, e) {
  return t.getBandWidth ? t.getBandWidth(e) / 2 : 0
}
function RH(t, e, n, r, i) {
  if (Pn(e, (d) => d.width) > n) return !0
  const o = t.clone()
  o.update({ range: [0, n] })
  const s = OT(t, i),
    c = s.map((d) => o.map(d) + NH(o, d)),
    l = s.map((d, p) => p),
    u = -r[0],
    f = n + r[1],
    h = (d, p) => {
      const { width: v } = p
      return [d - v / 2, d + v / 2]
    }
  for (let d = 0; d < l.length; d++) {
    const p = c[d],
      [v, g] = h(p, e[d])
    if (v < u || g > f) return !0
    const y = c[d + 1]
    if (y) {
      const [m] = h(y, e[d + 1])
      if (g > m) return !0
    }
  }
  return !1
}
function zl(t, e) {
  const n = IH(t),
    r = di(e, ['filter'])
  return n.attr(Object.assign(Object.assign({}, r), { visibility: 'none' })), n.getBBox()
}
function IH(t) {
  return t instanceof Be ? t : new Za({ style: { text: `${t}` } })
}
function jH(t) {
  return Math.abs(t) < 1e-15 ? t : parseFloat(t.toFixed(15))
}
function DH(t) {
  const e = t.find(({ type: n }) => n === 'axisZ')
  if (e) {
    const n = t.find(({ type: i }) => i === 'axisX')
    n.plane = 'xy'
    const r = t.find(({ type: i }) => i === 'axisY')
    ;(r.plane = 'xy'),
      (e.plane = 'yz'),
      (e.origin = [n.bbox.x, n.bbox.y, 0]),
      (e.eulerAngles = [0, -90, 0]),
      (e.bbox.x = n.bbox.x),
      (e.bbox.y = n.bbox.y),
      t.push(
        Object.assign(Object.assign({}, n), {
          plane: 'xz',
          showLabel: !1,
          showTitle: !1,
          origin: [n.bbox.x, n.bbox.y, 0],
          eulerAngles: [-90, 0, 0]
        })
      ),
      t.push(
        Object.assign(Object.assign({}, r), {
          plane: 'yz',
          showLabel: !1,
          showTitle: !1,
          origin: [r.bbox.x + r.bbox.width, r.bbox.y, 0],
          eulerAngles: [0, -90, 0]
        })
      ),
      t.push(
        Object.assign(Object.assign({}, e), {
          plane: 'xz',
          actualPosition: 'left',
          showLabel: !1,
          showTitle: !1,
          eulerAngles: [90, -90, 0]
        })
      )
  }
}
function $H(t, e, n, r) {
  var i, a
  const {
      width: o,
      height: s,
      depth: c,
      x: l = 0,
      y: u = 0,
      z: f = 0,
      inset: h = (i = n.inset) !== null && i !== void 0 ? i : 0,
      insetLeft: d = h,
      insetTop: p = h,
      insetBottom: v = h,
      insetRight: g = h,
      margin: y = (a = n.margin) !== null && a !== void 0 ? a : 0,
      marginLeft: m = y,
      marginBottom: b = y,
      marginTop: x = y,
      marginRight: w = y,
      padding: O = n.padding,
      paddingBottom: S = O,
      paddingLeft: _ = O,
      paddingRight: M = O,
      paddingTop: E = O
    } = FH(t, e, n, r),
    T = 1 / 4,
    C = (tt, it, ut, st, ht) => {
      const { marks: Ot } = e
      if (Ot.length === 0) return [st, ht]
      if (tt - st - ht - tt * T > 0) return [st, ht]
      const le = tt * (1 - T)
      return [
        it === 'auto' ? (le * st) / (st + ht) : st,
        ut === 'auto' ? (le * ht) / (st + ht) : ht
      ]
    },
    A = (tt) => (tt === 'auto' ? 20 : tt ?? 20),
    P = A(E),
    k = A(S),
    L = b1(t, s - P - k, [P + x, k + b], ['left', 'right'], e, n, r),
    { paddingLeft: R, paddingRight: j } = L,
    I = o - m - w,
    [D, $] = C(I, _, M, R, j),
    B = I - D - $,
    F = b1(t, B, [D + m, $ + w], ['bottom', 'top'], e, n, r),
    { paddingTop: W, paddingBottom: U } = F,
    K = s - b - x,
    [V, H] = C(K, S, E, U, W),
    Q = K - V - H
  return {
    width: o,
    height: s,
    depth: c,
    insetLeft: d,
    insetTop: p,
    insetBottom: v,
    insetRight: g,
    innerWidth: B,
    innerHeight: Q,
    paddingLeft: D,
    paddingRight: $,
    paddingTop: H,
    paddingBottom: V,
    marginLeft: m,
    marginBottom: b,
    marginTop: x,
    marginRight: w,
    x: l,
    y: u,
    z: f
  }
}
function BH(t) {
  const {
      height: e,
      width: n,
      padding: r = 0,
      paddingLeft: i = r,
      paddingRight: a = r,
      paddingTop: o = r,
      paddingBottom: s = r,
      margin: c = 16,
      marginLeft: l = c,
      marginRight: u = c,
      marginTop: f = c,
      marginBottom: h = c,
      inset: d = 0,
      insetLeft: p = d,
      insetRight: v = d,
      insetTop: g = d,
      insetBottom: y = d
    } = t,
    m = (w) => (w === 'auto' ? 20 : w),
    b = n - m(i) - m(a) - l - u - p - v,
    x = e - m(o) - m(s) - f - h - g - y
  return { width: b, height: x }
}
function FH(t, e, n, r) {
  const { coordinates: i } = e
  if (!_i(i) && !Go(i)) return e
  const a = t.filter((y) => typeof y.type == 'string' && y.type.startsWith('axis'))
  if (a.length === 0) return e
  const o = a.map((y) => {
      const m = y.type === 'axisArc' ? 'arc' : 'linear'
      return wT(y, m, n)
    }),
    s = Ct(o, (y) => {
      var m
      return (m = y.labelSpacing) !== null && m !== void 0 ? m : 0
    }),
    c = a
      .flatMap((y, m) => {
        const b = o[m],
          x = Du(y, r)
        return $u(b, x)
      })
      .filter(Gt),
    l = Ct(c, (y) => y.height) + s,
    u = a
      .flatMap((y, m) => {
        const b = o[m]
        return Bu(b)
      })
      .filter((y) => y !== null),
    f = u.length === 0 ? 0 : Ct(u, (y) => y.height),
    {
      inset: h = l,
      insetLeft: d = h,
      insetBottom: p = h,
      insetTop: v = h + f,
      insetRight: g = h
    } = e
  return Object.assign(Object.assign({}, e), {
    insetLeft: d,
    insetBottom: p,
    insetTop: v,
    insetRight: g
  })
}
function b1(t, e, n, r, i, a, o) {
  const s = qt(t, (p) => p.position),
    {
      padding: c = a.padding,
      paddingLeft: l = c,
      paddingRight: u = c,
      paddingBottom: f = c,
      paddingTop: h = c
    } = i,
    d = { paddingBottom: f, paddingLeft: l, paddingTop: h, paddingRight: u }
  for (const p of r) {
    const v = `padding${qd(pS(p))}`,
      g = s.get(p) || [],
      y = d[v],
      m = (M) => {
        M.size === void 0 && (M.size = M.defaultSize)
      },
      b = (M) => {
        M.type === 'group'
          ? (M.children.forEach(m), (M.size = Ct(M.children, (E) => E.size)))
          : (M.size = M.defaultSize)
      },
      x = (M) => {
        M.size || (y !== 'auto' ? b(M) : (xT(M, e, n, p, a, o), m(M)))
      },
      w = (M) => {
        M.type.startsWith('axis') && M.labelAutoHide === void 0 && (M.labelAutoHide = !0)
      },
      O = p === 'bottom' || p === 'top',
      S = gn(g, (M) => M.order),
      _ = g.filter((M) => M.type.startsWith('axis') && M.order == S)
    if ((_.length && (_[0].crossPadding = 0), typeof y == 'number')) g.forEach(m), g.forEach(w)
    else if (g.length === 0) d[v] = 0
    else {
      const M = O ? e + n[0] + n[1] : e,
        E = bT(g, M)
      E.forEach(x)
      const T = E.reduce((C, { size: A, crossPadding: P = 12 }) => C + A + P, 0)
      d[v] = T
    }
  }
  return d
}
function zH(t, e, n) {
  const r = qt(t, (O) => `${O.plane || 'xy'}-${O.position}`),
    {
      paddingLeft: i,
      paddingRight: a,
      paddingTop: o,
      paddingBottom: s,
      marginLeft: c,
      marginTop: l,
      marginBottom: u,
      marginRight: f,
      innerHeight: h,
      innerWidth: d,
      insetBottom: p,
      insetLeft: v,
      insetRight: g,
      insetTop: y,
      height: m,
      width: b,
      depth: x
    } = n,
    w = {
      xy: Gf({
        width: b,
        height: m,
        paddingLeft: i,
        paddingRight: a,
        paddingTop: o,
        paddingBottom: s,
        marginLeft: c,
        marginTop: l,
        marginBottom: u,
        marginRight: f,
        innerHeight: h,
        innerWidth: d,
        insetBottom: p,
        insetLeft: v,
        insetRight: g,
        insetTop: y
      }),
      yz: Gf({
        width: x,
        height: m,
        paddingLeft: 0,
        paddingRight: 0,
        paddingTop: 0,
        paddingBottom: 0,
        marginLeft: 0,
        marginTop: 0,
        marginBottom: 0,
        marginRight: 0,
        innerWidth: x,
        innerHeight: m,
        insetBottom: 0,
        insetLeft: 0,
        insetRight: 0,
        insetTop: 0
      }),
      xz: Gf({
        width: b,
        height: x,
        paddingLeft: 0,
        paddingRight: 0,
        paddingTop: 0,
        paddingBottom: 0,
        marginLeft: 0,
        marginTop: 0,
        marginBottom: 0,
        marginRight: 0,
        innerWidth: b,
        innerHeight: x,
        insetBottom: 0,
        insetLeft: 0,
        insetRight: 0,
        insetTop: 0
      })
    }
  for (const [O, S] of r.entries()) {
    const [_, M] = O.split('-'),
      E = w[_][M],
      [T, C] = Rb(S, (A) =>
        typeof A.type != 'string'
          ? !1
          : !!(M === 'center' || (A.type.startsWith('axis') && ['inner', 'outer'].includes(M)))
      )
    T.length && GH(T, e, E, M), C.length && ZH(S, e, E)
  }
}
function Gf({
  width: t,
  height: e,
  paddingLeft: n,
  paddingRight: r,
  paddingTop: i,
  paddingBottom: a,
  marginLeft: o,
  marginTop: s,
  marginBottom: c,
  marginRight: l,
  innerHeight: u,
  innerWidth: f,
  insetBottom: h,
  insetLeft: d,
  insetRight: p,
  insetTop: v
}) {
  const g = n + o,
    y = i + s,
    m = r + l,
    b = a + c,
    x = t - o - l,
    w = [g + d, y + v, f - d - p, u - v - h, 'center', null, null]
  return {
    top: [g, 0, f, y, 'vertical', !0, ae, o, x],
    right: [t - m, y, m, u, 'horizontal', !1, ae],
    bottom: [g, e - b, f, b, 'vertical', !1, ae, o, x],
    left: [0, y, g, u, 'horizontal', !0, ae],
    'top-left': [g, 0, f, y, 'vertical', !0, ae],
    'top-right': [g, 0, f, y, 'vertical', !0, ae],
    'bottom-left': [g, e - b, f, b, 'vertical', !1, ae],
    'bottom-right': [g, e - b, f, b, 'vertical', !1, ae],
    center: w,
    inner: w,
    outer: w
  }
}
function GH(t, e, n, r) {
  const [i, a] = Rb(t, (o) => !!(typeof o.type == 'string' && o.type.startsWith('axis')))
  WH(i, e, n, r), QH(a, e, n)
}
function WH(t, e, n, r) {
  r === 'center'
    ? EC(e)
      ? KH(t, e, n)
      : Zt(e)
      ? VH(t, e, n)
      : cu(e) && XH(t, e, n, t[0].orientation)
    : r === 'inner'
    ? YH(t, e, n)
    : r === 'outer' && HH(t, e, n)
}
function YH(t, e, n) {
  const [r, i, , a] = n,
    [o, s] = e.getCenter(),
    [c] = lu(e),
    l = a / 2,
    u = c * l,
    f = o - u,
    h = s - u
  for (let d = 0; d < t.length; d++) {
    const p = t[d]
    p.bbox = { x: r + f, y: i + h, width: u * 2, height: u * 2 }
  }
}
function HH(t, e, n) {
  const [r, i, a, o] = n
  for (const s of t) s.bbox = { x: r, y: i, width: a, height: o }
}
function VH(t, e, n) {
  const [r, i, a, o] = n
  for (const s of t) s.bbox = { x: r, y: i, width: a, height: o }
}
function XH(t, e, n, r) {
  r === 'horizontal' ? qH(t, e, n) : r === 'vertical' && UH(t, e, n)
}
function UH(t, e, n) {
  const [r, i, , a] = n,
    o = new Array(t.length).fill(0),
    c = e
      .map(o)
      .filter((l, u) => u % 2 === 0)
      .map((l) => l + r)
  for (let l = 0; l < t.length; l++) {
    const u = t[l],
      f = c[l],
      h = c[l + 1] - f
    u.bbox = { x: f, y: i, width: h, height: a }
  }
}
function qH(t, e, n) {
  const [r, i, a] = n,
    o = new Array(t.length).fill(0),
    c = e
      .map(o)
      .filter((l, u) => u % 2 === 1)
      .map((l) => l + i)
  for (let l = 0; l < t.length; l++) {
    const u = t[l],
      f = c[l],
      h = c[l + 1] - f
    u.bbox = { x: r, y: f, width: a, height: h }
  }
}
function KH(t, e, n, r) {
  const [i, a, o, s] = n
  for (const c of t)
    (c.bbox = { x: i, y: a, width: o, height: s }),
      (c.radar = { index: t.indexOf(c), count: t.length })
}
function ZH(t, e, n) {
  const [r, i, a, o, s, c, l, u, f] = n,
    [h, d, p, v, g, y, m, b] =
      s === 'vertical'
        ? ['y', i, 'x', r, 'height', o, 'width', a]
        : ['x', r, 'y', i, 'width', a, 'height', o]
  t.sort((M, E) => (l == null ? void 0 : l(M.order, E.order)))
  const x = (M) => M === 'title' || M === 'group' || M.startsWith('legend'),
    w = (M, E, T) => (T === void 0 ? E : x(M) ? T : E),
    O = (M, E, T) => (T === void 0 ? E : x(M) ? T : E),
    S = c ? d + y : d
  for (let M = 0, E = S; M < t.length; M++) {
    const T = t[M],
      { crossPadding: C = 0, type: A } = T,
      { size: P } = T
    ;(T.bbox = { [h]: c ? E - P - C : E + C, [p]: O(A, v, u), [g]: P, [m]: w(A, b, f) }),
      (E += (P + C) * (c ? -1 : 1))
  }
  const _ = t.filter((M) => M.type === 'group')
  for (const M of _) {
    const { bbox: E, children: T } = M,
      C = E[m],
      A = C / T.length,
      P = T.reduce((I, D) => {
        var $
        const B = ($ = D.layout) === null || $ === void 0 ? void 0 : $.justifyContent
        return B || I
      }, 'flex-start'),
      k = T.map((I, D) => {
        const { length: $ = A, padding: B = 0 } = I
        return $ + (D === T.length - 1 ? 0 : B)
      }),
      L = Pn(k),
      R = C - L,
      j = P === 'flex-start' ? 0 : P === 'center' ? R / 2 : R
    for (let I = 0, D = E[p] + j; I < T.length; I++) {
      const $ = T[I],
        { padding: B = 0 } = $,
        F = I === T.length - 1 ? 0 : B
      ;($.bbox = { [g]: E[g], [h]: E[h], [p]: D, [m]: k[I] - F }),
        X($, { layout: { justifyContent: P } }),
        (D += k[I])
    }
  }
}
function QH(t, e, n) {
  if (t.length === 0) return
  const [r, i, a, o] = n,
    [s] = lu(e),
    c = ((o / 2) * s) / Math.sqrt(2),
    l = r + a / 2,
    u = i + o / 2
  for (let f = 0; f < t.length; f++) {
    const h = t[f]
    h.bbox = { x: l - c, y: u - c, width: c * 2, height: c * 2 }
  }
}
var JH =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, r) {
      function i(a) {
        return a instanceof n
          ? a
          : new n(function (o) {
              o(a)
            })
      }
      return new (n || (n = Promise))(function (a, o) {
        function s(u) {
          try {
            l(r.next(u))
          } catch (f) {
            o(f)
          }
        }
        function c(u) {
          try {
            l(r.throw(u))
          } catch (f) {
            o(f)
          }
        }
        function l(u) {
          u.done ? a(u.value) : i(u.value).then(s, c)
        }
        l((r = r.apply(t, e || [])).next())
      })
    },
  Va =
    (globalThis && globalThis.__rest) ||
    function (t, e) {
      var n = {}
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
      if (t != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          e.indexOf(r[i]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
            (n[r[i]] = t[r[i]])
      return n
    }
function tV(t, e, n) {
  const { encode: r = {}, scale: i = {}, transform: a = [] } = e,
    o = Va(e, ['encode', 'scale', 'transform'])
  return [t, Object.assign(Object.assign({}, o), { encode: r, scale: i, transform: a })]
}
function ST(t, e, n) {
  return JH(this, void 0, void 0, function* () {
    const { library: r } = n,
      { data: i } = e,
      [a] = Kt('data', r),
      o = dV(i),
      { transform: s = [] } = o,
      u = [Va(o, ['transform']), ...s].map(a),
      f = yield Bk(u)(i),
      h = i && !Array.isArray(i) && !Array.isArray(f) ? { value: f } : f
    return [Array.isArray(f) ? Yi(f) : [], Object.assign(Object.assign({}, e), { data: h })]
  })
}
function eV(t, e, n) {
  const { encode: r } = e
  if (!r) return [t, e]
  const i = {}
  for (const [a, o] of Object.entries(r))
    if (Array.isArray(o))
      for (let s = 0; s < o.length; s++) {
        const c = `${a}${s === 0 ? '' : s}`
        i[c] = o[s]
      }
    else i[a] = o
  return [t, Object.assign(Object.assign({}, e), { encode: i })]
}
function nV(t, e, n) {
  const { encode: r, data: i } = e
  if (!r) return [t, e]
  const a = ri(r, (o) => (uV(o) ? o : { type: fV(i, o), value: o }))
  return [t, Object.assign(Object.assign({}, e), { encode: a })]
}
function rV(t, e, n) {
  const { encode: r } = e
  if (!r) return [t, e]
  const i = ri(r, (a, o) => {
    const { type: s } = a
    return s !== 'constant' || cH(o) ? a : Object.assign(Object.assign({}, a), { constant: !0 })
  })
  return [t, Object.assign(Object.assign({}, e), { encode: i })]
}
function iV(t, e, n) {
  const { encode: r, data: i } = e
  if (!r) return [t, e]
  const { library: a } = n,
    o = gV(a),
    s = ri(r, (c) => o(i, c))
  return [t, Object.assign(Object.assign({}, e), { encode: s })]
}
function aV(t, e, n) {
  const { tooltip: r = {} } = e
  return Er(r)
    ? [t, e]
    : Array.isArray(r)
    ? [t, Object.assign(Object.assign({}, e), { tooltip: { items: r } })]
    : Uo(r) && HS(r)
    ? [t, Object.assign(Object.assign({}, e), { tooltip: r })]
    : [t, Object.assign(Object.assign({}, e), { tooltip: { items: [r] } })]
}
function oV(t, e, n) {
  const { data: r, encode: i, tooltip: a = {} } = e
  if (Er(a)) return [t, e]
  const o = (f) => {
      if (!f) return f
      if (typeof f == 'string') return t.map((h) => ({ name: f, value: r[h][f] }))
      if (Uo(f)) {
        const { field: h, channel: d, color: p, name: v = h, valueFormatter: g = (O) => O } = f,
          y = typeof g == 'string' ? li(g) : g,
          m = d && i[d],
          b = m && i[d].field,
          x = v || b || d,
          w = []
        for (const O of t) {
          const S = h ? r[O][h] : m ? i[d].value[O] : null
          w[O] = { name: x, color: p, value: y(S) }
        }
        return w
      }
      if (typeof f == 'function') {
        const h = []
        for (const d of t) {
          const p = f(r[d], d, r, i)
          Uo(p) ? (h[d] = p) : (h[d] = { value: p })
        }
        return h
      }
      return f
    },
    { title: s, items: c = [] } = a,
    l = Va(a, ['title', 'items']),
    u = Object.assign({ title: o(s), items: Array.isArray(c) ? c.map(o) : [] }, l)
  return [t, Object.assign(Object.assign({}, e), { tooltip: u })]
}
function sV(t, e, n) {
  const { encode: r } = e,
    i = Va(e, ['encode'])
  if (!r) return [t, e]
  const a = Object.entries(r),
    o = a
      .filter(([, c]) => {
        const { value: l } = c
        return Array.isArray(l[0])
      })
      .flatMap(([c, l]) => {
        const u = [[c, new Array(t.length).fill(void 0)]],
          { value: f } = l,
          h = Va(l, ['value'])
        for (let d = 0; d < f.length; d++) {
          const p = f[d]
          if (Array.isArray(p))
            for (let v = 0; v < p.length; v++) {
              const g = u[v] || [`${c}${v}`, new Array(t).fill(void 0)]
              ;(g[1][d] = p[v]), (u[v] = g)
            }
        }
        return u.map(([d, p]) => [d, Object.assign({ type: 'column', value: p }, h)])
      }),
    s = Object.fromEntries([...a, ...o])
  return [t, Object.assign(Object.assign({}, i), { encode: s })]
}
function cV(t, e, n) {
  const { axis: r = {}, legend: i = {}, slider: a = {}, scrollbar: o = {} } = e,
    s = (l, u) => {
      if (typeof l == 'boolean') return l ? {} : null
      const f = l[u]
      return f === void 0 || f ? f : null
    },
    c = typeof r == 'object' ? Array.from(new Set(['x', 'y', ...Object.keys(r)])) : ['x', 'y']
  return (
    X(e, {
      scale: Object.assign(
        Object.assign(
          {},
          Object.fromEntries(
            c.map((l) => {
              const u = s(o, l)
              return [
                l,
                Object.assign(
                  { guide: s(r, l), slider: s(a, l), scrollbar: u },
                  u && { ratio: u.ratio === void 0 ? 0.5 : u.ratio }
                )
              ]
            })
          )
        ),
        {
          color: { guide: s(i, 'color') },
          size: { guide: s(i, 'size') },
          shape: { guide: s(i, 'shape') },
          opacity: { guide: s(i, 'opacity') }
        }
      )
    }),
    [t, e]
  )
}
function lV(t, e, n) {
  const { animate: r } = e
  return r || r === void 0
    ? [t, e]
    : (X(e, { animate: { enter: { type: null }, exit: { type: null }, update: { type: null } } }),
      [t, e])
}
function uV(t) {
  if (typeof t != 'object' || t instanceof Date || t === null) return !1
  const { type: e } = t
  return Gt(e)
}
function fV(t, e) {
  return typeof e == 'function'
    ? 'transform'
    : typeof e == 'string' && hV(t, e)
    ? 'field'
    : 'constant'
}
function hV(t, e) {
  return Array.isArray(t) ? t.some((n) => n[e] !== void 0) : !1
}
function dV(t) {
  if (ve(t)) return { type: 'inline', value: t }
  if (!t) return { type: 'inline', value: null }
  if (Array.isArray(t)) return { type: 'inline', value: t }
  const { type: e = 'inline' } = t,
    n = Va(t, ['type'])
  return Object.assign(Object.assign({}, n), { type: e })
}
var _T =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, r) {
      function i(a) {
        return a instanceof n
          ? a
          : new n(function (o) {
              o(a)
            })
      }
      return new (n || (n = Promise))(function (a, o) {
        function s(u) {
          try {
            l(r.next(u))
          } catch (f) {
            o(f)
          }
        }
        function c(u) {
          try {
            l(r.throw(u))
          } catch (f) {
            o(f)
          }
        }
        function l(u) {
          u.done ? a(u.value) : i(u.value).then(s, c)
        }
        l((r = r.apply(t, e || [])).next())
      })
    },
  pV =
    (globalThis && globalThis.__rest) ||
    function (t, e) {
      var n = {}
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
      if (t != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          e.indexOf(r[i]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
            (n[r[i]] = t[r[i]])
      return n
    }
function vV(t, e, n) {
  return _T(this, void 0, void 0, function* () {
    const r = { library: n },
      [i, a] = yield yV(t, e, r),
      { encode: o, scale: s, data: c, tooltip: l } = a
    if (Array.isArray(c) === !1) return null
    const { channels: u } = e,
      f = Pb(
        Object.entries(o).filter(([, d]) => Gt(d)),
        (d) => d.map(([p, v]) => Object.assign({ name: p }, v)),
        ([d]) => {
          var p
          const v = (p = /([^\d]+)\d*$/.exec(d)) === null || p === void 0 ? void 0 : p[1],
            g = u.find((y) => y.name === v)
          return g != null && g.independent ? d : v
        }
      ),
      h = u
        .filter((d) => {
          const { name: p, required: v } = d
          if (f.find(([g]) => g === p)) return !0
          if (v) throw new Error(`Missing encoding for channel: ${p}.`)
          return !1
        })
        .flatMap((d) => {
          const { name: p, scale: v, scaleKey: g, range: y, quantitative: m, ordinal: b } = d
          return f
            .filter(([w]) => w.startsWith(p))
            .map(([w, O], S) => {
              const _ = O.some((R) => R.visual),
                M = O.some((R) => R.constant),
                E = s[w] || {},
                {
                  independent: T = !1,
                  key: C = g || w,
                  type: A = M ? 'constant' : _ ? 'identity' : v
                } = E,
                P = pV(E, ['independent', 'key', 'type']),
                k = A === 'constant',
                L = k ? void 0 : y
              return {
                name: w,
                values: O,
                scaleKey: T || k ? Symbol('independent') : C,
                scale: Object.assign(Object.assign({ type: A, range: L }, P), {
                  quantitative: m,
                  ordinal: b
                })
              }
            })
        })
    return [a, Object.assign(Object.assign({}, e), { index: i, channels: h, tooltip: l })]
  })
}
function gV(t) {
  const [e] = Kt('encode', t)
  return (n, r) =>
    r === void 0 || n === void 0
      ? null
      : Object.assign(Object.assign({}, r), { type: 'column', value: e(r)(n), field: mV(r) })
}
function yV(t, e, n) {
  return _T(this, void 0, void 0, function* () {
    const { library: r } = n,
      [i] = Kt('transform', r),
      { preInference: a = [], postInference: o = [] } = e,
      { transform: s = [] } = t,
      c = [tV, ST, eV, nV, rV, iV, sV, lV, cV, aV, ...a.map(i), ...s.map(i), ...o.map(i), oV]
    let l = [],
      u = t
    for (const f of c) [l, u] = yield f(l, u, n)
    return [l, u]
  })
}
function mV(t) {
  const { type: e, value: n } = t
  return e === 'field' && typeof n == 'string' ? n : null
}
var _r =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, r) {
      function i(a) {
        return a instanceof n
          ? a
          : new n(function (o) {
              o(a)
            })
      }
      return new (n || (n = Promise))(function (a, o) {
        function s(u) {
          try {
            l(r.next(u))
          } catch (f) {
            o(f)
          }
        }
        function c(u) {
          try {
            l(r.throw(u))
          } catch (f) {
            o(f)
          }
        }
        function l(u) {
          u.done ? a(u.value) : i(u.value).then(s, c)
        }
        l((r = r.apply(t, e || [])).next())
      })
    },
  ti =
    (globalThis && globalThis.__rest) ||
    function (t, e) {
      var n = {}
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
      if (t != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          e.indexOf(r[i]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
            (n[r[i]] = t[r[i]])
      return n
    }
function W0(t, e, n, r) {
  var i, a
  return _r(this, void 0, void 0, function* () {
    const [o] = Kt('composition', n),
      [s] = Kt('interaction', n),
      c = new Set(
        Object.keys(n)
          .map((P) => {
            var k
            return (k = /mark\.(.*)/.exec(P)) === null || k === void 0 ? void 0 : k[1]
          })
          .filter(Gt)
      ),
      l = new Set(
        Object.keys(n)
          .map((P) => {
            var k
            return (k = /component\.(.*)/.exec(P)) === null || k === void 0 ? void 0 : k[1]
          })
          .filter(Gt)
      ),
      u = (P) => {
        const { type: k } = P
        if (typeof k == 'function') {
          const { props: L = {} } = k,
            { composite: R = !0 } = L
          if (R) return 'mark'
        }
        return typeof k != 'string' ? k : c.has(k) || l.has(k) ? 'mark' : k
      },
      f = (P) => u(P) === 'mark',
      h = (P) => u(P) === 'standardView',
      d = (P) => {
        const { type: k } = P
        return typeof k != 'string' ? !1 : !!l.has(k)
      },
      p = (P) => {
        if (h(P)) return [P]
        const k = u(P)
        return o({ type: k, static: d(P) })(P)
      },
      v = [],
      g = new Map(),
      y = new Map(),
      m = [t],
      b = []
    for (; m.length; ) {
      const P = m.shift()
      if (h(P)) {
        const k = y.get(P),
          [L, R] = k ? TT(k, P, n) : yield MT(P, n)
        g.set(L, P), v.push(L)
        const j = R.flatMap(p).map((I) => jE(I, n))
        if ((m.push(...j), j.every(h))) {
          const I = yield Promise.all(j.map((D) => ET(D, n)))
          zY(I)
          for (let D = 0; D < j.length; D++) {
            const $ = j[D],
              B = I[D]
            y.set($, B)
          }
        }
      } else {
        const k = f(P) ? P : yield CT(P, n),
          L = p(k)
        Array.isArray(L) ? m.push(...L) : typeof L == 'function' && b.push(L())
      }
    }
    r.emitter.emit(Lt.BEFORE_PAINT)
    const x = new Map(),
      w = new Map(),
      O = []
    e.selectAll(nr(id))
      .data(v, (P) => P.key)
      .join(
        (P) =>
          P.append('g')
            .attr('className', id)
            .attr('id', (k) => k.key)
            .call(x1)
            .each(function (k, L, R) {
              Md(k, ot(R), O, n, r), x.set(k, R)
            }),
        (P) =>
          P.call(x1).each(function (k, L, R) {
            Md(k, ot(R), O, n, r), w.set(k, R)
          }),
        (P) =>
          P.each(function (k, L, R) {
            const j = R.nameInteraction.values()
            for (const I of j) I.destroy()
          }).remove()
      )
    const S = (P) =>
        Array.from(P.entries()).map(([k, L]) => {
          const R = new Map(),
            j = ($, B = (F) => F) => R.set($, B),
            I = bV(ot(L), n, r),
            D = g.get(k)
          return {
            view: k,
            container: L,
            options: D,
            setState: j,
            update: () =>
              _r(this, void 0, void 0, function* () {
                const B = Ud(Array.from(R.values()))(D)
                return yield I(B)
              })
          }
        }),
      _ = S(x)
    for (const P of _) {
      const { options: k } = P,
        L = new Map()
      P.container.nameInteraction = L
      for (const R of Ed(k)) {
        const [j, I] = R
        if (I) {
          const $ = _d(P.view, j, I, s)(P, _, r.emitter)
          L.set(j, { destroy: $ })
        }
      }
    }
    const M = S(w)
    for (const P of M) {
      const { options: k, container: L } = P,
        R = L.nameInteraction
      for (const j of Ed(k)) {
        const [I, D] = j,
          $ = R.get(I)
        if (($ && ((i = $.destroy) === null || i === void 0 || i.call($)), D)) {
          const F = _d(P.view, I, D, s)(P, M, r.emitter)
          R.set(I, { destroy: F })
        }
      }
    }
    const { width: E, height: T } = t,
      C = []
    for (const P of b) {
      const k = new Promise((L) =>
        _r(this, void 0, void 0, function* () {
          for (const R of P) {
            const j = Object.assign({ width: E, height: T }, R)
            yield W0(j, e, n, r)
          }
          L()
        })
      )
      C.push(k)
    }
    ;(r.views = v),
      (a = r.animations) === null ||
        a === void 0 ||
        a.forEach((P) => (P == null ? void 0 : P.cancel())),
      (r.animations = O),
      r.emitter.emit(Lt.AFTER_PAINT)
    const A = O.filter(Gt)
      .map(RV)
      .map((P) => P.finished)
    return Promise.all([...A, ...C])
  })
}
function x1(t) {
  t.style('transform', (e) => `translate(${e.layout.x}, ${e.layout.y})`)
}
function bV(t, e, n) {
  return (r) =>
    _r(this, void 0, void 0, function* () {
      const i = [],
        [a, o] = yield MT(r, e)
      Md(a, t, i, e, n), xV(t, r, a, e, n)
      for (const s of o) W0(s, t, e, n)
      return { options: r, view: a }
    })
}
function xV(t, e, n, r, i) {
  var a
  const [o] = Kt('interaction', r),
    c = t.node().nameInteraction,
    l = Ed(e).find(([p]) => p === 'tooltip'),
    u = c.get('tooltip')
  if (!u || ((a = u.destroy) === null || a === void 0 || a.call(u), !l[1])) return
  const f = _d(n, 'tooltip', l[1], o),
    h = { options: e, view: n, container: t.node(), update: (p) => Promise.resolve(p) },
    d = f(h, [], i.emitter)
  c.set('tooltip', { destroy: d })
}
function MT(t, e) {
  return _r(this, void 0, void 0, function* () {
    const n = yield OV(t, e),
      r = wV(n)
    ;(t.interaction = r.interaction),
      (t.coordinate = r.coordinate),
      (t.marks = [...r.marks, ...r.components])
    const i = jE(r, e),
      a = yield ET(i, e)
    return TT(a, i, e)
  })
}
function wV(t) {
  const { coordinate: e = {}, interaction: n = {}, style: r = {}, marks: i } = t,
    a = ti(t, ['coordinate', 'interaction', 'style', 'marks']),
    o = i.map((h) => h.coordinate || {}),
    s = i.map((h) => h.interaction || {}),
    c = i.map((h) => h.viewStyle || {}),
    l = [...o, e].reduceRight((h, d) => X(h, d), {}),
    u = [n, ...s].reduce((h, d) => X(h, d), {}),
    f = [...c, r].reduce((h, d) => X(h, d), {})
  return Object.assign(Object.assign({}, a), { marks: i, coordinate: l, interaction: u, style: f })
}
function OV(t, e) {
  return _r(this, void 0, void 0, function* () {
    const [n, r] = Kt('mark', e),
      i = new Set(
        Object.keys(e)
          .map((h) => {
            var d
            return (d = /component\.(.*)/.exec(h)) === null || d === void 0 ? void 0 : d[1]
          })
          .filter(Gt)
      ),
      { marks: a } = t,
      o = [],
      s = [],
      c = [...a],
      { width: l, height: u } = BH(t),
      f = { options: t, width: l, height: u }
    for (; c.length; ) {
      const [h] = c.splice(0, 1),
        d = yield CT(h, e),
        { type: p = ql('G2Mark type is required.'), key: v } = d
      if (i.has(p)) s.push(d)
      else {
        const { props: g = {} } = r(p),
          { composite: y = !0 } = g
        if (!y) o.push(d)
        else {
          const { data: m } = d,
            b = Object.assign(Object.assign({}, d), {
              data: m && (Array.isArray(m) ? m : m.value)
            }),
            x = yield n(b, f),
            w = Array.isArray(x) ? x : [x]
          c.unshift(...w.map((O, S) => Object.assign(Object.assign({}, O), { key: `${v}-${S}` })))
        }
      }
    }
    return Object.assign(Object.assign({}, t), { marks: o, components: s })
  })
}
function ET(t, e) {
  return _r(this, void 0, void 0, function* () {
    const [n] = Kt('theme', e),
      [, r] = Kt('mark', e),
      { theme: i, marks: a, coordinates: o = [] } = t,
      s = n(kT(i)),
      c = new Map()
    for (const u of a) {
      const { type: f } = u,
        { props: h = {} } = r(f),
        d = yield vV(u, h, e)
      if (d) {
        const [p, v] = d
        c.set(p, v)
      }
    }
    const l = qt(
      Array.from(c.values()).flatMap((u) => u.channels),
      ({ scaleKey: u }) => u
    )
    for (const u of l.values()) {
      const f = u.reduce((b, { scale: x }) => X(b, x), {}),
        { scaleKey: h } = u[0],
        { values: d } = u[0],
        p = Array.from(new Set(d.map((b) => b.field).filter(Gt))),
        v = X({ guide: { title: p.length === 0 ? void 0 : p }, field: p[0] }, f),
        { name: g } = u[0],
        y = u.flatMap(({ values: b }) => b.map((x) => x.value)),
        m = Object.assign(Object.assign({}, DY(g, y, v, o, s, e)), { key: h })
      u.forEach((b) => (b.scale = m))
    }
    return c
  })
}
function _d(t, e, n, r) {
  const i = t.theme,
    a = typeof e == 'string' ? i[e] || {} : {}
  return r(X(a, Object.assign({ type: e }, n)))
}
function TT(t, e, n) {
  const [r] = Kt('mark', n),
    [i] = Kt('theme', n),
    [a] = Kt('labelTransform', n),
    { key: o, frame: s = !1, theme: c, clip: l, style: u = {}, labelTransform: f = [] } = e,
    h = i(kT(c)),
    d = Array.from(t.values()),
    p = BY(d, e),
    v = vH(pH($V(Array.from(p), d, t), e, n)),
    g = $H(v, e, h, n),
    y = dW(g, e, n),
    m = s ? X({ mainLineWidth: 1, mainStroke: '#000' }, u) : u
  zH(bT(v), y, g), DH(v)
  const b = {}
  for (const O of v) {
    const { scales: S = [] } = O,
      _ = []
    for (const M of S) {
      const { name: E } = M,
        T = f1(M, n)
      _.push(T), u1(b, { [E]: T })
    }
    O.scaleInstances = _
  }
  const x = []
  for (const [O, S] of t.entries()) {
    const { children: _, dataDomain: M, modifier: E, key: T } = O,
      { index: C, channels: A, tooltip: P } = S,
      k = Object.fromEntries(A.map(({ name: H, scale: Q }) => [H, Q])),
      L = ri(k, (H) => f1(H, n))
    u1(b, L)
    const R = $Y(A, L),
      j = r(O),
      [I, D, $] = MV(j(C, L, R, y)),
      B = M || I.length,
      F = E ? E(D, B, g) : [],
      W = (H) => {
        var Q, tt
        return (tt = (Q = P.title) === null || Q === void 0 ? void 0 : Q[H]) === null ||
          tt === void 0
          ? void 0
          : tt.value
      },
      U = (H) => P.items.map((Q) => Q[H]),
      K = I.map((H, Q) => {
        const tt = Object.assign(
          { points: D[Q], transform: F[Q], index: H, markKey: T, viewKey: o },
          P && { title: W(H), items: U(H) }
        )
        for (const [it, ut] of Object.entries(R))
          (tt[it] = ut[H]), $ && (tt[`series${ni(it)}`] = $[Q].map((st) => ut[st]))
        return (
          $ && (tt.seriesIndex = $[Q]),
          $ &&
            P &&
            ((tt.seriesItems = $[Q].map((it) => U(it))),
            (tt.seriesTitle = $[Q].map((it) => W(it)))),
          tt
        )
      })
    ;(S.data = K), (S.index = I)
    const V = _ == null ? void 0 : _(K, L, g)
    x.push(...(V || []))
  }
  return [
    {
      layout: g,
      theme: h,
      coordinate: y,
      markState: t,
      key: o,
      clip: l,
      scale: b,
      style: m,
      components: v,
      labelTransform: Ud(f.map(a))
    },
    x
  ]
}
function Md(t, e, n, r, i) {
  return _r(this, void 0, void 0, function* () {
    const {
        components: a,
        theme: o,
        layout: s,
        markState: c,
        coordinate: l,
        key: u,
        style: f,
        clip: h,
        scale: d
      } = t,
      { x: p, y: v, width: g, height: y } = s,
      m = ti(s, ['x', 'y', 'width', 'height']),
      b = ['view', 'plot', 'main', 'content'],
      x = b.map((j, I) => I),
      w = ['a', 'margin', 'padding', 'inset'],
      O = b.map((j) => Cb(Object.assign({}, o.view, f), j)),
      S = w.map((j) => et(m, j)),
      _ = (j) =>
        j
          .style('x', (I) => A[I].x)
          .style('y', (I) => A[I].y)
          .style('width', (I) => A[I].width)
          .style('height', (I) => A[I].height)
          .each(function (I, D, $) {
            BV(ot($), O[I])
          })
    let M = 0,
      E = 0,
      T = g,
      C = y
    const A = x.map((j) => {
      const I = S[j],
        { left: D = 0, top: $ = 0, bottom: B = 0, right: F = 0 } = I
      return (M += D), (E += $), (T -= D + F), (C -= $ + B), { x: M, y: E, width: T, height: C }
    })
    e.selectAll(nr(wm))
      .data(
        x.filter((j) => Gt(O[j])),
        (j) => b[j]
      )
      .join(
        (j) => j.append('rect').attr('className', wm).style('zIndex', -2).call(_),
        (j) => j.call(_),
        (j) => j.remove()
      )
    const P = AV(c),
      k = P ? { duration: P[1] } : !1
    for (const [, j] of Yd(a, (I) => `${I.type}-${I.position}`)) j.forEach((I, D) => (I.index = D))
    const L = e
      .selectAll(nr(xm))
      .data(a, (j) => `${j.type}-${j.position}-${j.index}`)
      .join(
        (j) =>
          j
            .append('g')
            .style('zIndex', ({ zIndex: I }) => I || -1)
            .attr('className', xm)
            .append((I) => m1(X({ animate: k, scale: d }, I), l, o, r, c)),
        (j) =>
          j.transition(function (I, D, $) {
            const { preserve: B = !1 } = I
            if (B) return
            const F = m1(X({ animate: k, scale: d }, I), l, o, r, c),
              { attributes: W } = F,
              [U] = $.childNodes
            return U.update(W)
          })
      )
      .transitions()
    n.push(...L.flat().filter(Gt))
    const R = e
      .selectAll(nr(ad))
      .data([s], () => u)
      .join(
        (j) =>
          j
            .append('rect')
            .style('zIndex', 0)
            .style('fill', 'transparent')
            .attr('className', ad)
            .call(w1)
            .call(O1, Array.from(c.keys()))
            .call(S1, h),
        (j) =>
          j
            .call(O1, Array.from(c.keys()))
            .call((I) => (P ? DV(I, P) : w1(I)))
            .call(S1, h)
      )
      .transitions()
    n.push(...R.flat())
    for (const [j, I] of c.entries()) {
      const { data: D } = I,
        { key: $, class: B, type: F } = j,
        W = e.select(`#${$}`),
        U = LV(j, I, t, r, i),
        K = NV(j, I, t, r),
        V = IV(j, I, t, r),
        H = jV(j, I, t, r),
        Q = kV(e, W, B, 'element'),
        tt = W.selectAll(nr(pr))
          .selectFacetAll(Q)
          .data(
            D,
            (it) => it.key,
            (it) => it.groupKey
          )
          .join(
            (it) =>
              it
                .append(U)
                .attr('className', pr)
                .attr('markType', F)
                .transition(function (ut, st, ht) {
                  return K(ut, [ht])
                }),
            (it) =>
              it.call((ut) => {
                const st = ut.parent(),
                  ht = Fk((Ot) => {
                    const [Mt, Yt] = Ot.getBounds().min
                    return [Mt, Yt]
                  })
                ut.transition(function (Ot, Mt, Yt) {
                  CV(Yt, st, ht)
                  const le = U(Ot, Mt),
                    Ve = V(Ot, [Yt], [le])
                  return (
                    Ve !== null ||
                      (Yt.nodeName === le.nodeName && le.nodeName !== 'g'
                        ? Kd(Yt, le)
                        : (Yt.parentNode.replaceChild(le, Yt),
                          (le.className = pr),
                          (le.markType = F),
                          (le.__data__ = Yt.__data__))),
                    Ve
                  )
                })
                  .attr('markType', F)
                  .attr('className', pr)
              }),
            (it) =>
              it
                .each(function (ut, st, ht) {
                  ht.__removed__ = !0
                })
                .transition(function (ut, st, ht) {
                  return H(ut, [ht])
                })
                .remove(),
            (it) =>
              it
                .append(U)
                .attr('className', pr)
                .attr('markType', F)
                .transition(function (ut, st, ht) {
                  const { __fromElements__: Ot } = ht,
                    Mt = V(ut, Ot, [ht])
                  return new dl(Ot, null, ht.parentNode).transition(Mt).remove(), Mt
                }),
            (it) =>
              it
                .transition(function (ut, st, ht) {
                  const Mt = new dl([], ht.__toData__, ht.parentNode)
                    .append(U)
                    .attr('className', pr)
                    .attr('markType', F)
                    .nodes()
                  return V(ut, [ht], Mt)
                })
                .remove()
          )
          .transitions()
      n.push(...tt.flat())
    }
    SV(t, e, n, r, i)
  })
}
function SV(t, e, n, r, i) {
  const [a] = Kt('labelTransform', r),
    { markState: o, labelTransform: s } = t,
    c = e.select(nr(rd)).node(),
    l = new Map(),
    u = new Map(),
    f = Array.from(o.entries()).flatMap(([v, g]) => {
      const { labels: y = [], key: m } = v,
        b = PV(v, g, t, r, i),
        x = e
          .select(`#${m}`)
          .selectAll(nr(pr))
          .nodes()
          .filter((w) => !w.__removed__)
      return y.flatMap((w, O) => {
        const S = ti(w, ['transform'])
        return x.flatMap((_) => {
          const M = _V(S, O, _)
          return (
            M.forEach((E) => {
              l.set(E, b), u.set(E, w)
            }),
            M
          )
        })
      })
    }),
    h = ot(c)
      .selectAll(nr(od))
      .data(f, (v) => v.key)
      .join(
        (v) => v.append((g) => l.get(g)(g)).attr('className', od),
        (v) =>
          v.each(function (g, y, m) {
            const x = l.get(g)(g)
            Kd(m, x)
          }),
        (v) => v.remove()
      )
      .nodes(),
    d = qt(h, (v) => u.get(v.__data__)),
    { coordinate: p } = t
  for (const [v, g] of d) {
    const { transform: y = [] } = v
    Ud(y.map(a))(g, p)
  }
  s && s(h, p)
}
function _V(t, e, n) {
  const { seriesIndex: r, seriesKey: i, points: a, key: o, index: s } = n.__data__,
    c = TV(n)
  if (!r)
    return [
      Object.assign(Object.assign({}, t), {
        key: `${o}-${e}`,
        bounds: c,
        index: s,
        points: a,
        dependentElement: n
      })
    ]
  const l = EV(t),
    u = r.map((f, h) =>
      Object.assign(Object.assign({}, t), {
        key: `${i[h]}-${e}`,
        bounds: [a[h]],
        index: f,
        points: a,
        dependentElement: n
      })
    )
  return l ? l(u) : u
}
function MV([t, e, n]) {
  if (n) return [t, e, n]
  const r = [],
    i = []
  for (let a = 0; a < t.length; a++) {
    const o = t[a],
      s = e[a]
    s.every(([c, l]) => Gt(c) && Gt(l)) && (r.push(o), i.push(s))
  }
  return [r, i]
}
function EV(t) {
  const { selector: e } = t
  if (!e) return null
  if (typeof e == 'function') return e
  if (e === 'first') return (n) => [n[0]]
  if (e === 'last') return (n) => [n[n.length - 1]]
  throw new Error(`Unknown selector: ${e}`)
}
function TV(t) {
  const e = t.cloneNode(),
    n = t.getAnimations()
  ;(e.style.visibility = 'hidden'),
    n.forEach((o) => {
      const s = o.effect.getKeyframes()
      e.attr(s[s.length - 1])
    }),
    t.parentNode.appendChild(e)
  const r = e.getLocalBounds()
  e.destroy()
  const { min: i, max: a } = r
  return [i, a]
}
function PV(t, e, n, r, i) {
  const [a] = Kt('shape', r),
    { data: o } = t,
    { data: s, defaultLabelShape: c } = e,
    l = s.map((d) => d.points),
    { theme: u, coordinate: f } = n,
    h = Object.assign(Object.assign({}, i), { document: IE(i), theme: u, coordinate: f })
  return (d) => {
    const { index: p, points: v } = d,
      g = o[p],
      { formatter: y = (k) => `${k}`, transform: m, style: b, render: x } = d,
      w = ti(d, ['formatter', 'transform', 'style', 'render']),
      O = ri(Object.assign(Object.assign({}, w), b), (k) => PT(k, g, p, o)),
      { shape: S = c, text: _ } = O,
      M = ti(O, ['shape', 'text']),
      E = typeof y == 'string' ? li(y) : y,
      T = Object.assign(Object.assign({}, M), { text: E(_, g, p, o), datum: g }),
      C = Object.assign({ type: `label.${S}`, render: x }, M),
      A = a(C, h),
      P = AT(u, 'label', S, 'label')
    return A(v, T, P, l)
  }
}
function PT(t, e, n, r) {
  return typeof t == 'function' ? t(e, n, r) : typeof t != 'string' ? t : e[t] !== void 0 ? e[t] : t
}
function AV(t) {
  let e = -1 / 0,
    n = 1 / 0
  for (const [r, i] of t) {
    const { animate: a = {} } = r,
      { data: o } = i,
      { enter: s = {}, update: c = {}, exit: l = {} } = a,
      { type: u, duration: f = 300, delay: h = 0 } = c,
      { type: d, duration: p = 300, delay: v = 0 } = s,
      { type: g, duration: y = 300, delay: m = 0 } = l
    for (const b of o) {
      const {
        updateType: x = u,
        updateDuration: w = f,
        updateDelay: O = h,
        enterType: S = d,
        enterDuration: _ = p,
        enterDelay: M = v,
        exitDuration: E = y,
        exitDelay: T = m,
        exitType: C = g
      } = b
      ;(x === void 0 || x) && ((e = Math.max(e, w + O)), (n = Math.min(n, O))),
        (C === void 0 || C) && ((e = Math.max(e, E + T)), (n = Math.min(n, T))),
        (S === void 0 || S) && ((e = Math.max(e, _ + M)), (n = Math.min(n, M)))
    }
  }
  return e === -1 / 0 ? null : [n, e - n]
}
function kV(t, e, n, r) {
  return t
    .node()
    .parentElement.findAll((a) => a.style.facet !== void 0 && a.style.facet === n && a !== e.node())
    .flatMap((a) => a.getElementsByClassName(r))
}
function CV(t, e, n) {
  if (!t.__facet__) return
  const r = t.parentNode.parentNode,
    i = e.parentNode,
    [a, o] = n(r),
    [s, c] = n(i),
    l = `translate(${a - s}, ${o - c})`
  zk(t, l), e.append(t)
}
function LV(t, e, n, r, i) {
  const [a] = Kt('shape', r),
    { data: o } = t,
    { defaultShape: s, data: c, shape: l } = e,
    u = c.map((g) => g.points),
    { theme: f, coordinate: h } = n,
    { type: d, style: p = {} } = t,
    v = Object.assign(Object.assign({}, i), { document: IE(i), coordinate: h, theme: f })
  return (g) => {
    const { shape: y = s } = p,
      { shape: m = y, points: b, seriesIndex: x, index: w } = g,
      O = ti(g, ['shape', 'points', 'seriesIndex', 'index']),
      S = Object.assign(Object.assign({}, O), { index: w }),
      _ = x ? x.map((A) => o[A]) : o[w],
      M = x || w,
      E = ri(p, (A) => PT(A, _, M, o)),
      T = l[m] ? l[m](E, v) : a(Object.assign(Object.assign({}, E), { type: LT(t, m) }), v),
      C = AT(f, d, m, s)
    return T(b, S, C, u)
  }
}
function AT(t, e, n, r) {
  if (typeof e != 'string') return
  const { color: i } = t,
    a = t[e] || {},
    o = a[n] || a[r]
  return Object.assign({ color: i }, o)
}
function Y0(t, e, n, r, i) {
  var a, o
  const [, s] = Kt('shape', i),
    [c] = Kt('animation', i),
    { defaultShape: l, shape: u } = n,
    { theme: f, coordinate: h } = r,
    p = `default${ni(t)}Animation`,
    { [p]: v } = ((a = u[l]) === null || a === void 0 ? void 0 : a.props) || s(LT(e, l)).props,
    { [t]: g = {} } = f,
    y = ((o = e.animate) === null || o === void 0 ? void 0 : o[t]) || {},
    m = { coordinate: h }
  return (b, x, w) => {
    const { [`${t}Type`]: O, [`${t}Delay`]: S, [`${t}Duration`]: _, [`${t}Easing`]: M } = b,
      E = Object.assign({ type: O || v }, y)
    if (!E.type) return null
    const A = c(E, m)(x, w, X(g, { delay: S, duration: _, easing: M }))
    return Array.isArray(A) ? A : [A]
  }
}
function NV(t, e, n, r) {
  return Y0('enter', t, e, n, r)
}
function RV(t) {
  return (
    t.finished.then(() => {
      t.cancel()
    }),
    t
  )
}
function IV(t, e, n, r) {
  return Y0('update', t, e, n, r)
}
function jV(t, e, n, r) {
  return Y0('exit', t, e, n, r)
}
function kT(t = {}) {
  if (typeof t == 'string') return { type: t }
  const { type: e = 'light' } = t,
    n = ti(t, ['type'])
  return Object.assign(Object.assign({}, n), { type: e })
}
function Ed(t) {
  const e = { event: !0, tooltip: !0, sliderFilter: !0, legendFilter: !0, scrollbarFilter: !0 },
    { interaction: n = {} } = t
  return Object.entries(X(e, n))
}
function CT(t, e) {
  return _r(this, void 0, void 0, function* () {
    const n = { library: e },
      { data: r } = t,
      i = ti(t, ['data'])
    if (r == null) return t
    const [, { data: a }] = yield ST([], { data: r }, n)
    return Object.assign({ data: a }, i)
  })
}
function w1(t) {
  t.style('x', (e) => e.paddingLeft + e.marginLeft)
    .style('y', (e) => e.paddingTop + e.marginTop)
    .style('width', (e) => e.innerWidth)
    .style('height', (e) => e.innerHeight)
}
function DV(t, e) {
  const [n, r] = e
  t.transition(function (i, a, o) {
    const { x: s, y: c, width: l, height: u } = o.style,
      {
        paddingLeft: f,
        paddingTop: h,
        innerWidth: d,
        innerHeight: p,
        marginLeft: v,
        marginTop: g
      } = i,
      y = [
        { x: s, y: c, width: l, height: u },
        { x: f + v, y: h + g, width: d, height: p }
      ]
    return o.animate(y, { delay: n, duration: r, fill: 'both' })
  })
}
function LT(t, e) {
  const { type: n } = t
  return typeof e == 'string' ? `${n}.${e}` : e
}
function O1(t, e) {
  const n = (a) => (a.class !== void 0 ? `${a.class}` : '')
  t.nodes().length === 0 ||
    (t
      .selectAll(nr(bm))
      .data(e, (a) => a.key)
      .join(
        (a) =>
          a
            .append('g')
            .attr('className', bm)
            .attr('id', (o) => o.key)
            .style('facet', n)
            .style('fill', 'transparent')
            .style('zIndex', (o) => {
              var s
              return (s = o.zIndex) !== null && s !== void 0 ? s : 0
            }),
        (a) =>
          a
            .style('facet', n)
            .style('fill', 'transparent')
            .style('zIndex', (o) => {
              var s
              return (s = o.zIndex) !== null && s !== void 0 ? s : 0
            }),
        (a) => a.remove()
      ),
    t.select(nr(rd)).node()) ||
    t.append('g').attr('className', rd).style('zIndex', 0)
}
function nr(...t) {
  return t.map((e) => `.${e}`).join('')
}
function S1(t, e) {
  t.node() &&
    t.style('clipPath', (n) => {
      if (!e) return null
      const {
        paddingTop: r,
        paddingLeft: i,
        marginLeft: a,
        marginTop: o,
        innerWidth: s,
        innerHeight: c
      } = n
      return new Xi({ style: { x: i + a, y: r + o, width: s, height: c } })
    })
}
function $V(t, e, n) {
  var r
  for (const [l] of n.entries()) if (l.type === 'cell') return t.filter((u) => u.name !== 'shape')
  if (e.length !== 1 || t.some((l) => l.name === 'shape')) return t
  const { defaultShape: i } = e[0]
  if (!['point', 'line', 'rect', 'hollow'].includes(i)) return t
  const o = { point: 'point', line: 'hyphen', rect: 'square', hollow: 'hollow' },
    c = {
      field:
        ((r = t.find((l) => l.name === 'color')) === null || r === void 0 ? void 0 : r.field) ||
        null,
      name: 'shape',
      type: 'constant',
      domain: [],
      range: [o[i]]
    }
  return [...t, c]
}
function BV(t, e) {
  for (const [n, r] of Object.entries(e)) t.style(n, r)
}
function FV(t) {
  const e = X({}, t),
    n = new Map([[e, null]]),
    r = new Map([[null, -1]]),
    i = [e]
  for (; i.length; ) {
    const a = i.shift()
    if (a.key === void 0) {
      const s = n.get(a),
        c = r.get(a),
        l = s === null ? '0' : `${s.key}-${c}`
      a.key = l
    }
    const { children: o = [] } = a
    if (Array.isArray(o))
      for (let s = 0; s < o.length; s++) {
        const c = X({}, o[s])
        ;(o[s] = c), n.set(c, a), r.set(c, s), i.push(c)
      }
  }
  return e
}
function zV(t, e) {
  const n = new zM()
  return (
    n.registerPlugin(new GM()),
    new ew({ width: t, height: e, container: document.createElement('div'), renderer: n })
  )
}
function GV(
  t,
  e = {},
  n = () => {},
  r = (i) => {
    throw i
  }
) {
  const { width: i = 640, height: a = 480, depth: o = 0 } = t,
    s = FV(t),
    { canvas: c = zV(i, a), emitter: l = new WM(), library: u } = e
  ;(e.canvas = c), (e.emitter = l)
  const { width: f, height: h } = c.getConfig()
  ;(f !== i || h !== a) && c.resize(i, a), l.emit(Lt.BEFORE_RENDER)
  const d = ot(c.document.documentElement)
  return (
    c.ready
      .then(() =>
        W0(Object.assign(Object.assign({}, s), { width: i, height: a, depth: o }), d, u, e)
      )
      .then(() => {
        if (o) {
          const [p, v] = c.document.documentElement.getPosition()
          c.document.documentElement.setPosition(p, v, -o / 2)
        }
        c.requestAnimationFrame(() => {
          l.emit(Lt.AFTER_RENDER), n == null || n()
        })
      })
      .catch((p) => {
        r == null || r(p)
      }),
    YV(c.getConfig().container)
  )
}
function _1(t, e = {}, n = !1) {
  const { canvas: r, emitter: i } = e
  r && (WV(r), n ? r.destroy() : r.destroyChildren()), i.off()
}
function WV(t) {
  const e = t.getRoot().querySelectorAll(`.${id}`)
  e == null ||
    e.forEach((n) => {
      const { nameInteraction: r = new Map() } = n
      ;(r == null ? void 0 : r.size) > 0 &&
        Array.from(r == null ? void 0 : r.values()).forEach((i) => {
          i == null || i.destroy()
        })
    })
}
function YV(t) {
  return typeof t == 'string' ? document.getElementById(t) : t
}
const HV = { visibility: 'visible', opacity: 1, fillOpacity: 1, strokeOpacity: 1 }
function VV(t, e) {
  var n
  return (n = t.style[e]) !== null && n !== void 0 ? n : HV[e]
}
function H0(t, e, n, r) {
  ;(t.style[e] = n), r && t.children.forEach((i) => H0(i, e, n, r))
}
function V0(t) {
  H0(t, 'visibility', 'hidden', !0)
}
function X0(t) {
  H0(t, 'visibility', 'visible', !0)
}
var Wo =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function ei(t) {
  return ot(t)
    .selectAll(`.${pr}`)
    .nodes()
    .filter((e) => !e.__removed__)
}
function NT(t, e) {
  return Td(t, e).flatMap(({ container: n }) => ei(n))
}
function Td(t, e) {
  return e.filter((n) => n !== t && n.options.parentKey === t.options.key)
}
function kr(t) {
  return ot(t).select(`.${ad}`).node()
}
function U0(t, e) {
  const { offsetX: n, offsetY: r } = e,
    i = t.getRenderBounds(),
    {
      min: [a, o],
      max: [s, c]
    } = i,
    l = n < a || n > s,
    u = r < o || r > c
  return l || u ? null : [n - a, r - o]
}
function Wf(t, e) {
  const { offsetX: n, offsetY: r } = e,
    [i, a, o, s] = XV(t)
  return [Math.min(o, Math.max(i, n)) - i, Math.min(s, Math.max(a, r)) - a]
}
function XV(t) {
  const e = t.getRenderBounds(),
    {
      min: [n, r],
      max: [i, a]
    } = e
  return [n, r, i, a]
}
function RT(t) {
  return (e) => e.__data__.color
}
function q0(t) {
  return (e) => e.__data__.x
}
function Wi(t) {
  const e = Array.isArray(t) ? t : [t],
    n = new Map(
      e.flatMap((r) => Array.from(r.markState.keys()).map((a) => [Gl(r.key, a.key), a.data]))
    )
  return (r) => {
    const { index: i, markKey: a, viewKey: o } = r.__data__
    return n.get(Gl(o, a))[i]
  }
}
function Mr(t, e = (r, i) => r, n = (r, i, a) => r.setAttribute(i, a)) {
  const r = '__states__',
    i = '__ordinal__',
    a = (u) => {
      const { [r]: f = [], [i]: h = {} } = u,
        d = f.reduce((p, v) => Object.assign(Object.assign({}, p), t[v]), h)
      if (Object.keys(d).length !== 0) {
        for (const [p, v] of Object.entries(d)) {
          const g = VV(u, p),
            y = e(v, u)
          n(u, p, y), p in h || (h[p] = g)
        }
        u[i] = h
      }
    },
    o = (u) => {
      u[r] || (u[r] = [])
    }
  return {
    setState: (u, ...f) => {
      o(u), (u[r] = [...f]), a(u)
    },
    removeState: (u, ...f) => {
      o(u)
      for (const h of f) {
        const d = u[r].indexOf(h)
        d !== -1 && u[r].splice(d, 1)
      }
      a(u)
    },
    hasState: (u, f) => (o(u), u[r].indexOf(f) !== -1)
  }
}
function UV(t) {
  return t === void 0 ? !0 : typeof t != 'object' ? !1 : Object.keys(t).length === 0
}
function Gl(t, e) {
  return `${t},${e}`
}
function Xa(t, e) {
  const r = (Array.isArray(t) ? t : [t]).flatMap((a) =>
      a.marks.map((o) => [Gl(a.key, o.key), o.state])
    ),
    i = {}
  for (const a of e) {
    const [o, s] = Array.isArray(a) ? a : [a, {}]
    i[o] = r.reduce((c, l) => {
      const [u, f = {}] = l,
        h = UV(f[o]) ? s : f[o]
      for (const [d, p] of Object.entries(h)) {
        const v = c[d],
          g = (y, m, b, x) => {
            const w = Gl(x.__data__.viewKey, x.__data__.markKey)
            return u !== w
              ? v == null
                ? void 0
                : v(y, m, b, x)
              : typeof p != 'function'
              ? p
              : p(y, m, b, x)
          }
        c[d] = g
      }
      return c
    }, {})
  }
  return i
}
function Ys(t, e) {
  const n = new Map(t.map((i, a) => [i, a])),
    r = e ? t.map(e) : t
  return (i, a) => {
    if (typeof i != 'function') return i
    const o = n.get(a),
      s = e ? e(a) : a
    return i(s, o, r, a)
  }
}
function IT(t) {
  var { link: e = !1, valueof: n = (u, f) => u, coordinate: r } = t,
    i = Wo(t, ['link', 'valueof', 'coordinate'])
  const a = 'element-link'
  if (!e) return [() => {}, () => {}]
  const o = (u) => u.__data__.points,
    s = (u, f) => {
      const [, h, d] = u,
        [p, , , v] = f
      return [h, p, v, d]
    }
  return [
    (u) => {
      var f
      if (u.length <= 1) return
      const h = xr(u, (d, p) => {
        const { x: v } = d.__data__,
          { x: g } = p.__data__
        return v - g
      })
      for (let d = 1; d < h.length; d++) {
        const p = Nn(),
          v = h[d - 1],
          g = h[d],
          [y, m, b, x] = s(o(v), o(g))
        p.moveTo(...y), p.lineTo(...m), p.lineTo(...b), p.lineTo(...x), p.closePath()
        const w = ri(i, (M) => n(M, v)),
          { fill: O = v.getAttribute('fill') } = w,
          S = Wo(w, ['fill']),
          _ = new rn({
            className: a,
            style: Object.assign({ d: p.toString(), fill: O, zIndex: -2 }, S)
          })
        ;(f = v.link) === null || f === void 0 || f.remove(),
          v.parentNode.appendChild(_),
          (v.link = _)
      }
    },
    (u) => {
      var f
      ;(f = u.link) === null || f === void 0 || f.remove(), (u.link = null)
    }
  ]
}
function jT(t, e, n) {
  const r = (i) => {
    const { transform: a } = t.style
    return a ? `${a} ${i}` : i
  }
  if (Zt(n)) {
    const { points: i } = t.__data__,
      [a, o] = ce(n) ? gu(i) : i,
      s = n.getCenter(),
      c = oe(a, s),
      l = oe(o, s),
      u = kn(c),
      f = Jx(c, l),
      h = u + f / 2,
      d = e * Math.cos(h),
      p = e * Math.sin(h)
    return r(`translate(${d}, ${p})`)
  }
  return ce(n) ? r(`translate(${e}, 0)`) : r(`translate(0, ${-e})`)
}
function DT(t) {
  var { document: e, background: n, scale: r, coordinate: i, valueof: a } = t,
    o = Wo(t, ['document', 'background', 'scale', 'coordinate', 'valueof'])
  const s = 'element-background'
  if (!n) return [() => {}, () => {}]
  const c = (y, m, b) => {
      const x = y.invert(m),
        w = m + y.getBandWidth(x) / 2,
        O = y.getStep(x) / 2,
        S = O * b
      return [w - O + S, w + O - S]
    },
    l = (y, m) => {
      const { x: b } = r
      if (!Do(b)) return [0, 1]
      const { __data__: x } = y,
        { x: w } = x,
        [O, S] = c(b, w, m)
      return [O, S]
    },
    u = (y, m) => {
      const { y: b } = r
      if (!Do(b)) return [0, 1]
      const { __data__: x } = y,
        { y: w } = x,
        [O, S] = c(b, w, m)
      return [O, S]
    },
    f = (y, m) => {
      const { padding: b } = m,
        [x, w] = l(y, b),
        [O, S] = u(y, b),
        _ = [
          [x, O],
          [w, O],
          [w, S],
          [x, S]
        ].map((C) => i.map(C)),
        { __data__: M } = y,
        { y: E, y1: T } = M
      return pw(e, _, { y: E, y1: T }, i, m)
    },
    h = (y, m) => {
      const {
          transform: b = 'scale(1.2, 1.2)',
          transformOrigin: x = 'center center',
          stroke: w = ''
        } = m,
        O = Wo(m, ['transform', 'transformOrigin', 'stroke']),
        S = Object.assign({ transform: b, transformOrigin: x, stroke: w }, O),
        _ = y.cloneNode(!0)
      for (const [M, E] of Object.entries(S)) _.style[M] = E
      return _
    },
    d = () => {
      const { x: y, y: m } = r
      return [y, m].some(Do)
    }
  return [
    (y) => {
      y.background && y.background.remove()
      const m = ri(o, (C) => a(C, y)),
        {
          fill: b = '#CCD6EC',
          fillOpacity: x = 0.3,
          zIndex: w = -2,
          padding: O = 0.001,
          strokeWidth: S = 0
        } = m,
        _ = Wo(m, ['fill', 'fillOpacity', 'zIndex', 'padding', 'strokeWidth']),
        M = Object.assign(Object.assign({}, _), {
          fill: b,
          fillOpacity: x,
          zIndex: w,
          padding: O,
          strokeWidth: S
        }),
        T = (d() ? f : h)(y, M)
      ;(T.className = s), y.parentNode.appendChild(T), (y.background = T)
    },
    (y) => {
      var m
      ;(m = y.background) === null || m === void 0 || m.remove(), (y.background = null)
    },
    (y) => y.className === s
  ]
}
function Ir(t, e) {
  const r = t.getRootNode().defaultView.getContextService().getDomElement()
  r != null && r.style && ((t.cursor = r.style.cursor), (r.style.cursor = e))
}
function qV(t) {
  Ir(t, t.cursor)
}
function K0(t, e, n) {
  return t.find((r) => Object.entries(e).every(([i, a]) => n(r)[i] === a))
}
var KV =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function ZV(
  t,
  {
    elements: e,
    datum: n,
    groupKey: r = (f) => f,
    link: i = !1,
    background: a = !1,
    delay: o = 60,
    scale: s,
    coordinate: c,
    emitter: l,
    state: u = {}
  }
) {
  var f
  const h = e(t),
    d = new Set(h),
    p = qt(h, r),
    v = Ys(h, n),
    [g, y] = IT(
      Object.assign({ elements: h, valueof: v, link: i, coordinate: c }, et(u.active, 'link'))
    ),
    [m, b, x] = DT(
      Object.assign(
        { document: t.ownerDocument, scale: s, coordinate: c, background: a, valueof: v },
        et(u.active, 'background')
      )
    ),
    w = X(u, {
      active: Object.assign(
        {},
        ((f = u.active) === null || f === void 0 ? void 0 : f.offset) && {
          transform: (...R) => {
            const j = u.active.offset(...R),
              [, I] = R
            return jT(h[I], j, c)
          }
        }
      )
    }),
    { setState: O, removeState: S, hasState: _ } = Mr(w, v)
  let M
  const E = (R) => {
      const { target: j, nativeEvent: I = !0 } = R
      if (!d.has(j)) return
      M && clearTimeout(M)
      const D = r(j),
        $ = p.get(D),
        B = new Set($)
      for (const F of h)
        B.has(F) ? _(F, 'active') || O(F, 'active') : (O(F, 'inactive'), y(F)), F !== j && b(F)
      m(j),
        g($),
        I && l.emit('element:highlight', { nativeEvent: I, data: { data: n(j), group: $.map(n) } })
    },
    T = () => {
      M && clearTimeout(M),
        (M = setTimeout(() => {
          C(), (M = null)
        }, o))
    },
    C = (R = !0) => {
      for (const j of h) S(j, 'active', 'inactive'), b(j), y(j)
      R && l.emit('element:unhighlight', { nativeEvent: R })
    },
    A = (R) => {
      const { target: j } = R
      ;(a && !x(j)) || (!a && !d.has(j)) || (o > 0 ? T() : C())
    },
    P = () => {
      C()
    }
  t.addEventListener('pointerover', E),
    t.addEventListener('pointerout', A),
    t.addEventListener('pointerleave', P)
  const k = (R) => {
      const { nativeEvent: j } = R
      j || C(!1)
    },
    L = (R) => {
      const { nativeEvent: j } = R
      if (j) return
      const { data: I } = R.data,
        D = K0(h, I, n)
      D && E({ target: D, nativeEvent: !1 })
    }
  return (
    l.on('element:highlight', L),
    l.on('element:unhighlight', k),
    () => {
      t.removeEventListener('pointerover', E),
        t.removeEventListener('pointerout', A),
        t.removeEventListener('pointerleave', P),
        l.off('element:highlight', L),
        l.off('element:unhighlight', k)
      for (const R of h) b(R), y(R)
    }
  )
}
function Z0(t) {
  var { delay: e, createGroup: n, background: r = !1, link: i = !1 } = t,
    a = KV(t, ['delay', 'createGroup', 'background', 'link'])
  return (o, s, c) => {
    const { container: l, view: u, options: f } = o,
      { scale: h, coordinate: d } = u,
      p = kr(l)
    return ZV(
      p,
      Object.assign(
        {
          elements: ei,
          datum: Wi(u),
          groupKey: n ? n(u) : void 0,
          coordinate: d,
          scale: h,
          state: Xa(f, [['active', r ? {} : { lineWidth: '1', stroke: '#000' }], 'inactive']),
          background: r,
          link: i,
          delay: e,
          emitter: c
        },
        a
      )
    )
  }
}
function QV(t) {
  return Z0(Object.assign(Object.assign({}, t), { createGroup: q0 }))
}
function JV(t) {
  return Z0(Object.assign(Object.assign({}, t), { createGroup: RT }))
}
var tX =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function eX(
  t,
  {
    elements: e,
    datum: n,
    groupKey: r = (f) => f,
    link: i = !1,
    single: a = !1,
    coordinate: o,
    background: s = !1,
    scale: c,
    emitter: l,
    state: u = {}
  }
) {
  var f
  const h = e(t),
    d = new Set(h),
    p = qt(h, r),
    v = Ys(h, n),
    [g, y] = IT(
      Object.assign({ link: i, elements: h, valueof: v, coordinate: o }, et(u.selected, 'link'))
    ),
    [m, b] = DT(
      Object.assign(
        { document: t.ownerDocument, background: s, coordinate: o, scale: c, valueof: v },
        et(u.selected, 'background')
      )
    ),
    x = X(u, {
      selected: Object.assign(
        {},
        ((f = u.selected) === null || f === void 0 ? void 0 : f.offset) && {
          transform: (...P) => {
            const k = u.selected.offset(...P),
              [, L] = P
            return jT(h[L], k, o)
          }
        }
      )
    }),
    { setState: w, removeState: O, hasState: S } = Mr(x, v),
    _ = (P = !0) => {
      for (const k of h) O(k, 'selected', 'unselected'), y(k), b(k)
      P && l.emit('element:unselect', { nativeEvent: !0 })
    },
    M = (P, k, L = !0) => {
      if (S(k, 'selected')) _()
      else {
        const R = r(k),
          j = p.get(R),
          I = new Set(j)
        for (const D of h) I.has(D) ? w(D, 'selected') : (w(D, 'unselected'), y(D)), D !== k && b(D)
        if ((g(j), m(k), !L)) return
        l.emit(
          'element:select',
          Object.assign(Object.assign({}, P), {
            nativeEvent: L,
            data: { data: [n(k), ...j.map(n)] }
          })
        )
      }
    },
    E = (P, k, L = !0) => {
      const R = r(k),
        j = p.get(R),
        I = new Set(j)
      if (S(k, 'selected')) {
        if (!h.some(($) => !I.has($) && S($, 'selected'))) return _()
        for (const $ of j) w($, 'unselected'), y($), b($)
      } else {
        const D = j.some(($) => S($, 'selected'))
        for (const $ of h) I.has($) ? w($, 'selected') : S($, 'selected') || w($, 'unselected')
        !D && i && g(j), m(k)
      }
      L &&
        l.emit(
          'element:select',
          Object.assign(Object.assign({}, P), {
            nativeEvent: L,
            data: { data: h.filter((D) => S(D, 'selected')).map(n) }
          })
        )
    },
    T = (P) => {
      const { target: k, nativeEvent: L = !0 } = P
      return d.has(k) ? (a ? M(P, k, L) : E(P, k, L)) : _()
    }
  t.addEventListener('click', T)
  const C = (P) => {
      const { nativeEvent: k, data: L } = P
      if (k) return
      const R = a ? L.data.slice(0, 1) : L.data
      for (const j of R) {
        const I = K0(h, j, n)
        T({ target: I, nativeEvent: !1 })
      }
    },
    A = () => {
      _(!1)
    }
  return (
    l.on('element:select', C),
    l.on('element:unselect', A),
    () => {
      for (const P of h) y(P)
      t.removeEventListener('click', T), l.off('element:select', C), l.off('element:unselect', A)
    }
  )
}
function Q0(t) {
  var { createGroup: e, background: n = !1, link: r = !1 } = t,
    i = tX(t, ['createGroup', 'background', 'link'])
  return (a, o, s) => {
    const { container: c, view: l, options: u } = a,
      { coordinate: f, scale: h } = l,
      d = kr(c)
    return eX(
      d,
      Object.assign(
        {
          elements: ei,
          datum: Wi(l),
          groupKey: e ? e(l) : void 0,
          coordinate: f,
          scale: h,
          state: Xa(u, [['selected', n ? {} : { lineWidth: '1', stroke: '#000' }], 'unselected']),
          background: n,
          link: r,
          emitter: s
        },
        i
      )
    )
  }
}
function nX(t) {
  return Q0(Object.assign(Object.assign({}, t), { createGroup: q0 }))
}
function rX(t) {
  return Q0(Object.assign(Object.assign({}, t), { createGroup: RT }))
}
var iX =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, r) {
      function i(a) {
        return a instanceof n
          ? a
          : new n(function (o) {
              o(a)
            })
      }
      return new (n || (n = Promise))(function (a, o) {
        function s(u) {
          try {
            l(r.next(u))
          } catch (f) {
            o(f)
          }
        }
        function c(u) {
          try {
            l(r.throw(u))
          } catch (f) {
            o(f)
          }
        }
        function l(u) {
          u.done ? a(u.value) : i(u.value).then(s, c)
        }
        l((r = r.apply(t, e || [])).next())
      })
    },
  aX =
    (globalThis && globalThis.__rest) ||
    function (t, e) {
      var n = {}
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
      if (t != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          e.indexOf(r[i]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
            (n[r[i]] = t[r[i]])
      return n
    }
function oX(t) {
  const { transform: e = [] } = t,
    n = e.find((i) => i.type === 'normalizeY')
  if (n) return n
  const r = { type: 'normalizeY' }
  return e.push(r), (t.transform = e), r
}
function sX(t, e, n) {
  const [r] = Array.from(t.entries())
    .filter(([i]) => i.type === e)
    .map(([i]) => {
      const { encode: a } = i,
        o = (s) => {
          const c = a[s]
          return [s, c ? c.value : void 0]
        }
      return Object.fromEntries(n.map(o))
    })
  return r
}
function cX(t) {
  var { wait: e = 20, leading: n, trailing: r = !1, labelFormatter: i = (o) => `${o}` } = t,
    a = aX(t, ['wait', 'leading', 'trailing', 'labelFormatter'])
  return (o) => {
    const { view: s, container: c, update: l, setState: u } = o,
      { markState: f, scale: h, coordinate: d } = s,
      p = sX(f, 'line', ['x', 'y', 'series'])
    if (!p) return
    const { y: v, x: g, series: y = [] } = p,
      m = v.map((R, j) => j),
      b = xr(m.map((R) => g[R])),
      x = kr(c),
      w = c.getElementsByClassName(pr),
      O = c.getElementsByClassName(od),
      _ = qt(O, (R) => R.__data__.key.split('-')[0]),
      M = new Rs({
        style: Object.assign(
          { x1: 0, y1: 0, x2: 0, y2: x.getAttribute('height'), stroke: 'black', lineWidth: 1 },
          et(a, 'rule')
        )
      }),
      E = new Za({
        style: Object.assign(
          { x: 0, y: x.getAttribute('height'), text: '', fontSize: 10 },
          et(a, 'label')
        )
      })
    M.append(E), x.appendChild(M)
    const T = (R, j, I) => {
        const [D] = R.invert(I),
          $ = j.invert(D)
        return b[vk(b, $)]
      },
      C = (R, j) => {
        M.setAttribute('x1', R[0]), M.setAttribute('x2', R[0]), E.setAttribute('text', i(j))
      }
    let A
    const P = (R) =>
        iX(this, void 0, void 0, function* () {
          const { x: j } = h,
            I = T(d, j, R)
          C(R, I),
            u('chartIndex', ($) => {
              const B = X({}, $),
                F = B.marks.find((H) => H.type === 'line'),
                U = Ct(
                  Hd(
                    m,
                    (H) => Ct(H, (Q) => +v[Q]) / gn(H, (Q) => +v[Q]),
                    (H) => y[H]
                  ).values()
                ),
                K = [1 / U, U]
              X(F, { scale: { y: { domain: K } } })
              const V = oX(F)
              ;(V.groupBy = 'color'),
                (V.basis = (H, Q) => {
                  const tt = H[Pa((it) => g[+it]).center(H, I)]
                  return Q[tt]
                })
              for (const H of B.marks) H.animate = !1
              return B
            }),
            (A = (yield l()).view)
        }),
      k = (R) => {
        const { scale: j, coordinate: I } = A,
          { x: D, y: $ } = j,
          B = T(I, D, R)
        C(R, B)
        for (const F of w) {
          const { seriesIndex: W, key: U } = F.__data__,
            K = W[Pa((st) => g[+st]).center(W, B)],
            V = [0, $.map(1)],
            H = [0, $.map(v[K] / v[W[0]])],
            [, Q] = I.map(V),
            [, tt] = I.map(H),
            it = Q - tt
          F.setAttribute('transform', `translate(0, ${it})`)
          const ut = _.get(U) || []
          for (const st of ut) st.setAttribute('dy', it)
        }
      },
      L = Ci(
        (R) => {
          const j = U0(x, R)
          j && k(j)
        },
        e,
        { leading: n, trailing: r }
      )
    return (
      P([0, 0]),
      x.addEventListener('pointerenter', L),
      x.addEventListener('pointermove', L),
      x.addEventListener('pointerleave', L),
      () => {
        M.remove(),
          x.removeEventListener('pointerenter', L),
          x.removeEventListener('pointermove', L),
          x.removeEventListener('pointerleave', L)
      }
    )
  }
}
function lX(t) {
  const { coordinate: e = {} } = t,
    { transform: n = [] } = e,
    r = n.find((a) => a.type === 'fisheye')
  if (r) return r
  const i = { type: 'fisheye' }
  return n.push(i), (e.transform = n), (t.coordinate = e), i
}
function uX({ wait: t = 30, leading: e, trailing: n = !1 }) {
  return (r) => {
    const { options: i, update: a, setState: o, container: s } = r,
      c = kr(s),
      l = Ci(
        (u) => {
          const f = U0(c, u)
          if (!f) {
            o('fisheye'), a()
            return
          }
          o('fisheye', (h) => {
            const d = X({}, h, { interaction: { tooltip: { preserve: !0 } } })
            for (const y of d.marks) y.animate = !1
            const [p, v] = f,
              g = lX(d)
            return (g.focusX = p), (g.focusY = v), (g.visual = !0), d
          }),
            a()
        },
        t,
        { leading: e, trailing: n }
      )
    return (
      c.addEventListener('pointerenter', l),
      c.addEventListener('pointermove', l),
      c.addEventListener('pointerleave', l),
      () => {
        c.removeEventListener('pointerenter', l),
          c.removeEventListener('pointermove', l),
          c.removeEventListener('pointerleave', l)
      }
    )
  }
}
var Hs =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function fX(t, e) {
  return e
    ? typeof e == 'string'
      ? document.querySelector(e)
      : e
    : t.getRootNode().defaultView.getConfig().container
}
function hX(t) {
  const e = t.getBounds(),
    {
      min: [n, r],
      max: [i, a]
    } = e
  return { x: n, y: r, width: i - n, height: a - r }
}
function dX(t, e) {
  const n = t.getBoundingClientRect(),
    r = e.getBoundingClientRect()
  return { x: n.x - r.x, y: n.y - r.y }
}
function pX(t, e, n, r, i, a, o, s = {}) {
  const c = {
      '.g2-tooltip': {},
      '.g2-tooltip-title': {
        overflow: 'hidden',
        'white-space': 'nowrap',
        'text-overflow': 'ellipsis'
      }
    },
    l = new WI({
      className: 'tooltip',
      style: {
        x: e,
        y: n,
        container: o,
        data: [],
        bounding: a,
        position: r,
        enterable: i,
        title: '',
        offset: [10, 10],
        template: { prefixCls: 'g2-' },
        style: X(c, s)
      }
    })
  return t.appendChild(l.HTMLTooltipElement), l
}
function $T({
  root: t,
  data: e,
  x: n,
  y: r,
  render: i,
  event: a,
  single: o,
  position: s = 'right-bottom',
  enterable: c = !1,
  css: l,
  mount: u,
  bounding: f
}) {
  const h = t.getRootNode().defaultView.getConfig().container,
    d = fX(t, u),
    p = o ? h : t,
    v = f || hX(t),
    g = dX(h, d),
    { tooltipElement: y = pX(d, n, r, s, c, v, g, l) } = p,
    { items: m, title: b = '' } = e
  y.update(
    Object.assign(
      { x: n, y: r, data: m, title: b, position: s, enterable: c },
      i !== void 0 && { content: i(a, { items: m, title: b }) }
    )
  ),
    (p.tooltipElement = y)
}
function $r({ root: t, single: e, emitter: n, nativeEvent: r = !0 }) {
  r && n.emit('tooltip:hide', { nativeEvent: r })
  const i = t.getRootNode().defaultView.getConfig().container,
    a = e ? i : t,
    { tooltipElement: o } = a
  o && o.hide()
}
function Pd({ root: t, single: e }) {
  const n = t.getRootNode().defaultView.getConfig().container,
    r = e ? n : t
  if (!r) return
  const { tooltipElement: i } = r
  i && (i.destroy(), (r.tooltipElement = void 0))
}
function BT(t) {
  const { value: e } = t
  return Object.assign(Object.assign({}, t), { value: e === void 0 ? 'undefined' : e })
}
function vX(t) {
  const { __data__: e } = t,
    { title: n, items: r = [] } = e,
    i = r
      .filter(Gt)
      .map((a) => {
        var { color: o = FT(t) } = a,
          s = Hs(a, ['color'])
        return Object.assign(Object.assign({}, s), { color: o })
      })
      .map(BT)
  return Object.assign(Object.assign({}, n && { title: n }), { items: i })
}
function gX(t, e) {
  const { color: n, series: r, facet: i = !1 } = t,
    { color: a, series: o } = e,
    s = (c) => c && c.invert && !(c instanceof ka) && !(c instanceof np)
  if (s(r)) return r.clone().invert(o)
  if (o && r instanceof ka && r.invert(o) !== a && !i) return r.invert(o)
  if (s(n)) {
    const c = n.invert(a)
    return Array.isArray(c) ? null : c
  }
  return null
}
function FT(t) {
  const e = t.getAttribute('fill'),
    n = t.getAttribute('stroke'),
    { __data__: r } = t,
    { color: i = e && e !== 'transparent' ? e : n } = r
  return i
}
function M1(t, e = (n) => n) {
  const n = new Map(t.map((r) => [e(r), r]))
  return Array.from(n.values())
}
function zT(t, e, n, r = t.map((a) => a.__data__), i = {}) {
  const a = (c) => (c instanceof Date ? +c : c),
    o = M1(
      r.map((c) => c.title),
      a
    ).filter(Gt),
    s = r
      .flatMap((c, l) => {
        const u = t[l],
          { items: f = [], title: h } = c,
          d = f.filter(Gt),
          p = n !== void 0 ? n : f.length <= 1
        return d.map((v) => {
          var { color: g = FT(u) || i.color, name: y } = v,
            m = Hs(v, ['color', 'name'])
          const b = gX(e, c),
            x = p ? b || y : y || b
          return Object.assign(Object.assign({}, m), { color: g, name: x || h })
        })
      })
      .map(BT)
  return Object.assign(Object.assign({}, o.length > 0 && { title: o.join(',') }), {
    items: M1(s, (c) => `(${a(c.name)}, ${a(c.value)}, ${a(c.color)})`)
  })
}
function yX(t, e, n) {
  var {
      plotWidth: r,
      plotHeight: i,
      mainWidth: a,
      mainHeight: o,
      startX: s,
      startY: c,
      transposed: l,
      polar: u,
      insetLeft: f,
      insetTop: h
    } = n,
    d = Hs(n, [
      'plotWidth',
      'plotHeight',
      'mainWidth',
      'mainHeight',
      'startX',
      'startY',
      'transposed',
      'polar',
      'insetLeft',
      'insetTop'
    ])
  const p = Object.assign({ lineWidth: 1, stroke: '#1b1e23', strokeOpacity: 0.5 }, d),
    v = e.map((M) => M[1]),
    g = e.map((M) => M[0]),
    y = Xo(v),
    m = Xo(g),
    b = () => {
      if (u) {
        const M = Math.min(a, o) / 2,
          E = s + f + a / 2,
          T = c + h + o / 2,
          C = kn(oe([m, y], [E, T])),
          A = E + M * Math.cos(C),
          P = T + M * Math.sin(C)
        return [E, A, T, P]
      }
      return l ? [s, s + r, y + c, y + c] : [m + s, m + s, c, c + i]
    },
    [x, w, O, S] = b(),
    _ = () => {
      const M = new Rs({ style: Object.assign({ x1: x, x2: w, y1: O, y2: S }, p) })
      return t.appendChild(M), M
    }
  if (g.length > 0) {
    const M = t.ruleY || _()
    ;(M.style.x1 = x), (M.style.x2 = w), (M.style.y1 = O), (M.style.y2 = S), (t.ruleY = M)
  }
}
function E1(t) {
  t.ruleY && (t.ruleY.remove(), (t.ruleY = void 0))
}
function mX(t, { data: e, style: n, theme: r }) {
  t.markers && t.markers.forEach((a) => a.remove())
  const i = e
    .filter((a) => {
      const [{ x: o, y: s }] = a
      return Gt(o) && Gt(s)
    })
    .map((a) => {
      const [{ color: o, element: s }, c] = a,
        l = o || s.style.fill || s.style.stroke || r.color
      return new Ns({
        style: Object.assign(
          { cx: c[0], cy: c[1], fill: l, r: 4, stroke: '#fff', strokeWidth: 2 },
          n
        )
      })
    })
  for (const a of i) t.appendChild(a)
  t.markers = i
}
function T1(t) {
  t.markers && (t.markers.forEach((e) => e.remove()), (t.markers = []))
}
function P1(t, e) {
  return Array.from(t.values()).some((n) => {
    var r
    return (r = n.interaction) === null || r === void 0 ? void 0 : r[e]
  })
}
function Yf(t, e) {
  return t === void 0 ? e : t
}
function GT(t) {
  const { title: e, items: n } = t
  return n.length === 0 && e === void 0
}
function bX(t) {
  return Array.from(t.values()).some((e) => {
    var n
    return ((n = e.interaction) === null || n === void 0 ? void 0 : n.seriesTooltip) && e.tooltip
  })
}
function A1(t, e) {
  var {
      elements: n,
      sort: r,
      filter: i,
      scale: a,
      coordinate: o,
      crosshairs: s,
      render: c,
      groupName: l,
      emitter: u,
      wait: f = 50,
      leading: h = !0,
      trailing: d = !1,
      startX: p = 0,
      startY: v = 0,
      body: g = !0,
      single: y = !0,
      position: m,
      enterable: b,
      mount: x,
      bounding: w,
      theme: O,
      disableNative: S = !1,
      marker: _ = !0,
      preserve: M = !1,
      style: E = {},
      css: T = {}
    } = e,
    C = Hs(e, [
      'elements',
      'sort',
      'filter',
      'scale',
      'coordinate',
      'crosshairs',
      'render',
      'groupName',
      'emitter',
      'wait',
      'leading',
      'trailing',
      'startX',
      'startY',
      'body',
      'single',
      'position',
      'enterable',
      'mount',
      'bounding',
      'theme',
      'disableNative',
      'marker',
      'preserve',
      'style',
      'css'
    ])
  const A = n(t),
    P = ce(o),
    k = Zt(o),
    L = X(E, C),
    {
      innerWidth: R,
      innerHeight: j,
      width: I,
      height: D,
      insetLeft: $,
      insetTop: B
    } = o.getOptions(),
    F = [],
    W = []
  for (const Pt of A) {
    const { __data__: Et } = Pt,
      { seriesX: Ht, title: At, items: xe } = Et
    Ht ? F.push(Pt) : (At || xe) && W.push(Pt)
  }
  const K = !!(P ? a.y : a.x).getBandWidth && W.length > 0
  F.sort((Pt, Et) => {
    const Ht = P ? 0 : 1,
      At = (xe) => xe.getBounds().min[Ht]
    return P ? At(Et) - At(Pt) : At(Pt) - At(Et)
  })
  const V = (Pt) => {
    const Et = P ? 1 : 0,
      { min: Ht, max: At } = Pt.getLocalBounds()
    return xr([Ht[Et], At[Et]])
  }
  W.sort((Pt, Et) => {
    const [Ht, At] = V(Pt),
      [xe, we] = V(Et),
      an = (Ht + At) / 2,
      on = (xe + we) / 2
    return P ? on - an : an - on
  })
  const H = new Map(
      F.map((Pt) => {
        const { __data__: Et } = Pt,
          { seriesX: Ht } = Et,
          At = Ht.map((we, an) => an),
          xe = xr(At, (we) => Ht[+we])
        return [Pt, [xe, Ht]]
      })
    ),
    { x: Q } = a,
    tt = Q != null && Q.getBandWidth ? Q.getBandWidth() / 2 : 0,
    it = (Pt) => {
      const [Et] = o.invert(Pt)
      return Et - tt
    },
    ut = (Pt, Et, Ht) => {
      const At = it(Pt),
        [xe, we] = xr([Ht[0], Ht[Ht.length - 1]])
      if (!K && (At < xe || At > we)) return null
      const an = Pa((jn) => Ht[+jn]).center,
        on = an(Et, At)
      return Et[on]
    },
    st = (Pt, Et) => {
      const At = Pt[P ? 1 : 0],
        xe = Et.filter((on) => {
          const [jn, Ki] = V(on)
          return At >= jn && At <= Ki
        })
      if (!K || xe.length > 0) return xe
      const we = Pa((on) => {
          const [jn, Ki] = V(on)
          return (jn + Ki) / 2
        }).center,
        an = we(Et, At)
      return [Et[an]].filter(Gt)
    },
    ht = (Pt, Et) => {
      const { __data__: Ht } = Pt
      return Object.fromEntries(
        Object.entries(Ht)
          .filter(([At]) => At.startsWith('series') && At !== 'series')
          .map(([At, xe]) => {
            const we = xe[Et]
            return [Q1(At.replace('series', '')), we]
          })
      )
    },
    Ot = Ci(
      (Pt) => {
        const Et = U0(t, Pt)
        if (!Et) return
        const Ht = t.getRenderBounds(),
          At = Ht.min[0],
          xe = Ht.min[1],
          we = [Et[0] - p, Et[1] - v]
        if (!we) return
        const an = st(we, W),
          on = [],
          jn = []
        for (const ye of F) {
          const [so, zu] = H.get(ye),
            cv = ut(we, so, zu)
          if (cv !== null) {
            on.push(ye)
            const lv = ht(ye, cv),
              { x: cP, y: lP } = lv,
              uP = o.map([(cP || 0) + tt, lP || 0])
            jn.push([Object.assign(Object.assign({}, lv), { element: ye }), uP])
          }
        }
        const Ki = Array.from(new Set(jn.map((ye) => ye[0].x))),
          oP = Ki[Xl(Ki, (ye) => Math.abs(ye - it(we)))],
          Fu = jn.filter((ye) => ye[0].x === oP),
          sP = [...Fu.map((ye) => ye[0]), ...an.map((ye) => ye.__data__)],
          sv = [...on, ...an],
          oo = zT(sv, a, l, sP, O)
        if (
          (r && oo.items.sort((ye, so) => r(ye) - r(so)),
          i && (oo.items = oo.items.filter(i)),
          sv.length === 0 || GT(oo))
        ) {
          Mt()
          return
        }
        if (
          (g &&
            $T({
              root: t,
              data: oo,
              x: Et[0] + At,
              y: Et[1] + xe,
              render: c,
              event: Pt,
              single: y,
              position: m,
              enterable: b,
              mount: x,
              bounding: w,
              css: T
            }),
          s)
        ) {
          const ye = Fu.map((zu) => zu[1]),
            so = et(L, 'crosshairs')
          yX(
            t,
            ye,
            Object.assign(Object.assign({}, so), {
              plotWidth: R,
              plotHeight: j,
              mainWidth: I,
              mainHeight: D,
              insetLeft: $,
              insetTop: B,
              startX: p,
              startY: v,
              transposed: P,
              polar: k
            })
          )
        }
        if (_) {
          const ye = et(L, 'marker')
          mX(t, { data: Fu, style: ye, theme: O })
        }
        u.emit(
          'tooltip:show',
          Object.assign(Object.assign({}, Pt), {
            nativeEvent: !0,
            data: { data: { x: Fa(a.x, it(we), !0) } }
          })
        )
      },
      f,
      { leading: h, trailing: d }
    ),
    Mt = () => {
      $r({ root: t, single: y, emitter: u }), s && E1(t), _ && T1(t)
    },
    Yt = () => {
      Pd({ root: t, single: y }), s && E1(t), _ && T1(t)
    },
    le = ({ nativeEvent: Pt, data: Et }) => {
      if (Pt) return
      const { x: Ht } = Et.data,
        { x: At } = a,
        xe = At.map(Ht),
        [we, an] = o.map([xe, 0.5]),
        {
          min: [on, jn]
        } = t.getRenderBounds()
      Ot({ offsetX: we + on, offsetY: an + jn })
    },
    Ve = () => {
      $r({ root: t, single: y, emitter: u, nativeEvent: !1 })
    },
    lr = () => {
      xn(), Yt()
    },
    pi = () => {
      Fe()
    },
    Fe = () => {
      S ||
        (t.addEventListener('pointerenter', Ot),
        t.addEventListener('pointermove', Ot),
        t.addEventListener('pointerleave', Mt))
    },
    xn = () => {
      S ||
        (t.removeEventListener('pointerenter', Ot),
        t.removeEventListener('pointermove', Ot),
        t.removeEventListener('pointerleave', Mt))
    }
  return (
    Fe(),
    u.on('tooltip:show', le),
    u.on('tooltip:hide', Ve),
    u.on('tooltip:disable', lr),
    u.on('tooltip:enable', pi),
    () => {
      xn(),
        u.off('tooltip:show', le),
        u.off('tooltip:hide', Ve),
        u.off('tooltip:disable', lr),
        u.off('tooltip:enable', pi),
        M ? $r({ root: t, single: y, emitter: u, nativeEvent: !1 }) : Yt()
    }
  )
}
function xX(
  t,
  {
    elements: e,
    scale: n,
    render: r,
    groupName: i,
    sort: a,
    filter: o,
    emitter: s,
    wait: c = 50,
    leading: l = !0,
    trailing: u = !1,
    groupKey: f = (M) => M,
    single: h = !0,
    position: d,
    enterable: p,
    datum: v,
    view: g,
    mount: y,
    bounding: m,
    theme: b,
    shared: x = !1,
    body: w = !0,
    disableNative: O = !1,
    preserve: S = !1,
    css: _ = {}
  }
) {
  const M = e(t),
    E = new Set(M),
    T = qt(M, f),
    C = Ci(
      (D) => {
        const { target: $ } = D
        if (!E.has($)) {
          $r({ root: t, single: h, emitter: s })
          return
        }
        const B = f($),
          F = T.get(B),
          W = F.length === 1 && !x ? vX(F[0]) : zT(F, n, i, void 0, b)
        if ((a && W.items.sort((V, H) => a(V) - a(H)), o && (W.items = W.items.filter(o)), GT(W))) {
          $r({ root: t, single: h, emitter: s })
          return
        }
        const { offsetX: U, offsetY: K } = D
        w &&
          $T({
            root: t,
            data: W,
            x: U,
            y: K,
            render: r,
            event: D,
            single: h,
            position: d,
            enterable: p,
            mount: y,
            bounding: m,
            css: _
          }),
          s.emit(
            'tooltip:show',
            Object.assign(Object.assign({}, D), { nativeEvent: !0, data: { data: NE($, g) } })
          )
      },
      c,
      { leading: l, trailing: u }
    ),
    A = (D) => {
      const { target: $ } = D
      E.has($) && $r({ root: t, single: h, emitter: s })
    },
    P = () => {
      O ||
        (t.addEventListener('pointerover', C),
        t.addEventListener('pointermove', C),
        t.addEventListener('pointerout', A))
    },
    k = () => {
      O ||
        (t.removeEventListener('pointerover', C),
        t.removeEventListener('pointermove', C),
        t.removeEventListener('pointerout', A))
    },
    L = ({ nativeEvent: D, data: $ }) => {
      if (D) return
      const B = K0(M, $.data, v)
      if (!B) return
      const F = B.getBBox(),
        { x: W, y: U, width: K, height: V } = F
      C({ target: B, offsetX: W + K / 2, offsetY: U + V / 2 })
    },
    R = ({ nativeEvent: D } = {}) => {
      D || $r({ root: t, single: h, emitter: s, nativeEvent: !1 })
    },
    j = () => {
      k(), Pd({ root: t, single: h })
    },
    I = () => {
      P()
    }
  return (
    s.on('tooltip:show', L),
    s.on('tooltip:hide', R),
    s.on('tooltip:enable', I),
    s.on('tooltip:disable', j),
    P(),
    () => {
      k(),
        s.off('tooltip:show', L),
        s.off('tooltip:hide', R),
        S ? $r({ root: t, single: h, emitter: s, nativeEvent: !1 }) : Pd({ root: t, single: h })
    }
  )
}
function wX(t) {
  const { shared: e, crosshairs: n, series: r, name: i, item: a = () => ({}), facet: o = !1 } = t,
    s = Hs(t, ['shared', 'crosshairs', 'series', 'name', 'item', 'facet'])
  return (c, l, u) => {
    const { container: f, view: h } = c,
      { scale: d, markState: p, coordinate: v, theme: g } = h,
      y = P1(p, 'seriesTooltip'),
      m = P1(p, 'crosshairs'),
      b = kr(f),
      x = Yf(r, y)
    if (x && bX(p) && !o)
      return A1(
        b,
        Object.assign(Object.assign({}, s), {
          theme: g,
          elements: ei,
          scale: d,
          coordinate: v,
          crosshairs: Yf(n, m),
          item: a,
          emitter: u
        })
      )
    if (x && o) {
      const w = l.filter((T) => T !== c && T.options.parentKey === c.options.key),
        O = NT(c, l),
        S = w[0].view.scale,
        _ = b.getBounds(),
        M = _.min[0],
        E = _.min[1]
      return (
        Object.assign(S, { facet: !0 }),
        A1(
          b.parentNode.parentNode,
          Object.assign(Object.assign({}, s), {
            theme: g,
            elements: () => O,
            scale: S,
            coordinate: v,
            crosshairs: Yf(n, m),
            item: a,
            startX: M,
            startY: E,
            emitter: u
          })
        )
      )
    }
    return xX(
      b,
      Object.assign(Object.assign({}, s), {
        datum: Wi(h),
        elements: ei,
        scale: d,
        coordinate: v,
        groupKey: e ? q0() : void 0,
        item: a,
        emitter: u,
        view: h,
        theme: g,
        shared: e
      })
    )
  }
}
var Uc =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(a) {
      return a instanceof n
        ? a
        : new n(function (o) {
            o(a)
          })
    }
    return new (n || (n = Promise))(function (a, o) {
      function s(u) {
        try {
          l(r.next(u))
        } catch (f) {
          o(f)
        }
      }
      function c(u) {
        try {
          l(r.throw(u))
        } catch (f) {
          o(f)
        }
      }
      function l(u) {
        u.done ? a(u.value) : i(u.value).then(s, c)
      }
      l((r = r.apply(t, e || [])).next())
    })
  }
const WT = 'legend-category',
  OX = 'legend-continuous',
  SX = 'items-item',
  _X = 'legend-category-item-marker',
  MX = 'legend-category-item-label'
function YT(t) {
  return t.getElementsByClassName(_X)[0]
}
function HT(t) {
  return t.getElementsByClassName(MX)[0]
}
function VT(t) {
  return t.getElementsByClassName(SX)
}
function XT(t) {
  return t.getElementsByClassName(WT)
}
function EX(t) {
  return t.getElementsByClassName(OX)
}
function Ad(t) {
  let e = t.parentNode
  for (; e && !e.__data__; ) e = e.parentNode
  return e.__data__
}
function TX(
  t,
  { legends: e, marker: n, label: r, datum: i, filter: a, emitter: o, channel: s, state: c = {} }
) {
  const l = new Map(),
    u = new Map(),
    f = new Map(),
    { unselected: h = { markerStroke: '#aaa', markerFill: '#aaa', labelFill: '#aaa' } } = c,
    d = { unselected: et(h, 'marker') },
    p = { unselected: et(h, 'label') },
    { setState: v, removeState: g } = Mr(d, void 0),
    { setState: y, removeState: m } = Mr(p, void 0),
    b = Array.from(e(t))
  let x = b.map(i)
  const w = () => {
    for (const _ of b) {
      const M = i(_),
        E = n(_),
        T = r(_)
      x.includes(M)
        ? (g(E, 'unselected'), m(T, 'unselected'))
        : (v(E, 'unselected'), y(T, 'unselected'))
    }
  }
  for (const _ of b) {
    const M = () => {
        Ir(t, 'pointer')
      },
      E = () => {
        qV(t)
      },
      T = (C) =>
        Uc(this, void 0, void 0, function* () {
          const A = i(_),
            P = x.indexOf(A)
          P === -1 ? x.push(A) : x.splice(P, 1),
            x.length === 0 && x.push(...b.map(i)),
            yield a(x),
            w()
          const { nativeEvent: k = !0 } = C
          k &&
            (x.length === b.length
              ? o.emit('legend:reset', { nativeEvent: k })
              : o.emit(
                  'legend:filter',
                  Object.assign(Object.assign({}, C), {
                    nativeEvent: k,
                    data: { channel: s, values: x }
                  })
                ))
        })
    _.addEventListener('click', T),
      _.addEventListener('pointerenter', M),
      _.addEventListener('pointerout', E),
      l.set(_, T),
      u.set(_, M),
      f.set(_, E)
  }
  const O = (_) =>
      Uc(this, void 0, void 0, function* () {
        const { nativeEvent: M } = _
        if (M) return
        const { data: E } = _,
          { channel: T, values: C } = E
        T === s && ((x = C), yield a(x), w())
      }),
    S = (_) =>
      Uc(this, void 0, void 0, function* () {
        const { nativeEvent: M } = _
        M || ((x = b.map(i)), yield a(x), w())
      })
  return (
    o.on('legend:filter', O),
    o.on('legend:reset', S),
    () => {
      for (const _ of b)
        _.removeEventListener('click', l.get(_)),
          _.removeEventListener('pointerenter', u.get(_)),
          _.removeEventListener('pointerout', f.get(_)),
          o.off('legend:filter', O),
          o.off('legend:reset', S)
    }
  )
}
function PX(t, { legend: e, filter: n, emitter: r, channel: i }) {
  const a = ({ detail: { value: o } }) => {
    n(o), r.emit({ nativeEvent: !0, data: { channel: i, values: o } })
  }
  return (
    e.addEventListener('valuechange', a),
    () => {
      e.removeEventListener('valuechange', a)
    }
  )
}
function UT(
  t,
  { legend: e, channel: n, value: r, ordinal: i, channels: a, allChannels: o, facet: s = !1 }
) {
  return Uc(this, void 0, void 0, function* () {
    const { view: c, update: l, setState: u } = t
    u(e, (f) => {
      const { marks: h } = f,
        d = h.map((p) => {
          if (p.type === 'legends') return p
          const { transform: v = [] } = p,
            g = v.findIndex(({ type: b }) => b.startsWith('group') || b.startsWith('bin')),
            y = [...v]
          y.splice(g + 1, 0, { type: 'filter', [n]: { value: r, ordinal: i } })
          const m = Object.fromEntries(
            a.map((b) => [b, { domain: c.scale[b].getOptions().domain }])
          )
          return X(
            {},
            p,
            Object.assign(Object.assign({ transform: y, scale: m }, !i && { animate: !1 }), {
              legend: s ? !1 : Object.fromEntries(o.map((b) => [b, { preserve: !0 }]))
            })
          )
        })
      return Object.assign(Object.assign({}, f), { marks: d })
    }),
      yield l()
  })
}
function AX(t, e) {
  for (const n of t) UT(n, Object.assign(Object.assign({}, e), { facet: !0 }))
}
function kX() {
  return (t, e, n) => {
    const { container: r } = t,
      i = e.filter((f) => f !== t),
      a = i.length > 0,
      o = (f) => Ad(f).scales.map((h) => h.name),
      s = [...XT(r), ...EX(r)],
      c = s.flatMap(o),
      l = a ? Ci(AX, 50, { trailing: !0 }) : Ci(UT, 50, { trailing: !0 }),
      u = s.map((f) => {
        const { name: h, domain: d } = Ad(f).scales[0],
          p = o(f),
          v = { legend: f, channel: h, channels: p, allChannels: c }
        return f.className === WT
          ? TX(r, {
              legends: VT,
              marker: YT,
              label: HT,
              datum: (g) => {
                const { __data__: y } = g,
                  { index: m } = y
                return d[m]
              },
              filter: (g) => {
                const y = Object.assign(Object.assign({}, v), { value: g, ordinal: !0 })
                l(a ? i : t, y)
              },
              state: f.attributes.state,
              channel: h,
              emitter: n
            })
          : PX(r, {
              legend: f,
              filter: (g) => {
                const y = Object.assign(Object.assign({}, v), { value: g, ordinal: !1 })
                l(a ? i : t, y)
              },
              emitter: n,
              channel: h
            })
      })
    return () => {
      u.forEach((f) => f())
    }
  }
}
function CX() {
  return (t, e, n) => {
    const { container: r, view: i, options: a } = t,
      o = XT(r),
      s = ei(r),
      c = (d) => Ad(d).scales[0].name,
      l = (d) => {
        const {
          scale: { [d]: p }
        } = i
        return p
      },
      u = Xa(a, ['active', 'inactive']),
      f = Ys(s, Wi(i)),
      h = []
    for (const d of o) {
      const p = (D) => {
          const { data: $ } = d.attributes,
            { __data__: B } = D,
            { index: F } = B
          return $[F].label
        },
        v = c(d),
        g = VT(d),
        y = l(v),
        m = qt(s, (D) => y.invert(D.__data__[v])),
        { state: b = {} } = d.attributes,
        { inactive: x = {} } = b,
        { setState: w, removeState: O } = Mr(u, f),
        S = { inactive: et(x, 'marker') },
        _ = { inactive: et(x, 'label') },
        { setState: M, removeState: E } = Mr(S),
        { setState: T, removeState: C } = Mr(_),
        A = (D) => {
          for (const $ of g) {
            const B = YT($),
              F = HT($)
            $ === D || D === null
              ? (E(B, 'inactive'), C(F, 'inactive'))
              : (M(B, 'inactive'), T(F, 'inactive'))
          }
        },
        P = (D, $) => {
          const B = p($),
            F = new Set(m.get(B))
          for (const U of s) F.has(U) ? w(U, 'active') : w(U, 'inactive')
          A($)
          const { nativeEvent: W = !0 } = D
          W &&
            n.emit(
              'legend:highlight',
              Object.assign(Object.assign({}, D), {
                nativeEvent: W,
                data: { channel: v, value: B }
              })
            )
        },
        k = new Map()
      for (const D of g) {
        const $ = (B) => {
          P(B, D)
        }
        D.addEventListener('pointerover', $), k.set(D, $)
      }
      const L = (D) => {
          for (const B of s) O(B, 'inactive', 'active')
          A(null)
          const { nativeEvent: $ = !0 } = D
          $ && n.emit('legend:unhighlight', { nativeEvent: $ })
        },
        R = (D) => {
          const { nativeEvent: $, data: B } = D
          if ($) return
          const { channel: F, value: W } = B
          if (F !== v) return
          const U = g.find((K) => p(K) === W)
          U && P({ nativeEvent: !1 }, U)
        },
        j = (D) => {
          const { nativeEvent: $ } = D
          $ || L({ nativeEvent: !1 })
        }
      d.addEventListener('pointerleave', L),
        n.on('legend:highlight', R),
        n.on('legend:unhighlight', j)
      const I = () => {
        d.removeEventListener(L), n.off('legend:highlight', R), n.off('legend:unhighlight', j)
        for (const [D, $] of k) D.removeEventListener($)
      }
      h.push(I)
    }
    return () => h.forEach((d) => d())
  }
}
var cn =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function LX(t, e) {
  const [n, r, i, a] = t,
    [o, s, c, l] = e
  return !(o > i || c < n || s > a || l < r)
}
function NX(t, e, n, r, i) {
  const [a, o, s, c] = i
  return [
    Math.max(a, Math.min(t, n)),
    Math.max(o, Math.min(e, r)),
    Math.min(s, Math.max(t, n)),
    Math.min(c, Math.max(e, r))
  ]
}
function RX(t) {
  const { width: e, height: n } = t.getBBox()
  return [0, 0, e, n]
}
function hr(t, e) {
  for (const [n, r] of Object.entries(e)) t.style(n, r)
}
const k1 = Ia((t) => {
  const e = t.attributes,
    {
      x: n,
      y: r,
      width: i,
      height: a,
      class: o,
      renders: s = {},
      handleSize: c = 10,
      document: l
    } = e,
    u = cn(e, ['x', 'y', 'width', 'height', 'class', 'renders', 'handleSize', 'document'])
  if (!l || i === void 0 || a === void 0 || n === void 0 || r === void 0) return
  const f = c / 2,
    h = (W, U, K) => {
      W.handle || ((W.handle = K.createElement('rect')), W.append(W.handle))
      const { handle: V } = W
      return V.attr(U), V
    },
    d = et(Uu(u, 'handleNW', 'handleNE'), 'handleN'),
    { render: p = h } = d,
    v = cn(d, ['render']),
    g = et(u, 'handleE'),
    { render: y = h } = g,
    m = cn(g, ['render']),
    b = et(Uu(u, 'handleSE', 'handleSW'), 'handleS'),
    { render: x = h } = b,
    w = cn(b, ['render']),
    O = et(u, 'handleW'),
    { render: S = h } = O,
    _ = cn(O, ['render']),
    M = et(u, 'handleNW'),
    { render: E = h } = M,
    T = cn(M, ['render']),
    C = et(u, 'handleNE'),
    { render: A = h } = C,
    P = cn(C, ['render']),
    k = et(u, 'handleSE'),
    { render: L = h } = k,
    R = cn(k, ['render']),
    j = et(u, 'handleSW'),
    { render: I = h } = j,
    D = cn(j, ['render']),
    $ = (W, U) => {
      const { id: K } = W,
        V = W.attributes,
        H = cn(V, ['x', 'y']),
        Q = U(W, Object.assign({ x: 0, y: 0 }, H), l)
      ;(Q.id = K), (Q.style.draggable = !0)
    },
    B = (W) => () => {
      const U = Ia((K) => $(K, W))
      return new U({})
    },
    F = ot(t).attr('className', o).style('x', n).style('y', r).style('draggable', !0)
  F.maybeAppend('selection', 'rect')
    .style('draggable', !0)
    .style('fill', 'transparent')
    .call(hr, Object.assign({ width: i, height: a }, Uu(u, 'handle'))),
    F.maybeAppend('handle-n', B(p))
      .style('x', f)
      .style('y', -f)
      .style('width', i - c)
      .style('height', c)
      .style('fill', 'transparent')
      .call(hr, v),
    F.maybeAppend('handle-e', B(y))
      .style('x', i - f)
      .style('y', f)
      .style('width', c)
      .style('height', a - c)
      .style('fill', 'transparent')
      .call(hr, m),
    F.maybeAppend('handle-s', B(x))
      .style('x', f)
      .style('y', a - f)
      .style('width', i - c)
      .style('height', c)
      .style('fill', 'transparent')
      .call(hr, w),
    F.maybeAppend('handle-w', B(S))
      .style('x', -f)
      .style('y', f)
      .style('width', c)
      .style('height', a - c)
      .style('fill', 'transparent')
      .call(hr, _),
    F.maybeAppend('handle-nw', B(E))
      .style('x', -f)
      .style('y', -f)
      .style('width', c)
      .style('height', c)
      .style('fill', 'transparent')
      .call(hr, T),
    F.maybeAppend('handle-ne', B(A))
      .style('x', i - f)
      .style('y', -f)
      .style('width', c)
      .style('height', c)
      .style('fill', 'transparent')
      .call(hr, P),
    F.maybeAppend('handle-se', B(L))
      .style('x', i - f)
      .style('y', a - f)
      .style('width', c)
      .style('height', c)
      .style('fill', 'transparent')
      .call(hr, R),
    F.maybeAppend('handle-sw', B(I))
      .style('x', -f)
      .style('y', a - f)
      .style('width', c)
      .style('height', c)
      .style('fill', 'transparent')
      .call(hr, D)
})
function J0(t, e) {
  var {
      brushed: n = () => {},
      brushended: r = () => {},
      brushcreated: i = () => {},
      brushstarted: a = () => {},
      brushupdated: o = () => {},
      extent: s = RX(t),
      brushRegion: c = (V, H, Q, tt, it) => [V, H, Q, tt],
      reverse: l = !1,
      fill: u = '#777',
      fillOpacity: f = '0.3',
      stroke: h = '#fff',
      selectedHandles: d = [
        'handle-n',
        'handle-e',
        'handle-s',
        'handle-w',
        'handle-nw',
        'handle-ne',
        'handle-se',
        'handle-sw'
      ]
    } = e,
    p = cn(e, [
      'brushed',
      'brushended',
      'brushcreated',
      'brushstarted',
      'brushupdated',
      'extent',
      'brushRegion',
      'reverse',
      'fill',
      'fillOpacity',
      'stroke',
      'selectedHandles'
    ])
  let v = null,
    g = null,
    y = null,
    m = null,
    b = null,
    x = !1
  const [w, O, S, _] = s
  Ir(t, 'crosshair'), (t.style.draggable = !0)
  const M = (V, H, Q) => {
      if ((a(Q), m && m.remove(), b && b.remove(), (v = [V, H]), l)) return E()
      T()
    },
    E = () => {
      ;(b = new rn({
        style: Object.assign(Object.assign({}, p), {
          fill: u,
          fillOpacity: f,
          stroke: h,
          pointerEvents: 'none'
        })
      })),
        (m = new k1({
          style: { x: 0, y: 0, width: 0, height: 0, draggable: !0, document: t.ownerDocument },
          className: 'mask'
        })),
        t.appendChild(b),
        t.appendChild(m)
    },
    T = () => {
      ;(m = new k1({
        style: Object.assign(Object.assign({ document: t.ownerDocument, x: 0, y: 0 }, p), {
          fill: u,
          fillOpacity: f,
          stroke: h,
          draggable: !0
        }),
        className: 'mask'
      })),
        t.appendChild(m)
    },
    C = (V = !0) => {
      m && m.remove(),
        b && b.remove(),
        (v = null),
        (g = null),
        (y = null),
        (x = !1),
        (m = null),
        (b = null),
        r(V)
    },
    A = (V, H, Q = !0) => {
      const [tt, it, ut, st] = NX(V[0], V[1], H[0], H[1], s),
        [ht, Ot, Mt, Yt] = c(tt, it, ut, st, s)
      return l ? k(ht, Ot, Mt, Yt) : P(ht, Ot, Mt, Yt), n(ht, Ot, Mt, Yt, Q), [ht, Ot, Mt, Yt]
    },
    P = (V, H, Q, tt) => {
      ;(m.style.x = V), (m.style.y = H), (m.style.width = Q - V), (m.style.height = tt - H)
    },
    k = (V, H, Q, tt) => {
      ;(b.style.d = `
      M${w},${O}L${S},${O}L${S},${_}L${w},${_}Z
      M${V},${H}L${V},${tt}L${Q},${tt}L${Q},${H}Z
    `),
        (m.style.x = V),
        (m.style.y = H),
        (m.style.width = Q - V),
        (m.style.height = tt - H)
    },
    L = (V) => {
      const H = (Ot, Mt, Yt, le, Ve) => (Ot + Mt < le ? le - Mt : Ot + Yt > Ve ? Ve - Yt : Ot),
        Q = V[0] - y[0],
        tt = V[1] - y[1],
        it = H(Q, v[0], g[0], w, S),
        ut = H(tt, v[1], g[1], O, _),
        st = [v[0] + it, v[1] + ut],
        ht = [g[0] + it, g[1] + ut]
      A(st, ht)
    },
    R = {
      'handle-n': { vector: [0, 1, 0, 0], cursor: 'ns-resize' },
      'handle-e': { vector: [0, 0, 1, 0], cursor: 'ew-resize' },
      'handle-s': { vector: [0, 0, 0, 1], cursor: 'ns-resize' },
      'handle-w': { vector: [1, 0, 0, 0], cursor: 'ew-resize' },
      'handle-nw': { vector: [1, 1, 0, 0], cursor: 'nwse-resize' },
      'handle-ne': { vector: [0, 1, 1, 0], cursor: 'nesw-resize' },
      'handle-se': { vector: [0, 0, 1, 1], cursor: 'nwse-resize' },
      'handle-sw': { vector: [1, 0, 0, 1], cursor: 'nesw-resize' }
    },
    j = (V) => D(V) || I(V),
    I = (V) => {
      const { id: H } = V
      return d.indexOf(H) === -1 ? !1 : new Set(Object.keys(R)).has(H)
    },
    D = (V) => V === m.getElementById('selection'),
    $ = (V) => {
      const { target: H } = V,
        [Q, tt] = Wf(t, V)
      if (!m || !j(H)) {
        M(Q, tt, V), (x = !0)
        return
      }
      j(H) && (y = [Q, tt])
    },
    B = (V) => {
      const { target: H } = V,
        Q = Wf(t, V)
      if (!v) return
      if (!y) return A(v, Q)
      if (D(H)) return L(Q)
      const [tt, it] = [Q[0] - y[0], Q[1] - y[1]],
        { id: ut } = H
      if (R[ut]) {
        const [st, ht, Ot, Mt] = R[ut].vector
        return A([v[0] + tt * st, v[1] + it * ht], [g[0] + tt * Ot, g[1] + it * Mt])
      }
    },
    F = (V) => {
      if (y) {
        y = null
        const { x: ut, y: st, width: ht, height: Ot } = m.style
        ;(v = [ut, st]), (g = [ut + ht, st + Ot]), o(ut, st, ut + ht, st + Ot, V)
        return
      }
      g = Wf(t, V)
      const [H, Q, tt, it] = A(v, g)
      ;(x = !1), i(H, Q, tt, it, V)
    },
    W = (V) => {
      const { target: H } = V
      m && !j(H) && C()
    },
    U = (V) => {
      const { target: H } = V
      !m || !j(H) || x ? Ir(t, 'crosshair') : D(H) ? Ir(t, 'move') : I(H) && Ir(t, R[H.id].cursor)
    },
    K = () => {
      Ir(t, 'default')
    }
  return (
    t.addEventListener('dragstart', $),
    t.addEventListener('drag', B),
    t.addEventListener('dragend', F),
    t.addEventListener('click', W),
    t.addEventListener('pointermove', U),
    t.addEventListener('pointerleave', K),
    {
      mask: m,
      move(V, H, Q, tt, it = !0) {
        m || M(V, H, {}), (v = [V, H]), (g = [Q, tt]), A([V, H], [Q, tt], it)
      },
      remove(V = !0) {
        m && C(V)
      },
      destroy() {
        m && C(!1),
          Ir(t, 'default'),
          t.removeEventListener('dragstart', $),
          t.removeEventListener('drag', B),
          t.removeEventListener('dragend', F),
          t.removeEventListener('click', W),
          t.removeEventListener('pointermove', U),
          t.removeEventListener('pointerleave', K)
      }
    }
  )
}
function tv(t, e, n) {
  return e.filter((r) => {
    if (r === t) return !1
    const { interaction: i = {} } = r.options
    return Object.values(i).find((a) => a.brushKey === n)
  })
}
function IX(t, e, n) {
  return tv(t, e, n).map((r) => kr(r.container))
}
function jX(t, e, n) {
  return tv(t, e, n).map((r) => r.options)
}
function C1(t, e) {
  var {
      elements: n,
      selectedHandles: r,
      siblings: i = (B) => [],
      datum: a,
      brushRegion: o,
      extent: s,
      reverse: c,
      scale: l,
      coordinate: u,
      series: f = !1,
      key: h = (B) => B,
      bboxOf: d = (B) => {
        const { x: F, y: W, width: U, height: K } = B.style
        return { x: F, y: W, width: U, height: K }
      },
      state: p = {},
      emitter: v
    } = e,
    g = cn(e, [
      'elements',
      'selectedHandles',
      'siblings',
      'datum',
      'brushRegion',
      'extent',
      'reverse',
      'scale',
      'coordinate',
      'series',
      'key',
      'bboxOf',
      'state',
      'emitter'
    ])
  const y = n(t),
    m = i(t),
    b = m.flatMap(n),
    x = Ys(y, a),
    w = et(g, 'mask'),
    { setState: O, removeState: S } = Mr(p, x),
    _ = new Map(),
    { width: M, height: E, x: T = 0, y: C = 0 } = d(t),
    A = s || [0, 0, M, E],
    P = () => {
      for (const B of [...y, ...b]) S(B, 'active', 'inactive')
    },
    k = (B, F, W, U) => {
      var K
      for (const H of m) (K = H.brush) === null || K === void 0 || K.remove()
      const V = new Set()
      for (const H of y) {
        const { min: Q, max: tt } = H.getLocalBounds(),
          [it, ut] = Q,
          [st, ht] = tt
        LX([it, ut, st, ht], [B, F, W, U]) ? (O(H, 'active'), V.add(h(H))) : O(H, 'inactive')
      }
      for (const H of b) V.has(h(H)) ? O(H, 'active') : O(H, 'inactive')
    },
    L = () => {
      for (const B of y) S(B, 'inactive')
      for (const B of _.values()) B.remove()
      _.clear()
    },
    R = (B, F, W, U) => {
      const K = (V) => {
        const H = V.cloneNode()
        return (H.__data__ = V.__data__), V.parentNode.appendChild(H), _.set(V, H), H
      }
      for (const V of y) {
        const H = _.get(V) || K(V)
        ;(H.style.clipPath = new Xi({
          style: { x: B + T, y: F + C, width: W - B, height: U - F }
        })),
          O(V, 'inactive'),
          O(H, 'active')
      }
    },
    j = J0(
      t,
      Object.assign(Object.assign({}, w), {
        extent: A,
        brushRegion: o,
        reverse: c,
        selectedHandles: r,
        brushended: (B) => {
          const F = f ? L : P
          B && v.emit('brush:remove', { nativeEvent: !0 }), F()
        },
        brushed: (B, F, W, U, K) => {
          const V = Vc(B, F, W, U, l, u)
          K && v.emit('brush:highlight', { nativeEvent: !0, data: { selection: V } }),
            (f ? R : k)(B, F, W, U)
        },
        brushcreated: (B, F, W, U, K) => {
          const V = Vc(B, F, W, U, l, u)
          v.emit(
            'brush:end',
            Object.assign(Object.assign({}, K), { nativeEvent: !0, data: { selection: V } })
          )
        },
        brushupdated: (B, F, W, U, K) => {
          const V = Vc(B, F, W, U, l, u)
          v.emit(
            'brush:end',
            Object.assign(Object.assign({}, K), { nativeEvent: !0, data: { selection: V } })
          )
        },
        brushstarted: (B) => {
          v.emit('brush:start', B)
        }
      })
    ),
    I = ({ nativeEvent: B, data: F }) => {
      if (B) return
      const { selection: W } = F,
        [U, K, V, H] = UB(W, l, u)
      j.move(U, K, V, H, !1)
    }
  v.on('brush:highlight', I)
  const D = ({ nativeEvent: B } = {}) => {
    B || j.remove(!1)
  }
  v.on('brush:remove', D)
  const $ = j.destroy.bind(j)
  return (
    (j.destroy = () => {
      v.off('brush:highlight', I), v.off('brush:remove', D), $()
    }),
    j
  )
}
function ev(t) {
  var { facet: e, brushKey: n } = t,
    r = cn(t, ['facet', 'brushKey'])
  return (i, a, o) => {
    const { container: s, view: c, options: l } = i,
      u = kr(s),
      f = { maskFill: '#777', maskFillOpacity: '0.3', maskStroke: '#fff', reverse: !1 },
      h = ['active', ['inactive', { opacity: 0.5 }]],
      { scale: d, coordinate: p } = c
    if (e) {
      const g = u.getBounds(),
        y = g.min[0],
        m = g.min[1],
        b = g.max[0],
        x = g.max[1]
      return C1(
        u.parentNode.parentNode,
        Object.assign(
          Object.assign(
            {
              elements: () => NT(i, a),
              datum: Wi(Td(i, a).map((w) => w.view)),
              brushRegion: (w, O, S, _) => [w, O, S, _],
              extent: [y, m, b, x],
              state: Xa(
                Td(i, a).map((w) => w.options),
                h
              ),
              emitter: o,
              scale: d,
              coordinate: p,
              selectedHandles: void 0
            },
            f
          ),
          r
        )
      )
    }
    const v = C1(
      u,
      Object.assign(
        Object.assign(
          {
            elements: ei,
            key: (g) => g.__data__.key,
            siblings: () => IX(i, a, n),
            datum: Wi([c, ...tv(i, a, n).map((g) => g.view)]),
            brushRegion: (g, y, m, b) => [g, y, m, b],
            extent: void 0,
            state: Xa([l, ...jX(i, a, n)], h),
            emitter: o,
            scale: d,
            coordinate: p,
            selectedHandles: void 0
          },
          f
        ),
        r
      )
    )
    return (u.brush = v), () => v.destroy()
  }
}
function nv(t, e, n, r, i) {
  const [, a, , o] = i
  return [t, a, n, o]
}
function DX(t) {
  return ev(
    Object.assign(Object.assign({}, t), {
      brushRegion: nv,
      selectedHandles: ['handle-e', 'handle-w']
    })
  )
}
function rv(t, e, n, r, i) {
  const [a, , o] = i
  return [a, e, o, r]
}
function $X(t) {
  return ev(
    Object.assign(Object.assign({}, t), {
      brushRegion: rv,
      selectedHandles: ['handle-n', 'handle-s']
    })
  )
}
var iv =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const BX = 'axis',
  FX = 'axis-line',
  zX = 'axis-main-group',
  qT = 'axis-hot-area'
function GX(t) {
  return t.getElementsByClassName(BX)
}
function KT(t) {
  return t.getElementsByClassName(FX)[0]
}
function WX(t) {
  return t.getElementsByClassName(zX)[0]
}
function ZT(t) {
  return WX(t).getLocalBounds()
}
function YX(t, e) {
  var { cross: n, offsetX: r, offsetY: i } = e,
    a = iv(e, ['cross', 'offsetX', 'offsetY'])
  const o = ZT(t),
    s = KT(t),
    [c] = s.getLocalBounds().min,
    [l, u] = o.min,
    [f, h] = o.max,
    d = (f - l) * 2
  return {
    brushRegion: rv,
    hotZone: new Xi({
      className: qT,
      style: Object.assign({ x: n ? l : c - d / 2, width: n ? d / 2 : d, y: u, height: h - u }, a)
    }),
    extent: n
      ? (p, v, g, y) => [-1 / 0, v, 1 / 0, y]
      : (p, v, g, y) => [Math.floor(l - r), v, Math.ceil(f - r), y]
  }
}
function HX(t, e) {
  var { offsetY: n, offsetX: r, cross: i = !1 } = e,
    a = iv(e, ['offsetY', 'offsetX', 'cross'])
  const o = ZT(t),
    s = KT(t),
    [, c] = s.getLocalBounds().min,
    [l, u] = o.min,
    [f, h] = o.max,
    d = h - u
  return {
    brushRegion: nv,
    hotZone: new Xi({
      className: qT,
      style: Object.assign({ x: l, width: f - l, y: i ? u : c - d, height: i ? d : d * 2 }, a)
    }),
    extent: i
      ? (p, v, g, y) => [p, -1 / 0, g, 1 / 0]
      : (p, v, g, y) => [p, Math.floor(u - n), g, Math.ceil(h - n)]
  }
}
function VX(t, e) {
  var {
      axes: n,
      elements: r,
      points: i,
      horizontal: a,
      datum: o,
      offsetY: s,
      offsetX: c,
      reverse: l = !1,
      state: u = {},
      emitter: f,
      coordinate: h
    } = e,
    d = iv(e, [
      'axes',
      'elements',
      'points',
      'horizontal',
      'datum',
      'offsetY',
      'offsetX',
      'reverse',
      'state',
      'emitter',
      'coordinate'
    ])
  const p = r(t),
    v = n(t),
    g = Ys(p, o),
    { setState: y, removeState: m } = Mr(u, g),
    b = new Map(),
    x = et(d, 'mask'),
    w = (I) =>
      Array.from(b.values()).every(([D, $, B, F]) =>
        I.some(([W, U]) => W >= D && W <= B && U >= $ && U <= F)
      ),
    O = v.map((I) => I.attributes.scale),
    S = (I) => (I.length > 2 ? [I[0], I[I.length - 1]] : I),
    _ = new Map(),
    M = () => {
      _.clear()
      for (let I = 0; I < v.length; I++) {
        const D = O[I],
          { domain: $ } = D.getOptions()
        _.set(I, S($))
      }
    }
  M()
  const E = (I, D) => {
      const $ = []
      for (const F of p) {
        const W = i(F)
        w(W) ? (y(F, 'active'), $.push(F)) : y(F, 'inactive')
      }
      if ((_.set(I, C($, I)), !D)) return
      const B = () => {
        if (!A) return Array.from(_.values())
        const F = []
        for (const [W, U] of _) {
          const K = O[W],
            { name: V } = K.getOptions()
          V === 'x' ? (F[0] = U) : (F[1] = U)
        }
        return F
      }
      f.emit('brushAxis:highlight', { nativeEvent: !0, data: { selection: B() } })
    },
    T = (I) => {
      for (const D of p) m(D, 'active', 'inactive')
      M(), I && f.emit('brushAxis:remove', { nativeEvent: !0 })
    },
    C = (I, D) => {
      const $ = O[D],
        { name: B } = $.getOptions(),
        F = I.map((W) => {
          const U = W.__data__
          return $.invert(U[B])
        })
      return S(Fr($, F))
    },
    A = v.some(a) && v.some((I) => !a(I)),
    P = []
  for (let I = 0; I < v.length; I++) {
    const D = v[I],
      $ = a(D) ? HX : YX,
      {
        hotZone: B,
        brushRegion: F,
        extent: W
      } = $(D, { offsetY: s, offsetX: c, cross: A, zIndex: 999, fill: 'transparent' })
    D.parentNode.appendChild(B)
    const U = J0(
      B,
      Object.assign(Object.assign({}, x), {
        reverse: l,
        brushRegion: F,
        brushended(K) {
          b.delete(D), Array.from(b.entries()).length === 0 ? T(K) : E(I, K)
        },
        brushed(K, V, H, Q, tt) {
          b.set(D, W(K, V, H, Q)), E(I, tt)
        }
      })
    )
    P.push(U)
  }
  const k = (I = {}) => {
      const { nativeEvent: D } = I
      D || P.forEach(($) => $.remove(!1))
    },
    L = (I, D, $) => {
      const [B, F] = I,
        W = (V) => (V.getStep ? V.getStep() : 0),
        U = R(B, D, $),
        K = R(F, D, $) + W(D)
      return a($) ? [U, -1 / 0, K, 1 / 0] : [-1 / 0, U, 1 / 0, K]
    },
    R = (I, D, $) => {
      const { height: B, width: F } = h.getOptions(),
        W = D.clone()
      return a($) ? W.update({ range: [0, F] }) : W.update({ range: [B, 0] }), W.map(I)
    },
    j = (I) => {
      const { nativeEvent: D } = I
      if (D) return
      const { selection: $ } = I.data
      for (let B = 0; B < P.length; B++) {
        const F = $[B],
          W = P[B],
          U = v[B]
        if (F) {
          const K = O[B]
          W.move(...L(F, K, U), !1)
        } else W.remove(!1)
      }
    }
  return (
    f.on('brushAxis:remove', k),
    f.on('brushAxis:highlight', j),
    () => {
      P.forEach((I) => I.destroy()), f.off('brushAxis:remove', k), f.off('brushAxis:highlight', j)
    }
  )
}
function XX(t) {
  return (e, n, r) => {
    const { container: i, view: a, options: o } = e,
      s = kr(i),
      { x: c, y: l } = s.getBBox(),
      { coordinate: u } = a
    return VX(
      i,
      Object.assign(
        {
          elements: ei,
          axes: GX,
          offsetY: l,
          offsetX: c,
          points: (f) => f.__data__.points,
          horizontal: (f) => {
            const {
              startPos: [h, d],
              endPos: [p, v]
            } = f.attributes
            return h !== p && d === v
          },
          datum: Wi(a),
          state: Xa(o, ['active', ['inactive', { opacity: 0.5 }]]),
          coordinate: u,
          emitter: r
        },
        t
      )
    )
  }
}
var UX =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, r) {
      function i(a) {
        return a instanceof n
          ? a
          : new n(function (o) {
              o(a)
            })
      }
      return new (n || (n = Promise))(function (a, o) {
        function s(u) {
          try {
            l(r.next(u))
          } catch (f) {
            o(f)
          }
        }
        function c(u) {
          try {
            l(r.throw(u))
          } catch (f) {
            o(f)
          }
        }
        function l(u) {
          u.done ? a(u.value) : i(u.value).then(s, c)
        }
        l((r = r.apply(t, e || [])).next())
      })
    },
  QT =
    (globalThis && globalThis.__rest) ||
    function (t, e) {
      var n = {}
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
      if (t != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          e.indexOf(r[i]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
            (n[r[i]] = t[r[i]])
      return n
    }
function qX(t = 300) {
  let e = null
  return (n) => {
    const { timeStamp: r } = n
    return e !== null && r - e < t ? ((e = r), !0) : ((e = r), !1)
  }
}
function KX(t, e) {
  var {
      filter: n,
      reset: r,
      brushRegion: i,
      extent: a,
      reverse: o,
      emitter: s,
      scale: c,
      coordinate: l,
      selection: u,
      series: f = !1
    } = e,
    h = QT(e, [
      'filter',
      'reset',
      'brushRegion',
      'extent',
      'reverse',
      'emitter',
      'scale',
      'coordinate',
      'selection',
      'series'
    ])
  const d = et(h, 'mask'),
    { width: p, height: v } = t.getBBox(),
    g = a || [0, 0, p, v],
    y = qX(),
    m = J0(
      t,
      Object.assign(Object.assign({}, d), {
        extent: g,
        brushRegion: i,
        reverse: o,
        brushcreated: b
      })
    )
  t.addEventListener('click', x)
  function b(O, S, _, M, E) {
    ;(E.nativeEvent = !0), n(u(O, S, _, M), E), m.remove()
  }
  function x(O) {
    y(O) && ((O.nativeEvent = !0), r(O))
  }
  const w = ({ nativeEvent: O, data: S }) => {
    if (O) return
    const { selection: _ } = S
    n(_, { nativeEvent: !1 })
  }
  return (
    s.on('brush:filter', w),
    () => {
      m.destroy(), s.off('brush:filter', w), t.removeEventListener('click', x)
    }
  )
}
function av(t) {
  var { hideX: e = !0, hideY: n = !0 } = t,
    r = QT(t, ['hideX', 'hideY'])
  return (i, a, o) => {
    const { container: s, view: c, options: l, update: u, setState: f } = i,
      h = kr(s),
      d = {
        maskFill: '#777',
        maskFillOpacity: '0.3',
        maskStroke: '#fff',
        unhighlightedOpacity: 0.5,
        reverse: !1
      }
    let p = !1,
      v = !1,
      g = c
    const { scale: y, coordinate: m } = c
    return KX(
      h,
      Object.assign(
        Object.assign(
          {
            brushRegion: (b, x, w, O) => [b, x, w, O],
            selection: (b, x, w, O) => {
              const { scale: S, coordinate: _ } = g
              return Vc(b, x, w, O, S, _)
            },
            filter: (b, x) =>
              UX(this, void 0, void 0, function* () {
                if (v) return
                v = !0
                const [w, O] = b
                f('brushFilter', (_) => {
                  const { marks: M } = _,
                    E = M.map((T) =>
                      X(
                        {
                          axis: Object.assign(
                            Object.assign({}, e && { x: { transform: [{ type: 'hide' }] } }),
                            n && { y: { transform: [{ type: 'hide' }] } }
                          )
                        },
                        T,
                        { scale: { x: { domain: w, nice: !1 }, y: { domain: O, nice: !1 } } }
                      )
                    )
                  return Object.assign(Object.assign({}, l), { marks: E, clip: !0 })
                }),
                  o.emit(
                    'brush:filter',
                    Object.assign(Object.assign({}, x), { data: { selection: [w, O] } })
                  ),
                  (g = (yield u()).view),
                  (v = !1),
                  (p = !0)
              }),
            reset: (b) => {
              if (v || !p) return
              const { scale: x } = c,
                { x: w, y: O } = x,
                S = w.getOptions().domain,
                _ = O.getOptions().domain
              o.emit(
                'brush:filter',
                Object.assign(Object.assign({}, b), { data: { selection: [S, _] } })
              ),
                (p = !1),
                (g = c),
                f('brushFilter'),
                u()
            },
            extent: void 0,
            emitter: o,
            scale: y,
            coordinate: m
          },
          d
        ),
        r
      )
    )
  }
}
function ZX(t) {
  return av(Object.assign(Object.assign({ hideX: !0 }, t), { brushRegion: nv }))
}
function QX(t) {
  return av(Object.assign(Object.assign({ hideY: !0 }, t), { brushRegion: rv }))
}
var JX =
  (globalThis && globalThis.__awaiter) ||
  function (t, e, n, r) {
    function i(a) {
      return a instanceof n
        ? a
        : new n(function (o) {
            o(a)
          })
    }
    return new (n || (n = Promise))(function (a, o) {
      function s(u) {
        try {
          l(r.next(u))
        } catch (f) {
          o(f)
        }
      }
      function c(u) {
        try {
          l(r.throw(u))
        } catch (f) {
          o(f)
        }
      }
      function l(u) {
        u.done ? a(u.value) : i(u.value).then(s, c)
      }
      l((r = r.apply(t, e || [])).next())
    })
  }
const tU = 'slider'
function eU(t, e, n, r = !1, i = 'x', a = 'y') {
  const { marks: o } = t,
    s = o.map((c) => {
      var l, u
      return X(
        { axis: { x: { transform: [{ type: 'hide' }] }, y: { transform: [{ type: 'hide' }] } } },
        c,
        {
          scale: e,
          [n]: Object.assign(
            Object.assign(
              {},
              ((l = c[n]) === null || l === void 0 ? void 0 : l[i]) && {
                [i]: Object.assign({ preserve: !0 }, r && { ratio: null })
              }
            ),
            ((u = c[n]) === null || u === void 0 ? void 0 : u[a]) && { [a]: { preserve: !0 } }
          ),
          animate: !1
        }
      )
    })
  return Object.assign(Object.assign({}, t), { marks: s, clip: !0, animate: !1 })
}
function nU(t, e, n) {
  const [r, i] = t,
    a = n ? (c) => 1 - c : (c) => c,
    o = Fa(e, a(r), !0),
    s = Fa(e, a(i), !1)
  return Fr(e, [o, s])
}
function Rc(t) {
  return [t[0], t[t.length - 1]]
}
function JT({
  initDomain: t = {},
  className: e = tU,
  prefix: n = 'slider',
  setValue: r = (c, l) => c.setValues(l),
  hasState: i = !1,
  wait: a = 50,
  leading: o = !0,
  trailing: s = !1
}) {
  return (c, l, u) => {
    const { container: f, view: h, update: d, setState: p } = c,
      v = f.getElementsByClassName(e)
    if (!v.length) return () => {}
    let g = !1
    const { scale: y, coordinate: m, layout: b } = h,
      { paddingLeft: x, paddingTop: w, paddingBottom: O, paddingRight: S } = b,
      { x: _, y: M } = y,
      E = ce(m),
      T = (k) => {
        const L = k === 'vertical' ? 'y' : 'x',
          R = k === 'vertical' ? 'x' : 'y'
        return E ? [R, L] : [L, R]
      },
      C = new Map(),
      A = new Set(),
      P = { x: t.x || _.getOptions().domain, y: t.y || M.getOptions().domain }
    for (const k of v) {
      const { orientation: L } = k.attributes,
        [R, j] = T(L),
        I = `${n}${ni(R)}:filter`,
        D = R === 'x',
        { ratio: $ } = _.getOptions(),
        { ratio: B } = M.getOptions(),
        F = (K) => {
          if (K.data) {
            const { selection: it } = K.data,
              [ut = Rc(P.x), st = Rc(P.y)] = it
            return D ? [Fr(_, ut, $), Fr(M, st, B)] : [Fr(M, st, B), Fr(_, ut, $)]
          }
          const { value: V } = K.detail,
            H = y[R],
            Q = nU(V, H, E && L === 'horizontal'),
            tt = P[j]
          return [Q, tt]
        },
        W = Ci(
          (K) =>
            JX(this, void 0, void 0, function* () {
              if (g) return
              g = !0
              const { nativeEvent: V = !0 } = K,
                [H, Q] = F(K)
              if (((P[R] = H), (P[j] = Q), V)) {
                const tt = D ? H : Q,
                  it = D ? Q : H
                u.emit(
                  I,
                  Object.assign(Object.assign({}, K), {
                    nativeEvent: V,
                    data: { selection: [Rc(tt), Rc(it)] }
                  })
                )
              }
              p(k, (tt) =>
                Object.assign(
                  Object.assign({}, eU(tt, { [R]: { domain: H, nice: !1 } }, n, i, R, j)),
                  { paddingLeft: x, paddingTop: w, paddingBottom: O, paddingRight: S }
                )
              ),
                yield d(),
                (g = !1)
            }),
          a,
          { leading: o, trailing: s }
        ),
        U = (K) => {
          const { nativeEvent: V } = K
          if (V) return
          const { data: H } = K,
            { selection: Q } = H,
            [tt, it] = Q
          k.dispatchEvent(new Bt('valuechange', { data: H, nativeEvent: !1 }))
          const ut = D ? Ml(tt, _) : Ml(it, M)
          r(k, ut)
        }
      u.on(I, U), k.addEventListener('valuechange', W), C.set(k, W), A.add([I, U])
    }
    return () => {
      for (const [k, L] of C) k.removeEventListener('valuechange', L)
      for (const [k, L] of A) u.off(k, L)
    }
  }
}
const L1 = 'g2-scrollbar'
function rU(t = {}) {
  return (e, n, r) => {
    const { view: i, container: a } = e
    if (!a.getElementsByClassName(L1).length) return () => {}
    const { scale: s } = i,
      { x: c, y: l } = s,
      u = { x: [...c.getOptions().domain], y: [...l.getOptions().domain] }
    return (
      c.update({ domain: c.getOptions().expectedDomain }),
      l.update({ domain: l.getOptions().expectedDomain }),
      JT(
        Object.assign(Object.assign({}, t), {
          initDomain: u,
          className: L1,
          prefix: 'scrollbar',
          hasState: !0,
          setValue: (h, d) => h.setValue(d[0])
        })
      )(e, n, r)
    )
  }
}
var iU =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
function aU(t, e, n) {
  return `<${t} style="${Object.entries(n)
    .map(([r, i]) => `${m9(r)}:${i}`)
    .join(';')}">${e}</${t}>`
}
const oU = {
  backgroundColor: 'rgba(0,0,0,0.75)',
  color: '#fff',
  width: 'max-content',
  padding: '1px 4px',
  fontSize: '12px',
  borderRadius: '2.5px',
  boxShadow:
    '0 3px 6px -4px rgba(0,0,0,0.12), 0 6px 16px 0 rgba(0,0,0,0.08), 0 9px 28px 8px rgba(0,0,0,0.05)'
}
function N1(t) {
  return t.nodeName !== 'text' ? !1 : !!t.isOverflowing()
}
function sU(t) {
  var { offsetX: e = 8, offsetY: n = 8 } = t,
    r = iU(t, ['offsetX', 'offsetY'])
  return (i) => {
    const { container: a } = i,
      [o, s] = a.getBounds().min,
      c = et(r, 'tip'),
      l = new Set(),
      u = (h) => {
        const { target: d } = h
        if (!N1(d)) {
          h.stopPropagation()
          return
        }
        const { offsetX: p, offsetY: v } = h,
          g = p + e - o,
          y = v + n - s
        if (d.tip) {
          ;(d.tip.style.x = g), (d.tip.style.y = y)
          return
        }
        const { text: m } = d.style,
          b = new du({
            className: 'poptip',
            style: { innerHTML: aU('div', m, Object.assign(Object.assign({}, oU), c)), x: g, y }
          })
        a.appendChild(b), (d.tip = b), l.add(b)
      },
      f = (h) => {
        const { target: d } = h
        if (!N1(d)) {
          h.stopPropagation()
          return
        }
        d.tip && (d.tip.remove(), (d.tip = null), l.delete(d.tip))
      }
    return (
      a.addEventListener('pointerover', u),
      a.addEventListener('pointerout', f),
      () => {
        a.removeEventListener('pointerover', u),
          a.removeEventListener('pointerout', f),
          l.forEach((h) => h.remove())
      }
    )
  }
}
function kd(t) {
  const { min: e, max: n } = t
  return [
    [e[0], e[1]],
    [n[0], n[1]]
  ]
}
function R1(t, e) {
  const [n, r] = t,
    [i, a] = e
  return n >= i[0] && n <= a[0] && r >= i[1] && r <= a[1]
}
function cU(t, e) {
  const [n, r] = t
  return !(R1(n, e) && R1(r, e))
}
function lU(t, e) {
  const [n, r] = t,
    [i, a] = e
  return n[0] < a[0] && r[0] > i[0] && n[1] < a[1] && r[1] > i[1]
}
const uU = (t) => {
  const { priority: e } = t
  return (n) => {
    const r = []
    return (
      e && n.sort(e),
      n.forEach((i) => {
        X0(i)
        const a = i.getLocalBounds()
        r.some((s) => lU(kd(a), kd(s.getLocalBounds()))) ? V0(i) : r.push(i)
      }),
      n
    )
  }
}
function fU([t, e], [n, r]) {
  return r > t && e > n
}
function Ic() {
  const t = new Map()
  return [(r) => t.get(r), (r, i) => t.set(r, i)]
}
function hU(t) {
  const e = t.cloneNode(!0),
    n = e.getElementById('connector')
  n && e.removeChild(n)
  const { min: r, max: i } = e.getRenderBounds()
  return e.destroy(), { min: r, max: i }
}
const dU = (t) => {
  const { maxIterations: e = 10, maxError: n = 0.1, padding: r = 1 } = t
  return (i) => {
    const a = i.length
    if (a <= 1) return i
    const [o, s] = Ic(),
      [c, l] = Ic(),
      [u, f] = Ic(),
      [h, d] = Ic()
    for (const p of i) {
      const { min: v, max: g } = hU(p),
        [y, m] = v,
        [b, x] = g
      s(p, m), l(p, m), f(p, x - m), d(p, [y, b])
    }
    for (let p = 0; p < e; p++) {
      i.sort((g, y) => ae(c(g), c(y)))
      let v = 0
      for (let g = 0; g < a - 1; g++) {
        const y = i[g]
        let m = g + 1,
          b
        for (; (b = i[m]) && !fU(h(y), h(b)); ) m += 1
        if (b) {
          const x = c(y),
            w = u(y),
            O = c(b),
            S = O - (x + w)
          if (S < r) {
            const _ = (r - S) / 2
            ;(v = Math.max(v, _)), l(y, x - _), l(b, O + _)
          }
        }
      }
      if (v < n) break
    }
    for (const p of i) p.style.y += c(p) - o(p)
    return i
  }
}
function pU(t) {
  return typeof t == 'object' ? t : Or(t)
}
function Hf(t) {
  let e = t / 255
  return (e = e <= 0.03928 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4)), e
}
function I1(t, e, n) {
  return 0.2126 * Hf(t) + 0.7152 * Hf(e) + 0.0722 * Hf(n)
}
function tP(t, e) {
  const { r: n, g: r, b: i } = t,
    { r: a, g: o, b: s } = e,
    c = I1(n, r, i),
    l = I1(a, o, s)
  return (Math.max(c, l) + 0.05) / (Math.min(c, l) + 0.05)
}
function vU(t, e) {
  const n = qa(e, (r) => tP(t, pU(r)))
  return e[n]
}
const gU = (t) => {
    const { threshold: e = 4.5, palette: n = ['#000', '#fff'] } = t
    return (r) => (
      r.forEach((i) => {
        const a = i.attr('dependentElement').parsedStyle.fill,
          o = i.parsedStyle.fill
        tP(o, a) < e && i.attr('fill', vU(a, n))
      }),
      r
    )
  },
  yU = () => (t) => (
    t.forEach((e) => {
      X0(e)
      const n = e.attr('bounds'),
        r = e.getLocalBounds()
      cU(kd(r), n) && V0(e)
    }),
    t
  )
function mU() {
  return {
    'data.fetch': d_,
    'data.inline': x_,
    'data.sortBy': b_,
    'data.sort': g_,
    'data.filter': v_,
    'data.pick': y_,
    'data.rename': m_,
    'data.fold': p_,
    'data.slice': T_,
    'data.custom': w_,
    'data.map': O_,
    'data.join': E_,
    'data.kde': k_,
    'data.log': D_,
    'transform.stackY': Bb,
    'transform.binX': n2,
    'transform.bin': op,
    'transform.dodgeX': Ub,
    'transform.jitter': Bx,
    'transform.jitterX': Fx,
    'transform.symmetryY': zx,
    'transform.diffY': Gx,
    'transform.stackEnter': qb,
    'transform.normalizeY': Kb,
    'transform.select': iu,
    'transform.selectX': Wx,
    'transform.selectY': Yx,
    'transform.groupX': Hx,
    'transform.groupY': Vx,
    'transform.groupColor': Xx,
    'transform.group': Ps,
    'transform.sortX': qx,
    'transform.sortY': Zx,
    'transform.sortColor': Kx,
    'transform.flexX': Qx,
    'transform.pack': e2,
    'transform.sample': r2,
    'transform.filter': i2,
    'coordinate.cartesian': F1,
    'coordinate.polar': bs,
    'coordinate.transpose': Nd,
    'coordinate.theta': G1,
    'coordinate.parallel': Id,
    'coordinate.fisheye': Y1,
    'coordinate.radial': Rd,
    'coordinate.radar': H1,
    'encode.constant': V1,
    'encode.field': U1,
    'encode.transform': X1,
    'encode.column': q1,
    'mark.interval': TS,
    'mark.rect': PS,
    'mark.line': AS,
    'mark.point': kS,
    'mark.text': CS,
    'mark.cell': LS,
    'mark.area': NS,
    'mark.link': t0,
    'mark.image': RS,
    'mark.polygon': IS,
    'mark.box': jS,
    'mark.vector': DS,
    'mark.lineX': BS,
    'mark.lineY': $S,
    'mark.connector': FS,
    'mark.range': zS,
    'mark.rangeX': GS,
    'mark.rangeY': WS,
    'mark.path': XS,
    'mark.shape': JS,
    'mark.density': F_,
    'mark.heatmap': z_,
    'palette.category10': W_,
    'palette.category20': Y_,
    'scale.linear': V_,
    'scale.ordinal': X_,
    'scale.band': H_,
    'scale.identity': U_,
    'scale.point': q_,
    'scale.time': K_,
    'scale.log': Z_,
    'scale.pow': Q_,
    'scale.sqrt': nM,
    'scale.threshold': J_,
    'scale.quantile': tM,
    'scale.quantize': eM,
    'scale.sequential': rM,
    'scale.constant': iM,
    'theme.classic': aM,
    'theme.classicDark': sM,
    'theme.academy': cM,
    'theme.light': c0,
    'theme.dark': oM,
    'component.axisX': bM,
    'component.axisY': xM,
    'component.legendCategory': u0,
    'component.legendContinuous': fi,
    'component.legends': AM,
    'component.title': _M,
    'component.sliderX': MM,
    'component.sliderY': EM,
    'component.scrollbarX': TM,
    'component.scrollbarY': PM,
    'animation.scaleInX': h0,
    'animation.scaleOutX': QB,
    'animation.scaleInY': kM,
    'animation.scaleOutY': JB,
    'animation.waveIn': IM,
    'animation.fadeIn': CM,
    'animation.fadeOut': LM,
    'animation.zoomIn': cF,
    'animation.zoomOut': lF,
    'animation.pathIn': jM,
    'animation.morphing': RM,
    'animation.growInX': DM,
    'animation.growInY': $M,
    'interaction.elementHighlight': Z0,
    'interaction.elementHighlightByX': QV,
    'interaction.elementHighlightByColor': JV,
    'interaction.elementSelect': Q0,
    'interaction.elementSelectByX': nX,
    'interaction.elementSelectByColor': rX,
    'interaction.fisheye': uX,
    'interaction.chartIndex': cX,
    'interaction.tooltip': wX,
    'interaction.legendFilter': kX,
    'interaction.legendHighlight': CX,
    'interaction.brushHighlight': ev,
    'interaction.brushXHighlight': DX,
    'interaction.brushYHighlight': $X,
    'interaction.brushAxisHighlight': XX,
    'interaction.brushFilter': av,
    'interaction.brushXFilter': ZX,
    'interaction.brushYFilter': QX,
    'interaction.sliderFilter': JT,
    'interaction.scrollbarFilter': rU,
    'interaction.poptip': sU,
    'composition.spaceLayer': KM,
    'composition.spaceFlex': ZM,
    'composition.facetRect': nE,
    'composition.repeatMatrix': qz,
    'composition.facetCircle': eG,
    'composition.timingKeyframe': rE,
    'labelTransform.overlapHide': uU,
    'labelTransform.overlapDodgeY': dU,
    'labelTransform.overflowHide': yU,
    'labelTransform.contrastReverse': gU
  }
}
function bU() {
  return { 'composition.geoView': LE, 'composition.geoPath': iE }
}
function xU() {
  return {
    'data.arc': S_,
    'data.cluster': l_,
    'mark.forceGraph': s_,
    'mark.tree': f_,
    'mark.pack': qS,
    'mark.sankey': VS,
    'mark.treemap': US
  }
}
function wU() {
  return {
    'data.venn': j_,
    'mark.boxplot': QS,
    'mark.gauge': B_,
    'mark.wordCloud': $_,
    'mark.liquid': G_
  }
}
function OU() {
  return Object.assign(Object.assign(Object.assign(Object.assign({}, bU()), xU()), wU()), mU())
}
function SU(t, e) {
  class n extends t {
    constructor(i) {
      super(Object.assign(Object.assign({}, i), { lib: e }))
    }
  }
  return n
}
const _U = {},
  ia = (t) => (t ? parseInt(t) : 0)
function MU(t) {
  const e = getComputedStyle(t),
    n = t.clientWidth || ia(e.width),
    r = t.clientHeight || ia(e.height),
    i = ia(e.paddingLeft) + ia(e.paddingRight),
    a = ia(e.paddingTop) + ia(e.paddingBottom)
  return { width: n - i, height: r - a }
}
function Vf(t, e) {
  const n = [t]
  for (; n.length; ) {
    const r = n.shift()
    e && e(r)
    const i = r.children || []
    for (const a of i) n.push(a)
  }
}
class ov {
  constructor(e = {}, n) {
    ;(this.parentNode = null),
      (this.children = []),
      (this.index = 0),
      (this.type = n),
      (this.value = e)
  }
  map(e = (n) => n) {
    const n = e(this.value)
    return (this.value = n), this
  }
  attr(e, n) {
    return arguments.length === 1 ? this.value[e] : this.map((r) => ((r[e] = n), r))
  }
  append(e) {
    const n = new e({})
    return (n.children = []), this.push(n), n
  }
  push(e) {
    return (e.parentNode = this), (e.index = this.children.length), this.children.push(e), this
  }
  remove() {
    const e = this.parentNode
    if (e) {
      const { children: n } = e,
        r = n.findIndex((i) => i === this)
      n.splice(r, 1)
    }
    return this
  }
  getNodeByKey(e) {
    let n = null
    return (
      Vf(this, (i) => {
        e === i.attr('key') && (n = i)
      }),
      n
    )
  }
  getNodesByType(e) {
    const n = []
    return (
      Vf(this, (i) => {
        e === i.type && n.push(i)
      }),
      n
    )
  }
  getNodeByType(e) {
    let n = null
    return (
      Vf(this, (r) => {
        n || (e === r.type && (n = r))
      }),
      n
    )
  }
  call(e, ...n) {
    return e(this.map(), ...n), this
  }
  getRoot() {
    let e = this
    for (; e && e.parentNode; ) e = e.parentNode
    return e
  }
}
var eP =
  (globalThis && globalThis.__rest) ||
  function (t, e) {
    var n = {}
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
    if (t != null && typeof Object.getOwnPropertySymbols == 'function')
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]])
    return n
  }
const nP = [
    'width',
    'height',
    'depth',
    'padding',
    'paddingLeft',
    'paddingRight',
    'paddingBottom',
    'paddingTop',
    'inset',
    'insetLeft',
    'insetRight',
    'insetTop',
    'insetBottom',
    'margin',
    'marginLeft',
    'marginRight',
    'marginTop',
    'marginBottom',
    'autoFit',
    'theme',
    'title'
  ],
  rP = '__remove__',
  iP = '__callback__',
  j1 = 1,
  D1 = 1
function EU(t) {
  if (t === void 0) {
    const e = document.createElement('div')
    return (e[rP] = !0), e
  }
  return typeof t == 'string' ? document.getElementById(t) : t
}
function TU(t) {
  const e = t.parentNode
  e && e.removeChild(t)
}
function PU(t) {
  if (t.type !== null) return t
  const e = t.children[t.children.length - 1]
  for (const n of nP) e.attr(n, t.attr(n))
  return e
}
function $1(t) {
  return Object.assign(Object.assign({}, t.value), { type: t.type })
}
function Xf(t, e) {
  const { width: n = 640, height: r = 480, autoFit: i, depth: a = 0 } = t
  let o = n,
    s = r
  if (i) {
    const { width: c, height: l } = MU(e)
    ;(o = c || o), (s = l || s)
  }
  return { width: Math.max(ve(o) ? o : j1, j1), height: Math.max(ve(s) ? s : D1, D1), depth: a }
}
function AU(t) {
  const e = PU(t),
    n = [e],
    r = new Map()
  for (r.set(e, $1(e)); n.length; ) {
    const i = n.pop(),
      a = r.get(i),
      { children: o = [] } = i
    for (const s of o)
      if (s.type === iP) a.children = s.value
      else {
        const c = $1(s),
          { children: l = [] } = a
        l.push(c), n.push(s), r.set(s, c), (a.children = l)
      }
  }
  return r.get(e)
}
function kU(t, e) {
  return typeof t == 'function' ? !0 : new Set(Object.keys(e)).has(t)
}
function CU(t, e, n, r) {
  const { type: i } = t,
    { type: a = n || i } = e
  if (a === 'view' || !kU(a, r)) return e
  const o = { type: 'view' },
    s = Object.assign({}, e)
  for (const c of nP) s[c] !== void 0 && ((o[c] = s[c]), delete s[c])
  return Object.assign(Object.assign({}, o), { children: [s] })
}
function LU(t, e, n) {
  if (typeof t == 'function') return e.mark
  const i = Object.assign(Object.assign({}, e), n)[t]
  if (!i) throw new Error(`Unknown mark: ${t}.`)
  return i
}
function NU(t, e, n) {
  if (typeof t == 'function') {
    const c = new ov()
    return (c.value = t), (c.type = iP), c
  }
  const { type: r, children: i } = t,
    a = eP(t, ['type', 'children']),
    o = LU(r, e, n),
    s = new o()
  return (s.value = a), (s.type = r), s
}
function RU(t, e) {
  const { type: n, children: r } = e,
    i = eP(e, ['type', 'children'])
  t.type === n || n === void 0
    ? Lb(t.value, i)
    : typeof n == 'string' && ((t.type = n), (t.value = i))
}
function IU(t, e, n, r) {
  if (!t) return
  const i = [[t, e]]
  for (; i.length; ) {
    const [a, o] = i.shift(),
      s = NU(o, n, r)
    Array.isArray(a.children) && a.push(s)
    const { children: c } = o
    if (Array.isArray(c)) for (const l of c) i.push([s, l])
    else typeof c == 'function' && i.push([s, c])
  }
}
function jU(t, e, n, r, i) {
  const a = CU(t, e, n, r),
    o = [[null, t, a]]
  for (; o.length; ) {
    const [s, c, l] = o.shift()
    if (!c) IU(s, l, r, i)
    else if (!l) c.remove()
    else {
      RU(c, l)
      const { children: u } = l,
        { children: f } = c
      if (Array.isArray(u) && Array.isArray(f)) {
        const h = Math.max(u.length, f.length)
        for (let d = 0; d < h; d++) {
          const p = u[d],
            v = f[d]
          o.push([c, v, p])
        }
      } else typeof u == 'function' && o.push([c, null, u])
    }
  }
}
function DU() {
  let t, e
  return [
    new Promise((r, i) => {
      ;(e = r), (t = i)
    }),
    e,
    t
  ]
}
function $U(t, e, { key: n = e }) {
  t.prototype[e] = function (r) {
    return arguments.length === 0 ? this.attr(n) : this.attr(n, r)
  }
}
function BU(t, e, { key: n = e }) {
  t.prototype[e] = function (r) {
    if (arguments.length === 0) return this.attr(n)
    if (Array.isArray(r)) return this.attr(n, r)
    const i = [...(this.attr(n) || []), r]
    return this.attr(n, i)
  }
}
function FU(t, e, { key: n = e }) {
  t.prototype[e] = function (r, i) {
    if (arguments.length === 0) return this.attr(n)
    if (arguments.length === 1 && typeof r != 'string') return this.attr(n, r)
    const a = this.attr(n) || {}
    return (a[r] = arguments.length === 1 ? !0 : i), this.attr(n, a)
  }
}
function zU(t, e, n) {
  t.prototype[e] = function (r) {
    if (arguments.length === 0) return this.attr(e)
    if (Array.isArray(r)) return this.attr(e, { items: r })
    if (Uo(r) && (r.title !== void 0 || r.items !== void 0)) return this.attr(e, r)
    if (r === null || r === !1) return this.attr(e, r)
    const i = this.attr(e) || {},
      { items: a = [] } = i
    return a.push(r), (i.items = a), this.attr(e, i)
  }
}
function GU(t, e, { ctor: n }) {
  t.prototype[e] = function (r) {
    const i = this.append(n)
    return e === 'mark' && (i.type = r), i
  }
}
function WU(t, e, { ctor: n }) {
  t.prototype[e] = function () {
    return (this.type = null), this.append(n)
  }
}
function Wl(t) {
  return (e) => {
    for (const [n, r] of Object.entries(t)) {
      const { type: i } = r
      i === 'value'
        ? $U(e, n, r)
        : i === 'array'
        ? BU(e, n, r)
        : i === 'object'
        ? FU(e, n, r)
        : i === 'node'
        ? GU(e, n, r)
        : i === 'container'
        ? WU(e, n, r)
        : i === 'mix' && zU(e, n)
    }
    return e
  }
}
function B1(t) {
  return Object.fromEntries(Object.entries(t).map(([e, n]) => [e, { type: 'node', ctor: n }]))
}
const aP = {
    encode: { type: 'object' },
    scale: { type: 'object' },
    data: { type: 'value' },
    transform: { type: 'array' },
    style: { type: 'object' },
    animate: { type: 'object' },
    coordinate: { type: 'object' },
    interaction: { type: 'object' },
    label: { type: 'array', key: 'labels' },
    axis: { type: 'object' },
    legend: { type: 'object' },
    slider: { type: 'object' },
    scrollbar: { type: 'object' },
    state: { type: 'object' },
    layout: { type: 'object' },
    theme: { type: 'object' },
    title: { type: 'value' }
  },
  YU = Object.assign(Object.assign({}, aP), {
    tooltip: { type: 'mix' },
    viewStyle: { type: 'object' }
  }),
  HU = Object.assign(Object.assign({}, aP), { labelTransform: { type: 'array' } })
var VU =
  (globalThis && globalThis.__decorate) ||
  function (t, e, n, r) {
    var i = arguments.length,
      a = i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, n)) : r,
      o
    if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
      a = Reflect.decorate(t, e, n, r)
    else
      for (var s = t.length - 1; s >= 0; s--)
        (o = t[s]) && (a = (i < 3 ? o(a) : i > 3 ? o(e, n, a) : o(e, n)) || a)
    return i > 3 && a && Object.defineProperty(e, n, a), a
  }
let Yl = class extends ov {
  changeData(e) {
    var n
    const r = this.getRoot()
    if (r)
      return (
        this.attr('data', e),
        !((n = this.children) === null || n === void 0) &&
          n.length &&
          this.children.forEach((i) => {
            i.attr('data', e)
          }),
        r == null ? void 0 : r.render()
      )
  }
  getView() {
    const e = this.getRoot(),
      { views: n } = e.getContext()
    if (n != null && n.length) return n.find((r) => r.key === this._key)
  }
  getScale() {
    var e
    return (e = this.getView()) === null || e === void 0 ? void 0 : e.scale
  }
  getScaleByChannel(e) {
    const n = this.getScale()
    if (n) return n[e]
  }
  getCoordinate() {
    var e
    return (e = this.getView()) === null || e === void 0 ? void 0 : e.coordinate
  }
  getTheme() {
    var e
    return (e = this.getView()) === null || e === void 0 ? void 0 : e.theme
  }
  getGroup() {
    const e = this._key
    return e ? this.getRoot().getContext().canvas.getRoot().getElementById(e) : void 0
  }
  show() {
    const e = this.getGroup()
    e && !e.isVisible() && X0(e)
  }
  hide() {
    const e = this.getGroup()
    e && e.isVisible() && V0(e)
  }
}
Yl = VU([Wl(HU)], Yl)
var XU =
  (globalThis && globalThis.__decorate) ||
  function (t, e, n, r) {
    var i = arguments.length,
      a = i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, n)) : r,
      o
    if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
      a = Reflect.decorate(t, e, n, r)
    else
      for (var s = t.length - 1; s >= 0; s--)
        (o = t[s]) && (a = (i < 3 ? o(a) : i > 3 ? o(e, n, a) : o(e, n)) || a)
    return i > 3 && a && Object.defineProperty(e, n, a), a
  }
let Cd = class extends ov {
  changeData(e) {
    const n = this.getRoot()
    if (n) return this.attr('data', e), n == null ? void 0 : n.render()
  }
  getMark() {
    var e
    const n = (e = this.getRoot()) === null || e === void 0 ? void 0 : e.getView()
    if (!n) return
    const { markState: r } = n,
      i = Array.from(r.keys()).find((a) => a.key === this.attr('key'))
    return r.get(i)
  }
  getScale() {
    var e
    const n = (e = this.getRoot()) === null || e === void 0 ? void 0 : e.getView()
    if (n) return n == null ? void 0 : n.scale
  }
  getScaleByChannel(e) {
    var n, r
    const i = (n = this.getRoot()) === null || n === void 0 ? void 0 : n.getView()
    if (i) return (r = i == null ? void 0 : i.scale) === null || r === void 0 ? void 0 : r[e]
  }
  getGroup() {
    const e = this.attr('key')
    return e ? this.getRoot().getContext().canvas.getRoot().getElementById(e) : void 0
  }
}
Cd = XU([Wl(YU)], Cd)
var UU =
    (globalThis && globalThis.__decorate) ||
    function (t, e, n, r) {
      var i = arguments.length,
        a = i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, n)) : r,
        o
      if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
        a = Reflect.decorate(t, e, n, r)
      else
        for (var s = t.length - 1; s >= 0; s--)
          (o = t[s]) && (a = (i < 3 ? o(a) : i > 3 ? o(e, n, a) : o(e, n)) || a)
      return i > 3 && a && Object.defineProperty(e, n, a), a
    },
  qU =
    (globalThis && globalThis.__rest) ||
    function (t, e) {
      var n = {}
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r])
      if (t != null && typeof Object.getOwnPropertySymbols == 'function')
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          e.indexOf(r[i]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
            (n[r[i]] = t[r[i]])
      return n
    }
const KU = 'G2_CHART_KEY'
class ZU extends Yl {
  constructor(e) {
    const { container: n, canvas: r, renderer: i, plugins: a, lib: o } = e,
      s = qU(e, ['container', 'canvas', 'renderer', 'plugins', 'lib'])
    super(s, 'view'),
      (this._hasBindAutoFit = !1),
      (this._rendering = !1),
      (this._trailing = !1),
      (this._trailingResolve = null),
      (this._trailingReject = null),
      (this._previousDefinedType = null),
      (this._onResize = J1(() => {
        this.forceFit()
      }, 300)),
      (this._renderer = i || new zM()),
      (this._plugins = a || []),
      (this._container = EU(n)),
      (this._emitter = new WM()),
      (this._context = {
        library: Object.assign(Object.assign({}, o), _U),
        emitter: this._emitter,
        canvas: r
      }),
      this._create()
  }
  render() {
    if (this._rendering) return this._addToTrailing()
    this._context.canvas || this._createCanvas(),
      (this._context.canvas.getConfig().supportsCSSTransform = !0),
      this._bindAutoFit(),
      (this._rendering = !0)
    const e = new Promise((a, o) =>
        GV(this._computedOptions(), this._context, this._createResolve(a), this._createReject(o))
      ),
      [n, r, i] = DU()
    return (
      e
        .then(r)
        .catch(i)
        .then(() => this._renderTrailing()),
      n
    )
  }
  options(e) {
    if (arguments.length === 0) return AU(this)
    const { type: n } = e
    return (
      n && (this._previousDefinedType = n),
      jU(this, e, this._previousDefinedType, this._marks, this._compositions),
      this
    )
  }
  getContainer() {
    return this._container
  }
  getContext() {
    return this._context
  }
  on(e, n, r) {
    return this._emitter.on(e, n, r), this
  }
  once(e, n) {
    return this._emitter.once(e, n), this
  }
  emit(e, ...n) {
    return this._emitter.emit(e, ...n), this
  }
  off(e, n) {
    return this._emitter.off(e, n), this
  }
  clear() {
    const e = this.options()
    this.emit(Lt.BEFORE_CLEAR), this._reset(), _1(e, this._context, !1), this.emit(Lt.AFTER_CLEAR)
  }
  destroy() {
    const e = this.options()
    this.emit(Lt.BEFORE_DESTROY),
      this._unbindAutoFit(),
      this._reset(),
      _1(e, this._context, !0),
      this._container[rP] && TU(this._container),
      this.emit(Lt.AFTER_DESTROY)
  }
  forceFit() {
    this.options.autoFit = !0
    const { width: e, height: n } = Xf(this.options(), this._container)
    if (e === this._width && n === this._height) return Promise.resolve(this)
    this.emit(Lt.BEFORE_CHANGE_SIZE)
    const r = this.render()
    return (
      r.then(() => {
        this.emit(Lt.AFTER_CHANGE_SIZE)
      }),
      r
    )
  }
  changeSize(e, n) {
    if (e === this._width && n === this._height) return Promise.resolve(this)
    this.emit(Lt.BEFORE_CHANGE_SIZE), this.attr('width', e), this.attr('height', n)
    const r = this.render()
    return (
      r.then(() => {
        this.emit(Lt.AFTER_CHANGE_SIZE)
      }),
      r
    )
  }
  _create() {
    const { library: e } = this._context,
      n = (a) =>
        a.startsWith('mark.') ||
        a === 'component.axisX' ||
        a === 'component.axisY' ||
        a === 'component.legends',
      r = ['mark.mark', ...Object.keys(e).filter(n)]
    this._marks = {}
    for (const a of r) {
      const o = a.split('.').pop()
      class s extends Cd {
        constructor() {
          super({}, o)
        }
      }
      ;(this._marks[o] = s),
        (this[o] = function (c) {
          const l = this.append(s)
          return o === 'mark' && (l.type = c), l
        })
    }
    const i = [
      'composition.view',
      ...Object.keys(e).filter((a) => a.startsWith('composition.') && a !== 'composition.mark')
    ]
    this._compositions = Object.fromEntries(
      i.map((a) => {
        const o = a.split('.').pop()
        let s = class extends Yl {
          constructor() {
            super({}, o)
          }
        }
        return (s = UU([Wl(B1(this._marks))], s)), [o, s]
      })
    )
    for (const a of Object.values(this._compositions)) Wl(B1(this._compositions))(a)
    for (const a of i) {
      const o = a.split('.').pop()
      this[o] = function () {
        const s = this._compositions[o]
        return (this.type = null), this.append(s)
      }
    }
  }
  _reset() {
    const e = ['theme', 'type', 'width', 'height', 'autoFit']
    ;(this.type = 'view'),
      (this.value = Object.fromEntries(
        Object.entries(this.value).filter(
          ([n]) =>
            n.startsWith('margin') ||
            n.startsWith('padding') ||
            n.startsWith('inset') ||
            e.includes(n)
        )
      )),
      (this.children = [])
  }
  _renderTrailing() {
    this._trailing &&
      ((this._trailing = !1),
      this.render()
        .then(() => {
          const e = this._trailingResolve.bind(this)
          ;(this._trailingResolve = null), e(this)
        })
        .catch((e) => {
          const n = this._trailingReject.bind(this)
          ;(this._trailingReject = null), n(e)
        }))
  }
  _createResolve(e) {
    return () => {
      ;(this._rendering = !1), e(this)
    }
  }
  _createReject(e) {
    return (n) => {
      ;(this._rendering = !1), e(n)
    }
  }
  _computedOptions() {
    const e = this.options(),
      { key: n = KU } = e,
      { width: r, height: i, depth: a } = Xf(e, this._container)
    return (
      (this._width = r),
      (this._height = i),
      (this._key = n),
      Object.assign(Object.assign({ key: this._key }, e), { width: r, height: i, depth: a })
    )
  }
  _createCanvas() {
    const { width: e, height: n } = Xf(this.options(), this._container)
    this._plugins.push(new GM()),
      this._plugins.forEach((r) => this._renderer.registerPlugin(r)),
      (this._context.canvas = new ew({
        container: this._container,
        width: e,
        height: n,
        renderer: this._renderer
      }))
  }
  _addToTrailing() {
    var e
    return (
      (e = this._trailingResolve) === null || e === void 0 || e.call(this, this),
      (this._trailing = !0),
      new Promise((r, i) => {
        ;(this._trailingResolve = r), (this._trailingReject = i)
      })
    )
  }
  _bindAutoFit() {
    const e = this.options(),
      { autoFit: n } = e
    if (this._hasBindAutoFit) {
      n || this._unbindAutoFit()
      return
    }
    n && ((this._hasBindAutoFit = !0), window.addEventListener('resize', this._onResize))
  }
  _unbindAutoFit() {
    this._hasBindAutoFit &&
      ((this._hasBindAutoFit = !1), window.removeEventListener('resize', this._onResize))
  }
}
Y.enableCSSParsing = !1
const QU = Object.assign({}, OU()),
  JU = SU(ZU, QU),
  lq = () => (
    fP.useEffect(() => {
      setTimeout(() => {
        const t = new JU({ container: 'container', autoFit: !0 })
        t
          .data({
            type: 'fetch',
            value: 'https://assets.antv.antgroup.com/g2/range-spline-area.json',
            transform: [
              {
                type: 'map',
                callback: ([e, n, r, i, a]) => ({ x: e, low: n, high: r, v2: i, v3: a })
              }
            ]
          })
          .axis('y', { title: !1 })
          .scale('x', { type: 'linear', tickCount: 10 }),
          t
            .area()
            .encode('x', 'x')
            .encode('y', ['low', 'high'])
            .encode('shape', 'smooth')
            .style('fillOpacity', 0.65)
            .style('fill', '#64b5f6')
            .style('lineWidth', 1),
          t
            .line()
            .encode('x', 'x')
            .encode('y', 'v3')
            .encode('color', '#FF6B3B')
            .encode('shape', 'smooth'),
          t.render()
      }, 100)
    }, []),
    uv(hP, { children: uv('div', { style: { width: 600, height: 300 }, id: 'container' }) })
  )
export { lq as default }
//# sourceMappingURL=AntVOne-7b4c080f.js.map
